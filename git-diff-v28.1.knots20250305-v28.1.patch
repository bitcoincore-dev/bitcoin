diff --git a/.github/ISSUE_TEMPLATE/bug.yml b/.github/ISSUE_TEMPLATE/bug.yml
index b2775ef650..83922b54cb 100644
--- a/.github/ISSUE_TEMPLATE/bug.yml
+++ b/.github/ISSUE_TEMPLATE/bug.yml
@@ -5,12 +5,11 @@ body:
   - type: markdown
     attributes:
       value: |
-        ## This issue tracker is only for technical issues related to Bitcoin Knots.
+        ## This issue tracker is only for technical issues related to Bitcoin Core.
 
         * General bitcoin questions and/or support requests should use Bitcoin StackExchange at https://bitcoin.stackexchange.com.
-        * For reporting security issues, please read instructions at https://bitcoinknots.org/contact/
+        * For reporting security issues, please read instructions at https://bitcoincore.org/en/contact/.
         * If the node is "stuck" during sync or giving "block checksum mismatch" errors, please ensure your hardware is stable by running `memtest` and observe CPU temperature with a load-test tool such as `linpack` before creating an issue.
-        * If your issue also affects Bitcoin Core, report it at https://github.com/bitcoin/bitcoin/issues/new?labels=bug&template=bug.yml
 
         ----
   - type: checkboxes
@@ -58,7 +57,7 @@ body:
       required: false
   - type: dropdown
     attributes:
-      label: How did you obtain Bitcoin Knots
+      label: How did you obtain Bitcoin Core
       multiple: false
       options:
         - Compiled from source
@@ -68,10 +67,10 @@ body:
     validations:
       required: true
   - type: input
-    id: knots-version
+    id: core-version
     attributes:
-      label: What version of Bitcoin Knots are you using?
-      description: Run `bitcoind --version` or in Bitcoin-QT use `Help > About Bitcoin Knots`
+      label: What version of Bitcoin Core are you using?
+      description: Run `bitcoind --version` or in Bitcoin-QT use `Help > About Bitcoin Core`
       placeholder: e.g. v24.0.1 or master@e1bf547
     validations:
       required: true
diff --git a/.github/ISSUE_TEMPLATE/config.yml b/.github/ISSUE_TEMPLATE/config.yml
index b792e69055..40370284a6 100644
--- a/.github/ISSUE_TEMPLATE/config.yml
+++ b/.github/ISSUE_TEMPLATE/config.yml
@@ -1,8 +1,8 @@
 blank_issues_enabled: true
 contact_links:
-  - name: Bitcoin Knots Security Policy
-    url: https://bitcoinknots.org/contact/
+  - name: Bitcoin Core Security Policy
+    url: https://github.com/bitcoin/bitcoin/blob/master/SECURITY.md
     about: View security policy
-  - name: Bitcoin Knots Website
-    url: https://bitcoinknots.org
-    about: User-oriented information
+  - name: Bitcoin Core Developers
+    url: https://bitcoincore.org
+    about: Bitcoin Core homepage
diff --git a/.github/ISSUE_TEMPLATE/good_first_issue.yml b/.github/ISSUE_TEMPLATE/good_first_issue.yml
new file mode 100644
index 0000000000..133937c011
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/good_first_issue.yml
@@ -0,0 +1,44 @@
+name: Good First Issue
+description: (Regular devs only) Suggest a new good first issue
+labels: [good first issue]
+body:
+  - type: markdown
+    attributes:
+      value: |
+        Please add the label "good first issue" manually before or after opening
+
+        A good first issue is an uncontroversial issue, that has a relatively unique and obvious solution
+
+        Motivate the issue and explain the solution briefly
+  - type: textarea
+    id: motivation
+    attributes:
+      label: Motivation
+      description: Motivate the issue
+    validations:
+      required: true
+  - type: textarea
+    id: solution
+    attributes:
+      label: Possible solution
+      description: Describe a possible solution
+    validations:
+      required: false
+  - type: textarea
+    id: useful-skills
+    attributes:
+      label: Useful Skills
+      description: For example, “`std::thread`”, “Qt5 GUI and async GUI design” or “basic understanding of Bitcoin mining and the Bitcoin Core RPC interface”.
+      value: |
+        * Compiling Bitcoin Core from source
+        * Running the C++ unit tests and the Python functional tests
+        * ...
+  - type: textarea
+    attributes:
+      label: Guidance for new contributors
+      description: Please leave this to automatically add the footer for new contributors
+      value: |
+        Want to work on this issue?
+
+        For guidance on contributing, please read [CONTRIBUTING.md](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md) before opening your pull request.
+
diff --git a/.github/ISSUE_TEMPLATE/gui_issue.yml b/.github/ISSUE_TEMPLATE/gui_issue.yml
new file mode 100644
index 0000000000..4fe578e9b5
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/gui_issue.yml
@@ -0,0 +1,18 @@
+name: Issue or feature request related to the GUI
+description: Any report, issue or feature request related to the GUI
+labels: [GUI]
+body:
+- type: checkboxes
+  id: acknowledgement
+  attributes:
+    label: Issues, reports or feature requests related to the GUI should be opened directly on the GUI repo
+    description: https://github.com/bitcoin-core/gui/issues/
+    options:
+      - label: I still think this issue should be opened here
+        required: true
+- type: textarea
+  id: gui-request
+  attributes:
+    label: Report
+  validations:
+    required: true
diff --git a/.github/PULL_REQUEST_TEMPLATE.md b/.github/PULL_REQUEST_TEMPLATE.md
index f42fc7e5cd..ae92fc78f2 100644
--- a/.github/PULL_REQUEST_TEMPLATE.md
+++ b/.github/PULL_REQUEST_TEMPLATE.md
@@ -1,17 +1,17 @@
 <!--
 *** Please remove the following help text before submitting: ***
 
-Before opening a pull request to Bitcoin Knots, please first consider if it
-is appropriate for Bitcoin Core and, if so, rebase it and [open a pull request](https://github.com/bitcoin/bitcoin/compare)
-there first! Bitcoin Core has a strict and slow review process, but since
-Knots is more relaxed, feel free to request a merge of your Core PR into
-Knots even while it's waiting on Core.
+Pull requests without a rationale and clear improvement may be closed
+immediately.
 
+GUI-related pull requests should be opened against
+https://github.com/bitcoin-core/gui
+first. See CONTRIBUTING.md
 -->
 
 <!--
 Please provide clear motivation for your patch and explain how it improves
-Bitcoin Knots user experience or Bitcoin Knots developer experience
+Bitcoin Core user experience or Bitcoin Core developer experience
 significantly:
 
 * Any test improvements or new tests that improve coverage are always welcome.
@@ -22,7 +22,22 @@ significantly:
 * Bug fixes are most welcome when they come with steps to reproduce or an
   explanation of the potential issue as well as reasoning for the way the bug
   was fixed.
-* Features are typically welcome.
-* Refactoring changes are never accepted in Knots, and must be performed in
-  Bitcoin Core.
+* Features are welcome, but might be rejected due to design or scope issues.
+  If a feature is based on a lot of dependencies, contributors should first
+  consider building the system outside of Bitcoin Core, if possible.
+* Refactoring changes are only accepted if they are required for a feature or
+  bug fix or otherwise improve developer experience significantly. For example,
+  most "code style" refactoring changes require a thorough explanation why they
+  are useful, what downsides they have and why they *significantly* improve
+  developer experience or avoid serious programming bugs. Note that code style
+  is often a subjective matter. Unless they are explicitly mentioned to be
+  preferred in the [developer notes](/doc/developer-notes.md), stylistic code
+  changes are usually rejected.
+-->
+
+<!--
+Bitcoin Core has a thorough review process and even the most trivial change
+needs to pass a lot of eyes and requires non-zero or even substantial time
+effort to review. There is a huge lack of active reviewers on the project, so
+patches often sit for a long time.
 -->
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index e6cbbdbe22..7961c3c900 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -105,7 +105,7 @@ jobs:
         run: |
           # A workaround for "The `brew link` step did not complete successfully" error.
           brew install --quiet python@3 || brew link --overwrite python@3
-          brew install --quiet automake libtool pkg-config gnu-getopt ccache boost libevent miniupnpc libnatpmp zeromq qt@5 qrencode imagemagick libicns librsvg
+          brew install --quiet automake libtool pkg-config gnu-getopt ccache boost libevent miniupnpc libnatpmp zeromq qt@5 qrencode
 
       - name: Set Ccache directory
         run: echo "CCACHE_DIR=${RUNNER_TEMP}/ccache_dir" >> "$GITHUB_ENV"
diff --git a/.gitignore b/.gitignore
index 367942103f..f7bcbd1459 100644
--- a/.gitignore
+++ b/.gitignore
@@ -136,7 +136,6 @@ test/lint/test_runner/target/
 
 /doc/doxygen/
 
-libbitcoinconsensus.pc
 contrib/devtools/split-debug.sh
 
 # Output from running db4 installation
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 4aec78c32e..f594172333 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -1,12 +1,12 @@
-Contributing to Bitcoin Knots
-=============================
+Contributing to Bitcoin Core
+============================
 
-The Bitcoin Knots project operates an open contributor model where anyone is
+The Bitcoin Core project operates an open contributor model where anyone is
 welcome to contribute towards development in the form of peer review, testing
 and patches. This document explains the practical process and guidelines for
 contributing.
 
-First, in terms of structure, there is no particular concept of "core
+First, in terms of structure, there is no particular concept of "Bitcoin Core
 developers" in the sense of privileged people. Open source often naturally
 revolves around a meritocracy where contributors earn trust from the developer
 community over time. Nevertheless, some hierarchy is necessary for practical
@@ -55,7 +55,7 @@ and is also an effective way to request assistance if and when you need it.
 Communication Channels
 ----------------------
 
-Most communication about Bitcoin development happens on IRC, in the
+Most communication about Bitcoin Core development happens on IRC, in the
 `#bitcoin-core-dev` channel on Libera Chat. The easiest way to participate on IRC is
 with the web client, [web.libera.chat](https://web.libera.chat/#bitcoin-core-dev). Chat
 history logs can be found
@@ -290,12 +290,12 @@ workload on reviewing.
 "Decision Making" Process
 -------------------------
 
-The following applies to code changes to the Bitcoin Knots project (and related
+The following applies to code changes to the Bitcoin Core project (and related
 projects such as libsecp256k1), and is not to be confused with overall Bitcoin
 Network Protocol consensus changes.
 
-Whether a pull request is merged into Bitcoin Knots rests with the project merge
-maintainers and ultimately the project lead.
+Whether a pull request is merged into Bitcoin Core rests with the project merge
+maintainers.
 
 Maintainers will take into consideration if a patch is in line with the general
 principles of the project; meets the minimum standards for inclusion; and will
diff --git a/COPYING b/COPYING
index 23dc5e905b..e6d6e9fe57 100644
--- a/COPYING
+++ b/COPYING
@@ -1,7 +1,7 @@
 The MIT License (MIT)
 
-Copyright (c) 2009-2025 The Bitcoin Core developers
-Copyright (c) 2009-2025 Bitcoin Developers
+Copyright (c) 2009-2024 The Bitcoin Core developers
+Copyright (c) 2009-2024 Bitcoin Developers
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
diff --git a/Makefile.am b/Makefile.am
index 99e3e3e60b..b746299a42 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -14,11 +14,6 @@ endif
 .PHONY: deploy FORCE
 .INTERMEDIATE: $(COVERAGE_INFO)
 
-if BUILD_BITCOIN_LIBS
-pkgconfigdir = $(libdir)/pkgconfig
-pkgconfig_DATA = libbitcoinconsensus.pc
-endif
-
 BITCOIND_BIN=$(top_builddir)/src/$(BITCOIN_DAEMON_NAME)$(EXEEXT)
 BITCOIN_QT_BIN=$(top_builddir)/src/qt/$(BITCOIN_GUI_NAME)$(EXEEXT)
 BITCOIN_TEST_BIN=$(top_builddir)/src/test/$(BITCOIN_TEST_NAME)$(EXEEXT)
@@ -37,14 +32,13 @@ OSX_APP=Bitcoin-Qt.app
 OSX_VOLNAME = $(subst $(space),-,$(PACKAGE_NAME))
 OSX_ZIP = $(OSX_VOLNAME).zip
 OSX_DEPLOY_SCRIPT=$(top_srcdir)/contrib/macdeploy/macdeployqtplus
-OSX_INSTALLER_ICONS=src/qt/res/rendered_icons/bitcoin.icns
+OSX_INSTALLER_ICONS=$(top_srcdir)/src/qt/res/icons/bitcoin.icns
 OSX_PLIST=$(top_builddir)/share/qt/Info.plist #not installed
 
 DIST_CONTRIB = \
 	       $(top_srcdir)/test/sanitizer_suppressions/lsan \
 	       $(top_srcdir)/test/sanitizer_suppressions/tsan \
 	       $(top_srcdir)/test/sanitizer_suppressions/ubsan \
-	       $(top_srcdir)/contrib/completions \
 	       $(top_srcdir)/contrib/linearize/linearize-data.py \
 	       $(top_srcdir)/contrib/linearize/linearize-hashes.py \
 	       $(top_srcdir)/contrib/signet/miner
@@ -57,9 +51,9 @@ BIN_CHECKS=$(top_srcdir)/contrib/devtools/symbol-check.py \
            $(top_srcdir)/contrib/devtools/security-check.py \
            $(top_srcdir)/contrib/devtools/utils.py
 
-WINDOWS_PACKAGING = src/qt/res/rendered_icons/bitcoin.ico \
-  src/qt/res/rendered_icons/nsis-header.bmp \
-  src/qt/res/rendered_icons/nsis-wizard.bmp \
+WINDOWS_PACKAGING = $(top_srcdir)/share/pixmaps/bitcoin.ico \
+  $(top_srcdir)/share/pixmaps/nsis-header.bmp \
+  $(top_srcdir)/share/pixmaps/nsis-wizard.bmp \
   $(top_srcdir)/doc/README_windows.txt
 
 OSX_PACKAGING = $(OSX_DEPLOY_SCRIPT) $(OSX_INSTALLER_ICONS) \
@@ -70,14 +64,11 @@ COVERAGE_INFO = $(COV_TOOL_WRAPPER) baseline.info \
   baseline_filtered.info functional_test.info functional_test_filtered.info \
   test_bitcoin_coverage.info test_bitcoin.info fuzz.info fuzz_filtered.info fuzz_coverage.info
 
-src/qt/res/rendered_icons/%: FORCE
-	$(MAKE) -C src $(patsubst src/%,%,$@)
-
 dist-hook:
 	-$(GIT) archive --format=tar HEAD -- src/clientversion.cpp | $(AMTAR) -C $(top_distdir) -xf -
 
 if TARGET_WINDOWS
-$(BITCOIN_WIN_INSTALLER): all-recursive $(WINDOWS_PACKAGING)
+$(BITCOIN_WIN_INSTALLER): all-recursive
 	$(MKDIR_P) $(top_builddir)/release
 	STRIPPROG="$(STRIP)" $(INSTALL_STRIP_PROGRAM) $(BITCOIND_BIN) $(top_builddir)/release
 	STRIPPROG="$(STRIP)" $(INSTALL_STRIP_PROGRAM) $(BITCOIN_QT_BIN) $(top_builddir)/release
@@ -317,8 +308,6 @@ EXTRA_DIST += \
     test/util/data/txreplacesingleinput.hex \
     test/util/rpcauth-test.py
 
-EXTRA_DIST += src/qt/res/rendered_icons/bitcoin_testnet.ico
-
 CLEANFILES = $(OSX_ZIP) $(BITCOIN_WIN_INSTALLER)
 
 DISTCHECK_CONFIGURE_FLAGS = --enable-man
@@ -335,9 +324,6 @@ docs:
 	@echo "error: doxygen not found"
 endif
 
-src_files: $(DISTFILES)
-	@true
-
 clean-docs:
 	rm -rf doc/doxygen
 
diff --git a/README.md b/README.md
index cf1fb8a2c4..2eab2315eb 100644
--- a/README.md
+++ b/README.md
@@ -1,41 +1,40 @@
-Bitcoin Knots
-=============
+Bitcoin Core integration/staging tree
+=====================================
 
-https://bitcoinknots.org
+https://bitcoincore.org
 
-For an immediately usable, binary version of the Bitcoin Knots software, see
-the website.
+For an immediately usable, binary version of the Bitcoin Core software, see
+https://bitcoincore.org/en/download/.
 
-What is Bitcoin Knots?
-----------------------
+What is Bitcoin Core?
+---------------------
 
-Bitcoin Knots connects to the Bitcoin peer-to-peer network to download and fully
+Bitcoin Core connects to the Bitcoin peer-to-peer network to download and fully
 validate blocks and transactions. It also includes a wallet and graphical user
 interface, which can be optionally built.
 
-Further information about Bitcoin Knots is available in the [doc folder](/doc).
+Further information about Bitcoin Core is available in the [doc folder](/doc).
 
 License
 -------
 
-Bitcoin Knots is released under the terms of the MIT license. See [COPYING](COPYING) for more
+Bitcoin Core is released under the terms of the MIT license. See [COPYING](COPYING) for more
 information or see https://opensource.org/licenses/MIT.
 
 Development Process
 -------------------
 
-Development generally takes place as part of [Bitcoin Core](https://github.com/bitcoin/bitcoin), and is merged into
-Knots for each release.
+The `master` branch is regularly built (see `doc/build-*.md` for instructions) and tested, but it is not guaranteed to be
+completely stable. [Tags](https://github.com/bitcoin/bitcoin/tags) are created
+regularly from release branches to indicate new official, stable release versions of Bitcoin Core.
 
-Even if your pull request to Core is closed, or if your feature is not
-suitable for Core (eg, because it builds on a feature not supported in Core;
-relies on centralised services; etc), it may still be eligible for inclusion
-in Bitcoin Knots. In this case, a pull request may be opened on the
-[Knots GitHub](https://github.com/bitcoinknots/bitcoin) for review and consideration.
-When accepted, you are expected to maintain the submitted branch in your own
-repository, and it will be automatically merged into new releases of Knots.
+The https://github.com/bitcoin-core/gui repository is used exclusively for the
+development of the GUI. Its master branch is identical in all monotree
+repositories. Release branches and tags do not exist, so please do not fork
+that repository unless it is for development reasons.
 
-Developer IRC can be found on Freenode at #bitcoin-dev.
+The contribution workflow is described in [CONTRIBUTING.md](CONTRIBUTING.md)
+and useful hints for developers can be found in [doc/developer-notes.md](doc/developer-notes.md).
 
 Testing
 -------
diff --git a/SECURITY.md b/SECURITY.md
index 769168593b..fd4c61d176 100644
--- a/SECURITY.md
+++ b/SECURITY.md
@@ -2,17 +2,19 @@
 
 ## Supported Versions
 
-See our website for versions of Bitcoin Knots that are currently supported with
-security updates: https://bitcoinknots.org/
+See our website for versions of Bitcoin Core that are currently supported with
+security updates: https://bitcoincore.org/en/lifecycle/#schedule
 
 ## Reporting a Vulnerability
 
-To report security issues send an email to luke+security+knots@dashjr.org (not for support).
+To report security issues send an email to security@bitcoincore.org (not for support).
 
-The following OpenPGP key should be used to communicate sensitive information:
+The following keys may be used to communicate sensitive information to developers:
 
 | Name | Fingerprint |
 |------|-------------|
-| Luke Dashjr | FAC0 98FE 8DF9 975F 9024  1881 3666 E2B1 782A 18E1 |
+| Pieter Wuille | 133E AC17 9436 F14A 5CF1  B794 860F EB80 4E66 9320 |
+| Michael Ford | E777 299F C265 DD04 7930  70EB 944D 35F9 AC3D B76A |
+| Ava Chow | 1528 1230 0785 C964 44D3  334D 1756 5732 E08E 5E41 |
 
 You can import a key by running the following command with that individual’s fingerprint: `gpg --keyserver hkps://keys.openpgp.org --recv-keys "<fingerprint>"` Ensure that you put quotes around fingerprints containing spaces.
diff --git a/build-aux/m4/bitcoin_qt.m4 b/build-aux/m4/bitcoin_qt.m4
index cd8bf304fd..7498127860 100644
--- a/build-aux/m4/bitcoin_qt.m4
+++ b/build-aux/m4/bitcoin_qt.m4
@@ -253,22 +253,6 @@ AC_DEFUN([BITCOIN_QT_CONFIGURE],[
     AC_MSG_RESULT([$bitcoin_enable_qt])
   fi
 
-  AC_MSG_CHECKING([whether to build with QWinTaskbarProgress support])
-  BITCOIN_QT_CHECK([
-    if test "x$have_qt_winextras" != xyes; then
-      AC_MSG_RESULT([no, ${qt_lib_prefix}WinExtras $qt_version not found])
-    elif test "x$have_dwmapi" != xyes; then
-      AC_MSG_RESULT([no, dwmapi missing])
-    else
-      AC_MSG_RESULT([yes])
-      QT_INCLUDES="$QT_INCLUDES $QT_WINEXTRAS_CFLAGS"
-      QT_LIBS="$QT_LIBS $QT_WINEXTRAS_LIBS"
-      AC_DEFINE(BITCOIN_QT_WIN_TASKBAR, 1, [Define this symbol if building with QWinTaskbarProgress])
-    fi
-  ],[
-    AC_MSG_RESULT([no, not building GUI])
-  ])
-
   AC_SUBST(QT_PIE_FLAGS)
   AC_SUBST(QT_INCLUDES)
   AC_SUBST(QT_LIBS)
@@ -387,14 +371,4 @@ AC_DEFUN([_BITCOIN_QT_FIND_LIBS],[
       PKG_CHECK_MODULES([QT_DBUS], [${qt_lib_prefix}DBus $qt_version], [QT_DBUS_INCLUDES="$QT_DBUS_CFLAGS"; have_qt_dbus=yes], [have_qt_dbus=no])
     fi
   ])
-
-  BITCOIN_QT_CHECK([
-    if test "x$TARGET_OS" = xwindows; then
-      PKG_CHECK_MODULES([QT_WINEXTRAS], [${qt_lib_prefix}WinExtras $qt_version], [
-        have_qt_winextras=yes
-      ],[
-        have_qt_winextras=no
-      ])
-    fi
-  ])
 ])
diff --git a/build-aux/m4/bitcoin_subdir_to_include.m4 b/build-aux/m4/bitcoin_subdir_to_include.m4
index 4e38d26d39..736270afea 100644
--- a/build-aux/m4/bitcoin_subdir_to_include.m4
+++ b/build-aux/m4/bitcoin_subdir_to_include.m4
@@ -5,48 +5,14 @@ dnl file COPYING or http://www.opensource.org/licenses/mit-license.php.
 dnl BITCOIN_SUBDIR_TO_INCLUDE([CPPFLAGS-VARIABLE-NAME],[SUBDIRECTORY-NAME],[HEADER-FILE])
 dnl SUBDIRECTORY-NAME must end with a path separator
 AC_DEFUN([BITCOIN_SUBDIR_TO_INCLUDE],[
-  m4_pushdef([_result_var],[$1])
-  m4_pushdef([_rel_path],[$2])
-  m4_pushdef([_header_file],[$3.h])
-  if test "[]_rel_path" = ""; then
+  if test "$2" = ""; then
     AC_MSG_RESULT([default])
   else
-    echo '[#]include <'"_rel_path"'/_header_file>' >conftest.cpp
-    newinclpath=$(
-      ${CXXCPP} ${CPPFLAGS} -M conftest.cpp 2>/dev/null |
-      ${SED} -E m4_bpatsubsts([[
-        :build_line
-# If the line doesn't end with a backslash, it is complete; go on to process it
-        /\\$/!b have_complete_line
-# Otherwise, read the next line, and concatenate it to the current one with a space
-        N
-        s/\\\n/ /
-# Then go back and check for a trailing backslash again.
-        t build_line
-
-# When we get here, we have the completed line, with all continuations collapsed.
-        :have_complete_line
-        s/^[^:]*:[[:space:]]*(([^[:space:]\]|\\.)*[[:space:]])*(([^[:space:]\]|\\.)*)(\\|\\\\|\/)?]]patsubst(]_header_file[,[\.],[\\.])[[([[:space:]].*)?$/\3/
-#         ^^^^^^^ The Make line begins with a target (which we don't care about)
-#                ^^^^^^^^^^^^ Ignore any spaces following it
-#                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Match any number of other dependencies
-#                                                              ^^^^^^^^^^^^^^^^^^^^^^ Match any path components for our dependency; note this is reference 3, which we are replacing with
-#                                                                                    ^^^^^^^^^^^^^ Accept the path ending in a backslash, a double-backslash (ie escaped), or a forward slash
-#                                                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ The filename must match exactly (periods are escaped, since a normal period matches any character in regex)
-#                                                                                                                                      ^^^^^^^^^^^^^^^^^ Filename must be followed by a space, but after that we don't care; we still need to match it all so it gets replaced, however
-# Delete the line, but only if we failed to find the directory (t jumps past the d if we matched)
-        t
-        d
-]],[
-\s*\(#.*\)?$],[],[
-        \(.*\)],[ -e '\1'])
-dnl ^^^^^^^^^^^^^^^^^^^^^^^ Deletes comments and processes sed expressions into -e arguments
-    )
-
+    echo "#include <$2$3.h>" >conftest.cpp
+    newinclpath=`${CXXCPP} ${CPPFLAGS} -M conftest.cpp 2>/dev/null | [ tr -d '\\n\\r\\\\' | sed -e 's/^.*[[:space:]:]\(\/[^[:space:]]*\)]$3[\.h[[:space:]].*$/\1/' -e t -e d`]
     AC_MSG_RESULT([${newinclpath}])
     if test "${newinclpath}" != ""; then
-      eval "_result_var=\"\$_result_var\"' -I${newinclpath}'"
+      eval "$1=\"\$$1\"' -I${newinclpath}'"
     fi
   fi
-  m4_popdef([_result_var],[_rel_path],[_header_file])
 ])
diff --git a/build_msvc/README.md b/build_msvc/README.md
index c643dd94e0..f97c7ca59c 100644
--- a/build_msvc/README.md
+++ b/build_msvc/README.md
@@ -11,7 +11,7 @@ To build Bitcoin Core from the command-line, it is sufficient to only install th
 
 The "Desktop development with C++" workload must be installed as well.
 
-Building Knots with Visual Studio is NOT supported, and it is recommended to instead use the Linux based [cross-compiler build](../doc/build-windows.md).
+Building with Visual Studio is an alternative to the Linux based [cross-compiler build](../doc/build-windows.md).
 
 
 Prerequisites
diff --git a/build_msvc/bitcoin_config.h.in b/build_msvc/bitcoin_config.h.in
index 33632ad17c..b0238c9112 100644
--- a/build_msvc/bitcoin_config.h.in
+++ b/build_msvc/bitcoin_config.h.in
@@ -49,9 +49,6 @@
    */
 #define HAVE_DECL_SETSID 0
 
-/* Define if the dllexport attribute is supported. */
-#define HAVE_DLLEXPORT_ATTRIBUTE 1
-
 /* Define to the address where bug reports for this package should be sent. */
 #define PACKAGE_BUGREPORT "https://github.com/bitcoin/bitcoin/issues"
 
diff --git a/build_msvc/common.qt.init.vcxproj b/build_msvc/common.qt.init.vcxproj
index 713ed7051e..dabbec707f 100644
--- a/build_msvc/common.qt.init.vcxproj
+++ b/build_msvc/common.qt.init.vcxproj
@@ -6,7 +6,7 @@
     <QtPluginsLibraryDir>$(QtBaseDir)\plugins</QtPluginsLibraryDir>
     <QtLibraryDir>$(QtBaseDir)\lib</QtLibraryDir>
     <QtIncludeDir>$(QtBaseDir)\include</QtIncludeDir>
-    <QtIncludes>$(QtIncludeDir);$(QtIncludeDir)\QtNetwork;$(QtIncludeDir)\QtCore;$(QtIncludeDir)\QtWidgets;$(QtIncludeDir)\QtGui;$(QtIncludeDir)\QtWinExtras;</QtIncludes>
+    <QtIncludes>$(QtIncludeDir);$(QtIncludeDir)\QtNetwork;$(QtIncludeDir)\QtCore;$(QtIncludeDir)\QtWidgets;$(QtIncludeDir)\QtGui;</QtIncludes>
     <GeneratedFilesOutDir>.\QtGeneratedFiles\qt</GeneratedFilesOutDir>
     <QtToolsDir>$(QtBaseDir)\bin</QtToolsDir>
     <QtReleaseLibraries>$(QtPluginsLibraryDir)\platforms\qminimal.lib;$(QtPluginsLibraryDir)\platforms\qwindows.lib;$(QtPluginsLibraryDir)\styles\qwindowsvistastyle.lib;$(QtLibraryDir)\Qt5WindowsUIAutomationSupport.lib;$(QtLibraryDir)\qtfreetype.lib;$(QtLibraryDir)\qtharfbuzz.lib;$(QtLibraryDir)\qtlibpng.lib;$(QtLibraryDir)\qtpcre2.lib;$(QtLibraryDir)\Qt5AccessibilitySupport.lib;$(QtLibraryDir)\Qt5Core.lib;$(QtLibraryDir)\Qt5Concurrent.lib;$(QtLibraryDir)\Qt5EventDispatcherSupport.lib;$(QtLibraryDir)\Qt5FontDatabaseSupport.lib;$(QtLibraryDir)\Qt5Gui.lib;$(QtLibraryDir)\Qt5Network.lib;$(QtLibraryDir)\Qt5PlatformCompositorSupport.lib;$(QtLibraryDir)\Qt5ThemeSupport.lib;$(QtLibraryDir)\Qt5Widgets.lib;$(QtLibraryDir)\Qt5WinExtras.lib;$(QtLibraryDir)\qtmain.lib;Wtsapi32.lib;userenv.lib;netapi32.lib;imm32.lib;Dwmapi.lib;version.lib;winmm.lib;UxTheme.lib</QtReleaseLibraries>
diff --git a/build_msvc/libbitcoin_consensus/libbitcoin_consensus.vcxproj b/build_msvc/libbitcoin_consensus/libbitcoin_consensus.vcxproj
index 95fdcdb79b..a34ef41d16 100644
--- a/build_msvc/libbitcoin_consensus/libbitcoin_consensus.vcxproj
+++ b/build_msvc/libbitcoin_consensus/libbitcoin_consensus.vcxproj
@@ -15,7 +15,6 @@
     <ClCompile Include="..\..\src\primitives\block.cpp" />
     <ClCompile Include="..\..\src\primitives\transaction.cpp" />
     <ClCompile Include="..\..\src\pubkey.cpp" />
-    <ClCompile Include="..\..\src\script\bitcoinconsensus.cpp" />
     <ClCompile Include="..\..\src\script\interpreter.cpp" />
     <ClCompile Include="..\..\src\script\script.cpp" />
     <ClCompile Include="..\..\src\script\script_error.cpp" />
diff --git a/ci/test/00_setup_env.sh b/ci/test/00_setup_env.sh
index 6995f65480..b9e6818afb 100755
--- a/ci/test/00_setup_env.sh
+++ b/ci/test/00_setup_env.sh
@@ -66,7 +66,7 @@ export BASE_BUILD_DIR=${BASE_BUILD_DIR:-$BASE_SCRATCH_DIR/build}
 # The folder for previous release binaries.
 # This folder exists only on the ci guest, and on the ci host as a volume.
 export PREVIOUS_RELEASES_DIR=${PREVIOUS_RELEASES_DIR:-$BASE_ROOT_DIR/prev_releases}
-export CI_BASE_PACKAGES=${CI_BASE_PACKAGES:-build-essential libtool autotools-dev automake pkg-config bsdmainutils curl ca-certificates ccache python3 rsync git procps bison e2fsprogs cmake icnsutils librsvg2-bin imagemagick}
+export CI_BASE_PACKAGES=${CI_BASE_PACKAGES:-build-essential libtool autotools-dev automake pkg-config bsdmainutils curl ca-certificates ccache python3 rsync git procps bison e2fsprogs cmake}
 export GOAL=${GOAL:-install}
 export DIR_QA_ASSETS=${DIR_QA_ASSETS:-${BASE_SCRATCH_DIR}/qa-assets}
 export CI_RETRY_EXE=${CI_RETRY_EXE:-"retry --"}
diff --git a/ci/test/00_setup_env_i686_centos.sh b/ci/test/00_setup_env_i686_centos.sh
index b8b8955848..5f8391c5da 100755
--- a/ci/test/00_setup_env_i686_centos.sh
+++ b/ci/test/00_setup_env_i686_centos.sh
@@ -9,7 +9,7 @@ export LC_ALL=C.UTF-8
 export HOST=i686-pc-linux-gnu
 export CONTAINER_NAME=ci_i686_centos
 export CI_IMAGE_NAME_TAG="quay.io/centos/amd64:stream9"
-export CI_BASE_PACKAGES="gcc-c++ glibc-devel.x86_64 libstdc++-devel.x86_64 glibc-devel.i686 libstdc++-devel.i686 ccache libtool make git python3 python3-pip which patch lbzip2 xz procps-ng dash rsync coreutils bison util-linux e2fsprogs cmake libicns-utils librsvg2-tools ImageMagick"
+export CI_BASE_PACKAGES="gcc-c++ glibc-devel.x86_64 libstdc++-devel.x86_64 glibc-devel.i686 libstdc++-devel.i686 ccache libtool make git python3 python3-pip which patch lbzip2 xz procps-ng dash rsync coreutils bison util-linux e2fsprogs cmake"
 export PIP_PACKAGES="pyzmq"
 export GOAL="install"
 export NO_WERROR=1  # Suppress error: #warning _FORTIFY_SOURCE > 2 is treated like 2 on this platform [-Werror=cpp]
diff --git a/ci/test/00_setup_env_mac_cross.sh b/ci/test/00_setup_env_mac_cross.sh
index f4b436a990..f607c93ae6 100755
--- a/ci/test/00_setup_env_mac_cross.sh
+++ b/ci/test/00_setup_env_mac_cross.sh
@@ -11,7 +11,7 @@ export SDK_URL=${SDK_URL:-https://bitcoincore.org/depends-sources/sdks}
 export CONTAINER_NAME=ci_macos_cross
 export CI_IMAGE_NAME_TAG="docker.io/ubuntu:24.04"
 export HOST=x86_64-apple-darwin
-export PACKAGES="clang lld llvm zip icnsutils imagemagick librsvg2-bin"
+export PACKAGES="clang lld llvm zip"
 export XCODE_VERSION=15.0
 export XCODE_BUILD_ID=15A240d
 export RUN_UNIT_TESTS=false
diff --git a/ci/test/00_setup_env_native_nowallet_libbitcoinkernel.sh b/ci/test/00_setup_env_native_nowallet_libbitcoinkernel.sh
index a6a2b8d071..49660aac0c 100755
--- a/ci/test/00_setup_env_native_nowallet_libbitcoinkernel.sh
+++ b/ci/test/00_setup_env_native_nowallet_libbitcoinkernel.sh
@@ -12,4 +12,4 @@ export CI_IMAGE_NAME_TAG="docker.io/debian:bullseye"
 export PACKAGES="python3-zmq clang-16 llvm-16 libc++abi-16-dev libc++-16-dev"
 export DEP_OPTS="NO_WALLET=1 CC=clang-16 CXX='clang++-16 -stdlib=libc++'"
 export GOAL="install"
-export BITCOIN_CONFIG="--enable-reduce-exports --enable-shared"
+export BITCOIN_CONFIG="--enable-reduce-exports --enable-experimental-util-chainstate --with-experimental-kernel-lib --enable-shared"
diff --git a/ci/test/00_setup_env_native_previous_releases.sh b/ci/test/00_setup_env_native_previous_releases.sh
index 3166686d9a..9da3b18999 100755
--- a/ci/test/00_setup_env_native_previous_releases.sh
+++ b/ci/test/00_setup_env_native_previous_releases.sh
@@ -16,5 +16,5 @@ export RUN_UNIT_TESTS_SEQUENTIAL="true"
 export RUN_UNIT_TESTS="false"
 export GOAL="install"
 export DOWNLOAD_PREVIOUS_RELEASES="true"
-export BITCOIN_CONFIG="--enable-zmq --with-libs=no --with-gui=qt5 --enable-reduce-exports --enable-debug \
+export BITCOIN_CONFIG="--enable-zmq --with-gui=qt5 --enable-reduce-exports --enable-debug \
 CFLAGS=\"-g0 -O2 -funsigned-char\" CPPFLAGS='-DBOOST_MULTI_INDEX_ENABLE_SAFE_MODE' CXXFLAGS=\"-g0 -O2 -funsigned-char\""
diff --git a/ci/test/03_test_script.sh b/ci/test/03_test_script.sh
index f298b63c8c..1d7a9d76db 100755
--- a/ci/test/03_test_script.sh
+++ b/ci/test/03_test_script.sh
@@ -110,7 +110,7 @@ fi
 ccache --zero-stats
 PRINT_CCACHE_STATISTICS="ccache --version | head -n 1 && ccache --show-stats"
 
-BITCOIN_CONFIG_ALL="${BITCOIN_CONFIG_ALL} --prefix=$BASE_OUTDIR"
+BITCOIN_CONFIG_ALL="${BITCOIN_CONFIG_ALL} --enable-external-signer --prefix=$BASE_OUTDIR"
 
 if [ -n "$CONFIG_SHELL" ]; then
   "$CONFIG_SHELL" -c "./autogen.sh"
@@ -143,6 +143,7 @@ du -sh "${PREVIOUS_RELEASES_DIR}"
 if [[ $HOST = *-mingw32 ]]; then
   # Generate all binaries, so that they can be wrapped
   make "$MAKEJOBS" -C src/secp256k1 VERBOSE=1
+  make "$MAKEJOBS" -C src minisketch/test.exe VERBOSE=1
   "${BASE_ROOT_DIR}/ci/test/wrap-wine.sh"
 fi
 
diff --git a/configure.ac b/configure.ac
index 2c66063975..86d5e5e214 100644
--- a/configure.ac
+++ b/configure.ac
@@ -4,10 +4,10 @@ define(_CLIENT_VERSION_MINOR, 1)
 define(_CLIENT_VERSION_BUILD, 0)
 define(_CLIENT_VERSION_RC, 0)
 define(_CLIENT_VERSION_IS_RELEASE, true)
-define(_COPYRIGHT_YEAR, 2025)
+define(_COPYRIGHT_YEAR, 2024)
 define(_COPYRIGHT_HOLDERS,[The %s developers])
-define(_COPYRIGHT_HOLDERS_SUBSTITUTION,[[Bitcoin Knots]])
-AC_INIT([Bitcoin Knots],m4_join([.], _CLIENT_VERSION_MAJOR, _CLIENT_VERSION_MINOR, _CLIENT_VERSION_BUILD)m4_if(_CLIENT_VERSION_RC, [0], [], [rc]_CLIENT_VERSION_RC),[https://github.com/bitcoinknots/bitcoin/issues],[bitcoin],[https://bitcoinknots.org/])
+define(_COPYRIGHT_HOLDERS_SUBSTITUTION,[[Bitcoin Core]])
+AC_INIT([Bitcoin Core],m4_join([.], _CLIENT_VERSION_MAJOR, _CLIENT_VERSION_MINOR, _CLIENT_VERSION_BUILD)m4_if(_CLIENT_VERSION_RC, [0], [], [rc]_CLIENT_VERSION_RC),[https://github.com/bitcoin/bitcoin/issues],[bitcoin],[https://bitcoincore.org/])
 AC_CONFIG_SRCDIR([src/validation.cpp])
 AC_CONFIG_HEADERS([src/config/bitcoin-config.h])
 AC_CONFIG_AUX_DIR([build-aux])
@@ -216,11 +216,6 @@ AC_ARG_ENABLE([reduce-exports],
   [use_reduce_exports=$enableval],
   [use_reduce_exports=no])
 
-AC_ARG_WITH([append-cxxflags],
-  [AS_HELP_STRING([--with-append-cxxflags],
-  [append given cxxflags without checking them (default is empty string)])],
-  [append_cxxflags=$withval])
-
 AC_ARG_ENABLE([ccache],
   [AS_HELP_STRING([--disable-ccache],
   [do not use ccache for building (default is to use if found)])],
@@ -298,11 +293,6 @@ AC_ARG_ENABLE([external-signer],
     [use_external_signer=$enableval],
     [use_external_signer=yes])
 
-AC_ARG_ENABLE([tor-subprocess],
-    [AS_HELP_STRING([--disable-tor-subprocess],[compile support for executing a dedicated Tor node (default is yes)])],
-    [use_tor_subprocess=$enableval],
-    [use_tor_subprocess=yes])
-
 AC_LANG_PUSH([C++])
 
 dnl Always set -g -O2 in our CXXFLAGS. Autoconf will try and set CXXFLAGS to "-g -O2" by default,
@@ -412,7 +402,7 @@ AX_CHECK_COMPILE_FLAG([-Wlogical-op], [WARN_CXXFLAGS="$WARN_CXXFLAGS -Wlogical-o
 AX_CHECK_COMPILE_FLAG([-Woverloaded-virtual], [WARN_CXXFLAGS="$WARN_CXXFLAGS -Woverloaded-virtual"], [], [$CXXFLAG_WERROR])
 AX_CHECK_COMPILE_FLAG([-Wsuggest-override], [WARN_CXXFLAGS="$WARN_CXXFLAGS -Wsuggest-override"], [], [$CXXFLAG_WERROR])
 AX_CHECK_COMPILE_FLAG([-Wimplicit-fallthrough], [WARN_CXXFLAGS="$WARN_CXXFLAGS -Wimplicit-fallthrough"], [], [$CXXFLAG_WERROR])
-AX_CHECK_COMPILE_FLAG([-Wunreachable-code-loop-increment], [WARN_CXXFLAGS="$WARN_CXXFLAGS -Wunreachable-code-loop-increment"], [], [$CXXFLAG_WERROR])
+AX_CHECK_COMPILE_FLAG([-Wunreachable-code], [WARN_CXXFLAGS="$WARN_CXXFLAGS -Wunreachable-code"], [], [$CXXFLAG_WERROR])
 AX_CHECK_COMPILE_FLAG([-Wdocumentation], [WARN_CXXFLAGS="$WARN_CXXFLAGS -Wdocumentation"], [], [$CXXFLAG_WERROR])
 AX_CHECK_COMPILE_FLAG([-Wself-assign], [WARN_CXXFLAGS="$WARN_CXXFLAGS -Wself-assign"], [], [$CXXFLAG_WERROR])
 AX_CHECK_COMPILE_FLAG([-Wundef], [WARN_CXXFLAGS="$WARN_CXXFLAGS -Wundef"], [], [$CXXFLAG_WERROR])
@@ -421,9 +411,6 @@ dnl Some compilers (gcc) ignore unknown -Wno-* options, but warn about all
 dnl unknown options if any other warning is produced. Test the -Wfoo case, and
 dnl set the -Wno-foo case if it works.
 AX_CHECK_COMPILE_FLAG([-Wunused-parameter], [NOWARN_CXXFLAGS="$NOWARN_CXXFLAGS -Wno-unused-parameter"], [], [$CXXFLAG_WERROR])
-if test "$CXXFLAG_WERROR" != ""; then
-  AX_CHECK_COMPILE_FLAG([-Wunused-function], [NOWARN_CXXFLAGS="$NOWARN_CXXFLAGS -Wno-error=unused-function"], [], [$CXXFLAG_WERROR])
-fi
 
 dnl Don't allow extended (non-ASCII) symbols in identifiers. This is easier for code review.
 AX_CHECK_COMPILE_FLAG([-fno-extended-identifiers], [CORE_CXXFLAGS="$CORE_CXXFLAGS -fno-extended-identifiers"], [], [$CXXFLAG_WERROR])
@@ -440,7 +427,6 @@ enable_sse42=no
 enable_sse41=no
 enable_avx2=no
 enable_x86_shani=no
-enable_power8=no
 
 dnl Check for optional instruction set support. Enabling these does _not_ imply that all code will
 dnl be compiled with them, rather that specific objects/libs may use them after checking for runtime
@@ -451,7 +437,6 @@ AX_CHECK_COMPILE_FLAG([-msse4.2], [SSE42_CXXFLAGS="-msse4.2"], [], [$CXXFLAG_WER
 AX_CHECK_COMPILE_FLAG([-msse4.1], [SSE41_CXXFLAGS="-msse4.1"], [], [$CXXFLAG_WERROR])
 AX_CHECK_COMPILE_FLAG([-mavx -mavx2], [AVX2_CXXFLAGS="-mavx -mavx2"], [], [$CXXFLAG_WERROR])
 AX_CHECK_COMPILE_FLAG([-msse4 -msha], [X86_SHANI_CXXFLAGS="-msse4 -msha"], [], [$CXXFLAG_WERROR])
-AX_CHECK_COMPILE_FLAG([-mpower8-vector], [POWER8_CXXFLAGS="-mpower8-vector"], [], [$CXXFLAG_WERROR])
 
 enable_clmul=
 AX_CHECK_COMPILE_FLAG([-mpclmul], [enable_clmul=yes], [], [$CXXFLAG_WERROR], [AC_LANG_PROGRAM([
@@ -498,12 +483,6 @@ CXXFLAGS="$SSE41_CXXFLAGS $CXXFLAGS"
 AC_MSG_CHECKING([for SSE4.1 intrinsics])
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
     #include <immintrin.h>
-
-    #if defined(__clang__)
-    #pragma clang attribute push(__attribute__((__target__("sse4.1"))), apply_to = function)
-    #elif defined(__GNUC__)
-    #pragma GCC target ("sse4.1")
-    #endif
   ]],[[
     __m128i a = _mm_set1_epi32(0);
     __m128i b = _mm_set1_epi32(1);
@@ -521,12 +500,6 @@ AC_MSG_CHECKING([for AVX2 intrinsics])
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
     #include <stdint.h>
     #include <immintrin.h>
-
-    #if defined(__clang__)
-    #pragma clang attribute push(__attribute__((__target__("avx,avx2"))), apply_to = function)
-    #elif defined(__GNUC__)
-    #pragma GCC target ("avx,avx2")
-    #endif
   ]],[[
     __m256i l = _mm256_set1_epi32(0);
     return _mm256_extract_epi32(l, 7);
@@ -542,12 +515,6 @@ AC_MSG_CHECKING([for x86 SHA-NI intrinsics])
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
     #include <stdint.h>
     #include <immintrin.h>
-
-    #if defined(__clang__)
-    #pragma clang attribute push(__attribute__((__target__("sse4,sse4.1,sha"))), apply_to = function)
-    #elif defined(__GNUC__)
-    #pragma GCC target ("sse4,sse4.1,sha")
-    #endif
   ]],[[
     __m128i i = _mm_set1_epi32(0);
     __m128i j = _mm_set1_epi32(1);
@@ -600,22 +567,6 @@ AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
 )
 CXXFLAGS="$TEMP_CXXFLAGS"
 
-TEMP_CXXFLAGS="$CXXFLAGS"
-CXXFLAGS="$TEMP_CXXFLAGS $POWER8_CXXFLAGS"
-AC_MSG_CHECKING(for POWER8 compiler support)
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-    #include <altivec.h>
-    #include <stdint.h>
-  ]], [[
-    unsigned char src[16];
-    __builtin_crypto_vshasigmaw((__vector uint32_t)vec_vsx_ld(0, src), 1, 0xf);
-    return 0;
-  ]])],
-  [ AC_MSG_RESULT(yes); enable_power8=yes; AC_DEFINE(ENABLE_POWER8, 1, [Define if compiler supports POWER8 instructions.]) ],
-  [ AC_MSG_RESULT(no) ]
-)
-CXXFLAGS="$TEMP_CXXFLAGS"
-
 CORE_CPPFLAGS="$CORE_CPPFLAGS -DHAVE_BUILD_INFO"
 
 AC_ARG_WITH([utils],
@@ -648,14 +599,17 @@ AC_ARG_ENABLE([util-util],
   [build_bitcoin_util=$enableval],
   [build_bitcoin_util=$build_bitcoin_utils])
 
-build_bitcoin_chainstate=no
-build_experimental_kernel_lib=no
+AC_ARG_ENABLE([experimental-util-chainstate],
+  [AS_HELP_STRING([--enable-experimental-util-chainstate],
+  [build experimental bitcoin-chainstate executable (default=no)])],
+  [build_bitcoin_chainstate=$enableval],
+  [build_bitcoin_chainstate=no])
 
-AC_ARG_WITH([libs],
-  [AS_HELP_STRING([--with-libs],
-  [build libraries (default=yes)])],
-  [build_bitcoin_libs=$withval],
-  [build_bitcoin_libs=yes])
+AC_ARG_WITH([experimental-kernel-lib],
+  [AS_HELP_STRING([--with-experimental-kernel-lib],
+  [build experimental bitcoinkernel library (default is to build if we're building the experimental build-chainstate executable)])],
+  [build_experimental_kernel_lib=$withval],
+  [build_experimental_kernel_lib=auto])
 
 AC_ARG_WITH([daemon],
   [AS_HELP_STRING([--with-daemon],
@@ -663,21 +617,9 @@ AC_ARG_WITH([daemon],
   [build_bitcoind=$withval],
   [build_bitcoind=yes])
 
-can_render_icons=yes
-AC_PATH_PROGS([RSVG_CONVERT],[rsvg-convert rsvg],no)
-AC_PATH_PROGS([IMAGEMAGICK_CONVERT],[magick convert],no)
-AC_PATH_PROGS([PNG2ICNS],[png2icns],no)
-
-if test x$RSVG_CONVERT = xno; then
-  can_render_icons='rsvg-convert'
-elif test x$IMAGEMAGICK_CONVERT = xno; then
-  can_render_icons='ImageMagick'
-fi
-
 case $host in
   *mingw*)
      TARGET_OS=windows
-     AC_CHECK_LIB([mingwthrd],[main],                    [], [AC_MSG_ERROR([libmingwthrd missing])])
      AC_CHECK_LIB([kernel32], [GetModuleFileNameA],      [], [AC_MSG_ERROR([libkernel32 missing])])
      AC_CHECK_LIB([user32],   [main],                    [], [AC_MSG_ERROR([libuser32 missing])])
      AC_CHECK_LIB([gdi32],    [main],                    [], [AC_MSG_ERROR([libgdi32 missing])])
@@ -692,7 +634,6 @@ case $host in
      AC_CHECK_LIB([ws2_32],   [WSAStartup],              [], [AC_MSG_ERROR([libws2_32 missing])])
      AC_CHECK_LIB([shlwapi],  [PathRemoveFileSpecW],     [], [AC_MSG_ERROR([libshlwapi missing])])
      AC_CHECK_LIB([iphlpapi], [GetAdaptersAddresses],    [], [AC_MSG_ERROR([libiphlpapi missing])])
-     AC_CHECK_LIB([dwmapi],   [main],                    [have_dwmapi=yes], [have_dwmapi=no])
 
      dnl -static is interpreted by libtool, where it has a different meaning.
      dnl In libtool-speak, it's -all-static.
@@ -729,15 +670,8 @@ case $host in
      dnl Avoid the use of aligned vector instructions when building for Windows.
      dnl See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54412.
      AX_CHECK_COMPILE_FLAG([-Wa,-muse-unaligned-vector-move], [CORE_CXXFLAGS="$CORE_CXXFLAGS -Wa,-muse-unaligned-vector-move"], [], [$CXXFLAG_WERROR])
-
-     AC_PATH_PROGS([RSVG_CONVERT], [rsvg-convert rsvg],rsvg-convert)
-     AC_PATH_PROGS([IMAGEMAGICK_CONVERT], [magick convert],convert)
      ;;
   *darwin*)
-     if test x$PNG2ICNS = xno; then
-       can_render_icons='png2icns'
-     fi
-
      TARGET_OS=darwin
      if  test $cross_compiling != "yes"; then
        BUILD_OS=darwin
@@ -814,13 +748,6 @@ case $host in
            dnl which may not exist in the path. Stripping the .a is not
            dnl necessary, so just disable it.
            old_striplib=
-
-           dnl libtool assumes "GNU strip" accepts --strip-unneeded, but at
-           dnl least recent versions of LLVM do not yet claim to be compatible
-           dnl with "GNU strip". For now, we just disable stripping shared
-           dnl libraries too, but it would be better to actually test the strip
-           dnl program (FIXME).
-           striplib=
            ;;
        esac
      fi
@@ -912,44 +839,6 @@ if test "$ac_cv_sys_large_files" != "" &&
   CORE_CPPFLAGS="$CORE_CPPFLAGS -D_LARGE_FILES=$ac_cv_sys_large_files"
 fi
 
-AC_SEARCH_LIBS([clock_gettime],[rt])
-
-AC_MSG_CHECKING([for clock_gettime w/ CLOCK_THREAD_CPUTIME_ID])
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-    #include <time.h>
-  ]],[[
-    timespec now;
-    clock_gettime(CLOCK_THREAD_CPUTIME_ID, &now);
-    (void)now.tv_sec;
-    (void)now.tv_nsec;
-  ]])
-],[
-  AC_MSG_RESULT([yes])
-  AC_DEFINE([HAVE_CLOCK_GETTIME], [1], [Define this symbol if you have clock_gettime])
-],[
-  AC_MSG_RESULT([no])
-])
-
-AC_MSG_CHECKING([for GetThreadTimes])
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-    #include <windows.h>
-    #include <winnt.h>
-
-    #include <processthreadsapi.h>
-  ]],[[
-    FILETIME creation;
-    FILETIME exit;
-    FILETIME kernel;
-    FILETIME user;
-    (void)GetThreadTimes(GetCurrentThread(), &creation, &exit, &kernel, &user);
-  ]])
-],[
-  AC_MSG_RESULT([yes])
-  AC_DEFINE([HAVE_GETTHREADTIMES], [1], [Define this symbol if you have GetThreadTimes])
-],[
-  AC_MSG_RESULT([no])
-])
-
 if test "$TARGET_OS" != "windows"; then
   dnl All windows code is PIC, forcing it on just adds useless compile warnings
   AX_CHECK_COMPILE_FLAG([-fPIC], [PIC_FLAGS="-fPIC"])
@@ -1038,21 +927,6 @@ AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <malloc.h>]],
  [ AC_MSG_RESULT([no])]
 )
 
-AC_MSG_CHECKING(for compatible sysinfo call)
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/sysinfo.h>]],
- [[
-  struct sysinfo info;
-  int rv = sysinfo(&info);
-  unsigned long test = info.freeram + info.bufferram + info.mem_unit;
- ]])],
- [
-  AC_MSG_RESULT(yes);
-  AC_DEFINE(HAVE_LINUX_SYSINFO, 1, [Define this symbol if you have a Linux-compatible sysinfo call])
- ],[
-  AC_MSG_RESULT(no)
- ]
-)
-
 dnl Check for posix_fallocate
 AC_MSG_CHECKING([for posix_fallocate])
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
@@ -1069,105 +943,6 @@ AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
  [ AC_MSG_RESULT([no])]
 )
 
-AC_MSG_CHECKING([for default visibility attribute])
-AC_COMPILE_IFELSE([AC_LANG_SOURCE([
-  int foo(void) __attribute__((visibility("default")));
-  int main(){}
-  ])],
-  [
-    AC_DEFINE([HAVE_DEFAULT_VISIBILITY_ATTRIBUTE], [1], [Define if the visibility attribute is supported.])
-    AC_MSG_RESULT([yes])
-  ],
-  [
-    AC_MSG_RESULT([no])
-    if test "$use_reduce_exports" = "yes"; then
-      AC_MSG_ERROR([Cannot find a working visibility attribute. Use --disable-reduce-exports.])
-    fi
-  ]
-)
-
-AC_MSG_CHECKING([for dllexport attribute])
-AC_COMPILE_IFELSE([AC_LANG_SOURCE([
-  __declspec(dllexport) int foo(void);
-  int main(){}
-  ])],
-  [
-    AC_DEFINE([HAVE_DLLEXPORT_ATTRIBUTE], [1], [Define if the dllexport attribute is supported.])
-    AC_MSG_RESULT([yes])
-  ],
-  [AC_MSG_RESULT([no])]
-)
-
-AC_MSG_CHECKING(for macOS iopolicy functions)
-AC_COMPILE_IFELSE([
-  AC_LANG_PROGRAM([[
-    #include <sys/resource.h>
-  ]],[[
-    int x = getiopolicy_np(IOPOL_TYPE_DISK, IOPOL_SCOPE_THREAD);
-    setiopolicy_np(IOPOL_TYPE_DISK, IOPOL_SCOPE_THREAD, x);
-  ]])
-],[
-  AC_MSG_RESULT([yes])
-  HAVE_IOPOLICY=1
-],[
-  AC_MSG_RESULT([no])
-  HAVE_IOPOLICY=0
-])
-AC_DEFINE_UNQUOTED([HAVE_IOPOLICY], [$HAVE_IOPOLICY], [Define to 1 if macOS iopolicy functions are usable.])
-
-if test x$HAVE_IOPOLICY = x0; then
-  AC_MSG_CHECKING(for Linux ioprio syscalls)
-  AC_COMPILE_IFELSE([
-    AC_LANG_PROGRAM([[
-      #define _GNU_SOURCE
-      #include <unistd.h>
-      #include <sys/syscall.h>
-    ]],[[
-      int x = syscall(SYS_ioprio_get, 1, 0);
-      syscall(SYS_ioprio_set, 1, 0, x);
-    ]])
-  ],[
-    AC_MSG_RESULT([yes])
-    HAVE_IOPRIO_SYSCALL=1
-  ],[
-    AC_MSG_RESULT([no])
-    HAVE_IOPRIO_SYSCALL=0
-  ])
-else
-  HAVE_IOPRIO_SYSCALL=0
-fi
-AC_DEFINE_UNQUOTED([HAVE_IOPRIO_SYSCALL], [$HAVE_IOPRIO_SYSCALL], [Define to 1 if Linux ioprio syscalls are usable.])
-
-AC_MSG_CHECKING(for Windows file I/O priority functions)
-AC_COMPILE_IFELSE([
-  AC_LANG_PROGRAM([[
-    #define _WIN32_WINNT 0x0601
-    #include <windows.h>
-    #include <io.h>
-    #include <stddef.h>
-    #include <stdint.h>
-    #include <stdio.h>
-  ]],[[
-    FILE_IO_PRIORITY_HINT_INFO priorityHint = {
-        .PriorityHint = IoPriorityHintLow,
-    };
-    FILE * const F = fopen("test", "r");
-    intptr_t osfhandle = _get_osfhandle(_fileno(F));
-    if (osfhandle == (intptr_t)INVALID_HANDLE_VALUE) osfhandle = 0;
-    HANDLE hFile = (HANDLE)osfhandle;
-
-    bool rv = SetFileInformationByHandle(hFile, FileIoPriorityHintInfo, &priorityHint, sizeof(priorityHint));
-    return rv;
-  ]])
-],[
-  AC_MSG_RESULT([yes])
-  HAVE_WINDOWS_IOPRIO=1
-],[
-  AC_MSG_RESULT([no])
-  HAVE_WINDOWS_IOPRIO=0
-])
-AC_DEFINE_UNQUOTED([HAVE_WINDOWS_IOPRIO], [$HAVE_WINDOWS_IOPRIO], [Define to 1 if Windows file IO functions are usable.])
-
 dnl Check for different ways of gathering OS randomness
 AC_MSG_CHECKING([for Linux getrandom function])
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
@@ -1300,68 +1075,6 @@ if test "$have_any_system" != "no"; then
   AC_DEFINE([HAVE_SYSTEM], [1], [Define to 1 if std::system or ::wsystem is available.])
 fi
 
-dnl Check for leveldb, only if explicitly requested
-LEVELDB_CPPFLAGS=
-LIBLEVELDB=
-LIBMEMENV=
-AC_ARG_WITH([system-leveldb],
-  [AS_HELP_STRING([--with-system-leveldb],
-  [Build with system LevelDB (default is no; DANGEROUS; NOT SUPPORTED)])],
-  [system_leveldb=$withval],
-  [system_leveldb=no]
-)
-if test x$system_leveldb != xno; then
-  LEVELDB_CPPFLAGS=
-  AC_CHECK_LIB([leveldb],[main],[
-    LIBLEVELDB=-lleveldb
-  ],[
-    AC_MSG_ERROR([leveldb library not found; using --with-system-leveldb is not supported anyway])
-  ])
-  AC_CHECK_HEADER([leveldb/filter_policy.h],[],[
-    AC_MSG_ERROR([LevelDB headers not found; using --with-system-leveldb is not supported anyway])
-  ])
-  AC_CHECK_HEADER([leveldb/helpers/memenv.h],[
-    AC_MSG_CHECKING([for memenv.h path])
-    BITCOIN_SUBDIR_TO_INCLUDE([LEVELDB_CPPFLAGS],[leveldb/helpers/],[memenv])
-  ],[
-    AC_CHECK_HEADER([memenv.h],[],[
-      AC_MSG_ERROR([LevelDB headers not found; using --with-system-leveldb is not supported anyway])
-    ])
-  ])
-
-  AC_MSG_CHECKING([library containing leveldb::NewMemEnv])
-  TEMP_LIBS="$LIBS"
-  TEMP_CPPFLAGS="$CPPFLAGS"
-  CPPFLAGS="$CPPFLAGS $LEVELDB_CPPFLAGS"
-  for searchlib in "" "-lmemenv" ERR; do
-    if test "x$searchlib" = "xERR"; then
-      AC_MSG_RESULT([no])
-      AC_MSG_ERROR([LevelDB's memenv helper not found; using --with-system-leveldb is not supported anyway])
-    fi
-    searchlib="$searchlib $LIBLEVELDB"
-    LIBS="$searchlib $TEMP_LIBS"
-    AC_LINK_IFELSE([AC_LANG_SOURCE([
-        #include <leveldb/env.h>
-        #include <memenv.h>
-
-        int main() {
-            leveldb::Env *myenv = leveldb::NewMemEnv(leveldb::Env::Default());
-            delete myenv;
-        }
-    ])],[
-      AC_MSG_RESULT([$searchlib])
-      LIBMEMENV="$searchlib"
-      break
-    ])
-  done
-  LIBS="$TEMP_LIBS"
-  CPPFLAGS="$TEMP_CPPFLAGS"
-fi
-AM_CONDITIONAL([EMBEDDED_LEVELDB],[test x$system_leveldb = xno])
-AC_SUBST(LEVELDB_CPPFLAGS)
-AC_SUBST(LIBLEVELDB)
-AC_SUBST(LIBMEMENV)
-
 dnl SUPPRESSED_CPPFLAGS=SUPPRESS_WARNINGS([$SOME_CPPFLAGS])
 dnl Replace -I with -isystem in $SOME_CPPFLAGS to suppress warnings from
 dnl headers from its include directories and return the result.
@@ -1384,13 +1097,11 @@ if test "$enable_fuzz" = "yes"; then
   build_bitcoin_chainstate=no
   build_bitcoin_wallet=no
   build_bitcoind=no
-  build_bitcoin_libs=no
   bitcoin_enable_qt=no
   bitcoin_enable_qt_test=no
   bitcoin_enable_qt_dbus=no
   use_bench=no
   use_tests=no
-  use_tor_subprocess=no
   use_external_signer=no
   use_upnp=no
   use_natpmp=no
@@ -1413,18 +1124,13 @@ else
   fi
 fi
 
-AM_CONDITIONAL([CAN_RENDER_ICONS], [test "$can_render_icons" = "yes"])
-if test "$can_render_icons" != "yes"; then
-  if test "$bitcoin_enable_qt" != "no" && test ! -f "${srcdir}/src/qt/res/rendered_icons/bitcoin.ico"; then
-    AC_MSG_ERROR([Couldn't find ${can_render_icons} (required to build GUI from git)])
-  fi
-fi
-
 if test "$enable_fuzz_binary" = "yes"; then
   AC_MSG_CHECKING([whether main function is needed for fuzz binary])
-  TEMP_LDFLAGS="$LDFLAGS"
-  LDFLAGS="$LDFLAGS $SANITIZER_LDFLAGS"
-  AC_LINK_IFELSE(
+  AX_CHECK_LINK_FLAG(
+    [],
+    [AC_MSG_RESULT([no])],
+    [AC_MSG_RESULT([yes]); CORE_CPPFLAGS="$CORE_CPPFLAGS -DPROVIDE_FUZZ_MAIN_FUNCTION"],
+    [$SANITIZER_LDFLAGS],
     [AC_LANG_PROGRAM([[
       #include <cstdint>
       #include <cstddef>
@@ -1432,38 +1138,8 @@ if test "$enable_fuzz_binary" = "yes"; then
       /* comment to remove the main function ...
      ]],[[
       */ int not_main() {
-     ]])],
-    [AC_MSG_RESULT([no])],
-    [AC_MSG_RESULT([yes]); CORE_CPPFLAGS="$CORE_CPPFLAGS -DPROVIDE_FUZZ_MAIN_FUNCTION"]
-    )
-  LDFLAGS="$TEMP_LDFLAGS"
-fi
-
-dnl Check for libsecp256k1, only if explicitly requested
-AC_ARG_WITH([system-libsecp256k1],
-  [AS_HELP_STRING([--with-system-libsecp256k1],
-  [Build with system libsecp256k1 (default is no; DANGEROUS; NOT SUPPORTED)])],
-  [system_libsecp256k1=$withval],
-  [system_libsecp256k1=no]
-)
-if test x$system_libsecp256k1 != xno; then
-  PKG_CHECK_MODULES([libsecp256k1],[libsecp256k1],,[true])
-  TEMP_CFLAGS="$CFLAGS"
-  TEMP_LIBS="$LIBS"
-  CFLAGS="$libsecp256k1_CFLAGS $CFLAGS"
-  LIBS="$libsecp256k1_LIBS $LIBS"
-  AC_CHECK_FUNCS([secp256k1_selftest],[],[
-    AC_MSG_ERROR([libsecp256k1 is too old or broken (must be at least v0.2.0 or newer)])
-  ])
-  CFLAGS="$TEMP_CFLAGS"
-  LIBS="$TEMP_LIBS"
-else
-  libsecp256k1_CFLAGS='-I$(srcdir)/secp256k1/include'
-  libsecp256k1_LIBS='secp256k1/libsecp256k1.la'
+     ]])])
 fi
-AM_CONDITIONAL([EMBEDDED_LIBSECP256K1],[test x$system_libsecp256k1 = xno])
-AC_SUBST(libsecp256k1_CFLAGS)
-AC_SUBST(libsecp256k1_LIBS)
 
 if test "$enable_wallet" != "no"; then
     dnl Check for libdb_cxx only if wallet enabled
@@ -1579,7 +1255,7 @@ if test "$use_boost" = "yes"; then
   dnl Check for Boost headers
   AX_BOOST_BASE([1.73.0],[],[AC_MSG_ERROR([Boost is not available!])])
   if test "$want_boost" = "no"; then
-    AC_MSG_ERROR([only libbitcoinconsensus can be built without Boost])
+    AC_MSG_ERROR([Boost is required])
   fi
 
   dnl we don't use multi_index serialization
@@ -1600,7 +1276,7 @@ fi
 case $host in
   dnl Re-enable it after enabling Windows support in cpp-subprocess.
   *mingw*)
-    true
+    use_external_signer="no"
   ;;
 esac
 if test "$use_external_signer" = "yes"; then
@@ -1608,11 +1284,6 @@ if test "$use_external_signer" = "yes"; then
 fi
 AM_CONDITIONAL([ENABLE_EXTERNAL_SIGNER], [test "$use_external_signer" = "yes"])
 
-if test "$use_tor_subprocess" = "yes"; then
-  AC_DEFINE([ENABLE_TOR_SUBPROCESS], [1], [Define if Tor subprocess support is enabled])
-fi
-AM_CONDITIONAL([ENABLE_TOR_SUBPROCESS], [test "$use_tor_subprocess" = "yes"])
-
 dnl Check for reduced exports
 if test "$use_reduce_exports" = "yes"; then
   AX_CHECK_COMPILE_FLAG([-fvisibility=hidden], [CORE_CXXFLAGS="$CORE_CXXFLAGS -fvisibility=hidden"],
@@ -1621,8 +1292,6 @@ if test "$use_reduce_exports" = "yes"; then
   AX_CHECK_LINK_FLAG([-Wl,-no_exported_symbols], [LIBTOOL_APP_LDFLAGS="$LIBTOOL_APP_LDFLAGS -Wl,-no_exported_symbols"], [], [$LDFLAG_WERROR])
 fi
 
-CXXFLAGS="$CXXFLAGS $append_cxxflags"
-
 if test "$use_tests" = "yes"; then
 
   if test "$HEXDUMP" = ""; then
@@ -1762,18 +1431,8 @@ fi
 AM_CONDITIONAL([BUILD_BITCOIN_CHAINSTATE], [test $build_bitcoin_chainstate = "yes"])
 AC_MSG_RESULT($build_bitcoin_chainstate)
 
-AC_MSG_CHECKING([whether to build libraries])
-AM_CONDITIONAL([BUILD_BITCOIN_LIBS], [test $build_bitcoin_libs = "yes"])
-
-if test "$build_bitcoin_libs" = "yes"; then
-  AC_DEFINE([HAVE_CONSENSUS_LIB], [1], [Define this symbol if the consensus lib has been built])
-  AC_CONFIG_FILES([libbitcoinconsensus.pc:libbitcoinconsensus.pc.in])
-fi
-
 AM_CONDITIONAL([BUILD_BITCOIN_KERNEL_LIB], [test "$build_experimental_kernel_lib" != "no" && ( test "$build_experimental_kernel_lib" = "yes" || test "$build_bitcoin_chainstate" = "yes" )])
 
-AC_MSG_RESULT($build_bitcoin_libs)
-
 AC_LANG_POP
 
 if test "$use_ccache" != "no"; then
@@ -1907,15 +1566,14 @@ else
   AC_MSG_RESULT([no])
 fi
 
-if test "$build_bitcoin_wallet$build_bitcoin_cli$build_bitcoin_tx$build_bitcoin_util$build_bitcoin_libs$build_bitcoind$bitcoin_enable_qt$enable_fuzz_binary$use_bench$use_tests" = "nononononononononono"; then
-  AC_MSG_ERROR([No targets! Please specify at least one of: --with-utils --with-libs --with-daemon --with-gui --enable-fuzz(-binary) --enable-bench or --enable-tests])
+if test "$build_bitcoin_wallet$build_bitcoin_cli$build_bitcoin_tx$build_bitcoin_util$build_bitcoind$bitcoin_enable_qt$enable_fuzz_binary$use_bench$use_tests" = "nonononononononono"; then
+  AC_MSG_ERROR([No targets! Please specify at least one of: --with-utils --with-daemon --with-gui --enable-fuzz(-binary) --enable-bench or --enable-tests])
 fi
 
 AM_CONDITIONAL([TARGET_DARWIN], [test "$TARGET_OS" = "darwin"])
 AM_CONDITIONAL([BUILD_DARWIN], [test "$BUILD_OS" = "darwin"])
 AM_CONDITIONAL([TARGET_LINUX], [test "$TARGET_OS" = "linux"])
 AM_CONDITIONAL([TARGET_WINDOWS], [test "$TARGET_OS" = "windows"])
-AM_CONDITIONAL([HAVE_PYTHON], [test "$PYTHON" != ""])
 AM_CONDITIONAL([ENABLE_WALLET], [test "$enable_wallet" = "yes"])
 AM_CONDITIONAL([USE_SQLITE], [test "$use_sqlite" = "yes"])
 AM_CONDITIONAL([USE_BDB], [test "$use_bdb" = "yes"])
@@ -1934,7 +1592,6 @@ AM_CONDITIONAL([ENABLE_AVX2], [test "$enable_avx2" = "yes"])
 AM_CONDITIONAL([ENABLE_X86_SHANI], [test "$enable_x86_shani" = "yes"])
 AM_CONDITIONAL([ENABLE_ARM_CRC], [test "$enable_arm_crc" = "yes"])
 AM_CONDITIONAL([ENABLE_ARM_SHANI], [test "$enable_arm_shani" = "yes"])
-AM_CONDITIONAL([ENABLE_POWER8], [test "$enable_power8" = "yes"])
 AM_CONDITIONAL([WORDS_BIGENDIAN], [test "$ac_cv_c_bigendian" = "yes"])
 AM_CONDITIONAL([USE_NATPMP], [test "$use_natpmp" = "yes"])
 AM_CONDITIONAL([USE_UPNP], [test "$use_upnp" = "yes"])
@@ -1993,12 +1650,10 @@ AC_SUBST(AVX2_CXXFLAGS)
 AC_SUBST(X86_SHANI_CXXFLAGS)
 AC_SUBST(ARM_CRC_CXXFLAGS)
 AC_SUBST(ARM_SHANI_CXXFLAGS)
-AC_SUBST(POWER8_CXXFLAGS)
 AC_SUBST(LIBTOOL_APP_LDFLAGS)
 AC_SUBST(USE_SQLITE)
 AC_SUBST(USE_BDB)
 AC_SUBST(ENABLE_EXTERNAL_SIGNER)
-AC_SUBST(ENABLE_TOR_SUBPROCESS)
 AC_SUBST(USE_UPNP)
 AC_SUBST(USE_QRCODE)
 AC_SUBST(TESTDEFS)
@@ -2038,10 +1693,8 @@ CPPFLAGS="$CPPFLAGS_TEMP"
 if test -n "$use_sanitizers"; then
   export SECP_CFLAGS="$SECP_CFLAGS $SANITIZER_CFLAGS"
 fi
-if test x$system_libsecp256k1 = xno; then
 ac_configure_args="${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --enable-module-recovery --disable-module-ecdh"
 AC_CONFIG_SUBDIRS([src/secp256k1])
-fi
 
 AC_OUTPUT
 
@@ -2067,9 +1720,7 @@ esac
 echo
 echo "Options used to compile and link:"
 echo "  external signer = $use_external_signer"
-echo "  tor subprocess  = $use_tor_subprocess"
 echo "  multiprocess    = $build_multiprocess"
-echo "  with libs       = $build_bitcoin_libs"
 echo "  with wallet     = $enable_wallet"
 if test "$enable_wallet" != "no"; then
     echo "    with sqlite   = $use_sqlite"
diff --git a/contrib/completions/bash/bitcoin-cli.bash b/contrib/completions/bash/bitcoin-cli.bash
index 2272502578..b04fdbcb0e 100644
--- a/contrib/completions/bash/bitcoin-cli.bash
+++ b/contrib/completions/bash/bitcoin-cli.bash
@@ -1,10 +1,5 @@
-# Dynamic bash programmable completion for bitcoin-cli(1)
-#     DO NOT EDIT THIS FILE BY HAND -- THIS WILL FAIL THE FUNCTIONAL TEST tool_cli_completion
-# This file is auto-generated by the functional test tool_cli_completion.
-# If you want to modify this file, modify test/functional/tool_cli_completion.py and re-autogenerate
-# this file via the --overwrite test flag.
-
-# Copyright (c) 2012-2024 The Bitcoin Core developers
+# bash programmable completion for bitcoin-cli(1)
+# Copyright (c) 2012-2022 The Bitcoin Core developers
 # Distributed under the MIT software license, see the accompanying
 # file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
@@ -35,8 +30,8 @@ _bitcoin_cli() {
 
     if ((cword > 5)); then
         case ${words[cword-5]} in
-            descriptorprocesspsbt)
-                COMPREPLY=( $( compgen -W "false true" -- "$cur" ) )
+            sendtoaddress)
+                COMPREPLY=( $( compgen -W "true false" -- "$cur" ) )
                 return 0
                 ;;
         esac
@@ -44,12 +39,12 @@ _bitcoin_cli() {
 
     if ((cword > 4)); then
         case ${words[cword-4]} in
-            createpsbt|createrawtransaction|descriptorprocesspsbt|setban)
-                COMPREPLY=( $( compgen -W "false true" -- "$cur" ) )
+            importaddress|listtransactions|setban)
+                COMPREPLY=( $( compgen -W "true false" -- "$cur" ) )
                 return 0
                 ;;
-            signrawtransactionwithkey)
-                COMPREPLY=( $( compgen -W "ALL ALL|ANYONECANPAY NONE NONE|ANYONECANPAY SINGLE SINGLE|ANYONECANPAY" -- "$cur" ) )
+            signrawtransactionwithkey|signrawtransactionwithwallet)
+                COMPREPLY=( $( compgen -W "ALL NONE SINGLE ALL|ANYONECANPAY NONE|ANYONECANPAY SINGLE|ANYONECANPAY" -- "$cur" ) )
                 return 0
                 ;;
         esac
@@ -57,8 +52,11 @@ _bitcoin_cli() {
 
     if ((cword > 3)); then
         case ${words[cword-3]} in
-            addnode|converttopsbt|dumptxoutset|getdescriptoractivity|gettxout|gettxoutsetinfo)
-                COMPREPLY=( $( compgen -W "false true" -- "$cur" ) )
+            addmultisigaddress)
+                return 0
+                ;;
+            getbalance|gettxout|importaddress|importpubkey|importprivkey|listreceivedbyaddress|listsinceblock)
+                COMPREPLY=( $( compgen -W "true false" -- "$cur" ) )
                 return 0
                 ;;
         esac
@@ -66,32 +64,31 @@ _bitcoin_cli() {
 
     if ((cword > 2)); then
         case ${words[cword-2]} in
-            converttopsbt|decoderawtransaction|finalizepsbt|getblockheader|getmempoolancestors|getmempooldescendants|getrawmempool|listmempooltransactions)
-                COMPREPLY=( $( compgen -W "false true" -- "$cur" ) )
-                return 0
-                ;;
             addnode)
-                COMPREPLY=( $( compgen -W "add onetry remove" -- "$cur" ) )
+                COMPREPLY=( $( compgen -W "add remove onetry" -- "$cur" ) )
                 return 0
                 ;;
             setban)
                 COMPREPLY=( $( compgen -W "add remove" -- "$cur" ) )
                 return 0
                 ;;
-            estimatesmartfee)
-                COMPREPLY=( $( compgen -W "CONSERVATIVE ECONOMICAL UNSET" -- "$cur" ) )
+            fundrawtransaction|getblock|getblockheader|getmempoolancestors|getmempooldescendants|getrawtransaction|gettransaction|listreceivedbyaddress|sendrawtransaction)
+                COMPREPLY=( $( compgen -W "true false" -- "$cur" ) )
                 return 0
                 ;;
         esac
     fi
 
     case "$prev" in
-        dumptxoutset|importmempool|loadtxoutset)
+        backupwallet|dumpwallet|importwallet)
             _filedir
             return 0
             ;;
-        getrawmempool|setnetworkactive|setscriptthreadsenabled)
-            COMPREPLY=( $( compgen -W "false true" -- "$cur" ) )
+        getaddednodeinfo|getrawmempool|lockunspent)
+            COMPREPLY=( $( compgen -W "true false" -- "$cur" ) )
+            return 0
+            ;;
+        getbalance|getnewaddress|listtransactions|sendmany)
             return 0
             ;;
     esac
diff --git a/contrib/debian/copyright b/contrib/debian/copyright
index af8a1bc0c1..dafc92f8ad 100644
--- a/contrib/debian/copyright
+++ b/contrib/debian/copyright
@@ -5,7 +5,7 @@ Upstream-Contact: Satoshi Nakamoto <satoshin@gmx.com>
 Source: https://github.com/bitcoin/bitcoin
 
 Files: *
-Copyright: 2009-2025, Bitcoin Core Developers
+Copyright: 2009-2024, Bitcoin Core Developers
 License: Expat
 Comment: The Bitcoin Core Developers encompasses all contributors to the
          project, listed in the release notes or the git log.
diff --git a/contrib/devtools/bitcoin-tidy/CMakeLists.txt b/contrib/devtools/bitcoin-tidy/CMakeLists.txt
index 512abf5734..95345b4782 100644
--- a/contrib/devtools/bitcoin-tidy/CMakeLists.txt
+++ b/contrib/devtools/bitcoin-tidy/CMakeLists.txt
@@ -58,7 +58,7 @@ else()
 endif()
 
 # Create a dummy library that runs clang-tidy tests as a side-effect of building
-add_library(bitcoin-tidy-tests OBJECT EXCLUDE_FROM_ALL example_nontrivial-threadlocal.cpp)
+add_library(bitcoin-tidy-tests OBJECT EXCLUDE_FROM_ALL example_logprintf.cpp example_nontrivial-threadlocal.cpp)
 add_dependencies(bitcoin-tidy-tests bitcoin-tidy)
 
 set_target_properties(bitcoin-tidy-tests PROPERTIES CXX_CLANG_TIDY "${CLANG_TIDY_COMMAND}")
diff --git a/contrib/devtools/bitcoin-tidy/bitcoin-tidy.cpp b/contrib/devtools/bitcoin-tidy/bitcoin-tidy.cpp
index ba6aef5992..1ef4494973 100644
--- a/contrib/devtools/bitcoin-tidy/bitcoin-tidy.cpp
+++ b/contrib/devtools/bitcoin-tidy/bitcoin-tidy.cpp
@@ -13,6 +13,7 @@ class BitcoinModule final : public clang::tidy::ClangTidyModule
 public:
     void addCheckFactories(clang::tidy::ClangTidyCheckFactories& CheckFactories) override
     {
+        CheckFactories.registerCheck<bitcoin::LogPrintfCheck>("bitcoin-unterminated-logprintf");
         CheckFactories.registerCheck<bitcoin::NonTrivialThreadLocal>("bitcoin-nontrivial-threadlocal");
     }
 };
diff --git a/contrib/devtools/circular-dependencies.py b/contrib/devtools/circular-dependencies.py
index 409d62424c..b742a8cea6 100755
--- a/contrib/devtools/circular-dependencies.py
+++ b/contrib/devtools/circular-dependencies.py
@@ -25,7 +25,6 @@ def module_name(path):
         return path
     if path.endswith(".h"):
         return path[:-2]
-    return path
     if path.endswith(".c"):
         return path[:-2]
     if path.endswith(".cpp"):
diff --git a/contrib/devtools/gen-manpages.py b/contrib/devtools/gen-manpages.py
index 71e595b258..92acd9a403 100755
--- a/contrib/devtools/gen-manpages.py
+++ b/contrib/devtools/gen-manpages.py
@@ -57,22 +57,19 @@ if any(verstr.endswith('-dirty') for (_, verstr, _) in versions):
     print('To properly generate man pages, please commit your changes (or discard them), rebuild, then run this script again.')
     print()
 
-basename_binaries = tuple(s.rpartition('/')[2] for s in BINARIES)
-
-for (abspath, verstr, copyright) in versions:
-  with tempfile.NamedTemporaryFile('w', suffix='.h2m') as footer:
+with tempfile.NamedTemporaryFile('w', suffix='.h2m') as footer:
     # Create copyright footer, and write it to a temporary include file.
     # Copyright is the same for all binaries, so just use the first.
     footer.write('[COPYRIGHT]\n')
     footer.write('\n'.join(versions[0][2]).strip())
     # Create SEE ALSO section
     footer.write('\n[SEE ALSO]\n')
-    footer.write(', '.join(s + "(1)" for s in basename_binaries if not abspath.endswith("/" + s)))
+    footer.write(', '.join(s.rpartition('/')[2] + '(1)' for s in BINARIES))
     footer.write('\n')
     footer.flush()
 
     # Call the binaries through help2man to produce a manual page for each of them.
-    if True:
+    for (abspath, verstr, _) in versions:
         outname = os.path.join(mandir, os.path.basename(abspath) + '.1')
         print(f'Generating {outname}…')
         subprocess.run([help2man, '-N', '--version-string=' + verstr, '--include=' + footer.name, '-o', outname, abspath], check=True)
diff --git a/contrib/devtools/symbol-check.py b/contrib/devtools/symbol-check.py
index 167346c799..1722c7d290 100755
--- a/contrib/devtools/symbol-check.py
+++ b/contrib/devtools/symbol-check.py
@@ -150,7 +150,7 @@ MACHO_ALLOWED_LIBRARIES = {
 'QuartzCore', # animation
 }
 
-PE_ALLOWED_LIBRARIES = {libname.lower() for libname in (
+PE_ALLOWED_LIBRARIES = {
 'ADVAPI32.dll', # security & registry
 'IPHLPAPI.DLL', # IP helper API
 'KERNEL32.dll', # win32 base APIs
@@ -171,7 +171,7 @@ PE_ALLOWED_LIBRARIES = {libname.lower() for libname in (
 'VERSION.dll', # version checking
 'WINMM.dll', # WinMM audio API
 'WTSAPI32.dll', # Remote Desktop
-)}
+}
 
 def check_version(max_versions, version, arch) -> bool:
     (lib, _, ver) = version.rpartition('_')
@@ -252,7 +252,7 @@ def check_MACHO_lld(binary) -> bool:
 def check_PE_libraries(binary) -> bool:
     ok: bool = True
     for dylib in binary.libraries:
-        if dylib.lower() not in PE_ALLOWED_LIBRARIES:
+        if dylib not in PE_ALLOWED_LIBRARIES:
             print(f'{dylib} is not in ALLOWED_LIBRARIES!')
             ok = False
     return ok
diff --git a/contrib/guix/guix-build b/contrib/guix/guix-build
index cd9d7be39c..2ea574fe4b 100755
--- a/contrib/guix/guix-build
+++ b/contrib/guix/guix-build
@@ -74,7 +74,8 @@ mkdir -p "$VERSION_BASE"
 ################
 
 # Default to building for all supported HOSTs (overridable by environment)
-export HOSTS="${HOSTS:-x86_64-linux-gnu arm-linux-gnueabihf aarch64-linux-gnu riscv64-linux-gnu powerpc64-linux-gnu powerpc64le-linux-gnu
+# powerpc64le-linux-gnu currently disabled due non-determinism issues across build arches.
+export HOSTS="${HOSTS:-x86_64-linux-gnu arm-linux-gnueabihf aarch64-linux-gnu riscv64-linux-gnu powerpc64-linux-gnu
                        x86_64-w64-mingw32
                        x86_64-apple-darwin arm64-apple-darwin}"
 
diff --git a/contrib/guix/libexec/build.sh b/contrib/guix/libexec/build.sh
index 01859e8320..fa6933b332 100755
--- a/contrib/guix/libexec/build.sh
+++ b/contrib/guix/libexec/build.sh
@@ -196,9 +196,7 @@ GIT_ARCHIVE="${DIST_ARCHIVE_BASE}/${DISTNAME}.tar.gz"
 # Create the source tarball if not already there
 if [ ! -e "$GIT_ARCHIVE" ]; then
     mkdir -p "$(dirname "$GIT_ARCHIVE")"
-    CONFIG_SITE="${BASEPREFIX}/${HOST}/share/config.site" \
-    REFERENCE_DATETIME="@${SOURCE_DATE_EPOCH}" \
-    contrib/guix/libexec/make_release_tarball.sh "${GIT_ARCHIVE}" "${DISTNAME}"
+    git archive --prefix="${DISTNAME}/" --output="$GIT_ARCHIVE" HEAD
 fi
 
 mkdir -p "$OUTDIR"
@@ -241,6 +239,8 @@ mkdir -p "$DISTSRC"
     # Extract the source tarball
     tar --strip-components=1 -xf "${GIT_ARCHIVE}"
 
+    ./autogen.sh
+
     # Configure this DISTSRC for $HOST
     # shellcheck disable=SC2086
     env CONFIG_SITE="${BASEPREFIX}/${HOST}/share/config.site" \
@@ -289,29 +289,37 @@ mkdir -p "$DISTSRC"
             ;;
     esac
 
+    case "$HOST" in
+        *darwin*)
+            make deploydir ${V:+V=1}
+            mkdir -p "unsigned-app-${HOST}"
+            cp  --target-directory="unsigned-app-${HOST}" \
+                contrib/macdeploy/detached-sig-create.sh
+            mv --target-directory="unsigned-app-${HOST}" dist
+            (
+                cd "unsigned-app-${HOST}"
+                find . -print0 \
+                    | sort --zero-terminated \
+                    | tar --create --no-recursion --mode='u+rw,go+r-w,a+X' --null --files-from=- \
+                    | gzip -9n > "${OUTDIR}/${DISTNAME}-${HOST}-unsigned.tar.gz" \
+                    || ( rm -f "${OUTDIR}/${DISTNAME}-${HOST}-unsigned.tar.gz" && exit 1 )
+            )
+            make deploy ${V:+V=1} OSX_ZIP="${OUTDIR}/${DISTNAME}-${HOST}-unsigned.zip"
+            ;;
+    esac
     (
         cd installed
 
-        case "$HOST" in
-            *mingw*)
-                mv --target-directory="$DISTNAME"/lib/ "$DISTNAME"/bin/*.dll
-                ;;
-        esac
-
         # Prune libtool and object archives
         find . -name "lib*.la" -delete
         find . -name "lib*.a" -delete
 
-        # Prune pkg-config files
-        rm -rf "${DISTNAME}/lib/pkgconfig"
-
         case "$HOST" in
             *darwin*) ;;
             *)
-                # Split binaries and libraries from their debug symbols
+                # Split binaries from their debug symbols
                 {
                     find "${DISTNAME}/bin" -type f -executable -print0
-                    find "${DISTNAME}/lib" -type f -print0
                 } | xargs -0 -P"$JOBS" -I{} "${DISTSRC}/contrib/devtools/split-debug.sh" {} {} {}.dbg
                 ;;
         esac
@@ -331,7 +339,7 @@ mkdir -p "$DISTSRC"
 
         cp -r "${DISTSRC}/share/rpcauth" "${DISTNAME}/share/"
 
-        # Deterministically produce {non-,}debug binary tarballs ready
+        # Finally, deterministically produce {non-,}debug binary tarballs ready
         # for release
         case "$HOST" in
             *mingw*)
@@ -370,7 +378,6 @@ mkdir -p "$DISTSRC"
         esac
     )  # $DISTSRC/installed
 
-    # Finally make tarballs for codesigning
     case "$HOST" in
         *mingw*)
             cp -rf --target-directory=. contrib/windeploy
@@ -385,23 +392,6 @@ mkdir -p "$DISTSRC"
                     || ( rm -f "${OUTDIR}/${DISTNAME}-win64-unsigned.tar.gz" && exit 1 )
             )
             ;;
-        *darwin*)
-            make deploydir ${V:+V=1}
-            mkdir -p "unsigned-app-${HOST}"
-            cp  --target-directory="unsigned-app-${HOST}" \
-                contrib/macdeploy/detached-sig-create.sh
-            mv --target-directory="unsigned-app-${HOST}" dist
-            cp -r --target-directory="unsigned-app-${HOST}" "${INSTALLPATH}"
-            (
-                cd "unsigned-app-${HOST}"
-                find . -print0 \
-                    | sort --zero-terminated \
-                    | tar --create --no-recursion --mode='u+rw,go+r-w,a+X' --null --files-from=- \
-                    | gzip -9n > "${OUTDIR}/${DISTNAME}-${HOST}-unsigned.tar.gz" \
-                    || ( rm -f "${OUTDIR}/${DISTNAME}-${HOST}-unsigned.tar.gz" && exit 1 )
-            )
-            make deploy ${V:+V=1} OSX_ZIP="${OUTDIR}/${DISTNAME}-${HOST}-unsigned.zip"
-            ;;
     esac
 )  # $DISTSRC
 
diff --git a/contrib/guix/libexec/codesign.sh b/contrib/guix/libexec/codesign.sh
index fb50733c2f..b56d2a2309 100755
--- a/contrib/guix/libexec/codesign.sh
+++ b/contrib/guix/libexec/codesign.sh
@@ -4,9 +4,6 @@
 # file COPYING or http://www.opensource.org/licenses/mit-license.php.
 export LC_ALL=C
 set -e -o pipefail
-
-# Environment variables for determinism
-export TAR_OPTIONS="--owner=0 --group=0 --numeric-owner --mtime='@${SOURCE_DATE_EPOCH}' --sort=name"
 export TZ=UTC
 
 # Although Guix _does_ set umask when building its own packages (in our case,
@@ -85,17 +82,8 @@ mkdir -p "$DISTSRC"
             done
             ;;
         *darwin*)
-            case "$HOST" in
-                arm64*) ARCH="arm64" ;;
-                x86_64*) ARCH="x86_64" ;;
-            esac
-
-            # Apply detached codesignatures (in-place)
-            signapple apply dist/Bitcoin-Qt.app codesignatures/osx/"${HOST}"/dist/Bitcoin-Qt.app
-            find "${DISTNAME}" -wholename "*/bin/*" -type f | while read -r bin
-            do
-                signapple apply "${bin}" "codesignatures/osx/${HOST}/${bin}.${ARCH}sign"
-            done
+            # Apply detached codesignatures to dist/ (in-place)
+            signapple apply dist/Bitcoin-Qt.app codesignatures/osx/dist
 
             # Make a .zip from dist/
             cd dist/
@@ -103,14 +91,6 @@ mkdir -p "$DISTSRC"
                 | xargs -0r touch --no-dereference --date="@${SOURCE_DATE_EPOCH}"
             find . | sort \
                 | zip -X@ "${OUTDIR}/${DISTNAME}-${HOST}.zip"
-            cd ..
-
-            # Make a .tar.gz from bins
-            find "${DISTNAME}" -print0 \
-                | sort --zero-terminated \
-                | tar --create --no-recursion --mode='u+rw,go+r-w,a+X' --null --files-from=- \
-                | gzip -9n > "${OUTDIR}/${DISTNAME}-${HOST}.tar.gz" \
-                || ( rm -f "${OUTDIR}/${DISTNAME}-${HOST}.tar.gz" && exit 1 )
             ;;
         *)
             exit 1
diff --git a/contrib/guix/libexec/make_release_tarball.sh b/contrib/guix/libexec/make_release_tarball.sh
deleted file mode 100755
index 2702c7a0f7..0000000000
--- a/contrib/guix/libexec/make_release_tarball.sh
+++ /dev/null
@@ -1,43 +0,0 @@
-#!/bin/sh
-# Copyright (c) 2020 The Bitcoin Core developers
-# Distributed under the MIT software license, see the accompanying
-# file COPYING or http://www.opensource.org/licenses/mit-license.php.
-#
-# A helper script to generate source release tarball
-
-export LC_ALL=C
-set -ex
-
-[ "$#" -ge 2 ]
-[ -n "${REFERENCE_DATETIME}" ]
-
-GIT_ARCHIVE="$1"
-DISTNAME="$2"
-
-git archive --prefix="${DISTNAME}/" HEAD | tar -xp --exclude '*minisketch*' --exclude 'doc/release-notes'
-
-# Generate correct build info file from git, before we lose git
-GIT_BUILD_INFO="$(share/genbuild.sh /dev/stdout)"
-sed 's/\/\/ No build information available/'"${GIT_BUILD_INFO}"'/' -i "${DISTNAME}/share/genbuild.sh"
-
-cd "${DISTNAME}"
-
-./autogen.sh
-./configure --prefix=/ --disable-ccache --disable-maintainer-mode --disable-dependency-tracking
-make src_files
-make distclean
-
-cd ..
-tar \
-  --format=ustar \
-  --exclude autom4te.cache \
-  --exclude .deps \
-  --exclude .git \
-  --sort=name \
-  --mode='u+rw,go+r-w,a+X' --owner=0 --group=0 \
-  --mtime="${REFERENCE_DATETIME}" \
-  -c "${DISTNAME}" | \
-  gzip -9n \
-  >"${GIT_ARCHIVE}"
-
-rm -rf "${DISTNAME}"
diff --git a/contrib/guix/manifest.scm b/contrib/guix/manifest.scm
index 75cb5035d5..1a47e91b49 100644
--- a/contrib/guix/manifest.scm
+++ b/contrib/guix/manifest.scm
@@ -10,9 +10,6 @@
              (gnu packages file)
              (gnu packages gawk)
              (gnu packages gcc)
-             (gnu packages gnome)
-             (gnu packages image)
-             (gnu packages imagemagick)
              ((gnu packages installers) #:select (nsis-x86_64))
              ((gnu packages linux) #:select (linux-libre-headers-6.1 util-linux))
              (gnu packages llvm)
@@ -20,15 +17,13 @@
              (gnu packages moreutils)
              (gnu packages pkg-config)
              ((gnu packages python) #:select (python-minimal))
-             ((gnu packages python-build) #:select (python-tomli python-poetry-core))
+             ((gnu packages python-build) #:select (python-tomli))
              ((gnu packages python-crypto) #:select (python-asn1crypto))
              ((gnu packages tls) #:select (openssl))
              ((gnu packages version-control) #:select (git-minimal))
              (guix build-system cmake)
-             (guix build-system font)
              (guix build-system gnu)
              (guix build-system python)
-             (guix build-system pyproject)
              (guix build-system trivial)
              (guix download)
              (guix gexp)
@@ -167,25 +162,6 @@ chain for " target " development."))
       (home-page (package-home-page pthreads-xgcc))
       (license (package-license pthreads-xgcc)))))
 
-(define-public font-tuffy
-  (package
-    (name "font-tuffy")
-    (version "20120614")
-    (source
-     (origin
-       (method url-fetch)
-       (uri (string-append "http://tulrich.com/fonts/tuffy-" version ".tar.gz"))
-       (file-name (string-append name "-" version ".tar.gz"))
-       (sha256
-        (base32
-         "02vf72bgrp30vrbfhxjw82s115z27dwfgnmmzfb0n9wfhxxfpyf6"))))
-    (build-system font-build-system)
-    (home-page "http://tulrich.com/fonts/")
-    (synopsis "The Tuffy Truetype Font Family")
-    (description
-     "Thatcher Ulrich's first outline font design. He started with the goal of producing a neutral, readable sans-serif text font. There are lots of \"expressive\" fonts out there, but he wanted to start with something very plain and clean, something he might want to actually use. ")
-    (license license:public-domain)))
-
 ;; While LIEF is packaged in Guix, we maintain our own package,
 ;; to simplify building, and more easily apply updates.
 ;; Moreover, the Guix's package uses cmake, which caused build
@@ -417,10 +393,10 @@ specific moment in time, whitelisting and revocation checks.")
       (license license:expat))))
 
 (define-public python-signapple
-  (let ((commit "85bfcecc33d2773bc09bc318cec0614af2c8e287"))
+  (let ((commit "62155712e7417aba07565c9780a80e452823ae6a"))
     (package
       (name "python-signapple")
-      (version (git-version "0.2.0" "1" commit))
+      (version (git-version "0.1" "1" commit))
       (source
        (origin
          (method git-fetch)
@@ -430,14 +406,13 @@ specific moment in time, whitelisting and revocation checks.")
          (file-name (git-file-name name commit))
          (sha256
           (base32
-           "17yqjll8nw83q6dhgqhkl7w502z5vy9sln8m6mlx0f1c10isg8yg"))))
-      (build-system pyproject-build-system)
+           "1nm6rm4h4m7kbq729si4cm8rzild62mk4ni8xr5zja7l33fhv3gb"))))
+      (build-system python-build-system)
       (propagated-inputs
         (list python-asn1crypto
               python-oscrypto
               python-certvalidator
               python-elfesteem))
-      (native-inputs (list python-poetry-core))
       ;; There are no tests, but attempting to run python setup.py test leads to
       ;; problems, just disable the test
       (arguments '(#:tests? #f))
@@ -485,7 +460,7 @@ inspecting signatures in Mach-O binaries.")
                #t))))))))
 
 (define-public glibc-2.31
-  (let ((commit "7b27c450c34563a28e634cccb399cd415e71ebfe"))
+  (let ((commit "8e30f03744837a85e33d84ccd34ed3abe30d37c3"))
   (package
     (inherit glibc) ;; 2.35
     (version "2.31")
@@ -497,7 +472,7 @@ inspecting signatures in Mach-O binaries.")
               (file-name (git-file-name "glibc" commit))
               (sha256
                (base32
-                "017qdpr5id7ddb4lpkzj2li1abvw916m3fc6n7nw28z4h5qbv2n0"))
+                "1zi0s9yy5zkisw823vivn7zlj8w6g9p3mm7lmlqiixcxdkz4dbn6"))
               (patches (search-our-patches "glibc-guix-prefix.patch"))))
     (arguments
       (substitute-keyword-arguments (package-arguments glibc)
@@ -505,11 +480,8 @@ inspecting signatures in Mach-O binaries.")
           `(append ,flags
             ;; https://www.gnu.org/software/libc/manual/html_node/Configuring-and-compiling.html
             (list "--enable-stack-protector=all",
-                  "--enable-cet",
                   "--enable-bind-now",
                   "--disable-werror",
-                  "--disable-timezone-tools",
-                  "--disable-profile",
                   building-on)))
     ((#:phases phases)
         `(modify-phases ,phases
@@ -554,9 +526,6 @@ inspecting signatures in Mach-O binaries.")
         autoconf-2.71
         automake
         pkg-config
-        imagemagick
-        libicns
-        librsvg-2.40
         ;; Scripting
         python-minimal ;; (3.10)
         ;; Git
@@ -565,7 +534,7 @@ inspecting signatures in Mach-O binaries.")
         python-lief)
   (let ((target (getenv "HOST")))
     (cond ((string-suffix? "-mingw32" target)
-           (list font-tuffy zip
+           (list zip
                  (make-mingw-pthreads-cross-toolchain "x86_64-w64-mingw32")
                  nsis-x86_64
                  nss-certs
diff --git a/contrib/init/bitcoind.conf b/contrib/init/bitcoind.conf
index ccd036c4e5..dde1bd0c4d 100644
--- a/contrib/init/bitcoind.conf
+++ b/contrib/init/bitcoind.conf
@@ -1,4 +1,4 @@
-description "Bitcoin Knots Daemon"
+description "Bitcoin Core Daemon"
 
 start on runlevel [2345]
 stop on starting rc RUNLEVEL=[016]
diff --git a/contrib/init/bitcoind.init b/contrib/init/bitcoind.init
index 367b6cd741..19e1f76d09 100644
--- a/contrib/init/bitcoind.init
+++ b/contrib/init/bitcoind.init
@@ -1,6 +1,6 @@
 #!/usr/bin/env bash
 #
-#  bitcoind The Bitcoin Knots server.
+#  bitcoind The bitcoin core server.
 #
 #
 # chkconfig: 345 80 20
diff --git a/contrib/init/bitcoind.openrc b/contrib/init/bitcoind.openrc
index 4133903be1..013a1a6070 100644
--- a/contrib/init/bitcoind.openrc
+++ b/contrib/init/bitcoind.openrc
@@ -18,7 +18,7 @@ BITCOIND_BIN=${BITCOIND_BIN:-/usr/bin/bitcoind}
 BITCOIND_NICE=${BITCOIND_NICE:-${NICELEVEL:-0}}
 BITCOIND_OPTS="${BITCOIND_OPTS:-${BITCOIN_OPTS}}"
 
-name="Bitcoin Knots Daemon"
+name="Bitcoin Core Daemon"
 description="Bitcoin cryptocurrency P2P network daemon"
 
 command="/usr/bin/bitcoind"
diff --git a/contrib/macdeploy/detached-sig-create.sh b/contrib/macdeploy/detached-sig-create.sh
index 89094403b7..097a7c35ee 100755
--- a/contrib/macdeploy/detached-sig-create.sh
+++ b/contrib/macdeploy/detached-sig-create.sh
@@ -6,57 +6,26 @@
 export LC_ALL=C
 set -e
 
+ROOTDIR=dist
+BUNDLE="${ROOTDIR}/Bitcoin-Qt.app"
+BINARY="${BUNDLE}/Contents/MacOS/Bitcoin-Qt"
 SIGNAPPLE=signapple
 TEMPDIR=sign.temp
-
-BUNDLE_ROOT=dist
-BUNDLE_NAME="Bitcoin-Qt.app"
-UNSIGNED_BUNDLE="${BUNDLE_ROOT}/${BUNDLE_NAME}"
-UNSIGNED_BINARY="${UNSIGNED_BUNDLE}/Contents/MacOS/Bitcoin-Qt"
-
-ARCH=$(${SIGNAPPLE} info ${UNSIGNED_BINARY} | head -n 1 | cut -d " " -f 1)
-
-OUTDIR="osx/${ARCH}-apple-darwin"
-OUTROOT="${TEMPDIR}/${OUTDIR}"
-
+ARCH=$(${SIGNAPPLE} info ${BINARY} | head -n 1 | cut -d " " -f 1)
 OUT="signature-osx-${ARCH}.tar.gz"
+OUTROOT=osx/dist
 
-if [ "$#" -ne 3 ]; then
-  echo "usage: $0 <path to key> <path to app store connect key> <apple developer team uuid>"
+if [ -z "$1" ]; then
+  echo "usage: $0 <signapple args>"
+  echo "example: $0 <path to key>"
   exit 1
 fi
 
 rm -rf ${TEMPDIR}
 mkdir -p ${TEMPDIR}
 
-stty -echo
-printf "Enter the passphrase for %s: " "$1"
-read cs_key_pass
-printf "\n"
-printf "Enter the passphrase for %s: " "$2"
-read api_key_pass
-printf "\n"
-stty echo
-
-# Sign and notarize app bundle
-${SIGNAPPLE} sign -f --hardened-runtime --detach "${OUTROOT}/${BUNDLE_ROOT}" --passphrase "${cs_key_pass}" "$1" "${UNSIGNED_BUNDLE}"
-${SIGNAPPLE} apply "${UNSIGNED_BUNDLE}" "${OUTROOT}/${BUNDLE_ROOT}/${BUNDLE_NAME}"
-${SIGNAPPLE} notarize --detach "${OUTROOT}/${BUNDLE_ROOT}" --passphrase "${api_key_pass}" "$2" "$3" "${UNSIGNED_BUNDLE}"
-
-# Sign each binary
-find . -maxdepth 3 -wholename "*/bin/*" -type f -exec realpath --relative-to=. {} \; | while read -r bin
-do
-    bin_dir=$(dirname "${bin}")
-    bin_name=$(basename "${bin}")
-    ${SIGNAPPLE} sign -f --hardened-runtime --detach "${OUTROOT}/${bin_dir}" --passphrase "${cs_key_pass}" "$1" "${bin}"
-    ${SIGNAPPLE} apply "${bin}" "${OUTROOT}/${bin_dir}/${bin_name}.${ARCH}sign"
-done
-
-# Notarize the binaries
-# Binaries cannot have stapled notarizations so this does not actually generate any output
-binaries_dir=$(dirname "$(find . -maxdepth 2 -wholename '*/bin' -type d -exec realpath --relative-to=. {} \;)")
-${SIGNAPPLE} notarize --passphrase "${api_key_pass}" "$2" "$3" "${binaries_dir}"
+${SIGNAPPLE} sign -f --detach "${TEMPDIR}/${OUTROOT}"  "$@" "${BUNDLE}" --hardened-runtime
 
-tar -C "${TEMPDIR}" -czf "${OUT}" "${OUTDIR}"
+tar -C "${TEMPDIR}" -czf "${OUT}" .
 rm -rf "${TEMPDIR}"
 echo "Created ${OUT}"
diff --git a/contrib/seeds/README.md b/contrib/seeds/README.md
index 10945e5b68..fe469aee9e 100644
--- a/contrib/seeds/README.md
+++ b/contrib/seeds/README.md
@@ -9,7 +9,7 @@ changes its default return value, as those are the services which seeds are adde
 to addrman with).
 
 The seeds compiled into the release are created from sipa's, achow101's and luke-jr's
-DNS seed, virtu's crawler, and asmap community AS map data. Run the following commands
+DNS seed, virtu's crawler, and fjahr's community AS map data. Run the following commands
 from the `/contrib/seeds` directory:
 
 ```
@@ -18,7 +18,7 @@ curl https://mainnet.achownodes.xyz/seeds.txt.gz | gzip -dc >> seeds_main.txt
 curl https://21.ninja/seeds.txt.gz | gzip -dc >> seeds_main.txt
 curl https://luke.dashjr.org/programs/bitcoin/files/charts/seeds.txt >> seeds_main.txt
 curl https://testnet.achownodes.xyz/seeds.txt.gz | gzip -dc > seeds_test.txt
-curl https://raw.githubusercontent.com/asmap/asmap-data/main/latest_asmap.dat > asmap-filled.dat
+curl https://raw.githubusercontent.com/fjahr/asmap-data/main/latest_asmap.dat > asmap-filled.dat
 python3 makeseeds.py -a asmap-filled.dat -s seeds_main.txt > nodes_main.txt
 python3 makeseeds.py -a asmap-filled.dat -s seeds_test.txt > nodes_test.txt
 # TODO: Uncomment when a seeder publishes seeds.txt.gz for testnet4
diff --git a/contrib/tracing/log_raw_p2p_msgs.py b/contrib/tracing/log_raw_p2p_msgs.py
index 67b92ce7b8..c0ab704106 100755
--- a/contrib/tracing/log_raw_p2p_msgs.py
+++ b/contrib/tracing/log_raw_p2p_msgs.py
@@ -41,8 +41,7 @@ from bcc import BPF, USDT
 program = """
 #include <uapi/linux/ptrace.h>
 
-// A min() macro. Prefixed with _TRACEPOINT_TEST to avoid collision with other MIN macros.
-#define _TRACEPOINT_TEST_MIN(a,b) ({ __typeof__ (a) _a = (a); __typeof__ (b) _b = (b); _a < _b ? _a : _b; })
+#define MIN(a,b) ({ __typeof__ (a) _a = (a); __typeof__ (b) _b = (b); _a < _b ? _a : _b; })
 
 // Maximum possible allocation size
 // from include/linux/percpu.h in the Linux kernel
@@ -89,7 +88,7 @@ int trace_inbound_message(struct pt_regs *ctx) {
     bpf_usdt_readarg_p(3, ctx, &msg->peer_conn_type, MAX_PEER_CONN_TYPE_LENGTH);
     bpf_usdt_readarg_p(4, ctx, &msg->msg_type, MAX_MSG_TYPE_LENGTH);
     bpf_usdt_readarg(5, ctx, &msg->msg_size);
-    bpf_usdt_readarg_p(6, ctx, &msg->msg, _TRACEPOINT_TEST_MIN(msg->msg_size, MAX_MSG_DATA_LENGTH));
+    bpf_usdt_readarg_p(6, ctx, &msg->msg, MIN(msg->msg_size, MAX_MSG_DATA_LENGTH));
 
     inbound_messages.perf_submit(ctx, msg, sizeof(*msg));
     return 0;
@@ -109,7 +108,7 @@ int trace_outbound_message(struct pt_regs *ctx) {
     bpf_usdt_readarg_p(3, ctx, &msg->peer_conn_type, MAX_PEER_CONN_TYPE_LENGTH);
     bpf_usdt_readarg_p(4, ctx, &msg->msg_type, MAX_MSG_TYPE_LENGTH);
     bpf_usdt_readarg(5, ctx, &msg->msg_size);
-    bpf_usdt_readarg_p(6, ctx, &msg->msg,  _TRACEPOINT_TEST_MIN(msg->msg_size, MAX_MSG_DATA_LENGTH));
+    bpf_usdt_readarg_p(6, ctx, &msg->msg,  MIN(msg->msg_size, MAX_MSG_DATA_LENGTH));
 
     outbound_messages.perf_submit(ctx, msg, sizeof(*msg));
     return 0;
diff --git a/depends/Makefile b/depends/Makefile
index 8b6834ac26..52a9a14e56 100644
--- a/depends/Makefile
+++ b/depends/Makefile
@@ -259,8 +259,7 @@ endef
 
 define check_or_remove_sources
   mkdir -p $($(package)_source_dir); cd $($(package)_source_dir); \
-  test -f $($(package)_fetched) && ( test `cat $($(package)_fetched) | wc -l` -eq $(words $($(package)_all_sources)) && \
-    $(build_SHA256SUM) -c $($(package)_fetched) >/dev/null 2>/dev/null || \
+  test -f $($(package)_fetched) && ( $(build_SHA256SUM) -c $($(package)_fetched) >/dev/null 2>/dev/null || \
     ( echo "Checksum missing or mismatched for $(package) source. Forcing re-download."; \
       rm -f $($(package)_all_sources) $($(1)_fetched))) || true
 endef
diff --git a/depends/packages/libevent.mk b/depends/packages/libevent.mk
index 8acb2bd895..4c05e8a0a7 100644
--- a/depends/packages/libevent.mk
+++ b/depends/packages/libevent.mk
@@ -11,10 +11,9 @@ $(package)_build_subdir=build
 # version as we do in configure. Due to quirks in libevents build system, this
 # is also required to enable support for ipv6. See #19375.
 define $(package)_set_vars
-  $(package)_config_opts=-DCMAKE_BUILD_TYPE=None -DEVENT__DISABLE_BENCHMARK=ON -DEVENT__DISABLE_OPENSSL=ON
+  $(package)_config_opts=-DEVENT__DISABLE_BENCHMARK=ON -DEVENT__DISABLE_OPENSSL=ON
   $(package)_config_opts+=-DEVENT__DISABLE_SAMPLES=ON -DEVENT__DISABLE_REGRESS=ON
   $(package)_config_opts+=-DEVENT__DISABLE_TESTS=ON -DEVENT__LIBRARY_TYPE=STATIC
-  $(package)_cflags += -ffile-prefix-map=$($(package)_extract_dir)=/usr
   $(package)_cppflags += -D_GNU_SOURCE
   $(package)_cppflags_mingw32=-D_WIN32_WINNT=0x0601
 
diff --git a/depends/packages/qt.mk b/depends/packages/qt.mk
index 17b7654e05..b133539495 100644
--- a/depends/packages/qt.mk
+++ b/depends/packages/qt.mk
@@ -1,9 +1,9 @@
 package=qt
-$(package)_version=5.15.16
-$(package)_download_path=https://download.qt.io/archive/qt/5.15/$($(package)_version)/submodules
+$(package)_version=5.15.14
+$(package)_download_path=https://download.qt.io/official_releases/qt/5.15/$($(package)_version)/submodules
 $(package)_suffix=everywhere-opensource-src-$($(package)_version).tar.xz
 $(package)_file_name=qtbase-$($(package)_suffix)
-$(package)_sha256_hash=b04815058c18058b6ba837206756a2c87d1391f07a0dcb0dd314f970fd041592
+$(package)_sha256_hash=500d3b390048e9538c28b5f523dfea6936f9c2e10d24ab46580ff57d430b98be
 $(package)_linux_dependencies=freetype fontconfig libxcb libxkbcommon libxcb_util libxcb_util_render libxcb_util_keysyms libxcb_util_image libxcb_util_wm
 $(package)_qt_libs=corelib network widgets gui plugins testlib
 $(package)_linguist_tools = lrelease lupdate lconvert
@@ -27,18 +27,14 @@ $(package)_patches += darwin_no_libm.patch
 $(package)_patches += zlib-timebits64.patch
 
 $(package)_qttranslations_file_name=qttranslations-$($(package)_suffix)
-$(package)_qttranslations_sha256_hash=415dbbb82a75dfc9a7be969e743bee54c0e6867be37bce4cf8f03da39f20112a
+$(package)_qttranslations_sha256_hash=5b94d1a11b566908622fcca2f8b799744d2f8a68da20be4caa5953ed63b10489
 
 $(package)_qttools_file_name=qttools-$($(package)_suffix)
-$(package)_qttools_sha256_hash=1cab11887faca54af59f4995ee435c9ad98d194e9e6889c846692c8b6815fc1c
+$(package)_qttools_sha256_hash=12061a85baf5f4de8fbc795e1d3872b706f340211b9e70962caeffc6f5e89563
 
 $(package)_extra_sources  = $($(package)_qttranslations_file_name)
 $(package)_extra_sources += $($(package)_qttools_file_name)
 
-$(package)_qtwinextras_file_name=qtwinextras-$($(package)_suffix)
-$(package)_qtwinextras_sha256_hash=8e7a3b0d03b0f726b10bb050f560659fa7babaa45273e174e9fcc3bb9c169a4e
-$(package)_extra_sources += $($(package)_qtwinextras_file_name)
-
 define $(package)_set_vars
 $(package)_config_env = QT_MAC_SDK_NO_VERSION_CHECK=1
 $(package)_config_opts_release = -release
@@ -196,7 +192,6 @@ endef
 define $(package)_fetch_cmds
 $(call fetch_file,$(package),$($(package)_download_path),$($(package)_download_file),$($(package)_file_name),$($(package)_sha256_hash)) && \
 $(call fetch_file,$(package),$($(package)_download_path),$($(package)_qttranslations_file_name),$($(package)_qttranslations_file_name),$($(package)_qttranslations_sha256_hash)) && \
-$(call fetch_file,$(package),$($(package)_download_path),$($(package)_qtwinextras_file_name),$($(package)_qtwinextras_file_name),$($(package)_qtwinextras_sha256_hash)) && \
 $(call fetch_file,$(package),$($(package)_download_path),$($(package)_qttools_file_name),$($(package)_qttools_file_name),$($(package)_qttools_sha256_hash))
 endef
 
@@ -205,14 +200,11 @@ define $(package)_extract_cmds
   echo "$($(package)_sha256_hash)  $($(package)_source)" > $($(package)_extract_dir)/.$($(package)_file_name).hash && \
   echo "$($(package)_qttranslations_sha256_hash)  $($(package)_source_dir)/$($(package)_qttranslations_file_name)" >> $($(package)_extract_dir)/.$($(package)_file_name).hash && \
   echo "$($(package)_qttools_sha256_hash)  $($(package)_source_dir)/$($(package)_qttools_file_name)" >> $($(package)_extract_dir)/.$($(package)_file_name).hash && \
-  echo "$($(package)_qtwinextras_sha256_hash)  $($(package)_source_dir)/$($(package)_qtwinextras_file_name)" >> $($(package)_extract_dir)/.$($(package)_file_name).hash && \
   $(build_SHA256SUM) -c $($(package)_extract_dir)/.$($(package)_file_name).hash && \
   mkdir qtbase && \
   $(build_TAR) --no-same-owner --strip-components=1 -xf $($(package)_source) -C qtbase && \
   mkdir qttranslations && \
   $(build_TAR) --no-same-owner --strip-components=1 -xf $($(package)_source_dir)/$($(package)_qttranslations_file_name) -C qttranslations && \
-  mkdir qtwinextras && \
-  $(build_TAR) --no-same-owner --strip-components=1 -xf $($(package)_source_dir)/$($(package)_qtwinextras_file_name) -C qtwinextras && \
   mkdir qttools && \
   $(build_TAR) --no-same-owner --strip-components=1 -xf $($(package)_source_dir)/$($(package)_qttools_file_name) -C qttools
 endef
@@ -232,6 +224,7 @@ endef
 define $(package)_preprocess_cmds
   cp $($(package)_patch_dir)/qt.pro qt.pro && \
   cp $($(package)_patch_dir)/qttools_src.pro qttools/src/src.pro && \
+  patch -p1 -i $($(package)_patch_dir)/fix-macos-linker.patch && \
   patch -p1 -i $($(package)_patch_dir)/dont_hardcode_pwd.patch && \
   patch -p1 -i $($(package)_patch_dir)/fix_qt_pkgconfig.patch && \
   patch -p1 -i $($(package)_patch_dir)/no-xlib.patch && \
@@ -245,7 +238,7 @@ define $(package)_preprocess_cmds
   patch -p1 -i $($(package)_patch_dir)/guix_cross_lib_path.patch && \
   patch -p1 -i $($(package)_patch_dir)/windows_lto.patch && \
   patch -p1 -i $($(package)_patch_dir)/darwin_no_libm.patch && \
-  sed -i.old -e '/qwinjumplist/d' qtwinextras/src/winextras/winextras.pro && \
+  patch -p1 -i $($(package)_patch_dir)/zlib-timebits64.patch && \
   mkdir -p qtbase/mkspecs/macx-clang-linux &&\
   cp -f qtbase/mkspecs/macx-clang/qplatformdefs.h qtbase/mkspecs/macx-clang-linux/ &&\
   cp -f $($(package)_patch_dir)/mac-qmake.conf qtbase/mkspecs/macx-clang-linux/qmake.conf && \
@@ -275,7 +268,6 @@ endef
 define $(package)_stage_cmds
   $(MAKE) -C qtbase/src INSTALL_ROOT=$($(package)_staging_dir) $(addsuffix -install_subtargets,$(addprefix sub-,$($(package)_qt_libs))) && \
   $(MAKE) -C qttools/src/linguist INSTALL_ROOT=$($(package)_staging_dir) $(addsuffix -install_subtargets,$(addprefix sub-,$($(package)_linguist_tools))) && \
-  $(MAKE) -C qtwinextras INSTALL_ROOT=$($(package)_staging_dir) install_subtargets && \
   $(MAKE) -C qttranslations INSTALL_ROOT=$($(package)_staging_dir) install_subtargets
 endef
 
diff --git a/depends/packages/zeromq.mk b/depends/packages/zeromq.mk
index 67a0dd88e5..df018a1032 100644
--- a/depends/packages/zeromq.mk
+++ b/depends/packages/zeromq.mk
@@ -12,7 +12,6 @@ $(package)_patches += openbsd_kqueue_headers.patch
 $(package)_patches += cmake_minimum.patch
 $(package)_patches += cacheline_undefined.patch
 $(package)_patches += no_librt.patch
-$(package)_patches += fix_mingw_link.patch
 
 define $(package)_set_vars
   $(package)_config_opts := -DCMAKE_BUILD_TYPE=None -DWITH_DOCS=OFF -DWITH_LIBSODIUM=OFF
@@ -31,8 +30,7 @@ define $(package)_preprocess_cmds
   patch -p1 < $($(package)_patch_dir)/fix_have_windows.patch && \
   patch -p1 < $($(package)_patch_dir)/openbsd_kqueue_headers.patch && \
   patch -p1 < $($(package)_patch_dir)/cmake_minimum.patch && \
-  patch -p1 < $($(package)_patch_dir)/no_librt.patch && \
-  patch -p1 < $($(package)_patch_dir)/fix_mingw_link.patch
+  patch -p1 < $($(package)_patch_dir)/no_librt.patch
 endef
 
 define $(package)_config_cmds
diff --git a/depends/patches/qt/memory_resource.patch b/depends/patches/qt/memory_resource.patch
index edc6c86baf..312f0669f6 100644
--- a/depends/patches/qt/memory_resource.patch
+++ b/depends/patches/qt/memory_resource.patch
@@ -44,6 +44,6 @@ and https://bugreports.qt.io/browse/QTBUG-114316
 +#   undef __cpp_lib_memory_resource // Only supported on macOS 14 and iOS 17
 +#  endif
 +# endif // (defined(Q_CC_CLANG) || defined(Q_CC_INTEL)) && defined(Q_OS_MAC)
- # if defined(Q_CC_CLANG) && defined(Q_OS_MAC) && defined(__cpp_lib_memory_resource) \
-    && ((defined(__MAC_OS_X_VERSION_MIN_REQUIRED)  && __MAC_OS_X_VERSION_MIN_REQUIRED  < 140000) \
-     || (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED < 170000))
+ # if defined(Q_CC_CLANG) && defined(Q_CC_INTEL) && Q_CC_INTEL >= 1500
+ // ICC 15.x and 16.0 have their own implementation of std::atomic, which is activated when in Clang mode
+ // (probably because libc++'s <atomic> on OS X failed to compile), but they're missing some
diff --git a/depends/patches/qt/qt.pro b/depends/patches/qt/qt.pro
index f5a59f329e..8f2e900a84 100644
--- a/depends/patches/qt/qt.pro
+++ b/depends/patches/qt/qt.pro
@@ -8,10 +8,9 @@ CONFIG += $$prl
 cache(CONFIG, add stash, prl)
 
 TEMPLATE = subdirs
-SUBDIRS = qtbase qttools qttranslations qtwinextras
+SUBDIRS = qtbase qttools qttranslations
 
 qttools.depends = qtbase
 qttranslations.depends = qttools
-qtwinextras.depends = qtbase
 
 load(qt_configure)
diff --git a/depends/patches/zeromq/fix_mingw_link.patch b/depends/patches/zeromq/fix_mingw_link.patch
deleted file mode 100644
index 1434557dc7..0000000000
--- a/depends/patches/zeromq/fix_mingw_link.patch
+++ /dev/null
@@ -1,31 +0,0 @@
-Fix CMake-generated `libzmq.pc` file
-
-This change mirrors the Autotools-based build system behavior for
-cross-compiling for Windows with static linking.
-
-See https://github.com/zeromq/libzmq/pull/4706.
-
-
-diff --git a/CMakeLists.txt b/CMakeLists.txt
-index 03462271..0315e606 100644
---- a/CMakeLists.txt
-+++ b/CMakeLists.txt
-@@ -546,12 +546,18 @@ if(ZMQ_HAVE_WINDOWS)
-   # Cannot use check_library_exists because the symbol is always declared as char(*)(void)
-   set(CMAKE_REQUIRED_LIBRARIES "ws2_32.lib")
-   check_cxx_symbol_exists(WSAStartup "winsock2.h" HAVE_WS2_32)
-+  if(HAVE_WS2_32)
-+    set(pkg_config_libs_private "${pkg_config_libs_private} -lws2_32")
-+  endif()
- 
-   set(CMAKE_REQUIRED_LIBRARIES "rpcrt4.lib")
-   check_cxx_symbol_exists(UuidCreateSequential "rpc.h" HAVE_RPCRT4)
- 
-   set(CMAKE_REQUIRED_LIBRARIES "iphlpapi.lib")
-   check_cxx_symbol_exists(GetAdaptersAddresses "winsock2.h;iphlpapi.h" HAVE_IPHLAPI)
-+  if(HAVE_IPHLAPI)
-+    set(pkg_config_libs_private "${pkg_config_libs_private} -liphlpapi")
-+  endif()
-   check_cxx_symbol_exists(if_nametoindex "iphlpapi.h" HAVE_IF_NAMETOINDEX)
- 
-   set(CMAKE_REQUIRED_LIBRARIES "")
diff --git a/doc/Doxyfile.in b/doc/Doxyfile.in
index 42a851b9f1..d8fd46d1c7 100644
--- a/doc/Doxyfile.in
+++ b/doc/Doxyfile.in
@@ -32,7 +32,7 @@ DOXYFILE_ENCODING      = UTF-8
 # title of most generated pages and in a few other places.
 # The default value is: My Project.
 
-PROJECT_NAME           = "Bitcoin Knots"
+PROJECT_NAME           = "Bitcoin Core"
 
 # The PROJECT_NUMBER tag can be used to enter a project or revision number. This
 # could be handy for archiving the generated documentation or if some version
diff --git a/doc/README.md b/doc/README.md
index 1f6795686c..74a85b04e6 100644
--- a/doc/README.md
+++ b/doc/README.md
@@ -1,15 +1,15 @@
-Bitcoin Knots
+Bitcoin Core
 =============
 
 Setup
 ---------------------
-Bitcoin Knots is the original Bitcoin client and it builds the backbone of the network. It downloads and, by default, stores the entire history of Bitcoin transactions, which requires a few hundred gigabytes of disk space. Depending on the speed of your computer and network connection, the synchronization process can take anywhere from a few hours to a day or more.
+Bitcoin Core is the original Bitcoin client and it builds the backbone of the network. It downloads and, by default, stores the entire history of Bitcoin transactions, which requires a few hundred gigabytes of disk space. Depending on the speed of your computer and network connection, the synchronization process can take anywhere from a few hours to a day or more.
 
-To download Bitcoin Knots, visit [bitcoinknots.org](https://bitcoinknots.org/).
+To download Bitcoin Core, visit [bitcoincore.org](https://bitcoincore.org/en/download/).
 
 Running
 ---------------------
-The following are some helpful notes on how to run Bitcoin Knots on your native platform.
+The following are some helpful notes on how to run Bitcoin Core on your native platform.
 
 ### Unix
 
@@ -24,7 +24,7 @@ Unpack the files into a directory, and then run bitcoin-qt.exe.
 
 ### macOS
 
-Drag Bitcoin Knots to your applications folder, and then run Bitcoin Knots.
+Drag Bitcoin Core to your applications folder, and then run Bitcoin Core.
 
 ### Need Help?
 
@@ -36,7 +36,7 @@ for help and more information.
 
 Building
 ---------------------
-The following are developer notes on how to build Bitcoin Knots on your native platform. They are not complete guides, but include notes on the necessary libraries, compile flags, etc.
+The following are developer notes on how to build Bitcoin Core on your native platform. They are not complete guides, but include notes on the necessary libraries, compile flags, etc.
 
 - [Dependencies](dependencies.md)
 - [macOS Build Notes](build-osx.md)
@@ -58,7 +58,6 @@ The Bitcoin repo's [root README](/README.md) contains relevant information on th
 - [Translation Strings Policy](translation_strings_policy.md)
 - [JSON-RPC Interface](JSON-RPC-interface.md)
 - [Unauthenticated REST Interface](REST-interface.md)
-- [Shared Libraries](shared-libraries.md)
 - [BIPS](bips.md)
 - [Dnsseed Policy](dnsseed-policy.md)
 - [Benchmarking](benchmarking.md)
diff --git a/doc/README_windows.txt b/doc/README_windows.txt
index 2a8062ed62..07d61b3bda 100644
--- a/doc/README_windows.txt
+++ b/doc/README_windows.txt
@@ -1,4 +1,4 @@
-Bitcoin Knots
+Bitcoin Core
 =============
 
 Intro
@@ -13,7 +13,7 @@ Setup
 -----
 Unpack the files into a directory and run bitcoin-qt.exe.
 
-Bitcoin Knots is the original Bitcoin client and it builds the backbone of the network.
+Bitcoin Core is the original Bitcoin client and it builds the backbone of the network.
 However, it downloads and stores the entire history of Bitcoin transactions;
 depending on the speed of your computer and network connection, the synchronization
 process can take anywhere from a few hours to a day or more.
diff --git a/doc/REST-interface.md b/doc/REST-interface.md
index 728013fcf2..6664bc2a3a 100644
--- a/doc/REST-interface.md
+++ b/doc/REST-interface.md
@@ -144,12 +144,6 @@ Refer to the `getrawmempool` RPC help for details. Defaults to setting
 *Query parameters for `verbose` and `mempool_sequence` available in 25.0 and up.*
 
 
-#### Fees
-`GET /rest/fee/<MODE>/<TARGET>.json`
-
-Returns fee and blocknumber where estimation was found. `<MODE>` should be one of `<unset|conservative|economical>`.
-`<TARGET>` is the desired confirmation time (in block height).
-
 Risks
 -------------
 Running a web browser on the same node with a REST enabled bitcoind can be a risk. Accessing prepared XSS websites could read out tx/block data of your node by placing links like `<script src="http://127.0.0.1:8332/rest/tx/1234567890.json">` which might break the nodes privacy.
diff --git a/doc/bips.md b/doc/bips.md
index 5e04a4070f..d544ff822b 100644
--- a/doc/bips.md
+++ b/doc/bips.md
@@ -1,11 +1,10 @@
-BIPs that are implemented by Bitcoin Knots:
+BIPs that are implemented by Bitcoin Core:
 
 * [`BIP 9`](https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki): The changes allowing multiple soft-forks to be deployed in parallel have been implemented since **v0.12.1**  ([PR #7575](https://github.com/bitcoin/bitcoin/pull/7575))
 * [`BIP 11`](https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki): Multisig outputs are standard since **v0.6.0** ([PR #669](https://github.com/bitcoin/bitcoin/pull/669)).
 * [`BIP 13`](https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki): The address format for P2SH addresses has been implemented since **v0.6.0** ([PR #669](https://github.com/bitcoin/bitcoin/pull/669)).
 * [`BIP 14`](https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki): The subversion string is being used as User Agent since **v0.6.0** ([PR #669](https://github.com/bitcoin/bitcoin/pull/669)).
 * [`BIP 16`](https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki): The pay-to-script-hash evaluation rules have been implemented since **v0.6.0**, and took effect on *April 1st 2012* ([PR #748](https://github.com/bitcoin/bitcoin/pull/748)).
-* [`BIP 20`](https://github.com/bitcoin/bips/blob/master/bip-0020.mediawiki): The extended amount format in URIs for Bitcoin payments has been implemented since **next-test 2011-12-23**
 * [`BIP 21`](https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki): The URI format for Bitcoin payments has been implemented since **v0.6.0** ([PR #176](https://github.com/bitcoin/bitcoin/pull/176)).
 * [`BIP 22`](https://github.com/bitcoin/bips/blob/master/bip-0022.mediawiki): The 'getblocktemplate' (GBT) RPC protocol for mining has been implemented since **v0.7.0** ([PR #936](https://github.com/bitcoin/bitcoin/pull/936)).
 * [`BIP 23`](https://github.com/bitcoin/bips/blob/master/bip-0023.mediawiki): Some extensions to GBT have been implemented since **v0.10.0rc1**, including longpolling and block proposals ([PR #1816](https://github.com/bitcoin/bitcoin/pull/1816)).
@@ -14,7 +13,7 @@ BIPs that are implemented by Bitcoin Knots:
 * [`BIP 32`](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki): Hierarchical Deterministic Wallets has been implemented since **v0.13.0** ([PR #8035](https://github.com/bitcoin/bitcoin/pull/8035)).
 * [`BIP 34`](https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki): The rule that requires blocks to contain their height (number) in the coinbase input, and the introduction of version 2 blocks has been implemented since **v0.7.0**. The rule took effect for version 2 blocks as of *block 224413* (March 5th 2013), and version 1 blocks are no longer allowed since *block 227931* (March 25th 2013) ([PR #1526](https://github.com/bitcoin/bitcoin/pull/1526)).
 * [`BIP 35`](https://github.com/bitcoin/bips/blob/master/bip-0035.mediawiki): The 'mempool' protocol message (and the protocol version bump to 60002) has been implemented since **v0.7.0** ([PR #1641](https://github.com/bitcoin/bitcoin/pull/1641)). As of **v0.13.0**, this is only available for `NODE_BLOOM` (BIP 111) peers.
-* [`BIP 37`](https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki): The bloom filtering for transaction relaying, partial Merkle trees for blocks, and the protocol version bump to 70001 (enabling low-bandwidth SPV clients) has been implemented since **v0.8.0** ([PR #1795](https://github.com/bitcoin/bitcoin/pull/1795)).
+* [`BIP 37`](https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki): The bloom filtering for transaction relaying, partial Merkle trees for blocks, and the protocol version bump to 70001 (enabling low-bandwidth SPV clients) has been implemented since **v0.8.0** ([PR #1795](https://github.com/bitcoin/bitcoin/pull/1795)). Disabled by default since **v0.19.0**, can be enabled by the `-peerbloomfilters` option.
 * [`BIP 42`](https://github.com/bitcoin/bips/blob/master/bip-0042.mediawiki): The bug that would have caused the subsidy schedule to resume after block 13440000 was fixed in **v0.9.2** ([PR #3842](https://github.com/bitcoin/bitcoin/pull/3842)).
 * [`BIP 43`](https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki): The experimental descriptor wallets introduced in **v0.21.0** by default use the Hierarchical Deterministic Wallet derivation proposed by BIP 43. ([PR #16528](https://github.com/bitcoin/bitcoin/pull/16528))
 * [`BIP 44`](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki): The experimental descriptor wallets introduced in **v0.21.0** by default use the Hierarchical Deterministic Wallet derivation proposed by BIP 44. ([PR #16528](https://github.com/bitcoin/bitcoin/pull/16528))
@@ -22,7 +21,6 @@ BIPs that are implemented by Bitcoin Knots:
 * [`BIP 61`](https://github.com/bitcoin/bips/blob/master/bip-0061.mediawiki): The 'reject' protocol message (and the protocol version bump to 70002) was added in **v0.9.0** ([PR #3185](https://github.com/bitcoin/bitcoin/pull/3185)). Starting **v0.17.0**, whether to send reject messages can be configured with the `-enablebip61` option, and support is deprecated (disabled by default) as of **v0.18.0**. Support was removed in **v0.20.0** ([PR #15437](https://github.com/bitcoin/bitcoin/pull/15437)).
 * [`BIP 65`](https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki): The CHECKLOCKTIMEVERIFY softfork was merged in **v0.12.0** ([PR #6351](https://github.com/bitcoin/bitcoin/pull/6351)), and backported to **v0.11.2** and **v0.10.4**. Mempool-only CLTV was added in [PR #6124](https://github.com/bitcoin/bitcoin/pull/6124).
 * [`BIP 66`](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki): The strict DER rules and associated version 3 blocks have been implemented since **v0.10.0** ([PR #5713](https://github.com/bitcoin/bitcoin/pull/5713)).
-* [`BIP 67`](https://github.com/bitcoin/bips/blob/master/bip-0067.mediawiki): Sorting multisig keys according to BIP 67 was merged in **v0.13.2.knots20161221* ([PR #8751](https://github.com/bitcoin/bitcoin/pull/8751)).
 * [`BIP 68`](https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki): Sequence locks have been implemented as of **v0.12.1**  ([PR #7184](https://github.com/bitcoin/bitcoin/pull/7184)), and have been *buried* since **v0.19.0** ([PR #16060](https://github.com/bitcoin/bitcoin/pull/16060)).
 * [`BIP 70`](https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki) [`71`](https://github.com/bitcoin/bips/blob/master/bip-0071.mediawiki) [`72`](https://github.com/bitcoin/bips/blob/master/bip-0072.mediawiki):
   Payment Protocol support has been available in Bitcoin Core GUI since **v0.9.0** ([PR #5216](https://github.com/bitcoin/bitcoin/pull/5216)).
@@ -32,7 +30,6 @@ BIPs that are implemented by Bitcoin Knots:
 * [`BIP 84`](https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki): The experimental descriptor wallets introduced in **v0.21.0** by default use the Hierarchical Deterministic Wallet derivation proposed by BIP 84. ([PR #16528](https://github.com/bitcoin/bitcoin/pull/16528))
 * [`BIP 86`](https://github.com/bitcoin/bips/blob/master/bip-0086.mediawiki): Descriptor wallets by default use the Hierarchical Deterministic Wallet derivation proposed by BIP 86 since **v23.0** ([PR #22364](https://github.com/bitcoin/bitcoin/pull/22364)).
 * [`BIP 90`](https://github.com/bitcoin/bips/blob/master/bip-0090.mediawiki): Trigger mechanism for activation of BIPs 34, 65, and 66 has been simplified to block height checks since **v0.14.0** ([PR #8391](https://github.com/bitcoin/bitcoin/pull/8391)).
-* [`BIP 93`](https://github.com/bitcoin/bips/blob/master/bip-0093.mediawiki): Support for importing codex32 seeds via the `importdescriptors` RPC method is available as of **v25.0.knots20230823** ([PR #27351](https://github.com/bitcoin/bitcoin/pull/27351)).
 * [`BIP 94`](https://github.com/bitcoin/bips/blob/master/bip-0094.mediawiki): Testnet 4 (`-testnet4`) supported as of **v28.0** ([PR #29775](https://github.com/bitcoin/bitcoin/pull/29775)).
 * [`BIP 111`](https://github.com/bitcoin/bips/blob/master/bip-0111.mediawiki): `NODE_BLOOM` service bit added, and enforced for all peer versions as of **v0.13.0** ([PR #6579](https://github.com/bitcoin/bitcoin/pull/6579) and [PR #6641](https://github.com/bitcoin/bitcoin/pull/6641)).
 * [`BIP 112`](https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki): The CHECKSEQUENCEVERIFY opcode has been implemented since **v0.12.1** ([PR #7524](https://github.com/bitcoin/bitcoin/pull/7524)), and has been *buried* since **v0.19.0** ([PR #16060](https://github.com/bitcoin/bitcoin/pull/16060)).
@@ -40,7 +37,6 @@ BIPs that are implemented by Bitcoin Knots:
 * [`BIP 125`](https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki): Opt-in full replace-by-fee partially implemented: signaling is enforced if configured. For other replacement rules, see doc/policy/mempool-replacements.md.
 * [`BIP 130`](https://github.com/bitcoin/bips/blob/master/bip-0130.mediawiki): direct headers announcement is negotiated with peer versions `>=70012` as of **v0.12.0** ([PR 6494](https://github.com/bitcoin/bitcoin/pull/6494)).
 * [`BIP 133`](https://github.com/bitcoin/bips/blob/master/bip-0133.mediawiki): feefilter messages are respected and sent for peer versions `>=70013` as of **v0.13.0** ([PR 7542](https://github.com/bitcoin/bitcoin/pull/7542)).
-* [`BIP 137`](https://github.com/bitcoin/bips/blob/master/bip-0137.mediawiki): Signing and verifying signed messages proving the receiver agrees to a message are supported for legacy addresses since **v0.5.0** and verification-only for Segwit addresses as of **v28.1.knots20250301**.
 * [`BIP 141`](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki): Segregated Witness (Consensus Layer) as of **v0.13.0** ([PR 8149](https://github.com/bitcoin/bitcoin/pull/8149)), defined for mainnet as of **v0.13.1** ([PR 8937](https://github.com/bitcoin/bitcoin/pull/8937)), and *buried* since **v0.19.0** ([PR #16060](https://github.com/bitcoin/bitcoin/pull/16060)).
 * [`BIP 143`](https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki): Transaction Signature Verification for Version 0 Witness Program as of **v0.13.0** ([PR 8149](https://github.com/bitcoin/bitcoin/pull/8149)), defined for mainnet as of **v0.13.1** ([PR 8937](https://github.com/bitcoin/bitcoin/pull/8937)), and *buried* since **v0.19.0** ([PR #16060](https://github.com/bitcoin/bitcoin/pull/16060)).
 * [`BIP 144`](https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki): Segregated Witness as of **0.13.0** ([PR 8149](https://github.com/bitcoin/bitcoin/pull/8149)).
@@ -48,14 +44,13 @@ BIPs that are implemented by Bitcoin Knots:
 * [`BIP 147`](https://github.com/bitcoin/bips/blob/master/bip-0147.mediawiki): NULLDUMMY softfork as of **v0.13.1** ([PR 8636](https://github.com/bitcoin/bitcoin/pull/8636) and [PR 8937](https://github.com/bitcoin/bitcoin/pull/8937)), *buried* since **v0.19.0** ([PR #16060](https://github.com/bitcoin/bitcoin/pull/16060)).
 * [`BIP 152`](https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki): Compact block transfer and related optimizations are used as of **v0.13.0** ([PR 8068](https://github.com/bitcoin/bitcoin/pull/8068)).
 * [`BIP 155`](https://github.com/bitcoin/bips/blob/master/bip-0155.mediawiki): The 'addrv2' and 'sendaddrv2' messages which enable relay of Tor V3 addresses (and other networks) are supported as of **v0.21.0** ([PR 19954](https://github.com/bitcoin/bitcoin/pull/19954)).
-* [`BIP 157`](https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki): Server-side support for Client Side Block Filtering can be enabled with the -peerblockfilters option as of **v0.19.0.1.knots20200104** ([PR #16442](https://github.com/bitcoin/bitcoin/pull/16442)).
-* [`BIP 158`](https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki): Compact Block Filters for Light Clients can be indexed as of **v0.19.0** ([PR #14121](https://github.com/bitcoin/bitcoin/pull/14121)).
+* [`BIP 157`](https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki)
+  [`158`](https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki): Compact Block Filters for Light Clients can be indexed as of **v0.19.0** ([PR #14121](https://github.com/bitcoin/bitcoin/pull/14121)) and served to peers on the P2P network as of **v0.21.0** ([PR #16442](https://github.com/bitcoin/bitcoin/pull/16442)).
 * [`BIP 159`](https://github.com/bitcoin/bips/blob/master/bip-0159.mediawiki): The `NODE_NETWORK_LIMITED` service bit is signalled as of **v0.16.0** ([PR 11740](https://github.com/bitcoin/bitcoin/pull/11740)), and such nodes are connected to as of **v0.17.0** ([PR 10387](https://github.com/bitcoin/bitcoin/pull/10387)).
-* [`BIP 173`](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki): Bech32 addresses for native Segregated Witness outputs are supported as of **v0.16.0** ([PR 11167](https://github.com/bitcoin/bitcoin/pull/11167)).
-* [`BIP 174`](https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki): RPCs to operate on Partially Signed Bitcoin Transactions (PSBT) are present as of **v0.17.0** ([PR 13557](https://github.com/bitcoin/bitcoin/pull/13557)). Limited GUI support in watch-only wallets since **v0.19.0.1.knots20200104**.
+* [`BIP 173`](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki): Bech32 addresses for native Segregated Witness outputs are supported as of **v0.16.0** ([PR 11167](https://github.com/bitcoin/bitcoin/pull/11167)). Bech32 addresses are generated by default as of **v0.20.0** ([PR 16884](https://github.com/bitcoin/bitcoin/pull/16884)).
+* [`BIP 174`](https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki): RPCs to operate on Partially Signed Bitcoin Transactions (PSBT) are present as of **v0.17.0** ([PR 13557](https://github.com/bitcoin/bitcoin/pull/13557)).
 * [`BIP 176`](https://github.com/bitcoin/bips/blob/master/bip-0176.mediawiki): Bits Denomination [QT only] is supported as of **v0.16.0** ([PR 12035](https://github.com/bitcoin/bitcoin/pull/12035)).
-* [`BIP 322`](https://github.com/bitcoin/bips/blob/master/bip-0322.mediawiki): Signing and verifying signed messages proving the receiver agrees to a message are supported for Segwit and Taproot addresses as of **v28.1.knots20250301**.
-* [`BIP 324`](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki): The v2 transport protocol specified by BIP324 and the associated `NODE_P2P_V2` service bit are supported as of **v26.0**, and on by default ([PR 28331](https://github.com/bitcoin/bitcoin/pull/28331)).
+* [`BIP 324`](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki): The v2 transport protocol specified by BIP324 and the associated `NODE_P2P_V2` service bit are supported as of **v26.0**, but off by default ([PR 28331](https://github.com/bitcoin/bitcoin/pull/28331)). On by default as of **v27.0** ([PR 29347](https://github.com/bitcoin/bitcoin/pull/29347)).
 * [`BIP 325`](https://github.com/bitcoin/bips/blob/master/bip-0325.mediawiki): Signet test network is supported as of **v0.21.0** ([PR 18267](https://github.com/bitcoin/bitcoin/pull/18267)).
 * [`BIP 339`](https://github.com/bitcoin/bips/blob/master/bip-0339.mediawiki): Relay of transactions by wtxid is supported as of **v0.21.0** ([PR 18044](https://github.com/bitcoin/bitcoin/pull/18044)).
 * [`BIP 340`](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki)
@@ -77,4 +72,4 @@ BIPs that are implemented by Bitcoin Knots:
   Output Script Descriptors, and most of Script Expressions are implemented as of **v0.17.0** ([PR 13697](https://github.com/bitcoin/bitcoin/pull/13697)).
 * [`BIP 386`](https://github.com/bitcoin/bips/blob/master/bip-0386.mediawiki): tr() Output Script Descriptors are implemented as of **v22.0** ([PR 22051](https://github.com/bitcoin/bitcoin/pull/22051)).
 * [`BIP 387`](https://github.com/bitcoin/bips/blob/master/bip-0387.mediawiki): Tapscript Multisig Output Script Descriptors are implemented as of **v24.0** ([PR 24043](https://github.com/bitcoin/bitcoin/pull/24043)).
-* [`BIP 431`](https://github.com/bitcoin/bips/blob/master/bip-0431.mediawiki): Transactions with nVersion=3 are standard and can be treated as Topologically Restricted Until Confirmation as of **v27.1.knots20240612**, though not enforced by default ([PR 29496](https://github.com/bitcoin/bitcoin/pull/29496)).
+* [`BIP 431`](https://github.com/bitcoin/bips/blob/master/bip-0431.mediawiki): transactions with nVersion=3 are standard and treated as Topologically Restricted Until Confirmation as of **v28.0** ([PR 29496](https://github.com/bitcoin/bitcoin/pull/29496)).
diff --git a/doc/build-unix.md b/doc/build-unix.md
index 3467963839..de54fb4eeb 100644
--- a/doc/build-unix.md
+++ b/doc/build-unix.md
@@ -7,11 +7,8 @@ Some notes on how to build Bitcoin Core in Unix.
 To Build
 ---------------------
 
-If you are building from git directly, you need to run `./autogen.sh` before
-the first time you build. This is not required if you downloaded the source
-code from the website.
-
 ```bash
+./autogen.sh
 ./configure
 make # use "-j N" for N parallel jobs
 make install # optional
@@ -90,10 +87,6 @@ Additionally, to support Wayland protocol for modern desktop environments:
 
     sudo apt install qtwayland5
 
-If you are building directly from git (instead of the official source code release), you will also need:
-
-    sudo apt install librsvg2-bin imagemagick
-
 libqrencode (optional) can be installed with:
 
     sudo apt-get install libqrencode-dev
@@ -151,10 +144,6 @@ Additionally, to support Wayland protocol for modern desktop environments:
 
     sudo dnf install qt5-qtwayland
 
-If you are building directly from git (instead of the official source code release), you will also need:
-
-    sudo dnf install librsvg2-tools ImageMagick
-
 libqrencode (optional) can be installed with:
 
     sudo dnf install qrencode-devel
@@ -213,8 +202,8 @@ Setup and Build Example: Arch Linux
 -----------------------------------
 This example lists the steps necessary to setup and build a command line only distribution of the latest changes on Arch Linux:
 
-    pacman --sync --needed autoconf automake boost gcc git libevent libtool make pkgconf python sqlite librsvg imagemagick
-    git clone https://github.com/bitcoinknots/bitcoin.git
+    pacman --sync --needed autoconf automake boost gcc git libevent libtool make pkgconf python sqlite
+    git clone https://github.com/bitcoin/bitcoin.git
     cd bitcoin/
     ./autogen.sh
     ./configure
diff --git a/doc/descriptors.md b/doc/descriptors.md
index 201fa208bf..5e8e4a24b0 100644
--- a/doc/descriptors.md
+++ b/doc/descriptors.md
@@ -23,9 +23,6 @@ Supporting RPCs are:
 - `listdescriptors` outputs descriptors imported into a descriptor wallet (since v22).
 - `scanblocks` takes as input descriptors to scan for in blocks and returns the
    relevant blockhashes (since v25).
-- `getdescriptoractivity` takes as input descriptors and blockhashes (as output
-  by `scanblocks`) and returns rich event data related to spends or receives associated
-  with the given descriptors.
 
 This document describes the language. For the specifics on usage, see the RPC
 documentation for the functions mentioned above.
diff --git a/doc/design/libraries.md b/doc/design/libraries.md
index 946ecee52c..caf414ac47 100644
--- a/doc/design/libraries.md
+++ b/doc/design/libraries.md
@@ -4,11 +4,10 @@
 |--------------------------|-------------|
 | *libbitcoin_cli*         | RPC client functionality used by *bitcoin-cli* executable |
 | *libbitcoin_common*      | Home for common functionality shared by different executables and libraries. Similar to *libbitcoin_util*, but higher-level (see [Dependencies](#dependencies)). |
-| *libbitcoin_consensus*   | Stable, backwards-compatible consensus functionality used by *libbitcoin_node* and *libbitcoin_wallet* and also exposed as a [shared library](../shared-libraries.md). |
-| *libbitcoinconsensus*    | Shared library build of static *libbitcoin_consensus* library |
+| *libbitcoin_consensus*   | Stable, backwards-compatible consensus functionality used by *libbitcoin_node* and *libbitcoin_wallet*. |
 | *libbitcoin_crypto*      | Hardware-optimized functions for data encryption, hashing, message authentication, and key derivation. |
-| *libbitcoin_kernel*      | Consensus engine and support library used for validation by *libbitcoin_node* and also exposed as a [shared library](../shared-libraries.md). |
-| *libbitcoinqt*           | GUI functionality used by *bitcoin-qt* and *bitcoin-gui* executables |
+| *libbitcoin_kernel*      | Consensus engine and support library used for validation by *libbitcoin_node*. |
+| *libbitcoinqt*           | GUI functionality used by *bitcoin-qt* and *bitcoin-gui* executables. |
 | *libbitcoin_ipc*         | IPC functionality used by *bitcoin-node*, *bitcoin-wallet*, *bitcoin-gui* executables to communicate when [`--enable-multiprocess`](multiprocess.md) is used. |
 | *libbitcoin_node*        | P2P and RPC server functionality used by *bitcoind* and *bitcoin-qt* executables. |
 | *libbitcoin_util*        | Home for common functionality shared by different executables and libraries. Similar to *libbitcoin_common*, but lower-level (see [Dependencies](#dependencies)). |
@@ -18,7 +17,7 @@
 
 ## Conventions
 
-- Most libraries are internal libraries and have APIs which are completely unstable! There are few or no restrictions on backwards compatibility or rules about external dependencies. Exceptions are *libbitcoin_consensus* and *libbitcoin_kernel* which have external interfaces documented at [../shared-libraries.md](../shared-libraries.md).
+- Most libraries are internal libraries and have APIs which are completely unstable! There are few or no restrictions on backwards compatibility or rules about external dependencies. An exception is *libbitcoin_kernel*, which, at some future point, will have a documented external interface.
 
 - Generally each library should have a corresponding source directory and namespace. Source code organization is a work in progress, so it is true that some namespaces are applied inconsistently, and if you look at [`libbitcoin_*_SOURCES`](../../src/Makefile.am) lists you can see that many libraries pull in files from outside their source directory. But when working with libraries, it is good to follow a consistent pattern like:
 
diff --git a/doc/files.md b/doc/files.md
index dd966d8ef3..b738d6055a 100644
--- a/doc/files.md
+++ b/doc/files.md
@@ -60,7 +60,6 @@ Subdirectory       | File(s)               | Description
 `./`               | `anchors.dat`         | Anchor IP address database, created on shutdown and deleted at startup. Anchors are last known outgoing block-relay-only peers that are tried to re-connect to on startup
 `./`               | `banlist.json`        | Stores the addresses/subnets of banned nodes.
 `./`               | `bitcoin.conf`        | User-defined [configuration settings](bitcoin-conf.md) for `bitcoind` or `bitcoin-qt`. File is not written to by the software and must be created manually. Path can be specified by `-conf` option
-`./`               | `bitcoin_rw.conf`     | Contains [configuration settings](bitcoin-conf.md) modified by `bitcoind` or `bitcoin-qt`; can be specified by `-confrw` option
 `./`               | `bitcoind.pid`        | Stores the process ID (PID) of `bitcoind` or `bitcoin-qt` while running; created at start and deleted on shutdown; can be specified by `-pid` option
 `./`               | `debug.log`           | Contains debug information and general logging generated by `bitcoind` or `bitcoin-qt`; can be specified by `-debuglogfile` option
 `./`               | `fee_estimates.dat`   | Stores statistics used to estimate minimum transaction fees required for confirmation
@@ -109,7 +108,6 @@ Subdirectory | File                 | Description
 ## GUI settings
 
 `bitcoin-qt` uses [`QSettings`](https://doc.qt.io/qt-5/qsettings.html) class; this implies platform-specific [locations where application settings are stored](https://doc.qt.io/qt-5/qsettings.html#locations-where-application-settings-are-stored).
-You can change this with the `-guisettingsdir=<path>` option. It will use the cross-platform ini format then. `<path>` is where the `.ini` file is stored.
 
 ## Legacy subdirectories and files
 
diff --git a/doc/man/bitcoin-cli.1 b/doc/man/bitcoin-cli.1
index 8a2fd9c286..d355289372 100644
--- a/doc/man/bitcoin-cli.1
+++ b/doc/man/bitcoin-cli.1
@@ -1,28 +1,21 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.3.
-.TH BITCOIN-CLI "1" "March 2025" "bitcoin-cli v28.1.0" "User Commands"
+.TH BITCOIN-CLI "1" "December 2024" "bitcoin-cli v28.1.0" "User Commands"
 .SH NAME
 bitcoin-cli \- manual page for bitcoin-cli v28.1.0
 .SH SYNOPSIS
 .B bitcoin-cli
-[\fI\,options\/\fR] \fI\,<command> \/\fR[\fI\,params\/\fR]
+[\fI\,options\/\fR] \fI\,<command> \/\fR[\fI\,params\/\fR]  \fI\,Send command to Bitcoin Core\/\fR
 .br
 .B bitcoin-cli
-[\fI\,options\/\fR] \fI\,-named <command> \/\fR[\fI\,name=value\/\fR]...
+[\fI\,options\/\fR] \fI\,-named <command> \/\fR[\fI\,name=value\/\fR]...  \fI\,Send command to Bitcoin Core (with named arguments)\/\fR
 .br
 .B bitcoin-cli
-[\fI\,options\/\fR] \fI\,help\/\fR
+[\fI\,options\/\fR] \fI\,help                List commands\/\fR
 .br
 .B bitcoin-cli
-[\fI\,options\/\fR] \fI\,help <command>\/\fR
+[\fI\,options\/\fR] \fI\,help <command>      Get help for a command\/\fR
 .SH DESCRIPTION
-Bitcoin Knots RPC client version v28.1.0
-.PP
-The bitcoin\-cli utility provides a command line interface to interact with a bitcoind/bitcoin\-qt RPC server.
-.PP
-It can be used to query network information, manage wallets, create or broadcast transactions, and control the bitcoind server.
-.PP
-Use the "help" command to list all commands. Use "help <command>" to show help for that command.
-The \fB\-named\fR option allows you to specify parameters using the key=value format, eliminating the need to pass unused positional parameters.
+Bitcoin Core RPC client version v28.1.0
 .SH OPTIONS
 .HP
 \-?
@@ -39,20 +32,13 @@ addresses known to the node may be higher.
 .IP
 Color setting for CLI output (default: auto). Valid values: always, auto
 (add color codes when standard output is connected to a terminal
-and OS is not WIN32), never. Only applies to the output of
-\fB\-getinfo\fR.
+and OS is not WIN32), never.
 .HP
 \fB\-conf=\fR<file>
 .IP
 Specify configuration file. Relative paths will be prefixed by datadir
 location. (default: bitcoin.conf)
 .HP
-\fB\-confrw=\fR<file>
-.IP
-Specify read/write configuration file. Relative paths will be prefixed
-by the network\-specific datadir location. (default:
-bitcoin_rw.conf)
-.HP
 \fB\-datadir=\fR<dir>
 .IP
 Specify data directory
@@ -68,12 +54,11 @@ nblocks and maxtries arguments. Example: bitcoin\-cli \fB\-generate\fR 4
 .HP
 \fB\-getinfo\fR
 .IP
-Get general information from the remote server, including the total
-balance and the balances of each loaded wallet when in
-multiwallet mode. Note that \fB\-getinfo\fR is the combined result of
-several RPCs (getnetworkinfo, getblockchaininfo, getwalletinfo,
-getbalances, and in multiwallet mode, listwallets), each with
-potentially different state.
+Get general information from the remote server. Note that unlike
+server\-side RPC calls, the output of \fB\-getinfo\fR is the result of
+multiple non\-atomic requests. Some entries in the output may
+represent results from different states (e.g. wallet balance may
+be as of a different block from the chain state reported)
 .HP
 \fB\-named\fR
 .IP
@@ -82,10 +67,8 @@ Pass named instead of positional arguments (default: false)
 \fB\-netinfo\fR
 .IP
 Get network peer connection information from the remote server. An
-optional argument from 0 to 4 can be passed for different peers
-listings (default: 0). If a non\-zero value is passed, an
-additional "outonly" (or "o") argument can be passed to see
-outbound peers only. Pass "help" (or "h") for detailed help
+optional integer argument from 0 to 4 can be passed for different
+peers listings (default: 0). Pass "help" for detailed help
 documentation.
 .HP
 \fB\-rpcclienttimeout=\fR<n>
@@ -170,12 +153,6 @@ testnet4, signet, regtest
 Use the signet chain. Equivalent to \fB\-chain\fR=\fI\,signet\/\fR. Note that the network
 is defined by the \fB\-signetchallenge\fR parameter
 .HP
-\fB\-signetblocktime\fR
-.IP
-Difficulty adjustment will target a block time of the given amount in
-seconds (only for custom signet networks, must have
-\fB\-signetchallenge\fR set; defaults to 10 minutes)
-.HP
 \fB\-signetchallenge\fR
 .IP
 Blocks must satisfy the given script to be considered valid (only for
@@ -199,15 +176,14 @@ Consider moving to testnet4 now by using \fB\-testnet4\fR.
 .IP
 Use the testnet4 chain. Equivalent to \fB\-chain\fR=\fI\,testnet4\/\fR.
 .SH COPYRIGHT
-Copyright (C) 2009-2025 The Bitcoin Knots developers
-Copyright (C) 2009-2025 The Bitcoin Core developers
+Copyright (C) 2009-2024 The Bitcoin Core developers
 
-Please contribute if you find Bitcoin Knots useful. Visit
-<https://bitcoinknots.org/> for further information about the software.
-The source code is available from <https://github.com/bitcoinknots/bitcoin>.
+Please contribute if you find Bitcoin Core useful. Visit
+<https://bitcoincore.org/> for further information about the software.
+The source code is available from <https://github.com/bitcoin/bitcoin>.
 
 This is experimental software.
 Distributed under the MIT software license, see the accompanying file COPYING
 or <https://opensource.org/licenses/MIT>
 .SH "SEE ALSO"
-bitcoind(1), bitcoin-tx(1), bitcoin-wallet(1), bitcoin-util(1), bitcoin-qt(1)
+bitcoind(1), bitcoin-cli(1), bitcoin-tx(1), bitcoin-wallet(1), bitcoin-util(1), bitcoin-qt(1)
diff --git a/doc/man/bitcoin-qt.1 b/doc/man/bitcoin-qt.1
index 61b3ac97b2..fe76cd970b 100644
--- a/doc/man/bitcoin-qt.1
+++ b/doc/man/bitcoin-qt.1
@@ -1,20 +1,14 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.3.
-.TH BITCOIN-QT "1" "March 2025" "bitcoin-qt v28.1.0" "User Commands"
+.TH BITCOIN-QT "1" "December 2024" "bitcoin-qt v28.1.0" "User Commands"
 .SH NAME
 bitcoin-qt \- manual page for bitcoin-qt v28.1.0
 .SH SYNOPSIS
 .B bitcoin-qt
-[\fI\,options\/\fR] [\fI\,URI\/\fR]
+[\fI\,command-line options\/\fR] [\fI\,URI\/\fR]
 .SH DESCRIPTION
-Bitcoin Knots version v28.1.0
+Bitcoin Core version v28.1.0
 .PP
-The bitcoin\-qt application provides a graphical interface for interacting with Bitcoin Knots.
-.PP
-It combines the core functionalities of bitcoind with a user\-friendly interface for wallet management, transaction history, and network statistics.
-.PP
-It is suitable for users who prefer a graphical over a command\-line interface.
-.PP
-You can optionally specify a payment [URI], in e.g. the BIP20 or BIP21 URI formats.
+Optional URI is a Bitcoin address in BIP21 URI format.
 .SH OPTIONS
 .HP
 \-?
@@ -36,7 +30,7 @@ datadir as a warning, not an error.
 If this block is in the chain assume that it and its ancestors are valid
 and potentially skip their script verification (0 to verify all,
 default:
-000000000000000000006e926737e6a349f7581525ad36e743dfe5f4bc3abbb7,
+000000000000000000011c5890365bdbe5d25b97ce0057589acaef4f1a57263f,
 testnet3:
 000000000000000465b1a66c9f386308e8c75acef9201f3f577811da09fc90ad,
 testnet4:
@@ -47,8 +41,8 @@ signet:
 \fB\-blockfilterindex=\fR<type>
 .IP
 Maintain an index of compact filters by block (default: 0, values:
-basic, v0). If <type> is not supplied or if <type> = 1, certain
-indexes are enabled (currently just basic).
+basic). If <type> is not supplied or if <type> = 1, indexes for
+all known types are enabled.
 .HP
 \fB\-blocknotify=\fR<cmd>
 .IP
@@ -88,16 +82,6 @@ Specify path to read\-only configuration file. Relative paths will be
 prefixed by datadir location (only useable from command line, not
 configuration file) (default: bitcoin.conf)
 .HP
-\fB\-confrw=\fR<file>
-.IP
-Specify read/write configuration file. Relative paths will be prefixed
-by the network\-specific datadir location (default:
-bitcoin_rw.conf)
-.HP
-\fB\-corepolicy\fR
-.IP
-Use Bitcoin Core policy defaults (default: 0)
-.HP
 \fB\-daemon\fR
 .IP
 Run in the background as a daemon and accept commands (default: 0)
@@ -113,7 +97,7 @@ Specify data directory
 .HP
 \fB\-dbcache=\fR<n>
 .IP
-Maximum database cache size <n> MiB (4 to 1048576, default: 450). In
+Maximum database cache size <n> MiB (4 to 16384, default: 450). In
 addition, unused mempool memory is shared for this cache (see
 \fB\-maxmempool\fR).
 .HP
@@ -132,11 +116,6 @@ Specify additional configuration file, relative to the \fB\-datadir\fR path
 .IP
 Imports blocks from external file on startup
 .HP
-\fB\-lowmem=\fR<n>
-.IP
-If system available memory falls below <n> MiB, flush caches (0 to
-disable, default: 10)
-.HP
 \fB\-maxmempool=\fR<n>
 .IP
 Keep the transaction memory pool below <n> megabytes (default: 300)
@@ -183,20 +162,13 @@ disable pruning blocks, 1 = allow manual pruning via RPC, >=550 =
 automatically prune block files to stay under the specified
 target size in MiB)
 .HP
-\fB\-pruneduringinit\fR
-.IP
-Temporarily adjusts the \fB\-prune\fR setting until initial sync completes.
-Ignored if pruning is disabled. (default: \fB\-1\fR = same value as
-\fB\-prune\fR)
-.HP
 \fB\-reindex\fR
 .IP
 If enabled, wipe chain state and block index, and rebuild them from
 blk*.dat files on disk. Also wipe and rebuild other optional
 indexes that are active. If an assumeutxo snapshot was loaded,
 its chainstate will be wiped as well. The snapshot can then be
-reloaded via RPC. Setting this to auto automatically reindexes
-the block database if it is corrupted.
+reloaded via RPC.
 .HP
 \fB\-reindex\-chainstate\fR
 .IP
@@ -374,7 +346,7 @@ Serve compact block filters to peers per BIP 157 (default: 0)
 \fB\-peerbloomfilters\fR
 .IP
 Support filtering of blocks and transaction with bloom filters (default:
-1)
+0)
 .HP
 \fB\-port=\fR<port>
 .IP
@@ -416,11 +388,6 @@ Tor control host and port to use if onion listening enabled (default:
 .IP
 Tor control port password (default: empty)
 .HP
-\fB\-uaappend=\fR<cmt>
-.IP
-Append literal to the user agent string (should only be used for
-software embedding)
-.HP
 \fB\-upnp\fR
 .IP
 Use UPnP to map the listening port (default: 0)
@@ -434,17 +401,14 @@ Support v2 transport (default: 1)
 Bind to the given address and add permission flags to the peers
 connecting to it. Use [host]:port notation for IPv6. Allowed
 permissions: bloomfilter (allow requesting BIP37 filtered blocks
-and transactions), blockfilters (serve compact block filters to
-peers per BIP157), noban (do not ban for misbehavior; implies
+and transactions), noban (do not ban for misbehavior; implies
 download), forcerelay (relay transactions that are already in the
 mempool; implies relay), relay (relay even in \fB\-blocksonly\fR mode,
 and unlimited transaction announcements), mempool (allow
 requesting BIP35 mempool contents), download (allow getheaders
 during IBD, no disconnect after maxuploadtarget limit), addr
 (responses to GETADDR avoid hitting the cache and contain random
-records with the most up\-to\-date info), forceinbound (when
-connections are full, attempt to evict a random unprotected
-inbound peer to open a slot; implies noban). Specify multiple
+records with the most up\-to\-date info). Specify multiple
 permissions separated by commas (default:
 download,noban,mempool,relay). Can be specified multiple times.
 .HP
@@ -454,8 +418,7 @@ Add permission flags to the peers using the given IP address (e.g.
 1.2.3.4) or CIDR\-notated network (e.g. 1.2.3.0/24). Uses the same
 permissions as \fB\-whitebind\fR. Additional flags "in" and "out"
 control whether permissions apply to incoming connections and/or
-outgoing (default: incoming only). Can be specified multiple
-times.
+manual (default: incoming only). Can be specified multiple times.
 .PP
 Wallet options:
 .HP
@@ -537,7 +500,7 @@ Spend unconfirmed change when sending transactions (default: 1)
 \fB\-txconfirmtarget=\fR<n>
 .IP
 If paytxfee is not set, include enough fee so transactions begin
-confirmation on average within n blocks (default: 144)
+confirmation on average within n blocks (default: 6)
 .HP
 \fB\-wallet=\fR<path>
 .IP
@@ -558,20 +521,16 @@ Make the wallet broadcast transactions (default: 1)
 Specify directory to hold wallets (default: <datadir>/wallets if it
 exists, otherwise <datadir>)
 .HP
-\fB\-walletimplicitsegwit\fR
-.IP
-Support segwit when restoring wallet backups and importing keys
-(default: 0)
-.HP
 \fB\-walletnotify=\fR<cmd>
 .IP
 Execute command when a wallet transaction changes. %s in cmd is replaced
 by TxID, %w is replaced by wallet name, %b is replaced by the
 hash of the block including the transaction (set to 'unconfirmed'
 if the transaction is not included) and %h is replaced by the
-block height (\fB\-1\fR if not included). %w should NOT be quoted
-because this would break shell escaping used to invoke the
-command.
+block height (\fB\-1\fR if not included). %w is not currently
+implemented on windows. On systems where %w is supported, it
+should NOT be quoted because this would break shell escaping used
+to invoke the command.
 .HP
 \fB\-walletrbf\fR
 .IP
@@ -596,15 +555,6 @@ Enable publish hash transaction in <address>
 Set publish hash transaction outbound message high water mark (default:
 1000)
 .HP
-\fB\-zmqpubhashwallettx=\fR<address>
-.IP
-Enable publish hash wallet transaction in <address>
-.HP
-\fB\-zmqpubhashwallettxhwm=\fR<n>
-.IP
-Set publish hash wallet transaction outbound message high water mark
-(default: 1000)
-.HP
 \fB\-zmqpubrawblock=\fR<address>
 .IP
 Enable publish raw block in <address>
@@ -622,15 +572,6 @@ Enable publish raw transaction in <address>
 Set publish raw transaction outbound message high water mark (default:
 1000)
 .HP
-\fB\-zmqpubrawwallettx=\fR<address>
-.IP
-Enable publish raw wallet transaction in <address>
-.HP
-\fB\-zmqpubrawwallettxhwm=\fR<n>
-.IP
-Set publish raw wallet transaction outbound message high water mark
-(default: 1000)
-.HP
 \fB\-zmqpubsequence=\fR<address>
 .IP
 Enable publish hash block and tx sequence in <address>
@@ -648,7 +589,7 @@ is optional). If <category> is not supplied or if <category> is 1
 or "all", output all debug logging. If <category> is 0 or "none",
 any other categories are ignored. Other valid values for
 <category> are: addrman, bench, blockstorage, cmpctblock, coindb,
-estimatefee, http, i2p, ipc, leveldb, libevent, lock, mempool,
+estimatefee, http, i2p, ipc, leveldb, libevent, mempool,
 mempoolrej, net, proxy, prune, qt, rand, reindex, rpc, scan,
 selectcoins, tor, txpackages, txreconciliation, validation,
 walletdb, zmq. This option can be specified multiple times to
@@ -717,12 +658,6 @@ testnet4, signet, regtest
 Use the signet chain. Equivalent to \fB\-chain\fR=\fI\,signet\/\fR. Note that the network
 is defined by the \fB\-signetchallenge\fR parameter
 .HP
-\fB\-signetblocktime\fR
-.IP
-Difficulty adjustment will target a block time of the given amount in
-seconds (only for custom signet networks, must have
-\fB\-signetchallenge\fR set; defaults to 10 minutes)
-.HP
 \fB\-signetchallenge\fR
 .IP
 Blocks must satisfy the given script to be considered valid (only for
@@ -748,71 +683,24 @@ Use the testnet4 chain. Equivalent to \fB\-chain\fR=\fI\,testnet4\/\fR.
 .PP
 Node relay options:
 .HP
-\fB\-acceptnonstddatacarrier\fR
-.IP
-Relay and mine non\-OP_RETURN datacarrier injection (default: 0)
-.HP
-\fB\-acceptnonstdtxn\fR
-.IP
-Relay and mine "non\-standard" transactions (default: 0)
-.HP
 \fB\-bytespersigop\fR
 .IP
 Equivalent bytes per sigop in transactions for relay and mining
 (default: 20)
 .HP
-\fB\-bytespersigopstrict\fR
-.IP
-Minimum bytes per sigop in transactions we relay and mine (default: 20)
-.HP
 \fB\-datacarrier\fR
 .IP
 Relay and mine data carrier transactions (default: 1)
 .HP
-\fB\-datacarriercost\fR
-.IP
-Treat extra data in transactions as at least N vbytes per actual byte
-(default: 1)
-.HP
 \fB\-datacarriersize\fR
 .IP
-Maximum size of data in data carrier transactions we relay and mine, in
-bytes (default: 42)
-.HP
-\fB\-dustdynamic\fR=\fI\,off\/\fR|[<multiplier>*]target:<blocks>|[<multiplier>*]mempool:<kvB>
-.IP
-Automatically raise dustrelayfee based on either the expected fee to be
-mined within <blocks> blocks, or to be within the best <kvB> kvB
-of this node's mempool. If unspecified, multiplier is 3.
-(default: off)
-.HP
-\fB\-dustrelayfee=\fR<amt>
-.IP
-Fee rate (in BTC/kvB) used to define dust, the value of an output such
-that it will cost more than its value in fees at this fee rate to
-spend it. (default: 0.00003)
-.HP
-\fB\-maxscriptsize\fR
-.IP
-Maximum size of scripts we relay and mine, in bytes (default: 1650)
+Relay and mine transactions whose data\-carrying raw scriptPubKey is of
+this size or less (default: 83)
 .HP
 \fB\-mempoolfullrbf\fR
 .IP
-Accept transaction replace\-by\-fee without requiring replaceability
-signaling (default: 1)
-.HP
-\fB\-mempoolreplacement\fR
-.IP
-Set to 0 to disable RBF entirely, "fee,optin" to honour RBF opt\-out
-signal, or "fee,\-optin" to always RBF aka full RBF (default:
-fee,\-optin)
-.HP
-\fB\-mempooltruc\fR
-.IP
-Behaviour for transactions requesting TRUC limits: "reject" the
-transactions entirely, "accept" them just like any other, or
-"enforce" to impose their requested restrictions (default:
-accept)
+(DEPRECATED) Accept transaction replace\-by\-fee without requiring
+replaceability signaling (default: 1)
 .HP
 \fB\-minrelaytxfee=\fR<amt>
 .IP
@@ -821,26 +709,7 @@ relaying, mining and transaction creation (default: 0.00001)
 .HP
 \fB\-permitbaremultisig\fR
 .IP
-Relay transactions creating non\-P2SH multisig outputs (default: 0)
-.HP
-\fB\-permitbarepubkey\fR
-.IP
-Relay legacy pubkey outputs (default: 0)
-.HP
-\fB\-rejectparasites\fR
-.IP
-Refuse to relay or mine parasitic overlay protocols (default: 1)
-.HP
-\fB\-rejecttokens\fR
-.IP
-Refuse to relay or mine transactions involving non\-bitcoin tokens
-(default: 0)
-.HP
-\fB\-spkreuse=\fR<policy>
-.IP
-Either "allow" to relay/mine transactions reusing addresses or other
-pubkey scripts, or "conflict" to treat them as exclusive prior to
-being mined (default: allow)
+Relay transactions creating non\-P2SH multisig outputs (default: 1)
 .HP
 \fB\-whitelistforcerelay\fR
 .IP
@@ -856,23 +725,14 @@ transactions (default: 1)
 .PP
 Block creation options:
 .HP
-\fB\-blockmaxsize=\fR<n>
-.IP
-Set maximum block size in bytes (default: 300000)
-.HP
 \fB\-blockmaxweight=\fR<n>
 .IP
-Set maximum BIP141 block weight (default: 1200000)
+Set maximum BIP141 block weight (default: 3996000)
 .HP
 \fB\-blockmintxfee=\fR<amt>
 .IP
 Set lowest fee rate (in BTC/kvB) for transactions to be included in
 block creation. (default: 0.00001)
-.HP
-\fB\-blockprioritysize=\fR<n>
-.IP
-Set maximum size of high\-priority/low\-fee transactions in bytes
-(default: 100000)
 .PP
 RPC server options:
 .HP
@@ -888,21 +748,14 @@ are a single IP (e.g. 1.2.3.4), a network/netmask (e.g.
 ipv4 (0.0.0.0/0), or all ipv6 (::/0). This option can be
 specified multiple times
 .HP
-\fB\-rpcauth=\fR<userpw>[:wallet]
+\fB\-rpcauth=\fR<userpw>
 .IP
 Username and HMAC\-SHA\-256 hashed password for JSON\-RPC connections. The
 field <userpw> comes in the format: <USERNAME>:<SALT>$<HASH>. A
 canonical python script is included in share/rpcauth. The client
 then connects normally using the
-rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. A
-single wallet name can also be specified to restrict access to
-only that wallet, or '\-' to deny all wallet access. This option
-can be specified multiple times
-.HP
-\fB\-rpcauthfile=\fR<userpw>
-.IP
-A file with a single lines with same format as rpcauth. This option can
-be specified multiple times
+rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. This
+option can be specified multiple times
 .HP
 \fB\-rpcbind=\fR<addr>[:port]
 .IP
@@ -934,7 +787,7 @@ Listen for JSON\-RPC connections on <port> (default: 8332, testnet3:
 .HP
 \fB\-rpcthreads=\fR<n>
 .IP
-Set the number of threads to service RPC calls (default: 16)
+Set the number of threads to service RPC calls (default: 4)
 .HP
 \fB\-rpcuser=\fR<user>
 .IP
@@ -967,10 +820,6 @@ UI Options:
 .IP
 Choose data directory on startup (default: 0)
 .HP
-\fB\-guisettingsdir=\fR<path>
-.IP
-Choose a custom data directory especially for the Qt Settings
-.HP
 \fB\-lang=\fR<lang>
 .IP
 Set language, for example "de_DE" (default: system locale)
@@ -986,26 +835,15 @@ Reset all settings changed in the GUI
 \fB\-splash\fR
 .IP
 Show splash screen on startup (default: 1)
-.PP
-Statistic options:
-.HP
-\fB\-statsenable\fR
-.IP
-Enable statistics (default: 0)
-.HP
-\fB\-statsmaxmemorytarget=\fR<n>
-.IP
-Set the memory limit target for statistics in bytes (default: 10485760)
 .SH COPYRIGHT
-Copyright (C) 2009-2025 The Bitcoin Knots developers
-Copyright (C) 2009-2025 The Bitcoin Core developers
+Copyright (C) 2009-2024 The Bitcoin Core developers
 
-Please contribute if you find Bitcoin Knots useful. Visit
-<https://bitcoinknots.org/> for further information about the software.
-The source code is available from <https://github.com/bitcoinknots/bitcoin>.
+Please contribute if you find Bitcoin Core useful. Visit
+<https://bitcoincore.org/> for further information about the software.
+The source code is available from <https://github.com/bitcoin/bitcoin>.
 
 This is experimental software.
 Distributed under the MIT software license, see the accompanying file COPYING
 or <https://opensource.org/licenses/MIT>
 .SH "SEE ALSO"
-bitcoind(1), bitcoin-cli(1), bitcoin-tx(1), bitcoin-wallet(1), bitcoin-util(1)
+bitcoind(1), bitcoin-cli(1), bitcoin-tx(1), bitcoin-wallet(1), bitcoin-util(1), bitcoin-qt(1)
diff --git a/doc/man/bitcoin-tx.1 b/doc/man/bitcoin-tx.1
index 7d151fb6d7..26cbd9bff7 100644
--- a/doc/man/bitcoin-tx.1
+++ b/doc/man/bitcoin-tx.1
@@ -1,19 +1,15 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.3.
-.TH BITCOIN-TX "1" "March 2025" "bitcoin-tx v28.1.0" "User Commands"
+.TH BITCOIN-TX "1" "December 2024" "bitcoin-tx v28.1.0" "User Commands"
 .SH NAME
 bitcoin-tx \- manual page for bitcoin-tx v28.1.0
 .SH SYNOPSIS
 .B bitcoin-tx
-[\fI\,options\/\fR] \fI\,<hex-tx> \/\fR[\fI\,commands\/\fR]
+[\fI\,options\/\fR] \fI\,<hex-tx> \/\fR[\fI\,commands\/\fR]  \fI\,Update hex-encoded bitcoin transaction\/\fR
 .br
 .B bitcoin-tx
-[\fI\,options\/\fR] \fI\,-create \/\fR[\fI\,commands\/\fR]
+[\fI\,options\/\fR] \fI\,-create \/\fR[\fI\,commands\/\fR]   \fI\,Create hex-encoded bitcoin transaction\/\fR
 .SH DESCRIPTION
-Bitcoin Knots bitcoin\-tx utility version v28.1.0
-.PP
-The bitcoin\-tx tool is used for creating and modifying bitcoin transactions.
-.PP
-bitcoin\-tx can be used with "<hex\-tx> [commands]" to update a hex\-encoded bitcoin transaction, or with "\-create [commands]" to create a hex\-encoded bitcoin transaction.
+Bitcoin Core bitcoin\-tx utility version v28.1.0
 .SH OPTIONS
 .HP
 \-?
@@ -50,12 +46,6 @@ testnet4, signet, regtest
 Use the signet chain. Equivalent to \fB\-chain\fR=\fI\,signet\/\fR. Note that the network
 is defined by the \fB\-signetchallenge\fR parameter
 .HP
-\fB\-signetblocktime\fR
-.IP
-Difficulty adjustment will target a block time of the given amount in
-seconds (only for custom signet networks, must have
-\fB\-signetchallenge\fR set; defaults to 10 minutes)
-.HP
 \fB\-signetchallenge\fR
 .IP
 Blocks must satisfy the given script to be considered valid (only for
@@ -152,15 +142,14 @@ set=NAME:JSON\-STRING
 .IP
 Set register NAME to given JSON\-STRING
 .SH COPYRIGHT
-Copyright (C) 2009-2025 The Bitcoin Knots developers
-Copyright (C) 2009-2025 The Bitcoin Core developers
+Copyright (C) 2009-2024 The Bitcoin Core developers
 
-Please contribute if you find Bitcoin Knots useful. Visit
-<https://bitcoinknots.org/> for further information about the software.
-The source code is available from <https://github.com/bitcoinknots/bitcoin>.
+Please contribute if you find Bitcoin Core useful. Visit
+<https://bitcoincore.org/> for further information about the software.
+The source code is available from <https://github.com/bitcoin/bitcoin>.
 
 This is experimental software.
 Distributed under the MIT software license, see the accompanying file COPYING
 or <https://opensource.org/licenses/MIT>
 .SH "SEE ALSO"
-bitcoind(1), bitcoin-cli(1), bitcoin-wallet(1), bitcoin-util(1), bitcoin-qt(1)
+bitcoind(1), bitcoin-cli(1), bitcoin-tx(1), bitcoin-wallet(1), bitcoin-util(1), bitcoin-qt(1)
diff --git a/doc/man/bitcoin-util.1 b/doc/man/bitcoin-util.1
index 1b52fa4424..415e6d04b1 100644
--- a/doc/man/bitcoin-util.1
+++ b/doc/man/bitcoin-util.1
@@ -1,17 +1,12 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.3.
-.TH BITCOIN-UTIL "1" "March 2025" "bitcoin-util v28.1.0" "User Commands"
+.TH BITCOIN-UTIL "1" "December 2024" "bitcoin-util v28.1.0" "User Commands"
 .SH NAME
 bitcoin-util \- manual page for bitcoin-util v28.1.0
 .SH SYNOPSIS
 .B bitcoin-util
-[\fI\,options\/\fR] [\fI\,command\/\fR]
-.br
-.B bitcoin-util
-[\fI\,options\/\fR] \fI\,grind <hex-block-header>\/\fR
+[\fI\,options\/\fR] [\fI\,commands\/\fR]  \fI\,Do stuff\/\fR
 .SH DESCRIPTION
-Bitcoin Knots bitcoin\-util utility version v28.1.0
-.PP
-The bitcoin\-util tool provides bitcoin related functionality that does not rely on the ability to access a running node. Available [commands] are listed below.
+Bitcoin Core bitcoin\-util utility version v28.1.0
 .SH OPTIONS
 .HP
 \-?
@@ -36,12 +31,6 @@ testnet4, signet, regtest
 Use the signet chain. Equivalent to \fB\-chain\fR=\fI\,signet\/\fR. Note that the network
 is defined by the \fB\-signetchallenge\fR parameter
 .HP
-\fB\-signetblocktime\fR
-.IP
-Difficulty adjustment will target a block time of the given amount in
-seconds (only for custom signet networks, must have
-\fB\-signetchallenge\fR set; defaults to 10 minutes)
-.HP
 \fB\-signetchallenge\fR
 .IP
 Blocks must satisfy the given script to be considered valid (only for
@@ -71,15 +60,14 @@ grind
 .IP
 Perform proof of work on hex header string
 .SH COPYRIGHT
-Copyright (C) 2009-2025 The Bitcoin Knots developers
-Copyright (C) 2009-2025 The Bitcoin Core developers
+Copyright (C) 2009-2024 The Bitcoin Core developers
 
-Please contribute if you find Bitcoin Knots useful. Visit
-<https://bitcoinknots.org/> for further information about the software.
-The source code is available from <https://github.com/bitcoinknots/bitcoin>.
+Please contribute if you find Bitcoin Core useful. Visit
+<https://bitcoincore.org/> for further information about the software.
+The source code is available from <https://github.com/bitcoin/bitcoin>.
 
 This is experimental software.
 Distributed under the MIT software license, see the accompanying file COPYING
 or <https://opensource.org/licenses/MIT>
 .SH "SEE ALSO"
-bitcoind(1), bitcoin-cli(1), bitcoin-tx(1), bitcoin-wallet(1), bitcoin-qt(1)
+bitcoind(1), bitcoin-cli(1), bitcoin-tx(1), bitcoin-wallet(1), bitcoin-util(1), bitcoin-qt(1)
diff --git a/doc/man/bitcoin-wallet.1 b/doc/man/bitcoin-wallet.1
index 6a39cbbc22..a0431292ae 100644
--- a/doc/man/bitcoin-wallet.1
+++ b/doc/man/bitcoin-wallet.1
@@ -1,18 +1,16 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.3.
-.TH BITCOIN-WALLET "1" "March 2025" "bitcoin-wallet v28.1.0" "User Commands"
+.TH BITCOIN-WALLET "1" "December 2024" "bitcoin-wallet v28.1.0" "User Commands"
 .SH NAME
 bitcoin-wallet \- manual page for bitcoin-wallet v28.1.0
-.SH SYNOPSIS
-.B bitcoin-wallet
-[\fI\,options\/\fR] \fI\,<command>\/\fR
 .SH DESCRIPTION
-Bitcoin Knots bitcoin\-wallet utility version v28.1.0
-.PP
-bitcoin\-wallet is an offline tool for creating and interacting with Bitcoin Knots wallet files.
+Bitcoin Core bitcoin\-wallet version v28.1.0
 .PP
+bitcoin\-wallet is an offline tool for creating and interacting with Bitcoin Core wallet files.
 By default bitcoin\-wallet will act on wallets in the default mainnet wallet directory in the datadir.
-.PP
-To change the target wallet, use the \fB\-datadir\fR, \fB\-wallet\fR and \fB\-regtest\fR / \fB\-signet\fR / \fB\-testnet\fR / \fB\-testnet4\fR arguments.
+To change the target wallet, use the \fB\-datadir\fR, \fB\-wallet\fR and \fB\-regtest\fR/\-signet/\-testnet/\-testnet4 arguments.
+.SS "Usage:"
+.IP
+bitcoin\-wallet [options] <command>
 .SH OPTIONS
 .HP
 \-?
@@ -77,12 +75,6 @@ testnet4, signet, regtest
 Use the signet chain. Equivalent to \fB\-chain\fR=\fI\,signet\/\fR. Note that the network
 is defined by the \fB\-signetchallenge\fR parameter
 .HP
-\fB\-signetblocktime\fR
-.IP
-Difficulty adjustment will target a block time of the given amount in
-seconds (only for custom signet networks, must have
-\fB\-signetchallenge\fR set; defaults to 10 minutes)
-.HP
 \fB\-signetchallenge\fR
 .IP
 Blocks must satisfy the given script to be considered valid (only for
@@ -120,10 +112,6 @@ dump
 .IP
 Print out all of the wallet key\-value records
 .IP
-importfromcoldcard
-.IP
-Create new wallet file and import descriptors from Coldcard wallet
-.IP
 info
 .IP
 Get wallet info
@@ -133,15 +121,14 @@ salvage
 Attempt to recover private keys from a corrupt wallet. Warning:
 \&'salvage' is experimental.
 .SH COPYRIGHT
-Copyright (C) 2009-2025 The Bitcoin Knots developers
-Copyright (C) 2009-2025 The Bitcoin Core developers
+Copyright (C) 2009-2024 The Bitcoin Core developers
 
-Please contribute if you find Bitcoin Knots useful. Visit
-<https://bitcoinknots.org/> for further information about the software.
-The source code is available from <https://github.com/bitcoinknots/bitcoin>.
+Please contribute if you find Bitcoin Core useful. Visit
+<https://bitcoincore.org/> for further information about the software.
+The source code is available from <https://github.com/bitcoin/bitcoin>.
 
 This is experimental software.
 Distributed under the MIT software license, see the accompanying file COPYING
 or <https://opensource.org/licenses/MIT>
 .SH "SEE ALSO"
-bitcoind(1), bitcoin-cli(1), bitcoin-tx(1), bitcoin-util(1), bitcoin-qt(1)
+bitcoind(1), bitcoin-cli(1), bitcoin-tx(1), bitcoin-wallet(1), bitcoin-util(1), bitcoin-qt(1)
diff --git a/doc/man/bitcoind.1 b/doc/man/bitcoind.1
index 155428ea90..1acb2dfa0a 100644
--- a/doc/man/bitcoind.1
+++ b/doc/man/bitcoind.1
@@ -1,20 +1,12 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.3.
-.TH BITCOIND "1" "March 2025" "bitcoind v28.1.0" "User Commands"
+.TH BITCOIND "1" "December 2024" "bitcoind v28.1.0" "User Commands"
 .SH NAME
 bitcoind \- manual page for bitcoind v28.1.0
 .SH SYNOPSIS
 .B bitcoind
-[\fI\,options\/\fR]
+[\fI\,options\/\fR]                     \fI\,Start Bitcoin Core\/\fR
 .SH DESCRIPTION
-Bitcoin Knots daemon version v28.1.0
-.PP
-The Bitcoin Knots daemon (bitcoind) is a headless program that connects to the Bitcoin network to validate and relay transactions and blocks, as well as relaying addresses.
-.PP
-It provides the backbone of the Bitcoin network and its RPC, REST and ZMQ services can provide various transaction, block and address\-related services.
-.PP
-There is an optional wallet component which provides cutting\-edge transaction services.
-.PP
-It can be used in a headless environment or as part of a server setup.
+Bitcoin Core version v28.1.0
 .SH OPTIONS
 .HP
 \-?
@@ -36,7 +28,7 @@ datadir as a warning, not an error.
 If this block is in the chain assume that it and its ancestors are valid
 and potentially skip their script verification (0 to verify all,
 default:
-000000000000000000006e926737e6a349f7581525ad36e743dfe5f4bc3abbb7,
+000000000000000000011c5890365bdbe5d25b97ce0057589acaef4f1a57263f,
 testnet3:
 000000000000000465b1a66c9f386308e8c75acef9201f3f577811da09fc90ad,
 testnet4:
@@ -47,8 +39,8 @@ signet:
 \fB\-blockfilterindex=\fR<type>
 .IP
 Maintain an index of compact filters by block (default: 0, values:
-basic, v0). If <type> is not supplied or if <type> = 1, certain
-indexes are enabled (currently just basic).
+basic). If <type> is not supplied or if <type> = 1, indexes for
+all known types are enabled.
 .HP
 \fB\-blocknotify=\fR<cmd>
 .IP
@@ -88,16 +80,6 @@ Specify path to read\-only configuration file. Relative paths will be
 prefixed by datadir location (only useable from command line, not
 configuration file) (default: bitcoin.conf)
 .HP
-\fB\-confrw=\fR<file>
-.IP
-Specify read/write configuration file. Relative paths will be prefixed
-by the network\-specific datadir location (default:
-bitcoin_rw.conf)
-.HP
-\fB\-corepolicy\fR
-.IP
-Use Bitcoin Core policy defaults (default: 0)
-.HP
 \fB\-daemon\fR
 .IP
 Run in the background as a daemon and accept commands (default: 0)
@@ -113,7 +95,7 @@ Specify data directory
 .HP
 \fB\-dbcache=\fR<n>
 .IP
-Maximum database cache size <n> MiB (4 to 1048576, default: 450). In
+Maximum database cache size <n> MiB (4 to 16384, default: 450). In
 addition, unused mempool memory is shared for this cache (see
 \fB\-maxmempool\fR).
 .HP
@@ -132,11 +114,6 @@ Specify additional configuration file, relative to the \fB\-datadir\fR path
 .IP
 Imports blocks from external file on startup
 .HP
-\fB\-lowmem=\fR<n>
-.IP
-If system available memory falls below <n> MiB, flush caches (0 to
-disable, default: 10)
-.HP
 \fB\-maxmempool=\fR<n>
 .IP
 Keep the transaction memory pool below <n> megabytes (default: 300)
@@ -183,20 +160,13 @@ disable pruning blocks, 1 = allow manual pruning via RPC, >=550 =
 automatically prune block files to stay under the specified
 target size in MiB)
 .HP
-\fB\-pruneduringinit\fR
-.IP
-Temporarily adjusts the \fB\-prune\fR setting until initial sync completes.
-Ignored if pruning is disabled. (default: \fB\-1\fR = same value as
-\fB\-prune\fR)
-.HP
 \fB\-reindex\fR
 .IP
 If enabled, wipe chain state and block index, and rebuild them from
 blk*.dat files on disk. Also wipe and rebuild other optional
 indexes that are active. If an assumeutxo snapshot was loaded,
 its chainstate will be wiped as well. The snapshot can then be
-reloaded via RPC. Setting this to auto automatically reindexes
-the block database if it is corrupted.
+reloaded via RPC.
 .HP
 \fB\-reindex\-chainstate\fR
 .IP
@@ -374,7 +344,7 @@ Serve compact block filters to peers per BIP 157 (default: 0)
 \fB\-peerbloomfilters\fR
 .IP
 Support filtering of blocks and transaction with bloom filters (default:
-1)
+0)
 .HP
 \fB\-port=\fR<port>
 .IP
@@ -416,11 +386,6 @@ Tor control host and port to use if onion listening enabled (default:
 .IP
 Tor control port password (default: empty)
 .HP
-\fB\-uaappend=\fR<cmt>
-.IP
-Append literal to the user agent string (should only be used for
-software embedding)
-.HP
 \fB\-upnp\fR
 .IP
 Use UPnP to map the listening port (default: 0)
@@ -434,17 +399,14 @@ Support v2 transport (default: 1)
 Bind to the given address and add permission flags to the peers
 connecting to it. Use [host]:port notation for IPv6. Allowed
 permissions: bloomfilter (allow requesting BIP37 filtered blocks
-and transactions), blockfilters (serve compact block filters to
-peers per BIP157), noban (do not ban for misbehavior; implies
+and transactions), noban (do not ban for misbehavior; implies
 download), forcerelay (relay transactions that are already in the
 mempool; implies relay), relay (relay even in \fB\-blocksonly\fR mode,
 and unlimited transaction announcements), mempool (allow
 requesting BIP35 mempool contents), download (allow getheaders
 during IBD, no disconnect after maxuploadtarget limit), addr
 (responses to GETADDR avoid hitting the cache and contain random
-records with the most up\-to\-date info), forceinbound (when
-connections are full, attempt to evict a random unprotected
-inbound peer to open a slot; implies noban). Specify multiple
+records with the most up\-to\-date info). Specify multiple
 permissions separated by commas (default:
 download,noban,mempool,relay). Can be specified multiple times.
 .HP
@@ -454,8 +416,7 @@ Add permission flags to the peers using the given IP address (e.g.
 1.2.3.4) or CIDR\-notated network (e.g. 1.2.3.0/24). Uses the same
 permissions as \fB\-whitebind\fR. Additional flags "in" and "out"
 control whether permissions apply to incoming connections and/or
-outgoing (default: incoming only). Can be specified multiple
-times.
+manual (default: incoming only). Can be specified multiple times.
 .PP
 Wallet options:
 .HP
@@ -537,7 +498,7 @@ Spend unconfirmed change when sending transactions (default: 1)
 \fB\-txconfirmtarget=\fR<n>
 .IP
 If paytxfee is not set, include enough fee so transactions begin
-confirmation on average within n blocks (default: 144)
+confirmation on average within n blocks (default: 6)
 .HP
 \fB\-wallet=\fR<path>
 .IP
@@ -558,20 +519,16 @@ Make the wallet broadcast transactions (default: 1)
 Specify directory to hold wallets (default: <datadir>/wallets if it
 exists, otherwise <datadir>)
 .HP
-\fB\-walletimplicitsegwit\fR
-.IP
-Support segwit when restoring wallet backups and importing keys
-(default: 0)
-.HP
 \fB\-walletnotify=\fR<cmd>
 .IP
 Execute command when a wallet transaction changes. %s in cmd is replaced
 by TxID, %w is replaced by wallet name, %b is replaced by the
 hash of the block including the transaction (set to 'unconfirmed'
 if the transaction is not included) and %h is replaced by the
-block height (\fB\-1\fR if not included). %w should NOT be quoted
-because this would break shell escaping used to invoke the
-command.
+block height (\fB\-1\fR if not included). %w is not currently
+implemented on windows. On systems where %w is supported, it
+should NOT be quoted because this would break shell escaping used
+to invoke the command.
 .HP
 \fB\-walletrbf\fR
 .IP
@@ -596,15 +553,6 @@ Enable publish hash transaction in <address>
 Set publish hash transaction outbound message high water mark (default:
 1000)
 .HP
-\fB\-zmqpubhashwallettx=\fR<address>
-.IP
-Enable publish hash wallet transaction in <address>
-.HP
-\fB\-zmqpubhashwallettxhwm=\fR<n>
-.IP
-Set publish hash wallet transaction outbound message high water mark
-(default: 1000)
-.HP
 \fB\-zmqpubrawblock=\fR<address>
 .IP
 Enable publish raw block in <address>
@@ -622,15 +570,6 @@ Enable publish raw transaction in <address>
 Set publish raw transaction outbound message high water mark (default:
 1000)
 .HP
-\fB\-zmqpubrawwallettx=\fR<address>
-.IP
-Enable publish raw wallet transaction in <address>
-.HP
-\fB\-zmqpubrawwallettxhwm=\fR<n>
-.IP
-Set publish raw wallet transaction outbound message high water mark
-(default: 1000)
-.HP
 \fB\-zmqpubsequence=\fR<address>
 .IP
 Enable publish hash block and tx sequence in <address>
@@ -648,7 +587,7 @@ is optional). If <category> is not supplied or if <category> is 1
 or "all", output all debug logging. If <category> is 0 or "none",
 any other categories are ignored. Other valid values for
 <category> are: addrman, bench, blockstorage, cmpctblock, coindb,
-estimatefee, http, i2p, ipc, leveldb, libevent, lock, mempool,
+estimatefee, http, i2p, ipc, leveldb, libevent, mempool,
 mempoolrej, net, proxy, prune, qt, rand, reindex, rpc, scan,
 selectcoins, tor, txpackages, txreconciliation, validation,
 walletdb, zmq. This option can be specified multiple times to
@@ -717,12 +656,6 @@ testnet4, signet, regtest
 Use the signet chain. Equivalent to \fB\-chain\fR=\fI\,signet\/\fR. Note that the network
 is defined by the \fB\-signetchallenge\fR parameter
 .HP
-\fB\-signetblocktime\fR
-.IP
-Difficulty adjustment will target a block time of the given amount in
-seconds (only for custom signet networks, must have
-\fB\-signetchallenge\fR set; defaults to 10 minutes)
-.HP
 \fB\-signetchallenge\fR
 .IP
 Blocks must satisfy the given script to be considered valid (only for
@@ -748,71 +681,24 @@ Use the testnet4 chain. Equivalent to \fB\-chain\fR=\fI\,testnet4\/\fR.
 .PP
 Node relay options:
 .HP
-\fB\-acceptnonstddatacarrier\fR
-.IP
-Relay and mine non\-OP_RETURN datacarrier injection (default: 0)
-.HP
-\fB\-acceptnonstdtxn\fR
-.IP
-Relay and mine "non\-standard" transactions (default: 0)
-.HP
 \fB\-bytespersigop\fR
 .IP
 Equivalent bytes per sigop in transactions for relay and mining
 (default: 20)
 .HP
-\fB\-bytespersigopstrict\fR
-.IP
-Minimum bytes per sigop in transactions we relay and mine (default: 20)
-.HP
 \fB\-datacarrier\fR
 .IP
 Relay and mine data carrier transactions (default: 1)
 .HP
-\fB\-datacarriercost\fR
-.IP
-Treat extra data in transactions as at least N vbytes per actual byte
-(default: 1)
-.HP
 \fB\-datacarriersize\fR
 .IP
-Maximum size of data in data carrier transactions we relay and mine, in
-bytes (default: 42)
-.HP
-\fB\-dustdynamic\fR=\fI\,off\/\fR|[<multiplier>*]target:<blocks>|[<multiplier>*]mempool:<kvB>
-.IP
-Automatically raise dustrelayfee based on either the expected fee to be
-mined within <blocks> blocks, or to be within the best <kvB> kvB
-of this node's mempool. If unspecified, multiplier is 3.
-(default: off)
-.HP
-\fB\-dustrelayfee=\fR<amt>
-.IP
-Fee rate (in BTC/kvB) used to define dust, the value of an output such
-that it will cost more than its value in fees at this fee rate to
-spend it. (default: 0.00003)
-.HP
-\fB\-maxscriptsize\fR
-.IP
-Maximum size of scripts we relay and mine, in bytes (default: 1650)
+Relay and mine transactions whose data\-carrying raw scriptPubKey is of
+this size or less (default: 83)
 .HP
 \fB\-mempoolfullrbf\fR
 .IP
-Accept transaction replace\-by\-fee without requiring replaceability
-signaling (default: 1)
-.HP
-\fB\-mempoolreplacement\fR
-.IP
-Set to 0 to disable RBF entirely, "fee,optin" to honour RBF opt\-out
-signal, or "fee,\-optin" to always RBF aka full RBF (default:
-fee,\-optin)
-.HP
-\fB\-mempooltruc\fR
-.IP
-Behaviour for transactions requesting TRUC limits: "reject" the
-transactions entirely, "accept" them just like any other, or
-"enforce" to impose their requested restrictions (default:
-accept)
+(DEPRECATED) Accept transaction replace\-by\-fee without requiring
+replaceability signaling (default: 1)
 .HP
 \fB\-minrelaytxfee=\fR<amt>
 .IP
@@ -821,26 +707,7 @@ relaying, mining and transaction creation (default: 0.00001)
 .HP
 \fB\-permitbaremultisig\fR
 .IP
-Relay transactions creating non\-P2SH multisig outputs (default: 0)
-.HP
-\fB\-permitbarepubkey\fR
-.IP
-Relay legacy pubkey outputs (default: 0)
-.HP
-\fB\-rejectparasites\fR
-.IP
-Refuse to relay or mine parasitic overlay protocols (default: 1)
-.HP
-\fB\-rejecttokens\fR
-.IP
-Refuse to relay or mine transactions involving non\-bitcoin tokens
-(default: 0)
-.HP
-\fB\-spkreuse=\fR<policy>
-.IP
-Either "allow" to relay/mine transactions reusing addresses or other
-pubkey scripts, or "conflict" to treat them as exclusive prior to
-being mined (default: allow)
+Relay transactions creating non\-P2SH multisig outputs (default: 1)
 .HP
 \fB\-whitelistforcerelay\fR
 .IP
@@ -856,23 +723,14 @@ transactions (default: 1)
 .PP
 Block creation options:
 .HP
-\fB\-blockmaxsize=\fR<n>
-.IP
-Set maximum block size in bytes (default: 300000)
-.HP
 \fB\-blockmaxweight=\fR<n>
 .IP
-Set maximum BIP141 block weight (default: 1200000)
+Set maximum BIP141 block weight (default: 3996000)
 .HP
 \fB\-blockmintxfee=\fR<amt>
 .IP
 Set lowest fee rate (in BTC/kvB) for transactions to be included in
 block creation. (default: 0.00001)
-.HP
-\fB\-blockprioritysize=\fR<n>
-.IP
-Set maximum size of high\-priority/low\-fee transactions in bytes
-(default: 100000)
 .PP
 RPC server options:
 .HP
@@ -888,21 +746,14 @@ are a single IP (e.g. 1.2.3.4), a network/netmask (e.g.
 ipv4 (0.0.0.0/0), or all ipv6 (::/0). This option can be
 specified multiple times
 .HP
-\fB\-rpcauth=\fR<userpw>[:wallet]
+\fB\-rpcauth=\fR<userpw>
 .IP
 Username and HMAC\-SHA\-256 hashed password for JSON\-RPC connections. The
 field <userpw> comes in the format: <USERNAME>:<SALT>$<HASH>. A
 canonical python script is included in share/rpcauth. The client
 then connects normally using the
-rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. A
-single wallet name can also be specified to restrict access to
-only that wallet, or '\-' to deny all wallet access. This option
-can be specified multiple times
-.HP
-\fB\-rpcauthfile=\fR<userpw>
-.IP
-A file with a single lines with same format as rpcauth. This option can
-be specified multiple times
+rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. This
+option can be specified multiple times
 .HP
 \fB\-rpcbind=\fR<addr>[:port]
 .IP
@@ -934,7 +785,7 @@ Listen for JSON\-RPC connections on <port> (default: 8332, testnet3:
 .HP
 \fB\-rpcthreads=\fR<n>
 .IP
-Set the number of threads to service RPC calls (default: 16)
+Set the number of threads to service RPC calls (default: 4)
 .HP
 \fB\-rpcuser=\fR<user>
 .IP
@@ -960,26 +811,15 @@ subject to empty whitelists.
 \fB\-server\fR
 .IP
 Accept command line and JSON\-RPC commands
-.PP
-Statistic options:
-.HP
-\fB\-statsenable\fR
-.IP
-Enable statistics (default: 0)
-.HP
-\fB\-statsmaxmemorytarget=\fR<n>
-.IP
-Set the memory limit target for statistics in bytes (default: 10485760)
 .SH COPYRIGHT
-Copyright (C) 2009-2025 The Bitcoin Knots developers
-Copyright (C) 2009-2025 The Bitcoin Core developers
+Copyright (C) 2009-2024 The Bitcoin Core developers
 
-Please contribute if you find Bitcoin Knots useful. Visit
-<https://bitcoinknots.org/> for further information about the software.
-The source code is available from <https://github.com/bitcoinknots/bitcoin>.
+Please contribute if you find Bitcoin Core useful. Visit
+<https://bitcoincore.org/> for further information about the software.
+The source code is available from <https://github.com/bitcoin/bitcoin>.
 
 This is experimental software.
 Distributed under the MIT software license, see the accompanying file COPYING
 or <https://opensource.org/licenses/MIT>
 .SH "SEE ALSO"
-bitcoin-cli(1), bitcoin-tx(1), bitcoin-wallet(1), bitcoin-util(1), bitcoin-qt(1)
+bitcoind(1), bitcoin-cli(1), bitcoin-tx(1), bitcoin-wallet(1), bitcoin-util(1), bitcoin-qt(1)
diff --git a/doc/release-notes.md b/doc/release-notes.md
index 87d6af5d4c..e134dcce43 100644
--- a/doc/release-notes.md
+++ b/doc/release-notes.md
@@ -1,17 +1,17 @@
-Bitcoin Knots version 28.1.knots20250305 is now available from:
+Bitcoin Core version 28.1 is now available from:
 
-  <https://bitcoinknots.org/files/28.x/28.1.knots20250305/>
+  <https://bitcoincore.org/bin/bitcoin-core-28.1>
 
 This release includes new features, various bug fixes and performance
 improvements, as well as updated translations.
 
 Please report bugs using the issue tracker at GitHub:
 
-  <https://github.com/bitcoinknots/bitcoin/issues>
+  <https://github.com/bitcoin/bitcoin/issues>
 
 To receive security and update notifications, please subscribe to:
 
-  <https://bitcoinknots.org/list/announcements/join/>
+  <https://bitcoincore.org/en/list/announcements/join/>
 
 How to Upgrade
 ==============
@@ -21,492 +21,87 @@ shut down (which might take a few minutes in some cases), then run the
 installer (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on macOS)
 or `bitcoind`/`bitcoin-qt` (on Linux).
 
-Upgrading directly from very old versions of Bitcoin Core or Knots is possible,
-but it might take some time if the data directory needs to be migrated. Old
-wallet versions of Bitcoin Knots are generally supported.
+Upgrading directly from a version of Bitcoin Core that has reached its EOL is
+possible, but it might take some time if the data directory needs to be migrated. Old
+wallet versions of Bitcoin Core are generally supported.
+
+Running Bitcoin Core binaries on macOS requires self signing.
+```
+cd /path/to/bitcoin-28.x/bin
+xattr -d com.apple.quarantine bitcoin-cli bitcoin-qt bitcoin-tx bitcoin-util bitcoin-wallet bitcoind test_bitcoin
+codesign -s - bitcoin-cli bitcoin-qt bitcoin-tx bitcoin-util bitcoin-wallet bitcoind test_bitcoin
+```
 
 Compatibility
 ==============
 
-Bitcoin Knots is supported on operating systems using the Linux kernel, macOS
-11.0+, and Windows 7 and newer. It is not recommended to use Bitcoin Knots on
+Bitcoin Core is supported and extensively tested on operating systems
+using the Linux Kernel 3.17+, macOS 11.0+, and Windows 7 and newer. Bitcoin
+Core should also work on most other UNIX-like systems but is not as
+frequently tested on them. It is not recommended to use Bitcoin Core on
 unsupported systems.
 
-Known Bugs
-==========
-
-In various locations, including the GUI's transaction details dialog and the
-`"vsize"` result in many RPC results, transaction virtual sizes may not account
-for an unusually high number of sigops (ie, as determined by the
-`-bytespersigop` policy) or datacarrier penalties (ie, `-datacarriercost`).
-This could result in reporting a lower virtual size than is actually used for
-mempool or mining purposes.
-
-Due to disruption of the shared Bitcoin Transifex repository, this release
-still does not include updated translations, and Bitcoin Knots may be unable
-to do so until/unless that is resolved.
-
 Notable changes
 ===============
 
-P2P and Network Changes
------------------------
-
-- Previously if Bitcoin Knots was listening for P2P connections, either using
-  default settings or via `bind=addr:port` it would always also bind to
-  `127.0.0.1:8334` to listen for Tor connections. It was not possible to switch
-  this off, even if the node didn't use Tor. This has been changed and now
-  `bind=addr:port` results in binding on `addr:port` only. The default behavior
-  of binding to `0.0.0.0:8333` and `127.0.0.1:8334` has not been changed.
-
-  If you are using a `bind=...` configuration without `bind=...=onion` and rely
-  on the previous implied behavior to accept incoming Tor connections at
-  `127.0.0.1:8334`, you need to now make this explicit by using
-  `bind=... bind=127.0.0.1:8334=onion`. (#22729)
-
-- When the `-port` configuration option is used, the default onion listening
-  port will now be derived to be that port + 1 instead of being set to a fixed
-  value (8334 on mainnet). This enables setups with multiple local nodes using
-  different `-port` and not using `-bind`.
-
-  Note that a `HiddenServicePort` manually configured in `torrc` may need
-  adjustment if used in connection with the `-port` option. For example, if you
-  are using `-port=5555` with a non-standard value and not using
-  `-bind=...=onion`, previously Bitcoin Knots would listen for incoming Tor
-  connections on `127.0.0.1:8334`. Now it would listen on `127.0.0.1:5556`
-  (`-port` plus one). If you configured the hidden service manually in torrc
-  now you have to change it from `HiddenServicePort 8333 127.0.0.1:8334` to
-  `HiddenServicePort 8333 127.0.0.1:5556`, or configure bitcoind with
-  `-bind=127.0.0.1:8334=onion` to get the previous behavior. (#31223)
-
-- Bitcoin Knots will now fail to start up if any of its P2P binds fail, rather
-  than the previous behaviour where it would only abort startup if all P2P
-  binds had failed. (#22729)
-
-- Support for Testnet4 as specified in [BIP94](https://github.com/bitcoin/bips/blob/master/bip-0094.mediawiki)
-  has been added. The network can be selected with the `-testnet4` option and
-  the section header is also named `[testnet4]`.
-  While the intention is to phase out support for Testnet3 in an upcoming
-  version, support for it is still available via the known options in this
-  release. (#29775)
-
-- UNIX domain sockets can now be used for proxy connections. Set `-onion` or
-  `-proxy` to the local socket path with the prefix `unix:` (e.g.
-  `-onion=unix:/home/me/torsocket`). (#27375)
-
-- Transactions having a feerate that is too low will be opportunistically
-  paired with their child transactions and submitted as a package, thus
-  enabling the node to download 1-parent-1-child packages using the existing
-  transaction relay protocol. Combined with other mempool policies, this change
-  allows limited "package relay" when a parent transaction is below the mempool
-  minimum feerate. Warning: this P2P feature is limited (unlike the
-  `submitpackage` interface, a child with multiple unconfirmed parents is not
-  supported) and not reliable. (#28970)
-
-Mempool Policy Changes
-----------------------
-
-- Topologically Restricted Until Confirmation (TRUC) parents are now allowed
-  to be below the minimum relay feerate (i.e., pay 0 fees).
-
-- Pay To Anchor (P2A) is a new standard witness output type for spending,
-  a newly recognised output template. This allows for key-less anchor
-  outputs, with compact spending conditions for additional efficiencies on
-  top of an equivalent `sh(OP_TRUE)` output, in addition to the txid stability
-  of the spending transaction.
-  N.B. propagation of this output spending on the network will be limited
-  until a sufficient number of nodes on the network adopt this upgrade.
-  (#30352)
-
-- Limited package RBF is now enabled, where the proposed conflicting package
-  would result in a connected component, aka cluster, of size 2 in the mempool.
-  All clusters being conflicted against must be of size 2 or lower. (#28984)
-
-GUI Changes
------------
-
-- Transactions no longer show as confirmed after a mere 6 blocks. Instead, the
-  confirmation period has been extended to 16 blocks, which is a safer duration
-  given the current problematic state of mining centralisation. Note that if
-  you wish to be secure against China/Bitmain, you should consider transactions
-  unconfirmed for a full week.
-
-- The "Migrate Wallet" menu allows users to migrate any legacy wallet in their
-  wallet directory, regardless of the wallets loaded. (gui#824)
-
-- A very basic block visualizer has been added to the Window menu. You can use
-  it to see a graphic for any block at a glance, or block templates your node
-  is generating for your miner.
-
-Signed Messages
----------------
-
-Bitcoin has the ability for the recipient of bitcoins to a given address to
-sign messages, typically intended for use agreeing to terms. Due to confusion,
-this feature has often been mis-used in an attempt to prove current ownership
-of bitcoins or having sent a Bitcoin transaction. However, these message
-signatures do not in fact reflect either ownership or who sent a transaction.
-For this reason, message signing was not implemented for Segwit in hopes of a
-better standard that never manifested. Nevertheless, being able to sign as the
-recipient remains useful in some scenarios, so this version of Bitcoin Knots
-extends it to support newer standards:
-
-- Verifying BIP 137, BIP 322, and Electrum signed messages is now supported.
-
-- When signing messages for a Segwit or Taproot address, a BIP 322 signature
-  will be produced. (#24058)
-
-JSON-RPC 2.0 Support
---------------------
-
-The JSON-RPC server now recognizes JSON-RPC 2.0 requests and responds with
-strict adherence to the [specification](https://www.jsonrpc.org/specification).
-See [JSON-RPC-interface.md](https://github.com/bitcoin/bitcoin/blob/master/doc/JSON-RPC-interface.md#json-rpc-11-vs-20) for details. (#27101)
-
-JSON-RPC clients may need to be updated to be compatible with the JSON-RPC
-server. Please open an issue on GitHub if any compatibility issues are found.
-
-Updated RPCs
-------------
-
-- The `dumptxoutset` RPC now returns the UTXO set dump in a new and improved
-  format. Correspondingly, the `loadtxoutset` RPC now expects this new format
-  in the dumps it tries to load. Dumps with the old format are no longer
-  supported and need to be recreated using the new format to be usable.
-  (#29612)
-
-- The `"warnings"` field in `getblockchaininfo`, `getmininginfo` and
-  `getnetworkinfo` now returns all the active node warnings as an array
-  of strings, instead of a single warning. The current behaviour
-  can be temporarily restored by running Bitcoin Knots with the configuration
-  option `-deprecatedrpc=warnings`. (#29845)
-
-- Previously when using the `sendrawtransaction` RPC and specifying outputs
-  that are already in the UTXO set, an RPC error code of `-27` with the
-  message "Transaction already in block chain" was returned in response.
-  The error message has been changed to "Transaction outputs already in utxo
-  set" to more accurately describe the source of the issue. (#30212)
-
-- The default mode for the `estimatesmartfee` RPC has been updated from
-  `conservative` to `economical`, which is expected to reduce over-estimation
-  for many users, particularly if Replace-by-Fee is an option. For users that
-  require high confidence in their fee estimates at the cost of potentially
-  over-estimating, the `conservative` mode remains available. (#30275)
-
-- RPC `submitpackage` now allows 2 new arguments to be passed: `maxfeerate` and
-  `maxburnamount`. See the submitpackage help for details. (#28950)
-
-- The `status` action of the `scanblocks` RPC now returns an additional array
-  `"relevant_blocks"` containing the matching block hashes found so far during
-  a scan. (#30713)
-
-- The `utxoupdatepsbt` method now accepts an optional third parameter,
-  `prevtxs`, containing an array of previous transactions (in hex) spent in
-  the PSBT being updated. The typical use-case would be when you have a too
-  low-fee (perhaps presigned) or timelocked parent transaction where you want
-  to sign the child transaction before broadcasting anything. (#30886)
-
-- It is now possible to pass a named pipe (aka fifo) to the `dumptxoutset` RPC
-  method. This could be used to transfer the UTXO set to another program, such
-  as one which populates a database, without writing the entire UTXO set to
-  disk first. (#31560)
-
-- A new field `"cpu_load"` has been added to the `getpeerinfo` RPC output. It
-  shows the CPU time (user + system) spent processing messages from the given
-  peer and crafting messages for it expressed in per milles (‰) of the duration
-  of the connection. The field is optional and will be omitted on platforms
-  that do not support this or if still not measured. (#31672)
-
-- The `getblocktemplate` method has been extended to accept new options to
-  control template creation: `blockreservedsigops`, `blockreservedsize`, and
-  `blockreservedweight` offset the maximum sigops/size/weight put into the
-  returned block template, while still respecting the configured limits.
-
-Changes to wallet-related RPCs can be found in the Wallet section below.
-
-New RPCs
---------
-
-- `getdescriptoractivity` can be used to find all spend/receive activity
-  relevant to a given set of descriptors within a set of specified blocks. This
-  call can be used with `scanblocks` to lessen the need for additional indexing
-  programs. (#30708)
-
-- `loadtxoutset` has been added, which allows loading a UTXO snapshot of the
-  format generated by `dumptxoutset`. See the AssumeUTXO section below for more
-  information.
-
-Updated REST APIs
------------------
-
-- As with the default mode for the `estimatesmartfee` RPC, the
-  `/rest/fee/unset/<TARGET>.json` endpoint has been updated to return estimates
-  calculated according to the `economical` mode rather than `conservative`.
-
-Wallet
-------
-
-- The wallet now detects when wallet transactions conflict with the mempool.
-  Mempool-conflicting transactions can be seen in the `"mempoolconflicts"`
-  field of `gettransaction`. The inputs of mempool-conflicted transactions can
-  now be respent without manually abandoning the transactions when the parent
-  transaction is dropped from the mempool, which can cause wallet balances to
-  appear higher. (#27307)
-
-- A new `max_tx_weight` option has been added to the RPCs `fundrawtransaction`,
-  `walletcreatefundedpsbt`, and `send`. It specifies the maximum transaction
-  weight. If the limit is exceeded during funding, the transaction will not be
-  built. The default value is 4,000,000 WU. (#29523)
-
-- A new `createwalletdescriptor` RPC allows users to add new automatically
-  generated descriptors to their wallet. This can be used to upgrade wallets
-  created prior to the introduction of a new standard descriptor, such as
-  taproot. (#29130)
-
-- A new RPC `gethdkeys` lists all of the BIP32 HD keys in use by all of the
-  descriptors in the wallet. These keys can be used in conjunction with
-  `createwalletdescriptor` to create and add single key descriptors to the
-  wallet for a particular key that the wallet already knows. (#29130)
-
-- In RPC `bumpfee`, if a `fee_rate` is specified, the feerate is no longer
-  restricted to following the wallet's incremental feerate of 5 sat/vb. The
-  feerate must still be at least the sum of the original fee and the mempool's
-  incremental feerate. (#27969)
-
-- The `getbalance` RPC method will now throw an error if `avoid_reuse` is set
-  together with `dummy=*`. (This combination was never supported, and the
-  `avoid_reuse` parameter had previously been silently ignored.)
-
-AssumeUTXO
-----------
-
-AssumeUTXO is a new experiemental feature that allows you to make a node usable
-quicker, only waiting on the complete sync to provide security. This is done by
-using the new `loadtxoutset` RPC method to load a trusted UTXO snapshot. Once
-this snapshot is loaded, its contents will be deserialized into a second
-chainstate data structure, which is then used to sync to the network's tip.
-
-Meanwhile, the original chainstate will complete the initial block download
-process in the background, eventually validating up to the block that the
-snapshot is based upon.
-
-The result is a usable node that is current with the network tip in a matter of
-minutes rather than hours. However, until the full background sync completes,
-the node and any wallets using it remain insecure and should not be trusted or
-relied on for confirmation of payment. (#27596)
-
-You can find more information on this process in
-[the `assumeutxo` design document](design/assumeutxo.md).
-
-- AssumeUTXO mainnet parameters have been added for height 840,000 and 880,000.
-  This means the new `loadtxoutset` RPC can be used only on mainnet with the
-  matching UTXO set from one of those heights. (#28553, #31969)
-
-- While the node remains in an incomplete AssumeUTXO state, transactions will
-  correctly display as unconfirmed. Applicable RPC methods dealing with
-  transactions will return an additional `"confirmations_assumed"` field until
-  the background sync has completed. Note that *block* confirmation counts are
-  not affected.
-
-- When using assumeutxo with `-prune`, the prune budget may be exceeded if it
-  is set lower than 1100MB (i.e. `MIN_DISK_SPACE_FOR_BLOCK_FILES * 2`). Prune
-  budget is normally split evenly across each chainstate, unless the resulting
-  prune budget per chainstate is beneath `MIN_DISK_SPACE_FOR_BLOCK_FILES` in
-  which case that value will be used. (#27596)
-
-CLI Tools
----------
-
-- The `bitcoin-cli -netinfo` command output now includes information about your
-  node's and peers' network services. (#30930, #31886)
-
-Build System
-------------
-
-- GCC 11.1 or later, or Clang 16.0 or later, are now required to compile
-  Bitcoin Knots. (#29091, #30263)
-
-- The minimum required glibc to run Bitcoin Knots is now 2.31. This means that
-  RHEL 8 and Ubuntu 18.04 (Bionic) are no-longer supported. (#29987)
-
-- `--enable-lcov-branch-coverage` has been removed, given incompatibilities
-  between lcov version 1 & 2. `LCOV_OPTS` should be used to set any options
-  instead. (#30192)
-
-Updated Settings
-----------------
+### P2P
 
-- When running with `-alertnotify`, an alert can now be raised multiple
-  times instead of just once. Previously, it was only raised when unknown
-  new consensus rules were activated. Its scope has now been increased to
-  include all warnings. Specifically, alerts will now also be raised
-  when an invalid chain with a large amount of work has been detected.
-  Additional warnings may be added in the future. (#30058)
+- When the `-port` configuration option is used, the default onion listening port will now
+  be derived to be that port + 1 instead of being set to a fixed value (8334 on mainnet).
+  This re-allows setups with multiple local nodes using different `-port` and not using `-bind`,
+  which would lead to a startup failure in v28.0 due to a port collision.
 
-Changes to GUI or wallet related settings can be found in the GUI or Wallet
-section below.
+  Note that a `HiddenServicePort` manually configured in `torrc` may need adjustment if used in
+  connection with the `-port` option.
+  For example, if you are using `-port=5555` with a non-standard value and not using `-bind=...=onion`,
+  previously Bitcoin Core would listen for incoming Tor connections on `127.0.0.1:8334`.
+  Now it would listen on `127.0.0.1:5556` (`-port` plus one). If you configured the hidden service manually
+  in torrc now you have to change it from `HiddenServicePort 8333 127.0.0.1:8334` to `HiddenServicePort 8333
+  127.0.0.1:5556`, or configure bitcoind with `-bind=127.0.0.1:8334=onion` to get the previous behavior.
+  (#31223)
+- #30568 addrman: change internal id counting to int64_t
 
-New Settings
-------------
+### Key
 
-- A `pruneduringinit` setting has been added to override the `prune` setting
-  only during the initial blockchain sync. It can be useful to set this higher
-  to optimise for sync performance at the cost of temporarily higher disk
-  usage. (#31845)
+- #31166 key: clear out secret data in DecodeExtKey
 
-Software Expiration
--------------------
+### Build
 
-Since v0.14.2.knots20170618, each new version of Bitcoin Knots by default
-expires 1-2 years after its release. This is a security precaution to help
-ensure nodes remain kept up to date. To avoid potential disruption during
-holidays, beginning with this version, the expiry date has been moved later,
-from January until November.
+- #31013 depends: For mingw cross compile use `-gcc-posix` to prevent library conflict
+- #31502 depends: Fix CXXFLAGS on NetBSD
 
-This is an optional feature. You may disable it by setting `softwareexpiry=0`
-in your config file. You may also set `softwareexpiry` to any other POSIX
-timestamp, to trigger an expiration at that time instead.
+### Test
 
-Low-level Changes
-=================
+- #31016 test: add missing sync to feature_fee_estimation.py
+- #31448 fuzz: add cstdlib to FuzzedDataProvider
+- #31419 test: fix MIN macro redefinition
+- #31563 rpc: Extend scope of validation mutex in generateblock
 
-RPC
----
+### Doc
 
-- The default for the `rpcthreads` and `rpcworkqueue` settings have been
-  increased. This may utilise slightly more system resources, but avoids
-  issues with common workloads. (#31215)
+- #31007 doc: add testnet4 section header for config file
 
-Tests
------
+### CI
 
-- The BIP94 timewarp attack mitigation is now active on the `regtest` network.
-  (#30681)
+- #30961 ci: add LLVM_SYMBOLIZER_PATH to Valgrind fuzz job
 
-- A new `-testdatadir` option has been added to `test_bitcoin` to allow
-  specifying the location of unit test data directories. (#26564)
+### Misc
 
-Blockstorage
-------------
-
-- Block files are now XOR'd by default with a key stored in the blocksdir.
-  Previous releases of Bitcoin Knots or previous external software will not be
-  able to read the blocksdir with a non-zero XOR-key. Refer to the `-blocksxor`
-  help for more details. (#28052)
-
-Chainstate
-----------
-
-- The chainstate database flushes that occur when blocks are pruned will no
-  longer empty the database cache. The cache will remain populated longer,
-  which significantly reduces the time for initial block download to complete.
-  (#28280)
-
-Windows Data Directory
-----------------------
-
-The default data directory on Windows has been moved from `C:\Users\Username\AppData\Roaming\Bitcoin`
-to `C:\Users\Username\AppData\Local\Bitcoin`. Bitcoin Knots will check the
-existence of the old directory first and continue to use that directory for
-backwards compatibility if it is present. (#27064)
-
-Dependencies
-------------
-
-- The dependency on Boost.Process has been replaced with cpp-subprocess, which
-  is contained in source. Builders will no longer need Boost.Process to build
-  with external signer or Tor subprocess support. (#28981) If you wish to build
-  without support for running a dedicated Tor subprocess, you can use the new
-  `--disable-tor-subprocess` configure flag.
+- #31267 refactor: Drop deprecated space in `operator""_mst`
+- #31431 util: use explicit cast in MultiIntBitSet::Fill()
 
 Credits
 =======
 
-Thanks to everyone who contributed to this release:
-- 0xb10c
-- Alfonso Roman Zubeldia
-- Andrew Toth
-- AngusP
-- Anthony Towns
-- Antoine Poinsot
-- Anton A
-- Ash Manning
-- Ava Chow
-- Ayush Singh
-- Ben Westgate
-- Brandon Odiwuor
-- brunoerg
-- bstin
-- CharlesCNorton
-- Charlie
-- Christopher Bergqvist
-- Cory Fields
-- crazeteam
-- Daniela Brozzoni
-- David Benjamin
-- David Gumberg
-- dergoegge
-- Edil Medeiros
-- Epic Curious
-- eval-exec
-- Fabian Jahr
 - fanquake
-- furszy
-- glozow
-- Greg Sanders
-- hanmz
 - Hennadii Stepanov
-- Hernan Marino
-- Hodlinator
-- ishaanam
-- ismaelsadeeq
-- Jadi
-- James O'Beirne
-- Jon Atack
-- josibake
-- jrakibi
-- Karl-Johan Alm
-- kevkevin
-- kevkevinpal
-- Konstantin Akimov
 - laanwj
-- Larry Ruane
-- Lőrinc
-- ludete
-- Luis Schwab
-- Luke Dashjr
 - MarcoFalke
-- marcofleon
-- Marnix
-- Martin Saposnic
 - Martin Zumsande
-- Matt Corallo
-- Matthew Zipkin
-- Matt Whitlock
-- Max Edwards
-- Michael Dietz
-- Michael Little
-- Murch
-- nanlour
-- pablomartin4btc
-- Peter Todd
-- Pieter Wuille
-- @RandyMcMillan
-- RoboSchmied
-- Roman Zeyde
-- Ryan Ofsky
+- Marnix
 - Sebastian Falbesoner
-- Sergi Delgado Segura
-- Sjors Provoost
-- spicyzboss
-- StevenMia
-- stickies-v
-- stratospher
-- Suhas Daftuar
-- sunerok
-- tdb3
-- TheCharlatan
-- umiumi
-- Vasil Dimov
-- virtu
-- willcl-ark
+
+Thanks to everyone who directly contributed to this release:
+
+As well as to everyone that helped with translations on
+[Transifex](https://www.transifex.com/bitcoin/bitcoin/).
diff --git a/doc/shared-libraries.md b/doc/shared-libraries.md
deleted file mode 100644
index 07aee46f0b..0000000000
--- a/doc/shared-libraries.md
+++ /dev/null
@@ -1,77 +0,0 @@
-Shared Libraries
-================
-
-## bitcoinconsensus
-
-The purpose of this library is to make the verification functionality that is critical to Bitcoin's consensus available to other applications, e.g. to language bindings.
-
-### API
-
-The interface is defined in the C header `bitcoinconsensus.h` located in `src/script/bitcoinconsensus.h`.
-
-#### Version
-
-`bitcoinconsensus_version` returns an `unsigned int` with the API version *(currently `2`)*.
-
-#### Script Validation
-
-`bitcoinconsensus_verify_script`, `bitcoinconsensus_verify_script_with_amount` and `bitcoinconsensus_verify_script_with_spent_outputs` return an `int` with the status of the verification. It will be `1` if the input script correctly spends the previous output `scriptPubKey`.
-
-##### Parameters
-###### bitcoinconsensus_verify_script
-- `const unsigned char *scriptPubKey` - The previous output script that encumbers spending.
-- `unsigned int scriptPubKeyLen` - The number of bytes for the `scriptPubKey`.
-- `const unsigned char *txTo` - The transaction with the input that is spending the previous output.
-- `unsigned int txToLen` - The number of bytes for the `txTo`.
-- `unsigned int nIn` - The index of the input in `txTo` that spends the `scriptPubKey`.
-- `unsigned int flags` - The script validation flags *(see below)*.
-- `bitcoinconsensus_error* err` - Will have the error/success code for the operation *(see below)*.
-
-###### bitcoinconsensus_verify_script_with_amount
-- `const unsigned char *scriptPubKey` - The previous output script that encumbers spending.
-- `unsigned int scriptPubKeyLen` - The number of bytes for the `scriptPubKey`.
-- `int64_t amount` - The amount spent in the input
-- `const unsigned char *txTo` - The transaction with the input that is spending the previous output.
-- `unsigned int txToLen` - The number of bytes for the `txTo`.
-- `unsigned int nIn` - The index of the input in `txTo` that spends the `scriptPubKey`.
-- `unsigned int flags` - The script validation flags *(see below)*.
-- `bitcoinconsensus_error* err` - Will have the error/success code for the operation *(see below)*.
-
-###### bitcoinconsensus_verify_script_with_spent_outputs
-- `const unsigned char *scriptPubKey` - The previous output script that encumbers spending.
-- `unsigned int scriptPubKeyLen` - The number of bytes for the `scriptPubKey`.
-- `int64_t amount` - The amount spent in the input
-- `const unsigned char *txTo` - The transaction with the input that is spending the previous output.
-- `unsigned int txToLen` - The number of bytes for the `txTo`.
-- `UTXO *spentOutputs` - Previous outputs spent in the transaction. `UTXO` is a struct composed by `const unsigned char *scriptPubKey`, `unsigned int scriptPubKeySize` (the number of bytes for the `scriptPubKey`) and `unsigned int value`.
-- `unsigned int spentOutputsLen` - The number of bytes for the `spentOutputs`.
-- `unsigned int nIn` - The index of the input in `txTo` that spends the `scriptPubKey`.
-- `unsigned int flags` - The script validation flags *(see below)*.
-- `bitcoinconsensus_error* err` - Will have the error/success code for the operation *(see below)*.
-
-##### Script Flags
-- `bitcoinconsensus_SCRIPT_FLAGS_VERIFY_NONE`
-- `bitcoinconsensus_SCRIPT_FLAGS_VERIFY_P2SH` - Evaluate P2SH ([BIP16](https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki)) subscripts
-- `bitcoinconsensus_SCRIPT_FLAGS_VERIFY_DERSIG` - Enforce strict DER ([BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)) compliance
-- `bitcoinconsensus_SCRIPT_FLAGS_VERIFY_NULLDUMMY` - Enforce NULLDUMMY ([BIP147](https://github.com/bitcoin/bips/blob/master/bip-0147.mediawiki))
-- `bitcoinconsensus_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY` - Enable CHECKLOCKTIMEVERIFY ([BIP65](https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki))
-- `bitcoinconsensus_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY` - Enable CHECKSEQUENCEVERIFY ([BIP112](https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki))
-- `bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS` - Enable WITNESS ([BIP141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki))
-- `bitcoinconsensus_SCRIPT_FLAGS_VERIFY_TAPROOT` - Enable TAPROOT ([BIP340](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki), [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki), [BIP342](https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki))
-
-##### Errors
-- `bitcoinconsensus_ERR_OK` - No errors with input parameters *(see the return value of `bitcoinconsensus_verify_script` for the verification status)*
-- `bitcoinconsensus_ERR_TX_INDEX` - An invalid index for `txTo`
-- `bitcoinconsensus_ERR_TX_SIZE_MISMATCH` - `txToLen` did not match with the size of `txTo`
-- `bitcoinconsensus_ERR_DESERIALIZE` - An error deserializing `txTo`
-- `bitcoinconsensus_ERR_AMOUNT_REQUIRED` - Input amount is required if WITNESS is used
-- `bitcoinconsensus_ERR_INVALID_FLAGS` - Script verification `flags` are invalid (i.e. not part of the libconsensus interface)
-- `bitcoinconsensus_ERR_SPENT_OUTPUTS_REQUIRED` - Spent outputs are required if TAPROOT is used
-- `bitcoinconsensus_ERR_SPENT_OUTPUTS_MISMATCH` - Spent outputs size doesn't match tx inputs size
-
-### Example Implementations
-- [NBitcoin](https://github.com/MetacoSA/NBitcoin/blob/5e1055cd7c4186dee4227c344af8892aea54faec/NBitcoin/Script.cs#L979-#L1031) (.NET Bindings)
-- [node-libbitcoinconsensus](https://github.com/bitpay/node-libbitcoinconsensus) (Node.js Bindings)
-- [java-libbitcoinconsensus](https://github.com/dexX7/java-libbitcoinconsensus) (Java Bindings)
-- [bitcoinconsensus-php](https://github.com/Bit-Wasp/bitcoinconsensus-php) (PHP Bindings)
-- [rust-bitcoinconsensus](https://github.com/rust-bitcoin/rust-bitcoinconsensus) (Rust Bindings)
\ No newline at end of file
diff --git a/doc/zmq.md b/doc/zmq.md
index bfa8e5f84e..07c340fb99 100644
--- a/doc/zmq.md
+++ b/doc/zmq.md
@@ -61,10 +61,8 @@ Currently, the following notifications are supported:
 
     -zmqpubhashtx=address
     -zmqpubhashblock=address
-    -zmqpubhashwallettx=address
     -zmqpubrawblock=address
     -zmqpubrawtx=address
-    -zmqpubrawwallettx=address
     -zmqpubsequence=address
 
 The socket type is PUB and the address must be a valid ZeroMQ socket
@@ -76,10 +74,8 @@ The option to set the PUB socket's outbound message high water mark
 
     -zmqpubhashtxhwm=n
     -zmqpubhashblockhwm=n
-    -zmqpubhashwallettxhwm=n
     -zmqpubrawblockhwm=n
     -zmqpubrawtxhwm=n
-    -zmqpubrawwallettxhwm=n
     -zmqpubsequencehwm=n
 
 The high water mark value must be an integer greater than or equal to 0.
@@ -97,14 +93,6 @@ corresponds to the notification type. For instance, for the
 notification `-zmqpubhashtx` the topic is `hashtx` (no null
 terminator). These options can also be provided in bitcoin.conf.
 
-For wallet transaction notifications (both hashwallettx and rawwallettx), the
-topic also indicates if the transaction came from a block or mempool. If
-originated from mempool `-mempool` postfix will be added to the topic, for
-block `-block` postfix will be added. Because zeromq is using prefix matching
-for topics you can subscribe to `rawwallettx` (or `hashwallettx`) to get both
-notifications. If you only want one type of notification subscribe to either
-`rawwallettx-mempool` or `rawwallettx-block`.
-
 The topics are:
 
 `sequence`: the body is structured as the following based on the type of message:
@@ -133,15 +121,6 @@ Where the 8-byte uints correspond to the mempool sequence number.
 
     | hashblock | <32-byte block hash in Little Endian> | <uint32 sequence number in Little Endian>
 
-
-`rawwallettx`: Identical to `rawtx`, except only when transactions are added (or updated) in an open wallet. Full topic is either `rawwallettx-block` for transactions in a block, or `rawwallettx-mempool` otherwise.
-
-    | rawwallettx-<"block" or "mempool"> | <serialized transaction> | <uint32 sequence number in Little Endian>
-
-`hashwallettx`: Identical to `hashtx`, except only when transactions are added (or updated) in an open wallet. Full topic is either `hashwallettx-block` for transactions in a block, or `hashwallettx-mempool` otherwise.
-
-    | hashwallettx-<"block" or "mempool"> | <32-byte transaction hash in Little Endian> | <uint32 sequence number in Little Endian>
-
 **_NOTE:_**  Note that the 32-byte hashes are in Little Endian and not in the Big Endian format that the RPC interface and block explorers use to display transaction and block hashes.
 
 ZeroMQ endpoint specifiers for TCP (and others) are documented in the
diff --git a/libbitcoinconsensus.pc.in b/libbitcoinconsensus.pc.in
deleted file mode 100644
index 1ceab280bb..0000000000
--- a/libbitcoinconsensus.pc.in
+++ /dev/null
@@ -1,10 +0,0 @@
-prefix=@prefix@
-exec_prefix=@exec_prefix@
-libdir=@libdir@
-includedir=@includedir@
-
-Name: @PACKAGE_NAME@ consensus library
-Description: Library for the Bitcoin consensus protocol.
-Version: @PACKAGE_VERSION@
-Libs: -L${libdir} -lbitcoinconsensus
-Cflags: -I${includedir}
diff --git a/share/examples/bitcoin.conf b/share/examples/bitcoin.conf
index fcdb30657a..a8dfc2735d 100644
--- a/share/examples/bitcoin.conf
+++ b/share/examples/bitcoin.conf
@@ -23,7 +23,7 @@
 # If this block is in the chain assume that it and its ancestors are valid
 # and potentially skip their script verification (0 to verify all,
 # default:
-# 000000000000000000006e926737e6a349f7581525ad36e743dfe5f4bc3abbb7,
+# 000000000000000000011c5890365bdbe5d25b97ce0057589acaef4f1a57263f,
 # testnet3:
 # 000000000000000465b1a66c9f386308e8c75acef9201f3f577811da09fc90ad,
 # testnet4:
@@ -33,8 +33,8 @@
 #assumevalid=<hex>
 
 # Maintain an index of compact filters by block (default: 0, values:
-# basic, v0). If <type> is not supplied or if <type> = 1, certain
-# indexes are enabled (currently just basic).
+# basic). If <type> is not supplied or if <type> = 1, indexes for
+# all known types are enabled.
 #blockfilterindex=<type>
 
 # Execute command when the best block changes (%s in cmd is replaced by
@@ -68,14 +68,6 @@
 # configuration file) (default: bitcoin.conf)
 #conf=<file>
 
-# Specify read/write configuration file. Relative paths will be prefixed
-# by the network-specific datadir location (default:
-# bitcoin_rw.conf)
-#confrw=<file>
-
-# Use Bitcoin Core policy defaults (default: 0)
-#corepolicy=1
-
 # Run in the background as a daemon and accept commands (default: 0)
 #daemon=1
 
@@ -86,7 +78,7 @@
 # Specify data directory
 #datadir=<dir>
 
-# Maximum database cache size <n> MiB (4 to 1048576, default: 450). In
+# Maximum database cache size <n> MiB (4 to 16384, default: 450). In
 # addition, unused mempool memory is shared for this cache (see
 # -maxmempool).
 #dbcache=<n>
@@ -103,10 +95,6 @@
 # Imports blocks from external file on startup
 #loadblock=<file>
 
-# If system available memory falls below <n> MiB, flush caches (0 to
-# disable, default: 10)
-#lowmem=<n>
-
 # Keep the transaction memory pool below <n> megabytes (default: 300)
 #maxmempool=<n>
 
@@ -145,17 +133,11 @@
 # target size in MiB)
 #prune=<n>
 
-# Temporarily adjusts the -prune setting until initial sync completes.
-# Ignored if pruning is disabled. (default: -1 = same value as
-# -prune)
-#pruneduringinit=1
-
 # If enabled, wipe chain state and block index, and rebuild them from
 # blk*.dat files on disk. Also wipe and rebuild other optional
 # indexes that are active. If an assumeutxo snapshot was loaded,
 # its chainstate will be wiped as well. The snapshot can then be
-# reloaded via RPC. Setting this to auto automatically reindexes
-# the block database if it is corrupted.
+# reloaded via RPC.
 #reindex=1
 
 # If enabled, wipe chain state, and rebuild it from blk*.dat files on
@@ -303,7 +285,7 @@
 #peerblockfilters=1
 
 # Support filtering of blocks and transaction with bloom filters (default:
-# 1)
+# 0)
 #peerbloomfilters=1
 
 # Listen for connections on <port> (default: 8333, testnet3: 18333,
@@ -339,10 +321,6 @@
 # Tor control port password (default: empty)
 #torpassword=<pass>
 
-# Append literal to the user agent string (should only be used for
-# software embedding)
-#uaappend=<cmt>
-
 # Use UPnP to map the listening port (default: 0)
 #upnp=1
 
@@ -352,17 +330,14 @@
 # Bind to the given address and add permission flags to the peers
 # connecting to it. Use [host]:port notation for IPv6. Allowed
 # permissions: bloomfilter (allow requesting BIP37 filtered blocks
-# and transactions), blockfilters (serve compact block filters to
-# peers per BIP157), noban (do not ban for misbehavior; implies
+# and transactions), noban (do not ban for misbehavior; implies
 # download), forcerelay (relay transactions that are already in the
 # mempool; implies relay), relay (relay even in -blocksonly mode,
 # and unlimited transaction announcements), mempool (allow
 # requesting BIP35 mempool contents), download (allow getheaders
 # during IBD, no disconnect after maxuploadtarget limit), addr
 # (responses to GETADDR avoid hitting the cache and contain random
-# records with the most up-to-date info), forceinbound (when
-# connections are full, attempt to evict a random unprotected
-# inbound peer to open a slot; implies noban). Specify multiple
+# records with the most up-to-date info). Specify multiple
 # permissions separated by commas (default:
 # download,noban,mempool,relay). Can be specified multiple times.
 #whitebind=<[permissions@]addr>
@@ -371,8 +346,7 @@
 # 1.2.3.4) or CIDR-notated network (e.g. 1.2.3.0/24). Uses the same
 # permissions as -whitebind. Additional flags "in" and "out"
 # control whether permissions apply to incoming connections and/or
-# outgoing (default: incoming only). Can be specified multiple
-# times.
+# manual (default: incoming only). Can be specified multiple times.
 #whitelist=<[permissions@]IP address or network>
 
 
@@ -442,7 +416,7 @@
 #spendzeroconfchange=1
 
 # If paytxfee is not set, include enough fee so transactions begin
-# confirmation on average within n blocks (default: 144)
+# confirmation on average within n blocks (default: 6)
 #txconfirmtarget=<n>
 
 # Specify wallet path to load at startup. Can be used multiple times to
@@ -461,17 +435,14 @@
 # exists, otherwise <datadir>)
 #walletdir=<dir>
 
-# Support segwit when restoring wallet backups and importing keys
-# (default: 0)
-#walletimplicitsegwit=1
-
 # Execute command when a wallet transaction changes. %s in cmd is replaced
 # by TxID, %w is replaced by wallet name, %b is replaced by the
 # hash of the block including the transaction (set to 'unconfirmed'
 # if the transaction is not included) and %h is replaced by the
-# block height (-1 if not included). %w should NOT be quoted
-# because this would break shell escaping used to invoke the
-# command.
+# block height (-1 if not included). %w is not currently
+# implemented on windows. On systems where %w is supported, it
+# should NOT be quoted because this would break shell escaping used
+# to invoke the command.
 #walletnotify=<cmd>
 
 # Send transactions with full-RBF opt-in enabled (RPC only, default: 1)
@@ -494,13 +465,6 @@
 # 1000)
 #zmqpubhashtxhwm=<n>
 
-# Enable publish hash wallet transaction in <address>
-#zmqpubhashwallettx=<address>
-
-# Set publish hash wallet transaction outbound message high water mark
-# (default: 1000)
-#zmqpubhashwallettxhwm=<n>
-
 # Enable publish raw block in <address>
 #zmqpubrawblock=<address>
 
@@ -514,13 +478,6 @@
 # 1000)
 #zmqpubrawtxhwm=<n>
 
-# Enable publish raw wallet transaction in <address>
-#zmqpubrawwallettx=<address>
-
-# Set publish raw wallet transaction outbound message high water mark
-# (default: 1000)
-#zmqpubrawwallettxhwm=<n>
-
 # Enable publish hash block and tx sequence in <address>
 #zmqpubsequence=<address>
 
@@ -536,7 +493,7 @@
 # or "all", output all debug logging. If <category> is 0 or "none",
 # any other categories are ignored. Other valid values for
 # <category> are: addrman, bench, blockstorage, cmpctblock, coindb,
-# estimatefee, http, i2p, ipc, leveldb, libevent, lock, mempool,
+# estimatefee, http, i2p, ipc, leveldb, libevent, mempool,
 # mempoolrej, net, proxy, prune, qt, rand, reindex, rpc, scan,
 # selectcoins, tor, txpackages, txreconciliation, validation,
 # walletdb, zmq. This option can be specified multiple times to
@@ -595,11 +552,6 @@
 # is defined by the -signetchallenge parameter
 #signet=1
 
-# Difficulty adjustment will target a block time of the given amount in
-# seconds (only for custom signet networks, must have
-# -signetchallenge set; defaults to 10 minutes)
-#signetblocktime=1
-
 # Blocks must satisfy the given script to be considered valid (only for
 # signet networks; defaults to the global default signet test
 # network challenge)
@@ -623,81 +575,28 @@
 ### Node relay options
 
 
-# Relay and mine non-OP_RETURN datacarrier injection (default: 0)
-#acceptnonstddatacarrier=1
-
-# Relay and mine "non-standard" transactions (default: 0)
-#acceptnonstdtxn=1
-
 # Equivalent bytes per sigop in transactions for relay and mining
 # (default: 20)
 #bytespersigop=1
 
-# Minimum bytes per sigop in transactions we relay and mine (default: 20)
-#bytespersigopstrict=1
-
 # Relay and mine data carrier transactions (default: 1)
 #datacarrier=1
 
-# Treat extra data in transactions as at least N vbytes per actual byte
-# (default: 1)
-#datacarriercost=1
-
-# Maximum size of data in data carrier transactions we relay and mine, in
-# bytes (default: 42)
+# Relay and mine transactions whose data-carrying raw scriptPubKey is of
+# this size or less (default: 83)
 #datacarriersize=1
 
-# Automatically raise dustrelayfee based on either the expected fee to be
-# mined within <blocks> blocks, or to be within the best <kvB> kvB
-# of this node's mempool. If unspecified, multiplier is 3.
-# (default: off)
-#dustdynamic=off|[<multiplier>*]target:<blocks>|[<multiplier>*]mempool:<kvB>
-
-# Fee rate (in BTC/kvB) used to define dust, the value of an output such
-# that it will cost more than its value in fees at this fee rate to
-# spend it. (default: 0.00003)
-#dustrelayfee=<amt>
-
-# Maximum size of scripts we relay and mine, in bytes (default: 1650)
-#maxscriptsize=1
-
-# Accept transaction replace-by-fee without requiring replaceability
-# signaling (default: 1)
+# (DEPRECATED) Accept transaction replace-by-fee without requiring
+# replaceability signaling (default: 1)
 #mempoolfullrbf=1
 
-# Set to 0 to disable RBF entirely, "fee,optin" to honour RBF opt-out
-# signal, or "fee,-optin" to always RBF aka full RBF (default:
-# fee,-optin)
-#mempoolreplacement=1
-
-# Behaviour for transactions requesting TRUC limits: "reject" the
-# transactions entirely, "accept" them just like any other, or
-# "enforce" to impose their requested restrictions (default:
-# accept)
-#mempooltruc=1
-
 # Fees (in BTC/kvB) smaller than this are considered zero fee for
 # relaying, mining and transaction creation (default: 0.00001)
 #minrelaytxfee=<amt>
 
-# Relay transactions creating non-P2SH multisig outputs (default: 0)
+# Relay transactions creating non-P2SH multisig outputs (default: 1)
 #permitbaremultisig=1
 
-# Relay legacy pubkey outputs (default: 0)
-#permitbarepubkey=1
-
-# Refuse to relay or mine parasitic overlay protocols (default: 1)
-#rejectparasites=1
-
-# Refuse to relay or mine transactions involving non-bitcoin tokens
-# (default: 0)
-#rejecttokens=1
-
-# Either "allow" to relay/mine transactions reusing addresses or other
-# pubkey scripts, or "conflict" to treat them as exclusive prior to
-# being mined (default: allow)
-#spkreuse=<policy>
-
 # Add 'forcerelay' permission to whitelisted peers with default
 # permissions. This will relay transactions even if the
 # transactions were already in the mempool. (default: 0)
@@ -712,20 +611,13 @@
 ### Block creation options
 
 
-# Set maximum block size in bytes (default: 300000)
-#blockmaxsize=<n>
-
-# Set maximum BIP141 block weight (default: 1200000)
+# Set maximum BIP141 block weight (default: 3996000)
 #blockmaxweight=<n>
 
 # Set lowest fee rate (in BTC/kvB) for transactions to be included in
 # block creation. (default: 0.00001)
 #blockmintxfee=<amt>
 
-# Set maximum size of high-priority/low-fee transactions in bytes
-# (default: 100000)
-#blockprioritysize=<n>
-
 
 ### RPC server options
 
@@ -744,15 +636,9 @@
 # field <userpw> comes in the format: <USERNAME>:<SALT>$<HASH>. A
 # canonical python script is included in share/rpcauth. The client
 # then connects normally using the
-# rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. A
-# single wallet name can also be specified to restrict access to
-# only that wallet, or '-' to deny all wallet access. This option
-# can be specified multiple times
-#rpcauth=<userpw>[:wallet]
-
-# A file with a single lines with same format as rpcauth. This option can
-# be specified multiple times
-#rpcauthfile=<userpw>
+# rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. This
+# option can be specified multiple times
+#rpcauth=<userpw>
 
 # Bind to given address to listen for JSON-RPC connections. Do not expose
 # the RPC server to untrusted networks such as the public internet!
@@ -777,7 +663,7 @@
 # 18332, testnet4: 48332, signet: 38332, regtest: 18443)
 #rpcport=<port>
 
-# Set the number of threads to service RPC calls (default: 16)
+# Set the number of threads to service RPC calls (default: 4)
 #rpcthreads=<n>
 
 # Username for JSON-RPC connections
@@ -802,16 +688,6 @@
 #server=1
 
 
-### Statistic options
-
-
-# Enable statistics (default: 0)
-#statsenable=1
-
-# Set the memory limit target for statistics in bytes (default: 10485760)
-#statsmaxmemorytarget=<n>
-
-
 # [Sections]
 # Most options will apply to all networks. To confine an option to a specific
 # network, add it under the relevant section below.
diff --git a/share/genbuild.sh b/share/genbuild.sh
index 963113ae2c..ecc96160e6 100755
--- a/share/genbuild.sh
+++ b/share/genbuild.sh
@@ -18,14 +18,9 @@ else
     exit 1
 fi
 
-# This checks that we are actually part of the intended git repository, and not just getting info about some unrelated git repository that the code happens to be in a directory under
-git_check_in_repo() {
-    ! { git status --porcelain -uall --ignored "$@" 2>/dev/null || echo '??'; } | grep -q '?'
-}
-
 GIT_TAG=""
 GIT_COMMIT=""
-if [ "${BITCOIN_GENBUILD_NO_GIT}" != "1" ] && [ -e "$(command -v git)" ] && [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" = "true" ] && git_check_in_repo share/genbuild.sh; then
+if [ "${BITCOIN_GENBUILD_NO_GIT}" != "1" ] && [ -e "$(command -v git)" ] && [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" = "true" ]; then
     # clean 'dirty' status of touched files that haven't been modified
     git diff >/dev/null 2>/dev/null
 
@@ -45,9 +40,7 @@ if [ -n "$GIT_TAG" ]; then
 elif [ -n "$GIT_COMMIT" ]; then
     NEWINFO="#define BUILD_GIT_COMMIT \"$GIT_COMMIT\""
 else
-    # NOTE: The NEWINFO line below this comment gets replaced by a string-match in contrib/guix/libexec/make_release_tarball.sh
-    # If changing it, update the script too!
-    NEWINFO='// No build information available'
+    NEWINFO="// No build information available"
 fi
 
 # only update build.h if necessary
diff --git a/share/rpcauth/rpcauth.py b/share/rpcauth/rpcauth.py
index 36a2b1b7f3..506fcf9d91 100755
--- a/share/rpcauth/rpcauth.py
+++ b/share/rpcauth/rpcauth.py
@@ -26,7 +26,6 @@ def main():
     parser.add_argument('username', help='the username for authentication')
     parser.add_argument('password', help='leave empty to generate a random password or specify "-" to prompt for password', nargs='?')
     parser.add_argument("-j", "--json", help="output to json instead of plain-text", action='store_true')
-    parser.add_argument('--output', dest='output', help='file to store credentials, to be used with -rpcauthfile')
     args = parser.parse_args()
 
     if not args.password:
@@ -37,21 +36,13 @@ def main():
     # Create 16 byte hex salt
     salt = generate_salt(16)
     password_hmac = password_to_hmac(salt, args.password)
-    rpcauth = f'{args.username}:{salt}${password_hmac}'
-
-    if args.output:
-        file = open(args.output, "a", encoding="utf8")
-        file.write(rpcauth + "\n")
 
     if args.json:
-        odict={'username':args.username, 'password':args.password}
-        if not args.output:
-            odict['rpcauth'] = rpcauth
+        odict={'username':args.username, 'password':args.password, 'rpcauth':f'{args.username}:{salt}${password_hmac}'}
         print(json.dumps(odict))
     else:
-        if not args.output:
-            print('String to be appended to bitcoin.conf:')
-            print(f'rpcauth={rpcauth}')
+        print('String to be appended to bitcoin.conf:')
+        print(f'rpcauth={args.username}:{salt}${password_hmac}')
         print(f'Your password:\n{args.password}')
 
 if __name__ == '__main__':
diff --git a/share/setup.nsi.in b/share/setup.nsi.in
index f4297ecc3b..2ce798bd2d 100644
--- a/share/setup.nsi.in
+++ b/share/setup.nsi.in
@@ -15,11 +15,11 @@ Unicode true
 !define URL @PACKAGE_URL@
 
 # MUI Symbol Definitions
-!define MUI_ICON "@abs_top_srcdir@/src/qt/res/rendered_icons/bitcoin.ico"
-!define MUI_WELCOMEFINISHPAGE_BITMAP "@abs_top_builddir@/src/qt/res/rendered_icons/nsis-wizard.bmp"
+!define MUI_ICON "@abs_top_srcdir@/share/pixmaps/bitcoin.ico"
+!define MUI_WELCOMEFINISHPAGE_BITMAP "@abs_top_srcdir@/share/pixmaps/nsis-wizard.bmp"
 !define MUI_HEADERIMAGE
 !define MUI_HEADERIMAGE_RIGHT
-!define MUI_HEADERIMAGE_BITMAP "@abs_top_builddir@/src/qt/res/rendered_icons/nsis-header.bmp"
+!define MUI_HEADERIMAGE_BITMAP "@abs_top_srcdir@/share/pixmaps/nsis-header.bmp"
 !define MUI_FINISHPAGE_NOAUTOCLOSE
 !define MUI_STARTMENUPAGE_REGISTRY_ROOT HKLM
 !define MUI_STARTMENUPAGE_REGISTRY_KEY ${REGKEY}
@@ -28,7 +28,7 @@ Unicode true
 !define MUI_FINISHPAGE_RUN "$WINDIR\explorer.exe"
 !define MUI_FINISHPAGE_RUN_PARAMETERS $INSTDIR\@BITCOIN_GUI_NAME@@EXEEXT@
 !define MUI_UNICON "${NSISDIR}\Contrib\Graphics\Icons\modern-uninstall.ico"
-!define MUI_UNWELCOMEFINISHPAGE_BITMAP "@abs_top_builddir@/src/qt/res/rendered_icons/nsis-wizard.bmp"
+!define MUI_UNWELCOMEFINISHPAGE_BITMAP "@abs_top_srcdir@/share/pixmaps/nsis-wizard.bmp"
 !define MUI_UNFINISHPAGE_NOAUTOCLOSE
 
 # Included files
diff --git a/src/Makefile.am b/src/Makefile.am
index b660b19068..1ccb5332c4 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -25,7 +25,7 @@ check_PROGRAMS =
 TESTS =
 BENCHMARKS =
 
-BITCOIN_INCLUDES=-I$(builddir) -I$(srcdir)/$(MINISKETCH_INCLUDE_DIR_INT) $(libsecp256k1_CFLAGS) -I$(srcdir)/$(UNIVALUE_INCLUDE_DIR_INT)
+BITCOIN_INCLUDES=-I$(builddir) -I$(srcdir)/$(MINISKETCH_INCLUDE_DIR_INT) -I$(srcdir)/secp256k1/include -I$(srcdir)/$(UNIVALUE_INCLUDE_DIR_INT)
 
 LIBBITCOIN_NODE=libbitcoin_node.a
 LIBBITCOIN_COMMON=libbitcoin_common.a
@@ -34,18 +34,11 @@ LIBBITCOIN_CLI=libbitcoin_cli.a
 LIBBITCOIN_UTIL=libbitcoin_util.a
 LIBBITCOIN_CRYPTO_BASE=crypto/libbitcoin_crypto_base.la
 LIBBITCOINQT=qt/libbitcoinqt.a
-if EMBEDDED_LIBSECP256K1
 LIBSECP256K1=secp256k1/libsecp256k1.la
-else
-LIBSECP256K1=$(libsecp256k1_LIBS)
-endif
 
 if ENABLE_ZMQ
 LIBBITCOIN_ZMQ=libbitcoin_zmq.a
 endif
-if BUILD_BITCOIN_LIBS
-LIBBITCOINCONSENSUS=libbitcoinconsensus.la
-endif
 if BUILD_BITCOIN_KERNEL_LIB
 LIBBITCOINKERNEL=libbitcoinkernel.la
 endif
@@ -71,16 +64,10 @@ if ENABLE_ARM_SHANI
 LIBBITCOIN_CRYPTO_ARM_SHANI = crypto/libbitcoin_crypto_arm_shani.la
 LIBBITCOIN_CRYPTO += $(LIBBITCOIN_CRYPTO_ARM_SHANI)
 endif
-if ENABLE_POWER8
-LIBBITCOIN_CRYPTO_POWER8 = crypto/libbitcoin_crypto_power8.la
-LIBBITCOIN_CRYPTO += $(LIBBITCOIN_CRYPTO_POWER8)
-endif
 noinst_LTLIBRARIES += $(LIBBITCOIN_CRYPTO)
 
-if EMBEDDED_LIBSECP256K1
 $(LIBSECP256K1): $(wildcard secp256k1/src/*.h) $(wildcard secp256k1/src/*.c) $(wildcard secp256k1/include/*)
 	$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C $(@D) $(@F)
-endif
 
 # Make is not made aware of per-object dependencies to avoid limiting building parallelization
 # But to build the less dependent modules first, we manually select their order here:
@@ -146,7 +133,6 @@ BITCOIN_CORE_H = \
   checkqueue.h \
   clientversion.h \
   cluster_linearize.h \
-  codex32.h \
   coins.h \
   common/args.h \
   common/bloom.h \
@@ -245,6 +231,7 @@ BITCOIN_CORE_H = \
   node/mempool_persist_args.h \
   node/miner.h \
   node/mini_miner.h \
+  node/minisketchwrapper.h \
   node/peerman_args.h \
   node/protocol_version.h \
   node/psbt.h \
@@ -256,7 +243,6 @@ BITCOIN_CORE_H = \
   node/warnings.h \
   noui.h \
   outputtype.h \
-  policy/coin_age_priority.h \
   policy/feerate.h \
   policy/fees.h \
   policy/fees_args.h \
@@ -276,7 +262,6 @@ BITCOIN_CORE_H = \
   rpc/mempool.h \
   rpc/mining.h \
   rpc/protocol.h \
-  rpc/rawtransaction.h \
   rpc/rawtransaction_util.h \
   rpc/register.h \
   rpc/request.h \
@@ -293,7 +278,6 @@ BITCOIN_CORE_H = \
   script/signingprovider.h \
   script/solver.h \
   signet.h \
-  stats/stats.h \
   streams.h \
   support/allocators/pool.h \
   support/allocators/secure.h \
@@ -328,7 +312,6 @@ BITCOIN_CORE_H = \
   util/hash_type.h \
   util/hasher.h \
   util/insert.h \
-  util/ioprio.h \
   util/macros.h \
   util/moneystr.h \
   util/overflow.h \
@@ -453,6 +436,7 @@ libbitcoin_node_a_SOURCES = \
   node/mempool_persist_args.cpp \
   node/miner.cpp \
   node/mini_miner.cpp \
+  node/minisketchwrapper.cpp \
   node/peerman_args.cpp \
   node/psbt.cpp \
   node/timeoffsets.cpp \
@@ -461,7 +445,6 @@ libbitcoin_node_a_SOURCES = \
   node/utxo_snapshot.cpp \
   node/warnings.cpp \
   noui.cpp \
-  policy/coin_age_priority.cpp \
   policy/fees.cpp \
   policy/fees_args.cpp \
   policy/packages.cpp \
@@ -484,8 +467,6 @@ libbitcoin_node_a_SOURCES = \
   rpc/txoutproof.cpp \
   script/sigcache.cpp \
   signet.cpp \
-  stats/rpc_stats.cpp \
-  stats/stats.cpp \
   torcontrol.cpp \
   txdb.cpp \
   txmempool.cpp \
@@ -507,7 +488,7 @@ endif
 
 # zmq #
 if ENABLE_ZMQ
-libbitcoin_zmq_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BOOST_CPPFLAGS) $(ZMQ_CFLAGS)
+libbitcoin_zmq_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(ZMQ_CFLAGS)
 libbitcoin_zmq_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)
 libbitcoin_zmq_a_SOURCES = \
   zmq/zmqabstractnotifier.cpp \
@@ -654,16 +635,6 @@ crypto_libbitcoin_crypto_arm_shani_la_CPPFLAGS += -DENABLE_ARM_SHANI
 crypto_libbitcoin_crypto_arm_shani_la_SOURCES = crypto/sha256_arm_shani.cpp
 #
 
-# See explanation for -static in crypto_libbitcoin_crypto_base_la's LDFLAGS and
-# CXXFLAGS above
-crypto_libbitcoin_crypto_power8_la_LDFLAGS = $(AM_LDFLAGS) -static
-crypto_libbitcoin_crypto_power8_la_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS) -static
-crypto_libbitcoin_crypto_power8_la_CPPFLAGS = $(AM_CPPFLAGS)
-crypto_libbitcoin_crypto_power8_la_CXXFLAGS += $(POWER8_CXXFLAGS)
-crypto_libbitcoin_crypto_power8_la_CPPFLAGS += -DENABLE_POWER8
-crypto_libbitcoin_crypto_power8_la_SOURCES = crypto/sha256_power8.cpp
-#
-
 # consensus #
 libbitcoin_consensus_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)
 libbitcoin_consensus_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)
@@ -685,7 +656,6 @@ libbitcoin_consensus_a_SOURCES = \
   primitives/transaction.h \
   pubkey.cpp \
   pubkey.h \
-  script/bitcoinconsensus.cpp \
   script/interpreter.cpp \
   script/interpreter.h \
   script/script.cpp \
@@ -708,7 +678,6 @@ libbitcoin_common_a_SOURCES = \
   bech32.cpp \
   chainparamsbase.cpp \
   chainparams.cpp \
-  codex32.cpp \
   coins.cpp \
   common/args.cpp \
   common/bloom.cpp \
@@ -776,7 +745,6 @@ libbitcoin_util_a_SOURCES = \
   util/fs.cpp \
   util/fs_helpers.cpp \
   util/hasher.cpp \
-  util/ioprio.cpp \
   util/sock.cpp \
   util/syserror.cpp \
   util/moneystr.cpp \
@@ -942,7 +910,7 @@ lib_LTLIBRARIES += $(LIBBITCOINKERNEL)
 
 libbitcoinkernel_la_LDFLAGS = $(AM_LDFLAGS) -no-undefined $(RELDFLAGS) $(PTHREAD_FLAGS)
 libbitcoinkernel_la_LIBADD = $(LIBBITCOIN_CRYPTO) $(LIBLEVELDB) $(LIBMEMENV) $(LIBSECP256K1)
-libbitcoinkernel_la_CPPFLAGS = $(AM_CPPFLAGS) -I$(builddir)/obj $(libsecp256k1_CFLAGS) $(BOOST_CPPFLAGS) $(LEVELDB_CPPFLAGS)
+libbitcoinkernel_la_CPPFLAGS = $(AM_CPPFLAGS) -I$(builddir)/obj -I$(srcdir)/secp256k1/include $(BOOST_CPPFLAGS) $(LEVELDB_CPPFLAGS)
 
 # libbitcoinkernel requires default symbol visibility, explicitly specify that
 # here so that things still work even when user configures with
@@ -1033,24 +1001,6 @@ libbitcoinkernel_la-clientversion.l$(OBJEXT): obj/build.h
 endif # BUILD_BITCOIN_KERNEL_LIB
 #
 
-# bitcoinconsensus library #
-if BUILD_BITCOIN_LIBS
-lib_LTLIBRARIES += $(LIBBITCOINCONSENSUS)
-
-include_HEADERS = script/bitcoinconsensus.h
-libbitcoinconsensus_la_SOURCES = \
-  util/strencodings.cpp \
-  $(crypto_libbitcoin_crypto_base_la_SOURCES) \
-  $(libbitcoin_consensus_a_SOURCES)
-
-libbitcoinconsensus_la_LDFLAGS = $(AM_LDFLAGS) -no-undefined $(RELDFLAGS)
-libbitcoinconsensus_la_LIBADD = $(LIBSECP256K1)
-libbitcoinconsensus_la_CPPFLAGS = $(AM_CPPFLAGS) -I$(builddir)/obj $(libsecp256k1_CFLAGS) -DBUILD_BITCOIN_INTERNAL -DDISABLE_OPTIMIZED_SHA256
-libbitcoinconsensus_la_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)
-
-endif
-#
-
 CTAES_DIST =  crypto/ctaes/bench.c
 CTAES_DIST += crypto/ctaes/ctaes.c
 CTAES_DIST += crypto/ctaes/ctaes.h
@@ -1158,56 +1108,10 @@ endif
 	 echo "};"; \
 	} > "$@.new" && mv -f "$@.new" "$@"
 
-# Rendered icons must be here, not in Makefile.qt.include, since they are distributed with the source tarball
-
-RES_RENDERED_ICON_SRC = \
-  qt/res/src/bitcoin.svg \
-  qt/res/src/nsis-header.svg
-
-RES_RENDERED_ICONS = \
-  qt/res/rendered_icons/bitcoin.ico \
-  qt/res/rendered_icons/bitcoin_testnet.ico \
-  qt/res/rendered_icons/bitcoin1024.png
-
-RES_ALL_RENDERED_ICONS = $(RES_RENDERED_ICONS) \
-  $(patsubst %,qt/res/rendered_icons/bitcoin%.png,16 32 48 256 290 512 1024) \
-  qt/res/rendered_icons/bitcoin.icns \
-  qt/res/rendered_icons/nsis-wizard.bmp
-
-EXTRA_DIST += $(RES_RENDERED_ICON_SRC) $(RES_ALL_RENDERED_ICONS)
+include Makefile.minisketch.include
 
-if CAN_RENDER_ICONS
-
-qt/res/rendered_icons/bitcoin%.png: qt/res/src/bitcoin.svg
-	@$(MKDIR_P) $(@D)
-	$(AM_V_GEN) $(RSVG_CONVERT) -f png -d $* -p $* < $< > $@
-
-# NOTE: ImageMagick will never convert transparent PNGs to 8-bit ICOs, but GIF is fine
-qt/res/rendered_icons/bitcoin%d8.gif: qt/res/rendered_icons/bitcoin%.png
-	$(AM_V_GEN) $(IMAGEMAGICK_CONVERT) $^ -colors 256 -channel A -threshold '50%' $@
-
-qt/res/rendered_icons/bitcoin.icns: $(patsubst %,qt/res/rendered_icons/bitcoin%.png,256 512 1024 32 16)
-	$(AM_V_GEN) $(PNG2ICNS) $@ $^
-
-qt/res/rendered_icons/bitcoin.ico: qt/res/rendered_icons/bitcoin32d8.gif $(patsubst %,qt/res/rendered_icons/bitcoin%.png,256 64 48 32 20 16)
-	$(AM_V_GEN) $(IMAGEMAGICK_CONVERT) $^ $@
-
-qt/res/rendered_icons/bitcoin_testnet.ico: qt/res/rendered_icons/bitcoin.ico
-	$(AM_V_GEN) $(IMAGEMAGICK_CONVERT) $^ -modulate 100,87,9 $@
-
-qt/res/rendered_icons/nsis-wizard.bmp: qt/res/rendered_icons/bitcoin290.png
-	$(AM_V_GEN) $(IMAGEMAGICK_CONVERT) $^ -crop 164x290+62+0 -border 0x12 -strip BMP3:$@
-
-qt/res/rendered_icons/nsis-header.bmp: qt/res/src/nsis-header.svg
-	$(AM_V_GEN) sed 's/PACKAGE_NAME/$(PACKAGE_NAME)/' < "$<" | $(RSVG_CONVERT) -f png -d 57 -p 57 | $(IMAGEMAGICK_CONVERT) - -background white -alpha remove BMP3:$@
-
-endif
-
-
-if EMBEDDED_LEVELDB
 include Makefile.crc32c.include
 include Makefile.leveldb.include
-endif
 
 include Makefile.test_util.include
 include Makefile.test_fuzz.include
@@ -1218,19 +1122,6 @@ if ENABLE_BENCH
 include Makefile.bench.include
 endif
 
-# Font handling must be here, not in Makefile.qt.include, since the output is distributed with the source tarball
-RES_MONOSPACE_FONT_INPUT = qt/res/fonts/RobotoTonalMono-Bold.ttf.in
-RES_MONOSPACE_FONT = qt/res/fonts/RobotoTonalMono-Bold.ttf
-EXTRA_DIST += $(RES_MONOSPACE_FONT_INPUT) $(RES_MONOSPACE_FONT)
-
-if HAVE_PYTHON
-
-$(RES_MONOSPACE_FONT): $(RES_MONOSPACE_FONT_INPUT)
-	@$(MKDIR_P) "$(@D)"
-	$(AM_V_GEN) $(PYTHON) -c 'import base64, lzma, sys; sys.stdout.buffer.write(lzma.decompress(base64.b85decode(sys.stdin.read())))' <"$<" >"$@.new" && mv "$@.new" "$@"
-
-endif
-
 if ENABLE_QT
 include Makefile.qt.include
 endif
diff --git a/src/Makefile.leveldb.include b/src/Makefile.leveldb.include
index 1851afe9e1..bf14fe206b 100644
--- a/src/Makefile.leveldb.include
+++ b/src/Makefile.leveldb.include
@@ -8,11 +8,11 @@ LIBMEMENV_INT  = leveldb/libmemenv.la
 noinst_LTLIBRARIES += $(LIBLEVELDB_INT)
 noinst_LTLIBRARIES += $(LIBMEMENV_INT)
 
-LIBLEVELDB += $(LIBLEVELDB_INT) $(LIBCRC32C)
-LIBMEMENV += $(LIBMEMENV_INT)
+LIBLEVELDB = $(LIBLEVELDB_INT) $(LIBCRC32C)
+LIBMEMENV = $(LIBMEMENV_INT)
 
+LEVELDB_CPPFLAGS =
 LEVELDB_CPPFLAGS += -I$(srcdir)/leveldb/include
-LEVELDB_CPPFLAGS += -I$(srcdir)/leveldb/helpers/memenv
 
 LEVELDB_CPPFLAGS_INT =
 LEVELDB_CPPFLAGS_INT += -I$(srcdir)/leveldb
diff --git a/src/Makefile.qt.include b/src/Makefile.qt.include
index bc0ca24410..1ac6b74688 100644
--- a/src/Makefile.qt.include
+++ b/src/Makefile.qt.include
@@ -20,7 +20,6 @@ QT_FORMS_UI = \
   qt/forms/createwalletdialog.ui \
   qt/forms/editaddressdialog.ui \
   qt/forms/helpmessagedialog.ui \
-  qt/forms/mempoolstats.ui \
   qt/forms/intro.ui \
   qt/forms/modaloverlay.ui \
   qt/forms/openuridialog.ui \
@@ -46,7 +45,6 @@ QT_MOC_CPP = \
   qt/moc_bitcoinamountfield.cpp \
   qt/moc_bitcoingui.cpp \
   qt/moc_bitcoinunits.cpp \
-  qt/moc_blockview.cpp \
   qt/moc_clientmodel.cpp \
   qt/moc_coincontroldialog.cpp \
   qt/moc_coincontroltreewidget.cpp \
@@ -58,14 +56,11 @@ QT_MOC_CPP = \
   qt/moc_macdockiconhandler.cpp \
   qt/moc_macnotificationhandler.cpp \
   qt/moc_modaloverlay.cpp \
-  qt/moc_mempoolstats.cpp \
-  qt/moc_netwatch.cpp \
   qt/moc_notificator.cpp \
   qt/moc_openuridialog.cpp \
   qt/moc_optionsdialog.cpp \
   qt/moc_optionsmodel.cpp \
   qt/moc_overviewpage.cpp \
-  qt/moc_pairingpage.cpp \
   qt/moc_peertablemodel.cpp \
   qt/moc_peertablesortproxy.cpp \
   qt/moc_paymentserver.cpp \
@@ -107,7 +102,6 @@ QT_MOC = \
 
 QT_QRC_CPP = qt/qrc_bitcoin.cpp
 QT_QRC = qt/bitcoin.qrc
-QT_QRC_BUILD = qt/qrc_bitcoin_build.qrc
 QT_QRC_LOCALE_CPP = qt/qrc_bitcoin_locale.cpp
 QT_QRC_LOCALE = qt/bitcoin_locale.qrc
 
@@ -121,7 +115,6 @@ BITCOIN_QT_H = \
   qt/bitcoinamountfield.h \
   qt/bitcoingui.h \
   qt/bitcoinunits.h \
-  qt/blockview.h \
   qt/clientmodel.h \
   qt/coincontroldialog.h \
   qt/coincontroltreewidget.h \
@@ -136,15 +129,12 @@ BITCOIN_QT_H = \
   qt/macnotificationhandler.h \
   qt/macos_appnap.h \
   qt/modaloverlay.h \
-  qt/mempoolstats.h \
-  qt/netwatch.h \
   qt/networkstyle.h \
   qt/notificator.h \
   qt/openuridialog.h \
   qt/optionsdialog.h \
   qt/optionsmodel.h \
   qt/overviewpage.h \
-  qt/pairingpage.h \
   qt/paymentserver.h \
   qt/peertablemodel.h \
   qt/peertablesortproxy.h \
@@ -162,7 +152,6 @@ BITCOIN_QT_H = \
   qt/sendcoinsrecipient.h \
   qt/signverifymessagedialog.h \
   qt/splashscreen.h \
-  qt/tonalutils.h \
   qt/trafficgraphwidget.h \
   qt/transactiondesc.h \
   qt/transactiondescdialog.h \
@@ -180,11 +169,14 @@ BITCOIN_QT_H = \
   qt/winshutdownmonitor.h
 
 QT_RES_FONTS = \
-  $(RES_MONOSPACE_FONT)
+  qt/res/fonts/RobotoMono-Bold.ttf
 
-QT_RES_ICONS = $(RES_RENDERED_ICONS) \
+QT_RES_ICONS = \
   qt/res/icons/add.png \
   qt/res/icons/address-book.png \
+  qt/res/icons/bitcoin.ico \
+  qt/res/icons/bitcoin_testnet.ico \
+  qt/res/icons/bitcoin.png \
   qt/res/icons/chevron.png \
   qt/res/icons/clock1.png \
   qt/res/icons/clock2.png \
@@ -234,29 +226,23 @@ BITCOIN_QT_BASE_CPP = \
   qt/bitcoinamountfield.cpp \
   qt/bitcoingui.cpp \
   qt/bitcoinunits.cpp \
-  qt/blockview.cpp \
   qt/clientmodel.cpp \
   qt/csvmodelwriter.cpp \
   qt/guiutil.cpp \
   qt/initexecutor.cpp \
   qt/intro.cpp \
   qt/modaloverlay.cpp \
-  qt/mempoolstats.cpp \
-  qt/netwatch.cpp \
   qt/networkstyle.cpp \
   qt/notificator.cpp \
   qt/optionsdialog.cpp \
   qt/optionsmodel.cpp \
-  qt/pairingpage.cpp \
   qt/peertablemodel.cpp \
   qt/peertablesortproxy.cpp \
   qt/platformstyle.cpp \
-  qt/qrimagewidget.cpp \
   qt/qvalidatedlineedit.cpp \
   qt/qvaluecombobox.cpp \
   qt/rpcconsole.cpp \
   qt/splashscreen.cpp \
-  qt/tonalutils.cpp \
   qt/trafficgraphwidget.cpp \
   qt/utilitydialog.cpp
 
@@ -274,6 +260,7 @@ BITCOIN_QT_WALLET_CPP = \
   qt/overviewpage.cpp \
   qt/paymentserver.cpp \
   qt/psbtoperationsdialog.cpp \
+  qt/qrimagewidget.cpp \
   qt/receivecoinsdialog.cpp \
   qt/receiverequestdialog.cpp \
   qt/recentrequeststablemodel.cpp \
@@ -305,8 +292,6 @@ QT_RES_ANIMATION = $(wildcard $(srcdir)/qt/res/animation/spinner-*.png)
 
 BITCOIN_QT_RC = qt/res/bitcoin-qt-res.rc
 
-$(BITCOIN_RC): qt/res/rendered_icons/bitcoin.ico qt/res/rendered_icons/bitcoin_testnet.ico
-
 BITCOIN_QT_INCLUDES = -DQT_NO_KEYWORDS -DQT_USE_QSTRINGBUILDER
 
 qt_libbitcoinqt_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BITCOIN_QT_INCLUDES) \
@@ -394,14 +379,11 @@ $(QT_QRC_LOCALE_CPP): $(QT_QRC_LOCALE) $(QT_QM)
 	$(AM_V_GEN) QT_SELECT=$(QT_SELECT) $(RCC) -name bitcoin_locale --format-version 1 $(@D)/temp_$(<F) > $@
 	@rm $(@D)/temp_$(<F)
 
-$(QT_QRC_BUILD): $(QT_QRC)
-	$(SED) -e 's:\(res\/\(icons\|animation\)/\):$(abs_srcdir)/qt/\1:' <"$<" >"$@"
-
-$(QT_QRC_CPP): $(QT_QRC_BUILD) $(QT_FORMS_H) $(QT_RES_FONTS) $(QT_RES_ICONS) $(QT_RES_ANIMATION)
+$(QT_QRC_CPP): $(QT_QRC) $(QT_FORMS_H) $(QT_RES_FONTS) $(QT_RES_ICONS) $(QT_RES_ANIMATION)
 	@test -f $(RCC) || (echo "rcc $(RCC) not found, but is required for generating qrc cpp files"; exit 1)
 	$(AM_V_GEN) QT_SELECT=$(QT_SELECT) $(RCC) -name bitcoin --format-version 1 $< > $@
 
-CLEAN_QT = $(nodist_qt_libbitcoinqt_a_SOURCES) $(QT_QM) $(QT_FORMS_H) qt/*.gcda qt/*.gcno qt/temp_bitcoin_locale.qrc $(QT_QRC_BUILD)
+CLEAN_QT = $(nodist_qt_libbitcoinqt_a_SOURCES) $(QT_QM) $(QT_FORMS_H) qt/*.gcda qt/*.gcno qt/temp_bitcoin_locale.qrc
 
 CLEANFILES += $(CLEAN_QT)
 
diff --git a/src/Makefile.test.include b/src/Makefile.test.include
index 040c8b7353..c396cc2ebf 100644
--- a/src/Makefile.test.include
+++ b/src/Makefile.test.include
@@ -84,7 +84,6 @@ BITCOIN_TESTS =\
   test/bswap_tests.cpp \
   test/checkqueue_tests.cpp \
   test/cluster_linearize_tests.cpp \
-  test/codex32_tests.cpp \
   test/coins_tests.cpp \
   test/coinscachepair_tests.cpp \
   test/coinstatsindex_tests.cpp \
@@ -115,6 +114,7 @@ BITCOIN_TESTS =\
   test/miner_tests.cpp \
   test/miniminer_tests.cpp \
   test/miniscript_tests.cpp \
+  test/minisketch_tests.cpp \
   test/multisig_tests.cpp \
   test/net_peer_connection_tests.cpp \
   test/net_peer_eviction_tests.cpp \
@@ -177,12 +177,8 @@ BITCOIN_TESTS =\
   test/validationinterface_tests.cpp \
   test/versionbits_tests.cpp
 
-BITCOIN_TESTS += \
-  stats/test/stats_tests.cpp
-
 if ENABLE_WALLET
 BITCOIN_TESTS += \
-  wallet/test/db_tests.cpp \
   wallet/test/feebumper_tests.cpp \
   wallet/test/psbt_wallet_tests.cpp \
   wallet/test/spend_tests.cpp \
@@ -202,6 +198,10 @@ FUZZ_SUITE_LD_COMMON +=\
  $(SQLITE_LIBS) \
  $(BDB_LIBS)
 
+if USE_BDB
+BITCOIN_TESTS += wallet/test/db_tests.cpp
+endif
+
 FUZZ_WALLET_SRC = \
  wallet/test/fuzz/coincontrol.cpp \
  wallet/test/fuzz/coinselection.cpp \
@@ -343,6 +343,7 @@ test_fuzz_fuzz_SOURCES = \
  test/fuzz/merkleblock.cpp \
  test/fuzz/message.cpp \
  test/fuzz/miniscript.cpp \
+ test/fuzz/minisketch.cpp \
  test/fuzz/mini_miner.cpp \
  test/fuzz/muhash.cpp \
  test/fuzz/multiplication_overflow.cpp \
@@ -375,7 +376,6 @@ test_fuzz_fuzz_SOURCES = \
  test/fuzz/rpc.cpp \
  test/fuzz/script.cpp \
  test/fuzz/script_assets_test_minimizer.cpp \
- test/fuzz/script_bitcoin_consensus.cpp \
  test/fuzz/script_descriptor_cache.cpp \
  test/fuzz/script_flags.cpp \
  test/fuzz/script_format.cpp \
@@ -449,9 +449,7 @@ if ENABLE_BENCH
 	$(BENCH_BINARY) -sanity-check -priority-level=high
 endif
 endif
-if EMBEDDED_LIBSECP256K1
 	$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C secp256k1 check
-endif
 
 if ENABLE_TESTS
 UNIVALUE_TESTS = univalue/test/object univalue/test/unitester
diff --git a/src/addrdb.cpp b/src/addrdb.cpp
index 9eb169911d..b89141c88e 100644
--- a/src/addrdb.cpp
+++ b/src/addrdb.cpp
@@ -24,7 +24,6 @@
 #include <univalue.h>
 #include <util/fs.h>
 #include <util/fs_helpers.h>
-#include <util/syserror.h>
 #include <util/translation.h>
 
 namespace {
@@ -80,11 +79,7 @@ bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data
         LogError("%s: Failed to flush file %s\n", __func__, fs::PathToString(pathTmp));
         return false;
     }
-    if (fileout.fclose() != 0) {
-        remove(pathTmp);
-        LogError("%s: Failed to close file %s: %s\n", __func__, fs::PathToString(pathTmp), SysErrorString(errno));
-        return false;
-    }
+    fileout.fclose();
 
     // replace existing file, if any, with new file
     if (!RenameOver(pathTmp, path)) {
diff --git a/src/bech32.cpp b/src/bech32.cpp
index 786f8d9010..5694ad54c8 100644
--- a/src/bech32.cpp
+++ b/src/bech32.cpp
@@ -17,7 +17,22 @@ namespace bech32
 namespace
 {
 
-typedef internal::data data;
+typedef std::vector<uint8_t> data;
+
+/** The Bech32 and Bech32m character set for encoding. */
+const char* CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
+
+/** The Bech32 and Bech32m character set for decoding. */
+const int8_t CHARSET_REV[128] = {
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    15, -1, 10, 17, 21, 20, 26, 30,  7,  5, -1, -1, -1, -1, -1, -1,
+    -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,
+     1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1,
+    -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,
+     1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1
+};
 
 /** We work with the finite field GF(1024) defined as a degree 2 extension of the base field GF(32)
  * The defining polynomial of the extension is x^2 + 9x + 23.
@@ -293,6 +308,21 @@ bool CheckCharacters(const std::string& str, std::vector<int>& errors)
     return errors.empty();
 }
 
+std::vector<unsigned char> PreparePolynomialCoefficients(const std::string& hrp, const data& values)
+{
+    data ret;
+    ret.reserve(hrp.size() + 1 + hrp.size() + values.size() + CHECKSUM_SIZE);
+
+    /** Expand a HRP for use in checksum computation. */
+    for (size_t i = 0; i < hrp.size(); ++i) ret.push_back(hrp[i] >> 5);
+    ret.push_back(0);
+    for (size_t i = 0; i < hrp.size(); ++i) ret.push_back(hrp[i] & 0x1f);
+
+    ret.insert(ret.end(), values.begin(), values.end());
+
+    return ret;
+}
+
 /** Verify a checksum. */
 Encoding VerifyChecksum(const std::string& hrp, const data& values)
 {
@@ -301,7 +331,7 @@ Encoding VerifyChecksum(const std::string& hrp, const data& values)
     // list of values would result in a new valid list. For that reason, Bech32 requires the
     // resulting checksum to be 1 instead. In Bech32m, this constant was amended. See
     // https://gist.github.com/sipa/14c248c288c3880a3b191f978a34508e for details.
-    auto enc = internal::PreparePolynomialCoefficients(hrp, values);
+    auto enc = PreparePolynomialCoefficients(hrp, values);
     const uint32_t check = PolyMod(enc);
     if (check == EncodingConstant(Encoding::BECH32)) return Encoding::BECH32;
     if (check == EncodingConstant(Encoding::BECH32M)) return Encoding::BECH32M;
@@ -311,7 +341,7 @@ Encoding VerifyChecksum(const std::string& hrp, const data& values)
 /** Create a checksum. */
 data CreateChecksum(Encoding encoding, const std::string& hrp, const data& values)
 {
-    auto enc = internal::PreparePolynomialCoefficients(hrp, values);
+    auto enc = PreparePolynomialCoefficients(hrp, values);
     enc.insert(enc.end(), CHECKSUM_SIZE, 0x00);
     uint32_t mod = PolyMod(enc) ^ EncodingConstant(encoding); // Determine what to XOR into those 6 zeroes.
     data ret(CHECKSUM_SIZE);
@@ -324,42 +354,8 @@ data CreateChecksum(Encoding encoding, const std::string& hrp, const data& value
 
 } // namespace
 
-namespace internal {
-
-/** The Bech32 and Bech32m character set for encoding. */
-const char* CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
-
-/** The Bech32 and Bech32m character set for decoding. */
-const int8_t CHARSET_REV[128] = {
-    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-    15, -1, 10, 17, 21, 20, 26, 30,  7,  5, -1, -1, -1, -1, -1, -1,
-    -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,
-     1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1,
-    -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,
-     1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1
-};
-
-
-std::vector<unsigned char> PreparePolynomialCoefficients(const std::string& hrp, const data& values)
-{
-    data ret;
-    ret.reserve(hrp.size() + 1 + hrp.size() + values.size() + CHECKSUM_SIZE);
-
-    /** Expand a HRP for use in checksum computation. */
-    for (size_t i = 0; i < hrp.size(); ++i) ret.push_back(hrp[i] >> 5);
-    ret.push_back(0);
-    for (size_t i = 0; i < hrp.size(); ++i) ret.push_back(hrp[i] & 0x1f);
-
-    ret.insert(ret.end(), values.begin(), values.end());
-
-    return ret;
-}
-
-
-/** Encode a hrpstring without concerning ourselves with checksum validity */
-std::string Encode(const std::string& hrp, const data& values, const data& checksum) {
+/** Encode a Bech32 or Bech32m string. */
+std::string Encode(Encoding encoding, const std::string& hrp, const data& values) {
     // First ensure that the HRP is all lowercase. BIP-173 and BIP350 require an encoder
     // to return a lowercase Bech32/Bech32m string, but if given an uppercase HRP, the
     // result will always be invalid.
@@ -370,17 +366,17 @@ std::string Encode(const std::string& hrp, const data& values, const data& check
     ret += hrp;
     ret += '1';
     for (const uint8_t& i : values) ret += CHARSET[i];
-    for (const uint8_t& i : checksum) ret += CHARSET[i];
+    for (const uint8_t& i : CreateChecksum(encoding, hrp, values)) ret += CHARSET[i];
     return ret;
 }
 
-/** Decode a hrpstring without concerning ourselves with checksum validity */
-std::pair<std::string, data> Decode(const std::string& str, CharLimit limit, size_t checksum_length) {
+/** Decode a Bech32 or Bech32m string. */
+DecodeResult Decode(const std::string& str, CharLimit limit) {
     std::vector<int> errors;
     if (!CheckCharacters(str, errors)) return {};
     size_t pos = str.rfind('1');
     if (str.size() > limit) return {};
-    if (pos == str.npos || pos == 0 || pos + checksum_length >= str.size()) {
+    if (pos == str.npos || pos == 0 || pos + CHECKSUM_SIZE >= str.size()) {
         return {};
     }
     data values(str.size() - 1 - pos);
@@ -398,22 +394,9 @@ std::pair<std::string, data> Decode(const std::string& str, CharLimit limit, siz
     for (size_t i = 0; i < pos; ++i) {
         hrp += LowerCase(str[i]);
     }
-    return std::make_pair(hrp, values);
-}
-
-} // namespace internal
-
-/** Encode a Bech32 or Bech32m string. */
-std::string Encode(Encoding encoding, const std::string& hrp, const data& values) {
-    return internal::Encode(hrp, values, CreateChecksum(encoding, hrp, values));
-}
-
-/** Decode a Bech32 or Bech32m string. */
-DecodeResult Decode(const std::string& str, CharLimit limit) {
-    auto res = internal::Decode(str, limit, CHECKSUM_SIZE);
-    Encoding result = VerifyChecksum(res.first, res.second);
+    Encoding result = VerifyChecksum(hrp, values);
     if (result == Encoding::INVALID) return {};
-    return {result, std::move(res.first), data(res.second.begin(), res.second.end() - CHECKSUM_SIZE)};
+    return {result, std::move(hrp), data(values.begin(), values.end() - CHECKSUM_SIZE)};
 }
 
 /** Find index of an incorrect character in a Bech32 string. */
@@ -449,7 +432,7 @@ std::pair<std::string, std::vector<int>> LocateErrors(const std::string& str, Ch
     data values(length);
     for (size_t i = pos + 1; i < str.size(); ++i) {
         unsigned char c = str[i];
-        int8_t rev = internal::CHARSET_REV[c];
+        int8_t rev = CHARSET_REV[c];
         if (rev == -1) {
             error_locations.push_back(i);
             return std::make_pair("Invalid Base 32 character", std::move(error_locations));
@@ -464,7 +447,7 @@ std::pair<std::string, std::vector<int>> LocateErrors(const std::string& str, Ch
         std::vector<int> possible_errors;
         // Recall that (expanded hrp + values) is interpreted as a list of coefficients of a polynomial
         // over GF(32). PolyMod computes the "remainder" of this polynomial modulo the generator G(x).
-        auto enc = internal::PreparePolynomialCoefficients(hrp, values);
+        auto enc = PreparePolynomialCoefficients(hrp, values);
         uint32_t residue = PolyMod(enc) ^ EncodingConstant(encoding);
 
         // All valid codewords should be multiples of G(x), so this remainder (after XORing with the encoding
diff --git a/src/bech32.h b/src/bech32.h
index 3d49588e18..33d1ca1935 100644
--- a/src/bech32.h
+++ b/src/bech32.h
@@ -37,7 +37,6 @@ enum class Encoding {
  *  and we would never encode an address with such a massive value */
 enum CharLimit : size_t {
     BECH32 = 90,            //!< BIP173/350 imposed character limit for Bech32(m) encoded addresses. This guarantees finding up to 4 errors.
-    CODEX32 = 127,
 };
 
 /** Encode a Bech32 or Bech32m string. If hrp contains uppercase characters, this will cause an
@@ -60,24 +59,6 @@ DecodeResult Decode(const std::string& str, CharLimit limit = CharLimit::BECH32)
 /** Return the positions of errors in a Bech32 string. */
 std::pair<std::string, std::vector<int>> LocateErrors(const std::string& str, CharLimit limit = CharLimit::BECH32);
 
-// The internal namespace is used for things shared between bech32(m) and codex32.
-// These functions should not be used except by other hrpstring-encoded codes.
-namespace internal {
-typedef std::vector<uint8_t> data;
-
-extern const char* CHARSET;
-extern const int8_t CHARSET_REV[128];
-
-std::vector<unsigned char> PreparePolynomialCoefficients(const std::string& hrp, const data& values);
-
-/** Encode a hrpstring without concerning ourselves with checksum validity */
-std::string Encode(const std::string& hrp, const data& values, const data& checksum);
-
-/** Decode a hrpstring without concerning ourselves with checksum validity */
-std::pair<std::string, data> Decode(const std::string& str, CharLimit limit, size_t checksum_length);
-
-} // namespace internal
-
 } // namespace bech32
 
 #endif // BITCOIN_BECH32_H
diff --git a/src/bench/mempool_eviction.cpp b/src/bench/mempool_eviction.cpp
index 22e82b4ad2..1a9b013277 100644
--- a/src/bench/mempool_eviction.cpp
+++ b/src/bench/mempool_eviction.cpp
@@ -12,16 +12,14 @@
 static void AddTx(const CTransactionRef& tx, const CAmount& nFee, CTxMemPool& pool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)
 {
     int64_t nTime = 0;
-    double dPriority = 10.0;
     unsigned int nHeight = 1;
     uint64_t sequence = 0;
     bool spendsCoinbase = false;
     unsigned int sigOpCost = 4;
     LockPoints lp;
     pool.addUnchecked(CTxMemPoolEntry(
-        tx, nFee, nTime, dPriority, nHeight, sequence,
-        tx->GetValueOut(),
-        spendsCoinbase, /*extra_weight=*/0, sigOpCost, lp));
+        tx, nFee, nTime, nHeight, sequence,
+        spendsCoinbase, sigOpCost, lp));
 }
 
 // Right now this is only testing eviction performance in an extremely small
diff --git a/src/bench/mempool_stress.cpp b/src/bench/mempool_stress.cpp
index c1b89f1fe2..3c82f55c19 100644
--- a/src/bench/mempool_stress.cpp
+++ b/src/bench/mempool_stress.cpp
@@ -16,13 +16,12 @@
 static void AddTx(const CTransactionRef& tx, CTxMemPool& pool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)
 {
     int64_t nTime = 0;
-    constexpr double coin_age{10.0};
     unsigned int nHeight = 1;
     uint64_t sequence = 0;
     bool spendsCoinbase = false;
     unsigned int sigOpCost = 4;
     LockPoints lp;
-    pool.addUnchecked(CTxMemPoolEntry(tx, 1000, nTime, nHeight, sequence, /*entry_tx_inputs_coin_age=*/coin_age, tx->GetValueOut(), spendsCoinbase, /*extra_weight=*/0, sigOpCost, lp));
+    pool.addUnchecked(CTxMemPoolEntry(tx, 1000, nTime, nHeight, sequence, spendsCoinbase, sigOpCost, lp));
 }
 
 struct Available {
diff --git a/src/bench/rpc_mempool.cpp b/src/bench/rpc_mempool.cpp
index 5cd86fa848..a55aa0c794 100644
--- a/src/bench/rpc_mempool.cpp
+++ b/src/bench/rpc_mempool.cpp
@@ -9,7 +9,6 @@
 #include <test/util/setup_common.h>
 #include <txmempool.h>
 #include <util/chaintype.h>
-#include <validation.h>
 
 #include <univalue.h>
 
@@ -17,13 +16,12 @@
 static void AddTx(const CTransactionRef& tx, const CAmount& fee, CTxMemPool& pool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)
 {
     LockPoints lp;
-    pool.addUnchecked(CTxMemPoolEntry(tx, fee, /*time=*/0, /*entry_height=*/0, /*entry_sequence=*/0, /*entry_tx_inputs_coin_age=*/0.0, /*in_chain_input_value=*/0, /*spends_coinbase=*/false, /*extra_weight=*/0, /*sigops_cost=*/4, lp));
+    pool.addUnchecked(CTxMemPoolEntry(tx, fee, /*time=*/0, /*entry_height=*/1, /*entry_sequence=*/0, /*spends_coinbase=*/false, /*sigops_cost=*/4, lp));
 }
 
 static void RpcMempool(benchmark::Bench& bench)
 {
-    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(ChainType::MAIN);
-    auto& chainman = *testing_setup->m_node.chainman;
+    const auto testing_setup = MakeNoLogFileContext<const ChainTestingSetup>(ChainType::MAIN);
     CTxMemPool& pool = *Assert(testing_setup->m_node.mempool);
     LOCK2(cs_main, pool.cs);
 
@@ -40,7 +38,7 @@ static void RpcMempool(benchmark::Bench& bench)
     }
 
     bench.run([&] {
-        (void)MempoolToJSON(chainman, pool, /*verbose=*/true);
+        (void)MempoolToJSON(pool, /*verbose=*/true);
     });
 }
 
diff --git a/src/bench/sign_transaction.cpp b/src/bench/sign_transaction.cpp
index a6f9dd0c9b..6f28f581af 100644
--- a/src/bench/sign_transaction.cpp
+++ b/src/bench/sign_transaction.cpp
@@ -56,7 +56,7 @@ static void SignTransactionSingleInput(benchmark::Bench& bench, InputType input_
     bench.minEpochIterations(100).run([&] {
         CMutableTransaction tx{unsigned_tx};
         std::map<COutPoint, Coin> coins;
-        const CScript& prev_spk = prev_spks[(iter++) % prev_spks.size()];
+        CScript prev_spk = prev_spks[(iter++) % prev_spks.size()];
         coins[prevout] = Coin(CTxOut(10000, prev_spk), /*nHeightIn=*/100, /*fCoinBaseIn=*/false);
         std::map<int, bilingual_str> input_errors;
         bool complete = SignTransaction(tx, &keystore, coins, SIGHASH_ALL, input_errors);
diff --git a/src/bench/verify_script.cpp b/src/bench/verify_script.cpp
index 81139feb47..f38aa49a23 100644
--- a/src/bench/verify_script.cpp
+++ b/src/bench/verify_script.cpp
@@ -2,15 +2,8 @@
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
-#if defined(HAVE_CONFIG_H)
-#include <config/bitcoin-config.h>
-#endif
-
 #include <bench/bench.h>
 #include <key.h>
-#if defined(HAVE_CONSENSUS_LIB)
-#include <script/bitcoinconsensus.h>
-#endif
 #include <script/script.h>
 #include <script/interpreter.h>
 #include <streams.h>
@@ -63,17 +56,6 @@ static void VerifyScriptBench(benchmark::Bench& bench)
             &err);
         assert(err == SCRIPT_ERR_OK);
         assert(success);
-
-#if defined(HAVE_CONSENSUS_LIB)
-        DataStream stream;
-        stream << TX_WITH_WITNESS(txSpend);
-        int csuccess = bitcoinconsensus_verify_script_with_amount(
-            txCredit.vout[0].scriptPubKey.data(),
-            txCredit.vout[0].scriptPubKey.size(),
-            txCredit.vout[0].nValue,
-            (const unsigned char*)stream.data(), stream.size(), 0, flags, nullptr);
-        assert(csuccess == 1);
-#endif
     });
 }
 
diff --git a/src/bitcoin-chainstate.cpp b/src/bitcoin-chainstate.cpp
index 44c3a1e8be..ebe013b638 100644
--- a/src/bitcoin-chainstate.cpp
+++ b/src/bitcoin-chainstate.cpp
@@ -87,7 +87,7 @@ int main(int argc, char* argv[])
         {
             std::cout << "Progress: " << title.original << ", " << progress_percent << ", " << resume_possible << std::endl;
         }
-        void warningSet(kernel::Warning id, const bilingual_str& message, bool update) override
+        void warningSet(kernel::Warning id, const bilingual_str& message) override
         {
             std::cout << "Warning " << static_cast<int>(id) << " set: " << message.original << std::endl;
         }
diff --git a/src/bitcoin-cli.cpp b/src/bitcoin-cli.cpp
index c98dee300e..934b5fb6dc 100644
--- a/src/bitcoin-cli.cpp
+++ b/src/bitcoin-cli.cpp
@@ -11,7 +11,6 @@
 #include <common/system.h>
 #include <compat/compat.h>
 #include <compat/stdin.h>
-#include <consensus/amount.h>
 #include <policy/feerate.h>
 #include <rpc/client.h>
 #include <rpc/mining.h>
@@ -58,7 +57,6 @@ static const int DEFAULT_HTTP_CLIENT_TIMEOUT=900;
 static constexpr int DEFAULT_WAIT_CLIENT_TIMEOUT = 0;
 static const bool DEFAULT_NAMED=false;
 static const int CONTINUE_EXECUTION=-1;
-static constexpr uint8_t NETINFO_MAX_LEVEL{4};
 static constexpr int8_t UNKNOWN_NETWORK{-1};
 // See GetNetworkName() in netbase.cpp
 static constexpr std::array NETWORKS{"not_publicly_routable", "ipv4", "ipv6", "onion", "i2p", "cjdns", "internal"};
@@ -83,7 +81,6 @@ static void SetupCliArgs(ArgsManager& argsman)
 
     argsman.AddArg("-version", "Print version and exit", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
     argsman.AddArg("-conf=<file>", strprintf("Specify configuration file. Relative paths will be prefixed by datadir location. (default: %s)", BITCOIN_CONF_FILENAME), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
-    argsman.AddArg("-confrw=<file>", strprintf("Specify read/write configuration file. Relative paths will be prefixed by the network-specific datadir location. (default: %s)", BITCOIN_RW_CONF_FILENAME), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
     argsman.AddArg("-datadir=<dir>", "Specify data directory", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
     argsman.AddArg("-generate",
                    strprintf("Generate blocks, equivalent to RPC getnewaddress followed by RPC generatetoaddress. Optional positional integer "
@@ -92,11 +89,11 @@ static void SetupCliArgs(ArgsManager& argsman)
                              DEFAULT_NBLOCKS, DEFAULT_MAX_TRIES),
                    ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
     argsman.AddArg("-addrinfo", "Get the number of addresses known to the node, per network and total, after filtering for quality and recency. The total number of addresses known to the node may be higher.", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
-    argsman.AddArg("-getinfo", "Get general information from the remote server, including the total balance and the balances of each loaded wallet when in multiwallet mode. Note that -getinfo is the combined result of several RPCs (getnetworkinfo, getblockchaininfo, getwalletinfo, getbalances, and in multiwallet mode, listwallets), each with potentially different state.", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
-    argsman.AddArg("-netinfo", strprintf("Get network peer connection information from the remote server. An optional argument from 0 to %d can be passed for different peers listings (default: 0). If a non-zero value is passed, an additional \"outonly\" (or \"o\") argument can be passed to see outbound peers only. Pass \"help\" (or \"h\") for detailed help documentation.", NETINFO_MAX_LEVEL), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
+    argsman.AddArg("-getinfo", "Get general information from the remote server. Note that unlike server-side RPC calls, the output of -getinfo is the result of multiple non-atomic requests. Some entries in the output may represent results from different states (e.g. wallet balance may be as of a different block from the chain state reported)", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
+    argsman.AddArg("-netinfo", "Get network peer connection information from the remote server. An optional integer argument from 0 to 4 can be passed for different peers listings (default: 0). Pass \"help\" for detailed help documentation.", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
 
     SetupChainParamsBaseOptions(argsman);
-    argsman.AddArg("-color=<when>", strprintf("Color setting for CLI output (default: %s). Valid values: always, auto (add color codes when standard output is connected to a terminal and OS is not WIN32), never. Only applies to the output of -getinfo.", DEFAULT_COLOR_SETTING), ArgsManager::ALLOW_ANY | ArgsManager::DISALLOW_NEGATION, OptionsCategory::OPTIONS);
+    argsman.AddArg("-color=<when>", strprintf("Color setting for CLI output (default: %s). Valid values: always, auto (add color codes when standard output is connected to a terminal and OS is not WIN32), never.", DEFAULT_COLOR_SETTING), ArgsManager::ALLOW_ANY | ArgsManager::DISALLOW_NEGATION, OptionsCategory::OPTIONS);
     argsman.AddArg("-named", strprintf("Pass named instead of positional arguments (default: %s)", DEFAULT_NAMED), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
     argsman.AddArg("-rpcclienttimeout=<n>", strprintf("Timeout in seconds during HTTP requests, or 0 for no timeout. (default: %d)", DEFAULT_HTTP_CLIENT_TIMEOUT), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
     argsman.AddArg("-rpcconnect=<ip>", strprintf("Send commands to node running on <ip> (default: %s)", DEFAULT_RPCCONNECT), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
@@ -147,23 +144,17 @@ static int AppInitRPC(int argc, char* argv[])
         tfm::format(std::cerr, "Error parsing command line arguments: %s\n", error);
         return EXIT_FAILURE;
     }
-    if (argc < 2 || HelpRequested(gArgs) || gArgs.GetBoolArg("-version", false)) {
+    if (argc < 2 || HelpRequested(gArgs) || gArgs.IsArgSet("-version")) {
         std::string strUsage = PACKAGE_NAME " RPC client version " + FormatFullVersion() + "\n";
 
-        if (gArgs.GetBoolArg("-version", false)) {
+        if (gArgs.IsArgSet("-version")) {
             strUsage += FormatParagraph(LicenseInfo());
         } else {
             strUsage += "\n"
-                "The bitcoin-cli utility provides a command line interface to interact with a bitcoind/bitcoin-qt RPC server.\n"
-                "\nIt can be used to query network information, manage wallets, create or broadcast transactions, and control the bitcoind server.\n"
-                "\nUse the \"help\" command to list all commands. Use \"help <command>\" to show help for that command.\n"
-                "The -named option allows you to specify parameters using the key=value format, eliminating the need to pass unused positional parameters.\n"
-                "\n"
-                "Usage: bitcoin-cli [options] <command> [params]\n"
-                "or:    bitcoin-cli [options] -named <command> [name=value]...\n"
-                "or:    bitcoin-cli [options] help\n"
-                "or:    bitcoin-cli [options] help <command>\n"
-                "\n";
+                "Usage:  bitcoin-cli [options] <command> [params]  Send command to " PACKAGE_NAME "\n"
+                "or:     bitcoin-cli [options] -named <command> [name=value]...  Send command to " PACKAGE_NAME " (with named arguments)\n"
+                "or:     bitcoin-cli [options] help                List commands\n"
+                "or:     bitcoin-cli [options] help <command>      Get help for a command\n";
             strUsage += "\n" + gArgs.GetHelpMessage();
         }
 
@@ -182,6 +173,13 @@ static int AppInitRPC(int argc, char* argv[])
         tfm::format(std::cerr, "Error reading configuration file: %s\n", error);
         return EXIT_FAILURE;
     }
+    // Check for chain settings (BaseParams() calls are only valid after this clause)
+    try {
+        SelectBaseParams(gArgs.GetChainType());
+    } catch (const std::exception& e) {
+        tfm::format(std::cerr, "Error: %s\n", e.what());
+        return EXIT_FAILURE;
+    }
     return CONTINUE_EXECUTION;
 }
 
@@ -285,7 +283,7 @@ public:
         if (!reply["error"].isNull()) return reply;
         const std::vector<UniValue>& nodes{reply["result"].getValues()};
         if (!nodes.empty() && nodes.at(0)["network"].isNull()) {
-            throw std::runtime_error("-addrinfo requires bitcoind server to be running v0.21.1.knots or newer");
+            throw std::runtime_error("-addrinfo requires bitcoind server to be running v22.0 and up");
         }
         // Count the number of peers known to our node, by network.
         std::array<uint64_t, NETWORKS.size()> counts{{}};
@@ -381,6 +379,7 @@ public:
 class NetinfoRequestHandler : public BaseRequestHandler
 {
 private:
+    static constexpr uint8_t MAX_DETAIL_LEVEL{4};
     std::array<std::array<uint16_t, NETWORKS.size() + 1>, 3> m_counts{{{}}}; //!< Peer counts by (in/out/total, networks/total)
     uint8_t m_block_relay_peers_count{0};
     uint8_t m_manual_peers_count{0};
@@ -395,21 +394,18 @@ private:
     bool DetailsRequested() const { return m_details_level > 0 && m_details_level < 5; }
     bool IsAddressSelected() const { return m_details_level == 2 || m_details_level == 4; }
     bool IsVersionSelected() const { return m_details_level == 3 || m_details_level == 4; }
-    bool m_outbound_only_selected{false};
     bool m_is_asmap_on{false};
     size_t m_max_addr_length{0};
     size_t m_max_addr_processed_length{5};
     size_t m_max_addr_rate_limited_length{6};
     size_t m_max_age_length{5};
     size_t m_max_id_length{2};
-    size_t m_max_services_length{6};
     struct Peer {
         std::string addr;
         std::string sub_version;
         std::string conn_type;
         std::string network;
         std::string age;
-        std::string services;
         std::string transport_protocol_type;
         double min_ping;
         double ping;
@@ -460,25 +456,6 @@ private:
         if (conn_type == "addr-fetch") return "addr";
         return "";
     }
-    std::string FormatServices(const UniValue& services)
-    {
-        std::string str;
-        for (size_t i = 0; i < services.size(); ++i) {
-            const std::string s{services[i].get_str()};
-            str += s == "NETWORK_LIMITED" ? 'l' : s == "P2P_V2" ? '2' : ToLower(s[0]);
-        }
-        return str;
-    }
-    std::string ServicesList(const UniValue& services)
-    {
-        std::vector<std::string> v;
-        for (size_t i = 0; i < services.size(); ++i) {
-            std::string s{ToLower((services[i].get_str()))};
-            std::ranges::replace(s, '_', ' ');
-            v.push_back(s);
-        }
-        return Join(v, ", ");
-    }
 
 public:
     static constexpr int ID_PEERINFO = 0;
@@ -489,18 +466,9 @@ public:
         if (!args.empty()) {
             uint8_t n{0};
             if (ParseUInt8(args.at(0), &n)) {
-                m_details_level = std::min(n, NETINFO_MAX_LEVEL);
+                m_details_level = std::min(n, MAX_DETAIL_LEVEL);
             } else {
-                throw std::runtime_error(strprintf("invalid -netinfo level argument: %s\nFor more information, run: bitcoin-cli -netinfo help", args.at(0)));
-            }
-            if (args.size() > 1) {
-                if (std::string_view s{args.at(1)}; n && (s == "o" || s == "outonly")) {
-                    m_outbound_only_selected = true;
-                } else if (n) {
-                    throw std::runtime_error(strprintf("invalid -netinfo outonly argument: %s\nFor more information, run: bitcoin-cli -netinfo help", s));
-                } else {
-                    throw std::runtime_error(strprintf("invalid -netinfo outonly argument: %s\nThe outonly argument is only valid for a level greater than 0 (the first argument). For more information, run: bitcoin-cli -netinfo help", s));
-                }
+                throw std::runtime_error(strprintf("invalid -netinfo argument: %s\nFor more information, run: bitcoin-cli -netinfo help", args.at(0)));
             }
         }
         UniValue result(UniValue::VARR);
@@ -535,7 +503,6 @@ public:
             ++m_counts.at(2).at(NETWORKS.size());           // total overall
             if (conn_type == "block-relay-only") ++m_block_relay_peers_count;
             if (conn_type == "manual") ++m_manual_peers_count;
-            if (m_outbound_only_selected && !is_outbound) continue;
             if (DetailsRequested()) {
                 // Push data for this peer to the peers vector.
                 const int peer_id{peer["id"].getInt<int>()};
@@ -552,32 +519,28 @@ public:
                 const double ping{peer["pingtime"].isNull() ? -1 : peer["pingtime"].get_real()};
                 const std::string addr{peer["addr"].get_str()};
                 const std::string age{conn_time == 0 ? "" : ToString((time_now - conn_time) / 60)};
-                const std::string services{FormatServices(peer["servicesnames"])};
                 const std::string sub_version{peer["subver"].get_str()};
                 const std::string transport{peer["transport_protocol_type"].isNull() ? "v1" : peer["transport_protocol_type"].get_str()};
                 const bool is_addr_relay_enabled{peer["addr_relay_enabled"].isNull() ? false : peer["addr_relay_enabled"].get_bool()};
                 const bool is_bip152_hb_from{peer["bip152_hb_from"].get_bool()};
                 const bool is_bip152_hb_to{peer["bip152_hb_to"].get_bool()};
-                m_peers.push_back({addr, sub_version, conn_type, NETWORK_SHORT_NAMES[network_id], age, services, transport, min_ping, ping, addr_processed, addr_rate_limited, last_blck, last_recv, last_send, last_trxn, peer_id, mapped_as, version, is_addr_relay_enabled, is_bip152_hb_from, is_bip152_hb_to, is_outbound, is_tx_relay});
+                m_peers.push_back({addr, sub_version, conn_type, NETWORK_SHORT_NAMES[network_id], age, transport, min_ping, ping, addr_processed, addr_rate_limited, last_blck, last_recv, last_send, last_trxn, peer_id, mapped_as, version, is_addr_relay_enabled, is_bip152_hb_from, is_bip152_hb_to, is_outbound, is_tx_relay});
                 m_max_addr_length = std::max(addr.length() + 1, m_max_addr_length);
                 m_max_addr_processed_length = std::max(ToString(addr_processed).length(), m_max_addr_processed_length);
                 m_max_addr_rate_limited_length = std::max(ToString(addr_rate_limited).length(), m_max_addr_rate_limited_length);
                 m_max_age_length = std::max(age.length(), m_max_age_length);
                 m_max_id_length = std::max(ToString(peer_id).length(), m_max_id_length);
-                m_max_services_length = std::max(services.length(), m_max_services_length);
                 m_is_asmap_on |= (mapped_as != 0);
             }
         }
 
         // Generate report header.
-        const std::string_view services{DetailsRequested() ? strprintf(" - services %s", FormatServices(networkinfo["localservicesnames"])) : ""};
-        std::string result{strprintf("%s client %s%s - server %i%s%s\n\n", PACKAGE_NAME, FormatFullVersion(), ChainToString(), networkinfo["protocolversion"].getInt<int>(), networkinfo["subversion"].get_str(), services)};
+        std::string result{strprintf("%s client %s%s - server %i%s\n\n", PACKAGE_NAME, FormatFullVersion(), ChainToString(), networkinfo["protocolversion"].getInt<int>(), networkinfo["subversion"].get_str())};
 
         // Report detailed peer connections list sorted by direction and minimum ping time.
         if (DetailsRequested() && !m_peers.empty()) {
             std::sort(m_peers.begin(), m_peers.end());
-            result += strprintf("<->   type   net %*s  v  mping   ping send recv  txn  blk  hb %*s%*s%*s ",
-                                m_max_services_length, "serv",
+            result += strprintf("<->   type   net  v  mping   ping send recv  txn  blk  hb %*s%*s%*s ",
                                 m_max_addr_processed_length, "addrp",
                                 m_max_addr_rate_limited_length, "addrl",
                                 m_max_age_length, "age");
@@ -586,12 +549,10 @@ public:
             for (const Peer& peer : m_peers) {
                 std::string version{ToString(peer.version) + peer.sub_version};
                 result += strprintf(
-                    "%3s %6s %5s %*s %2s%7s%7s%5s%5s%5s%5s  %2s %*s%*s%*s%*i %*s %-*s%s\n",
+                    "%3s %6s %5s %2s%7s%7s%5s%5s%5s%5s  %2s %*s%*s%*s%*i %*s %-*s%s\n",
                     peer.is_outbound ? "out" : "in",
                     ConnectionTypeForNetinfo(peer.conn_type),
                     peer.network,
-                    m_max_services_length, // variable spacing
-                    peer.services,
                     (peer.transport_protocol_type.size() == 2 && peer.transport_protocol_type[0] == 'v') ? peer.transport_protocol_type[1] : ' ',
                     PingTimeToString(peer.min_ping),
                     PingTimeToString(peer.ping),
@@ -614,7 +575,7 @@ public:
                     IsAddressSelected() ? peer.addr : "",
                     IsVersionSelected() && version != "0" ? version : "");
             }
-            result += strprintf("                %*s         ms     ms  sec  sec  min  min                %*s\n\n", m_max_services_length, "", m_max_age_length, "min");
+            result += strprintf("                        ms     ms  sec  sec  min  min                %*s\n\n", m_max_age_length, "min");
         }
 
         // Report peer connection totals by type.
@@ -653,9 +614,6 @@ public:
         }
 
         // Report local addresses, ports, and scores.
-        if (!DetailsRequested()) {
-            result += strprintf("\n\nLocal services: %s", ServicesList(networkinfo["localservicesnames"]));
-        }
         result += "\n\nLocal addresses";
         const std::vector<UniValue>& local_addrs{networkinfo["localaddresses"].getValues()};
         if (local_addrs.empty()) {
@@ -674,28 +632,25 @@ public:
     }
 
     const std::string m_help_doc{
-        "-netinfo (level [outonly]) | help\n\n"
+        "-netinfo level|\"help\" \n\n"
         "Returns a network peer connections dashboard with information from the remote server.\n"
         "This human-readable interface will change regularly and is not intended to be a stable API.\n"
         "Under the hood, -netinfo fetches the data by calling getpeerinfo and getnetworkinfo.\n"
-        + strprintf("An optional argument from 0 to %d can be passed for different peers listings; values above %d up to 255 are parsed as %d.\n", NETINFO_MAX_LEVEL, NETINFO_MAX_LEVEL, NETINFO_MAX_LEVEL) +
-        "If that argument is passed, an optional additional \"outonly\" argument may be passed to obtain the listing with outbound peers only.\n"
-        "Pass \"help\" or \"h\" to see this detailed help documentation.\n"
-        "If more than two arguments are passed, only the first two are read and parsed.\n"
-        "Suggestion: use -netinfo with the Linux watch(1) command for a live dashboard; see example below.\n\n"
+        + strprintf("An optional integer argument from 0 to %d can be passed for different peers listings; %d to 255 are parsed as %d.\n", MAX_DETAIL_LEVEL, MAX_DETAIL_LEVEL, MAX_DETAIL_LEVEL) +
+        "Pass \"help\" to see this detailed help documentation.\n"
+        "If more than one argument is passed, only the first one is read and parsed.\n"
+        "Suggestion: use with the Linux watch(1) command for a live dashboard; see example below.\n\n"
         "Arguments:\n"
-        + strprintf("1. level (integer 0-%d, optional)  Specify the info level of the peers dashboard (default 0):\n", NETINFO_MAX_LEVEL) +
+        + strprintf("1. level (integer 0-%d, optional)  Specify the info level of the peers dashboard (default 0):\n", MAX_DETAIL_LEVEL) +
         "                                  0 - Peer counts for each reachable network as well as for block relay peers\n"
         "                                      and manual peers, and the list of local addresses and ports\n"
         "                                  1 - Like 0 but preceded by a peers listing (without address and version columns)\n"
         "                                  2 - Like 1 but with an address column\n"
         "                                  3 - Like 1 but with a version column\n"
         "                                  4 - Like 1 but with both address and version columns\n"
-        "2. outonly (\"outonly\" or \"o\", optional) Return the peers listing with outbound peers only, i.e. to save screen space\n"
-        "                                        when a node has many inbound peers. Only valid if a level is passed.\n\n"
-        "help (\"help\" or \"h\", optional) Print this help documentation instead of the dashboard.\n\n"
+        "2. help (string \"help\", optional) Print this help documentation instead of the dashboard.\n\n"
         "Result:\n\n"
-        + strprintf("* The peers listing in levels 1-%d displays all of the peers sorted by direction and minimum ping time:\n\n", NETINFO_MAX_LEVEL) +
+        + strprintf("* The peers listing in levels 1-%d displays all of the peers sorted by direction and minimum ping time:\n\n", MAX_DETAIL_LEVEL) +
         "  Column   Description\n"
         "  ------   -----------\n"
         "  <->      Direction\n"
@@ -708,31 +663,22 @@ public:
         "           \"feeler\" - short-lived connection for testing addresses\n"
         "           \"addr\"   - address fetch; short-lived connection for requesting addresses\n"
         "  net      Network the peer connected through (\"ipv4\", \"ipv6\", \"onion\", \"i2p\", \"cjdns\", or \"npr\" (not publicly routable))\n"
-        "  serv     Services offered by the peer\n"
-        "           \"n\" - NETWORK: peer can serve the full block chain\n"
-        "           \"b\" - BLOOM: peer can handle bloom-filtered connections (see BIP 111)\n"
-        "           \"w\" - WITNESS: peer can be asked for blocks and transactions with witness data (SegWit)\n"
-        "           \"c\" - COMPACT_FILTERS: peer can handle basic block filter requests (see BIPs 157 and 158)\n"
-        "           \"l\" - NETWORK_LIMITED: peer limited to serving only the last 288 blocks (~2 days)\n"
-        "           \"2\" - P2P_V2: peer supports version 2 P2P transport protocol, as defined in BIP 324\n"
-        "           \"r\" - REPLACE_BY_FEE? peer supports replacement of transactions without BIP 125 signalling\n"
-        "           \"u\" - UNKNOWN: unrecognized bit flag\n"
         "  v        Version of transport protocol used for the connection\n"
         "  mping    Minimum observed ping time, in milliseconds (ms)\n"
         "  ping     Last observed ping time, in milliseconds (ms)\n"
         "  send     Time since last message sent to the peer, in seconds\n"
         "  recv     Time since last message received from the peer, in seconds\n"
         "  txn      Time since last novel transaction received from the peer and accepted into our mempool, in minutes\n"
-        "           \"*\" - we do not relay transactions to this peer (getpeerinfo \"relaytxes\" is false)\n"
+        "           \"*\" - we do not relay transactions to this peer (relaytxes is false)\n"
         "  blk      Time since last novel block passing initial validity checks received from the peer, in minutes\n"
         "  hb       High-bandwidth BIP152 compact block relay\n"
         "           \".\" (to)   - we selected the peer as a high-bandwidth peer\n"
         "           \"*\" (from) - the peer selected us as a high-bandwidth peer\n"
         "  addrp    Total number of addresses processed, excluding those dropped due to rate limiting\n"
-        "           \".\" - we do not relay addresses to this peer (getpeerinfo \"addr_relay_enabled\" is false)\n"
+        "           \".\" - we do not relay addresses to this peer (addr_relay_enabled is false)\n"
         "  addrl    Total number of addresses dropped due to rate limiting\n"
         "  age      Duration of connection to the peer, in minutes\n"
-        "  asmap    Mapped AS (Autonomous System) number at the end of the BGP route to the peer, used for diversifying\n"
+        "  asmap    Mapped AS (Autonomous System) number in the BGP route to the peer, used for diversifying\n"
         "           peer selection (only displayed if the -asmap config option is set)\n"
         "  id       Peer index, in increasing order of peer connections since node startup\n"
         "  address  IP address and port of the peer\n"
@@ -746,11 +692,9 @@ public:
         "The same, preceded by a peers listing without address and version columns\n"
         "> bitcoin-cli -netinfo 1\n\n"
         "Full dashboard\n"
-        + strprintf("> bitcoin-cli -netinfo %d\n\n", NETINFO_MAX_LEVEL) +
-        "Full dashboard, but with outbound peers only\n"
-        + strprintf("> bitcoin-cli -netinfo %d outonly\n\n", NETINFO_MAX_LEVEL) +
+        + strprintf("> bitcoin-cli -netinfo %d\n\n", MAX_DETAIL_LEVEL) +
         "Full live dashboard, adjust --interval or --no-title as needed (Linux)\n"
-        + strprintf("> watch --interval 1 --no-title bitcoin-cli -netinfo %d\n\n", NETINFO_MAX_LEVEL) +
+        + strprintf("> watch --interval 1 --no-title bitcoin-cli -netinfo %d\n\n", MAX_DETAIL_LEVEL) +
         "See this help\n"
         "> bitcoin-cli -netinfo help\n"};
 };
@@ -1006,8 +950,7 @@ static void ParseError(const UniValue& error, std::string& strPrint, int& nRet)
             strPrint += ("error message:\n" + err_msg.get_str());
         }
         if (err_code.isNum() && err_code.getInt<int>() == RPC_WALLET_NOT_SPECIFIED) {
-            strPrint += " Or for the CLI, specify the \"-rpcwallet=<walletname>\" option before the command";
-            strPrint += " (run \"bitcoin-cli -h\" for help or \"bitcoin-cli listwallets\" to see which wallets are currently loaded).";
+            strPrint += "\nTry adding \"-rpcwallet=<filename>\" option to bitcoin-cli command line.";
         }
     } else {
         strPrint = "error: " + error.write();
@@ -1015,29 +958,9 @@ static void ParseError(const UniValue& error, std::string& strPrint, int& nRet)
     nRet = abs(error["code"].getInt<int>());
 }
 
-static CAmount AmountFromValue(const UniValue& value)
-{
-    CAmount amount{0};
-    if (!ParseFixedPoint(value.getValStr(), 8, &amount))
-        throw std::runtime_error("Invalid amount");
-    if (!MoneyRange(amount))
-        throw std::runtime_error("Amount out of range");
-    return amount;
-}
-
-static UniValue ValueFromAmount(const CAmount& amount)
-{
-    bool sign{amount < 0};
-    int64_t n_abs{sign ? -amount : amount};
-    int64_t quotient{n_abs / COIN};
-    int64_t remainder{n_abs % COIN};
-    return UniValue(UniValue::VNUM, strprintf("%s%d.%08d", sign ? "-" : "", quotient, remainder));
-}
-
 /**
- * GetWalletBalances calls listwallets; if more than one wallet is loaded, it
- * then fetches mine.trusted balances for each loaded wallet and pushes all the
- * balances, followed by the total balance, to `result`.
+ * GetWalletBalances calls listwallets; if more than one wallet is loaded, it then
+ * fetches mine.trusted balances for each loaded wallet and pushes them to `result`.
  *
  * @param result  Reference to UniValue object the wallet names and balances are pushed to.
  */
@@ -1050,17 +973,13 @@ static void GetWalletBalances(UniValue& result)
     if (wallets.size() <= 1) return;
 
     UniValue balances(UniValue::VOBJ);
-    CAmount total_balance{0};
     for (const UniValue& wallet : wallets.getValues()) {
         const std::string& wallet_name = wallet.get_str();
         const UniValue getbalances = ConnectAndCallRPC(&rh, "getbalances", /* args=*/{}, wallet_name);
-        if (!getbalances.find_value("error").isNull()) continue;
         const UniValue& balance = getbalances.find_value("result")["mine"]["trusted"];
-        total_balance += AmountFromValue(balance);
         balances.pushKV(wallet_name, balance);
     }
     result.pushKV("balances", std::move(balances));
-    result.pushKV("total_balance", ValueFromAmount(total_balance));
 }
 
 /**
@@ -1203,7 +1122,6 @@ static void ParseGetInfoResult(UniValue& result)
                                        wallet.empty() ? "\"\"" : wallet);
         }
         result_string += "\n";
-        result_string += strprintf("%sTotal balance:%s %s\n\n", CYAN, RESET, result["total_balance"].getValStr());
     }
 
     const std::string warnings{result["warnings"].getValStr()};
@@ -1294,20 +1212,12 @@ static int CommandLineRPC(int argc, char *argv[])
                 fputc('\n', stdout);
             }
         }
-        int nRh = 0;
-        if (gArgs.IsArgSet("-getinfo")) nRh++;
-        if (gArgs.GetBoolArg("-netinfo", false)) nRh++;
-        if (gArgs.GetBoolArg("-generate", false)) nRh++;
-        if (gArgs.GetBoolArg("-addrinfo", false)) nRh++;
-        if (nRh > 1) {
-            throw std::runtime_error("Only one of \"-getinfo\", \"-netinfo\", \"-generate\", and \"-addrinfo\" may be specified.");
-        }
         std::unique_ptr<BaseRequestHandler> rh;
         std::string method;
-        if (gArgs.GetBoolArg("-getinfo", false)) {
+        if (gArgs.IsArgSet("-getinfo")) {
             rh.reset(new GetinfoRequestHandler());
         } else if (gArgs.GetBoolArg("-netinfo", false)) {
-            if (!args.empty() && (args.at(0) == "h" || args.at(0) == "help")) {
+            if (!args.empty() && args.at(0) == "help") {
                 tfm::format(std::cout, "%s\n", NetinfoRequestHandler().m_help_doc);
                 return 0;
             }
diff --git a/src/bitcoin-tx.cpp b/src/bitcoin-tx.cpp
index d93b69118e..89c03c1647 100644
--- a/src/bitcoin-tx.cpp
+++ b/src/bitcoin-tx.cpp
@@ -105,19 +105,16 @@ static int AppInitRawTx(int argc, char* argv[])
 
     fCreateBlank = gArgs.GetBoolArg("-create", false);
 
-    if (argc < 2 || HelpRequested(gArgs) || gArgs.GetBoolArg("-version", false)) {
+    if (argc < 2 || HelpRequested(gArgs) || gArgs.IsArgSet("-version")) {
         // First part of help message is specific to this utility
         std::string strUsage = PACKAGE_NAME " bitcoin-tx utility version " + FormatFullVersion() + "\n";
 
-        if (gArgs.GetBoolArg("-version", false)) {
+        if (gArgs.IsArgSet("-version")) {
             strUsage += FormatParagraph(LicenseInfo());
         } else {
             strUsage += "\n"
-                "The bitcoin-tx tool is used for creating and modifying bitcoin transactions.\n\n"
-                "bitcoin-tx can be used with \"<hex-tx> [commands]\" to update a hex-encoded bitcoin transaction, or with \"-create [commands]\" to create a hex-encoded bitcoin transaction.\n"
-                "\n"
-                "Usage: bitcoin-tx [options] <hex-tx> [commands]\n"
-                "or:    bitcoin-tx [options] -create [commands]\n"
+                "Usage:  bitcoin-tx [options] <hex-tx> [commands]  Update hex-encoded bitcoin transaction\n"
+                "or:     bitcoin-tx [options] -create [commands]   Create hex-encoded bitcoin transaction\n"
                 "\n";
             strUsage += gArgs.GetHelpMessage();
         }
@@ -304,7 +301,7 @@ static void MutateTxAddOutAddr(CMutableTransaction& tx, const std::string& strIn
     CAmount value = ExtractAndValidateValue(vStrInputParts[0]);
 
     // extract and validate ADDRESS
-    const std::string& strAddr = vStrInputParts[1];
+    std::string strAddr = vStrInputParts[1];
     CTxDestination destination = DecodeDestination(strAddr);
     if (!IsValidDestination(destination)) {
         throw std::runtime_error("invalid TX output address");
@@ -337,7 +334,7 @@ static void MutateTxAddOutPubKey(CMutableTransaction& tx, const std::string& str
     bool bSegWit = false;
     bool bScriptHash = false;
     if (vStrInputParts.size() == 3) {
-        const std::string& flags = vStrInputParts[2];
+        std::string flags = vStrInputParts[2];
         bSegWit = (flags.find('W') != std::string::npos);
         bScriptHash = (flags.find('S') != std::string::npos);
     }
@@ -398,7 +395,7 @@ static void MutateTxAddOutMultiSig(CMutableTransaction& tx, const std::string& s
     bool bSegWit = false;
     bool bScriptHash = false;
     if (vStrInputParts.size() == numkeys + 4) {
-        const std::string& flags = vStrInputParts.back();
+        std::string flags = vStrInputParts.back();
         bSegWit = (flags.find('W') != std::string::npos);
         bScriptHash = (flags.find('S') != std::string::npos);
     }
@@ -473,14 +470,14 @@ static void MutateTxAddOutScript(CMutableTransaction& tx, const std::string& str
     CAmount value = ExtractAndValidateValue(vStrInputParts[0]);
 
     // extract and validate script
-    const std::string& strScript = vStrInputParts[1];
+    std::string strScript = vStrInputParts[1];
     CScript scriptPubKey = ParseScript(strScript);
 
     // Extract FLAGS
     bool bSegWit = false;
     bool bScriptHash = false;
     if (vStrInputParts.size() == 3) {
-        const std::string& flags = vStrInputParts.back();
+        std::string flags = vStrInputParts.back();
         bSegWit = (flags.find('W') != std::string::npos);
         bScriptHash = (flags.find('S') != std::string::npos);
     }
diff --git a/src/bitcoin-util.cpp b/src/bitcoin-util.cpp
index 777244c02e..c8f5bc5026 100644
--- a/src/bitcoin-util.cpp
+++ b/src/bitcoin-util.cpp
@@ -50,18 +50,15 @@ static int AppInitUtil(ArgsManager& args, int argc, char* argv[])
         return EXIT_FAILURE;
     }
 
-    if (HelpRequested(args) || args.GetBoolArg("-version", false)) {
+    if (HelpRequested(args) || args.IsArgSet("-version")) {
         // First part of help message is specific to this utility
         std::string strUsage = PACKAGE_NAME " bitcoin-util utility version " + FormatFullVersion() + "\n";
 
-        if (args.GetBoolArg("-version", false)) {
+        if (args.IsArgSet("-version")) {
             strUsage += FormatParagraph(LicenseInfo());
         } else {
             strUsage += "\n"
-                "The bitcoin-util tool provides bitcoin related functionality that does not rely on the ability to access a running node. Available [commands] are listed below.\n"
-                "\n"
-                "Usage:  bitcoin-util [options] [command]\n"
-                "or:     bitcoin-util [options] grind <hex-block-header>\n";
+                "Usage:  bitcoin-util [options] [commands]  Do stuff\n";
             strUsage += "\n" + args.GetHelpMessage();
         }
 
diff --git a/src/bitcoin-wallet.cpp b/src/bitcoin-wallet.cpp
index f97dcd5955..7d030abe97 100644
--- a/src/bitcoin-wallet.cpp
+++ b/src/bitcoin-wallet.cpp
@@ -49,7 +49,6 @@ static void SetupWalletToolArgs(ArgsManager& argsman)
     argsman.AddCommand("salvage", "Attempt to recover private keys from a corrupt wallet. Warning: 'salvage' is experimental.");
     argsman.AddCommand("dump", "Print out all of the wallet key-value records");
     argsman.AddCommand("createfromdump", "Create new wallet file from dumped records");
-    argsman.AddCommand("importfromcoldcard", "Create new wallet file and import descriptors from Coldcard wallet");
 }
 
 static std::optional<int> WalletAppInit(ArgsManager& args, int argc, char* argv[])
@@ -61,19 +60,18 @@ static std::optional<int> WalletAppInit(ArgsManager& args, int argc, char* argv[
         return EXIT_FAILURE;
     }
     const bool missing_args{argc < 2};
-    if (missing_args || HelpRequested(args) || args.GetBoolArg("-version", false)) {
-        std::string strUsage = strprintf("%s bitcoin-wallet utility version", PACKAGE_NAME) + " " + FormatFullVersion() + "\n";
+    if (missing_args || HelpRequested(args) || args.IsArgSet("-version")) {
+        std::string strUsage = strprintf("%s bitcoin-wallet version", PACKAGE_NAME) + " " + FormatFullVersion() + "\n";
 
-        if (args.GetBoolArg("-version", false)) {
+        if (args.IsArgSet("-version")) {
             strUsage += FormatParagraph(LicenseInfo());
         } else {
             strUsage += "\n"
-                "bitcoin-wallet is an offline tool for creating and interacting with " PACKAGE_NAME " wallet files.\n\n"
-                "By default bitcoin-wallet will act on wallets in the default mainnet wallet directory in the datadir.\n\n"
-                "To change the target wallet, use the -datadir, -wallet and -regtest / -signet / -testnet / -testnet4 arguments.\n"
-                "\n"
-                "Usage: bitcoin-wallet [options] <command>\n"
-                "\n";
+                        "bitcoin-wallet is an offline tool for creating and interacting with " PACKAGE_NAME " wallet files.\n"
+                        "By default bitcoin-wallet will act on wallets in the default mainnet wallet directory in the datadir.\n"
+                        "To change the target wallet, use the -datadir, -wallet and -regtest/-signet/-testnet/-testnet4 arguments.\n\n"
+                        "Usage:\n"
+                        "  bitcoin-wallet [options] <command>\n";
             strUsage += "\n" + args.GetHelpMessage();
         }
         tfm::format(std::cout, "%s", strUsage);
diff --git a/src/bitcoind.cpp b/src/bitcoind.cpp
index b8e67dccbc..a09bb5c9da 100644
--- a/src/bitcoind.cpp
+++ b/src/bitcoind.cpp
@@ -128,32 +128,19 @@ static bool ParseArgs(ArgsManager& args, int argc, char* argv[])
             return InitError(Untranslated(strprintf("Command line contains unexpected token '%s', see bitcoind -h for a list of options.", argv[i])));
         }
     }
-
-    g_software_expiry = args.GetIntArg("-softwareexpiry", DEFAULT_SOFTWARE_EXPIRY);
-    if (IsThisSoftwareExpired(GetTime())) {
-        tfm::format(std::cerr, "This software is expired, and may be out of consensus. You must choose to upgrade or override this expiration.\n");
-        exit(EXIT_FAILURE);
-    }
-
     return true;
 }
 
 static bool ProcessInitCommands(ArgsManager& args)
 {
     // Process help and version before taking care about datadir
-    if (HelpRequested(args) || args.GetBoolArg("-version", false)) {
-        std::string strUsage = PACKAGE_NAME " daemon version " + FormatFullVersion() + "\n";
+    if (HelpRequested(args) || args.IsArgSet("-version")) {
+        std::string strUsage = PACKAGE_NAME " version " + FormatFullVersion() + "\n";
 
-        if (args.GetBoolArg("-version", false)) {
+        if (args.IsArgSet("-version")) {
             strUsage += FormatParagraph(LicenseInfo());
         } else {
-            strUsage += "\n"
-                "The " PACKAGE_NAME " daemon (bitcoind) is a headless program that connects to the Bitcoin network to validate and relay transactions and blocks, as well as relaying addresses.\n\n"
-                "It provides the backbone of the Bitcoin network and its RPC, REST and ZMQ services can provide various transaction, block and address-related services.\n\n"
-                "There is an optional wallet component which provides cutting-edge transaction services.\n\n"
-                "It can be used in a headless environment or as part of a server setup.\n"
-                "\n"
-                "Usage: bitcoind [options]\n"
+            strUsage += "\nUsage:  bitcoind [options]                     Start " PACKAGE_NAME "\n"
                 "\n";
             strUsage += args.GetHelpMessage();
         }
diff --git a/src/blockfilter.cpp b/src/blockfilter.cpp
index 53e5c16321..5e6702ccc3 100644
--- a/src/blockfilter.cpp
+++ b/src/blockfilter.cpp
@@ -10,7 +10,6 @@
 #include <hash.h>
 #include <primitives/block.h>
 #include <primitives/transaction.h>
-#include <script/interpreter.h>
 #include <script/script.h>
 #include <streams.h>
 #include <undo.h>
@@ -21,7 +20,6 @@ using util::Join;
 
 static const std::map<BlockFilterType, std::string> g_filter_types = {
     {BlockFilterType::BASIC, "basic"},
-    {BlockFilterType::V0, "v0"},
 };
 
 uint64_t GCSFilter::HashToRange(const Element& element) const
@@ -184,10 +182,8 @@ const std::string& ListBlockFilterTypes()
     return type_list;
 }
 
-static GCSFilter::ElementSet BuildFilterElements(const CBlock& block,
-                                                 const CBlockUndo& block_undo,
-                                                 bool only_segwit = false,
-                                                 int witness_version = 0)
+static GCSFilter::ElementSet BasicFilterElements(const CBlock& block,
+                                                 const CBlockUndo& block_undo)
 {
     GCSFilter::ElementSet elements;
 
@@ -195,13 +191,6 @@ static GCSFilter::ElementSet BuildFilterElements(const CBlock& block,
         for (const CTxOut& txout : tx->vout) {
             const CScript& script = txout.scriptPubKey;
             if (script.empty() || script[0] == OP_RETURN) continue;
-            if (only_segwit) {
-                int witnessversion;
-                std::vector<unsigned char> witnessprogram;
-                if (!script.IsWitnessProgram(witnessversion, witnessprogram)) continue;
-                if (witnessversion != witness_version) continue;
-                if (!(witnessversion == 0 && (witnessprogram.size() == WITNESS_V0_KEYHASH_SIZE || witnessprogram.size() == WITNESS_V0_SCRIPTHASH_SIZE))) continue; // specific v0 checks
-            }
             elements.emplace(script.begin(), script.end());
         }
     }
@@ -210,13 +199,6 @@ static GCSFilter::ElementSet BuildFilterElements(const CBlock& block,
         for (const Coin& prevout : tx_undo.vprevout) {
             const CScript& script = prevout.out.scriptPubKey;
             if (script.empty()) continue;
-            if (only_segwit) {
-                int witnessversion;
-                std::vector<unsigned char> witnessprogram;
-                if (!script.IsWitnessProgram(witnessversion, witnessprogram)) continue;
-                if (witnessversion != witness_version) continue;
-                if (!(witnessversion == 0 && (witnessprogram.size() == WITNESS_V0_KEYHASH_SIZE || witnessprogram.size() == WITNESS_V0_SCRIPTHASH_SIZE))) continue; // specific v0 checks
-            }
             elements.emplace(script.begin(), script.end());
         }
     }
@@ -242,24 +224,13 @@ BlockFilter::BlockFilter(BlockFilterType filter_type, const CBlock& block, const
     if (!BuildParams(params)) {
         throw std::invalid_argument("unknown filter_type");
     }
-
-    switch (m_filter_type) {
-    case BlockFilterType::BASIC:
-        m_filter = GCSFilter(params, BuildFilterElements(block, block_undo));
-        break;
-    case BlockFilterType::V0:
-        m_filter = GCSFilter(params, BuildFilterElements(block, block_undo, true));
-        break;
-    case BlockFilterType::INVALID:
-        assert(false);
-    }
+    m_filter = GCSFilter(params, BasicFilterElements(block, block_undo));
 }
 
 bool BlockFilter::BuildParams(GCSFilter::Params& params) const
 {
     switch (m_filter_type) {
     case BlockFilterType::BASIC:
-    case BlockFilterType::V0:
         params.m_siphash_k0 = m_block_hash.GetUint64(0);
         params.m_siphash_k1 = m_block_hash.GetUint64(1);
         params.m_P = BASIC_FILTER_P;
diff --git a/src/blockfilter.h b/src/blockfilter.h
index fb3cbe3208..8eab4afa76 100644
--- a/src/blockfilter.h
+++ b/src/blockfilter.h
@@ -92,8 +92,6 @@ constexpr uint32_t BASIC_FILTER_M = 784931;
 enum class BlockFilterType : uint8_t
 {
     BASIC = 0,
-    // Filter 1 is reserved as an option to include all filters.
-    V0 = 2,
     INVALID = 255,
 };
 
diff --git a/src/chainparams.cpp b/src/chainparams.cpp
index bca1c4fd66..68319e8e8b 100644
--- a/src/chainparams.cpp
+++ b/src/chainparams.cpp
@@ -39,15 +39,6 @@ void ReadSigNetArgs(const ArgsManager& args, CChainParams::SigNetOptions& option
         }
         options.challenge.emplace(*val);
     }
-    if (const auto signetblocktime{args.GetIntArg("-signetblocktime")}) {
-        if (!args.IsArgSet("-signetchallenge")) {
-            throw std::runtime_error("-signetblocktime cannot be set without -signetchallenge");
-        }
-        if (*signetblocktime <= 0) {
-            throw std::runtime_error("-signetblocktime must be greater than 0");
-        }
-        options.pow_target_spacing = *signetblocktime;
-    }
 }
 
 void ReadRegTestArgs(const ArgsManager& args, CChainParams::RegTestOptions& options)
diff --git a/src/chainparamsbase.cpp b/src/chainparamsbase.cpp
index 69443d7d62..060d519d92 100644
--- a/src/chainparamsbase.cpp
+++ b/src/chainparamsbase.cpp
@@ -22,7 +22,6 @@ void SetupChainParamsBaseOptions(ArgsManager& argsman)
     argsman.AddArg("-vbparams=deployment:start:end[:min_activation_height]", "Use given start/end times and min_activation_height for specified version bits deployment (regtest-only)", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::CHAINPARAMS);
     argsman.AddArg("-signet", "Use the signet chain. Equivalent to -chain=signet. Note that the network is defined by the -signetchallenge parameter", ArgsManager::ALLOW_ANY, OptionsCategory::CHAINPARAMS);
     argsman.AddArg("-signetchallenge", "Blocks must satisfy the given script to be considered valid (only for signet networks; defaults to the global default signet test network challenge)", ArgsManager::ALLOW_ANY | ArgsManager::DISALLOW_NEGATION, OptionsCategory::CHAINPARAMS);
-    argsman.AddArg("-signetblocktime", "Difficulty adjustment will target a block time of the given amount in seconds (only for custom signet networks, must have -signetchallenge set; defaults to 10 minutes)", ArgsManager::ALLOW_ANY | ArgsManager::DISALLOW_NEGATION, OptionsCategory::CHAINPARAMS);
     argsman.AddArg("-signetseednode", "Specify a seed node for the signet network, in the hostname[:port] format, e.g. sig.net:1234 (may be used multiple times to specify multiple seed nodes; defaults to the global default signet test network seed node(s))", ArgsManager::ALLOW_ANY | ArgsManager::DISALLOW_NEGATION, OptionsCategory::CHAINPARAMS);
 }
 
diff --git a/src/checkqueue.h b/src/checkqueue.h
index 0e3e7365ac..a1de000714 100644
--- a/src/checkqueue.h
+++ b/src/checkqueue.h
@@ -182,7 +182,6 @@ public:
     }
 
     bool HasThreads() const { return !m_worker_threads.empty(); }
-    size_t ThreadCount() const { return m_worker_threads.size(); }
 };
 
 /**
diff --git a/src/clientversion.cpp b/src/clientversion.cpp
index 6bf7ef6406..e52703c8bf 100644
--- a/src/clientversion.cpp
+++ b/src/clientversion.cpp
@@ -64,15 +64,11 @@ std::string FormatFullVersion()
 /**
  * Format the subversion field according to BIP 14 spec (https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki)
  */
-std::string FormatSubVersion(const std::string& name, int nClientVersion, const std::vector<std::string>& comments, const bool base_name_only)
+std::string FormatSubVersion(const std::string& name, int nClientVersion, const std::vector<std::string>& comments)
 {
     std::string comments_str;
     if (!comments.empty()) comments_str = strprintf("(%s)", Join(comments, "; "));
-    std::string ua = strprintf("/%s:%s%s/", name, FormatVersion(nClientVersion), comments_str);
-    if (!base_name_only) {
-        ua += "Knots:20250305/";
-    }
-    return ua;
+    return strprintf("/%s:%s%s/", name, FormatVersion(nClientVersion), comments_str);
 }
 
 std::string CopyrightHolders(const std::string& strPrefix)
@@ -89,7 +85,7 @@ std::string CopyrightHolders(const std::string& strPrefix)
 
 std::string LicenseInfo()
 {
-    const std::string URL_SOURCE_CODE = "<https://github.com/bitcoinknots/bitcoin>";
+    const std::string URL_SOURCE_CODE = "<https://github.com/bitcoin/bitcoin>";
 
     return CopyrightHolders(strprintf(_("Copyright (C) %i-%i").translated, 2009, COPYRIGHT_YEAR) + " ") + "\n" +
            "\n" +
@@ -103,13 +99,3 @@ std::string LicenseInfo()
            strprintf(_("Distributed under the MIT software license, see the accompanying file %s or %s").translated, "COPYING", "<https://opensource.org/licenses/MIT>") +
            "\n";
 }
-
-int64_t g_software_expiry{DEFAULT_SOFTWARE_EXPIRY};
-
-bool IsThisSoftwareExpired(int64_t nTime)
-{
-    if (g_software_expiry <= 0) {
-        return false;
-    }
-    return (nTime > g_software_expiry);
-}
diff --git a/src/clientversion.h b/src/clientversion.h
index 0d3fd033a3..73aaf868e4 100644
--- a/src/clientversion.h
+++ b/src/clientversion.h
@@ -25,7 +25,6 @@
 
 #if !defined(WINDRES_PREPROC)
 
-#include <cstdint>
 #include <string>
 #include <vector>
 
@@ -38,21 +37,13 @@ extern const std::string CLIENT_NAME;
 
 
 std::string FormatFullVersion();
-std::string FormatSubVersion(const std::string& name, int nClientVersion, const std::vector<std::string>& comments, bool base_name_only = false);
+std::string FormatSubVersion(const std::string& name, int nClientVersion, const std::vector<std::string>& comments);
 
 std::string CopyrightHolders(const std::string& strPrefix);
 
 /** Returns licensing information (for -version) */
 std::string LicenseInfo();
 
-static constexpr int64_t SECONDS_PER_YEAR = 31558060;
-static constexpr int POSIX_EPOCH_YEAR = 1970;
-static constexpr int64_t DEFAULT_SOFTWARE_EXPIRY_OFFSET = 26784000;  // Around Nov 7
-static constexpr int64_t DEFAULT_SOFTWARE_EXPIRY = ((COPYRIGHT_YEAR - POSIX_EPOCH_YEAR) * SECONDS_PER_YEAR) + (SECONDS_PER_YEAR * 2) + DEFAULT_SOFTWARE_EXPIRY_OFFSET;
-extern int64_t g_software_expiry;
-
-bool IsThisSoftwareExpired(int64_t nTime);
-
 #endif // WINDRES_PREPROC
 
 #endif // BITCOIN_CLIENTVERSION_H
diff --git a/src/codex32.cpp b/src/codex32.cpp
deleted file mode 100644
index d5e8085e54..0000000000
--- a/src/codex32.cpp
+++ /dev/null
@@ -1,424 +0,0 @@
-// Copyright (c) 2017, 2021 Pieter Wuille
-// Copyright (c) 2021-2022 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#include <bech32.h>
-#include <codex32.h>
-#include <util/vector.h>
-
-#include <array>
-#include <assert.h>
-#include <numeric>
-#include <optional>
-
-namespace codex32
-{
-
-namespace
-{
-
-typedef bech32::internal::data data;
-
-// Build multiplication and logarithm tables for GF(32).
-//
-// We represent GF(32) as an extension of GF(2) by appending a root, alpha, of the
-// polynomial x^5 + x^3 + 1. All elements of GF(32) can be represented as degree-4
-// polynomials in alpha. So e.g. 1 is represented by 1, alpha by 2, alpha^2 by 4,
-// and so on.
-//
-// alpha is also a generator of the multiplicative group of the field. So every nonzero
-// element in GF(32) can be represented as alpha^i, for some i in {0, 1, ..., 31}.
-// This representation makes multiplication and division very easy, since it is just
-// addition and subtraction in the exponent.
-//
-// These tables allow converting from the normal binary representation of GF(32) elements
-// to the power-of-alpha one.
-constexpr std::pair<std::array<int8_t, 31>, std::array<int8_t, 32>> GenerateGF32Tables() {
-    // We use these tables to perform arithmetic in GF(32) below, when constructing the
-    // tables for GF(1024).
-    std::array<int8_t, 31> GF32_EXP{};
-    std::array<int8_t, 32> GF32_LOG{};
-
-    // fmod encodes the defining polynomial of GF(32) over GF(2), x^5 + x^3 + 1.
-    // Because coefficients in GF(2) are binary digits, the coefficients are packed as 101001.
-    const int fmod = 41;
-
-    // Elements of GF(32) are encoded as vectors of length 5 over GF(2), that is,
-    // 5 binary digits. Each element (b_4, b_3, b_2, b_1, b_0) encodes a polynomial
-    // b_4*x^4 + b_3*x^3 + b_2*x^2 + b_1*x^1 + b_0 (modulo fmod).
-    // For example, 00001 = 1 is the multiplicative identity.
-    GF32_EXP[0] = 1;
-    GF32_LOG[0] = -1;
-    GF32_LOG[1] = 0;
-    int v = 1;
-    for (int i = 1; i < 31; ++i) {
-        // Multiplication by x is the same as shifting left by 1, as
-        // every coefficient of the polynomial is moved up one place.
-        v = v << 1;
-        // If the polynomial now has an x^5 term, we subtract fmod from it
-        // to remain working modulo fmod. Subtraction is the same as XOR in characteristic
-        // 2 fields.
-        if (v & 32) v ^= fmod;
-        GF32_EXP[i] = v;
-        GF32_LOG[v] = i;
-    }
-
-    return std::make_pair(GF32_EXP, GF32_LOG);
-}
-
-constexpr auto tables32 = GenerateGF32Tables();
-constexpr const std::array<int8_t, 31>& GF32_EXP = tables32.first;
-constexpr const std::array<int8_t, 32>& GF32_LOG = tables32.second;
-
-uint8_t gf32_mul(uint8_t x, uint8_t y) {
-    if (x == 0 || y == 0) {
-        return 0;
-    }
-    return GF32_EXP[(GF32_LOG[x] + GF32_LOG[y]) % 31];
-}
-
-uint8_t gf32_div(uint8_t x, uint8_t y) {
-    assert(y != 0);
-    if (x == 0) {
-        return 0;
-    }
-    return GF32_EXP[(GF32_LOG[x] + 31 - GF32_LOG[y]) % 31];
-}
-
-// The bech32 string "secretshare32"
-constexpr const std::array<uint8_t, 13> CODEX32_M = {
-    16, 25, 24, 3, 25, 11, 16, 23, 29, 3, 25, 17, 10
-};
-
-// The bech32 string "secretshare32ex"
-constexpr const std::array<uint8_t, 15> CODEX32_LONG_M = {
-    16, 25, 24, 3, 25, 11, 16, 23, 29, 3, 25, 17, 10, 25, 6,
-};
-
-// The generator for the codex32 checksum, not including the leading x^13 term
-constexpr const std::array<uint8_t, 13> CODEX32_GEN = {
-    25, 27, 17, 8, 0, 25, 25, 25, 31, 27, 24, 16, 16,
-};
-
-// The generator for the long codex32 checksum, not including the leading x^15 term
-constexpr const std::array<uint8_t, 15> CODEX32_LONG_GEN = {
-    15, 10, 25, 26, 9, 25, 21, 6, 23, 21, 6, 5, 22, 4, 23,
-};
-
-/** This function will compute what 5-bit values to XOR into the last <checksum length>
- *  input values, in order to make the checksum 0. These values are returned in an array
- *  whose length is implied by the type of the generator polynomial (`CODEX32_GEN` or
- *  `CODEX32_LONG_GEN`) that is passed in. The result should be xored with the target
- *  residue ("secretshare32" or "secretshare32ex". */
-template <typename Residue>
-Residue PolyMod(const data& v, const Residue& gen)
-{
-    // The input is interpreted as a list of coefficients of a polynomial over F = GF(32),
-    // in the same way as in bech32. The block comment in bech32::<anonymous>::PolyMod
-    // provides more details.
-    //
-    // Unlike bech32, the output consists of 13 5-bit values, rather than 6, so they cannot
-    // be packed into a uint32_t, or even a uint64_t.
-    //
-    // Like bech32 we have a generator polynomial which defines the BCH code. For "short"
-    // strings, whose data part is 93 characters or less, we use
-    //     g(x) = x^13 + {25}x^12 + {27}x^11 + {17}x^10 + {8}x^9 + {0}x^8 + {25}x^7
-    //               + {25}x^6  + {25}x^5 + {31}x^4 + {27}x^3 + {24}x^2 + {16}x + {16}
-    //
-    // For long strings, whose data part is more than 93 characters, we use
-    //     g(x) = x^15 + {15}x^14 + {10}x^13 + {25}x^12 + {26}x^11 + {9}x^10
-    //               + {25}x^9 + {21}x^8 + {6}x^7 + {23}x^6 + {21}x^5 + {6}x^4
-    //               + {5}x^3  + {22}x^2 + {4}x^1 + {23}
-    //
-    // In both cases g is chosen in such a way that the resulting code is a BCH code which
-    // can detect up to 8 errors in a window of 93 characters. Unlike bech32, no further
-    // optimization was done to achieve more detection capability than the design parameters.
-    //
-    // For information about the {n} encoding of GF32 elements, see the block comment in
-    // bech32::<anonymous>::PolyMod.
-    Residue res{};
-    res[gen.size() - 1] = 1;
-    for (const auto v_i : v) {
-        // We want to update `res` to correspond to a polynomial with one extra term. That is,
-        // we first multiply it by x and add the next character, which is done by left-shifting
-        // the entire array and adding the next character to the open slot.
-        //
-        // We then reduce it module g, which involves taking the shifted-off character, multiplying
-        // it by g, and adding it to the result of the previous step. This makes sense because after
-        // multiplying by x, `res` has the same degree as g, so reduction by g simply requires
-        // dividing the most significant coefficient of `res` by the most significant coefficient of
-        // g (which is 1), then subtracting that multiple of g.
-        //
-        // Recall that we are working in a characteristic-2 field, so that subtraction is the same
-        // thing as addition.
-
-        // Multiply by x
-        uint8_t shift = res[0];
-        for (size_t i = 1; i < res.size(); ++i) {
-            res[i - 1] = res[i];
-        }
-        // Add the next value
-        res[res.size() - 1] = v_i;
-        // Reduce
-        if (shift != 0) {
-            for(size_t i = 0; i < res.size(); ++i) {
-                if (gen[i] != 0) {
-                    res[i] ^= gf32_mul(gen[i], shift);
-                }
-            }
-        }
-    }
-    return res;
-}
-
-/** Verify a checksum. */
-template <typename Residue>
-bool VerifyChecksum(const std::string& hrp, const data& values, const Residue& gen, const Residue& target)
-{
-    auto enc = bech32::internal::PreparePolynomialCoefficients(hrp, values);
-    auto res = PolyMod(enc, gen);
-    for (size_t i = 0; i < res.size(); ++i) {
-        if (res[i] != target[i]) {
-            return 0;
-        }
-    }
-    return 1;
-}
-
-/** Create a checksum. */
-template <typename Residue>
-data CreateChecksum(const std::string& hrp, const data& values, const Residue& gen, const Residue& target)
-{
-    data enc = bech32::internal::PreparePolynomialCoefficients(hrp, values);
-    enc.resize(enc.size() + gen.size());
-    const auto checksum = PolyMod(enc, gen);
-    data ret(gen.size());
-    for (size_t i = 0; i < checksum.size(); ++i) {
-        ret[i] = checksum[i] ^ target[i];
-    }
-    return ret;
-}
-
-// Given a set of share indices and a target index `idx`, which must be in the set,
-// compute the Lagrange basis polynomial for `idx` evaluated at the point `eval`.
-//
-// All inputs are GF32 elements, rather than array indices or anything else.
-uint8_t lagrange_coefficient(std::vector<uint8_t>& indices, uint8_t idx, uint8_t eval) {
-    uint8_t num = 1;
-    uint8_t den = 1;
-    for (const auto idx_i : indices) {
-        if (idx_i != idx) {
-            num = gf32_mul(num, idx_i ^ eval);
-            den = gf32_mul(den, idx_i ^ idx);
-        }
-    }
-
-    // return num / den
-    return gf32_div(num, den);
-}
-
-} // namespace
-
-std::string ErrorString(Error e) {
-    switch (e) {
-    case OK: return "ok";
-    case BAD_CHECKSUM: return "bad checksum";
-    case BECH32_DECODE: return "bech32 decode failure (invalid character, no HRP, or inconsistent case)";
-    case INVALID_HRP: return "hrp differed from 'ms'";
-    case INVALID_ID_LEN: return "seed ID was not 4 characters";
-    case INVALID_ID_CHAR: return "seed ID used a non-bech32 character";
-    case INVALID_LENGTH: return "invalid length";
-    case INVALID_K: return "invalid threshold (k) value";
-    case INVALID_SHARE_IDX: return "invalid share index";
-    case TOO_FEW_SHARES: return "tried to derive a share but did not have enough input shares";
-    case DUPLICATE_SHARE: return "tried to derive a share but two input shares had the same index";
-    case MISMATCH_K: return "tried to derive a share but input shares had inconsistent threshold (k) values";
-    case MISMATCH_ID: return "tried to derive a share but input shares had inconsistent seed IDs";
-    case MISMATCH_LENGTH: return "tried to derive a share but input shares had inconsistent lengths";
-    }
-    assert(0);
-}
-
-/** Encode a codex32 string. */
-std::string Result::Encode() const {
-    assert(IsValid());
-
-    const data checksum = m_data.size() <= 80
-        ? CreateChecksum(m_hrp, m_data, CODEX32_GEN, CODEX32_M)
-        : CreateChecksum(m_hrp, m_data, CODEX32_LONG_GEN, CODEX32_LONG_M);
-    return bech32::internal::Encode(m_hrp, m_data, checksum);
-}
-
-/** Decode a codex32 string */
-Result::Result(const std::string& str) {
-    m_valid = OK;
-
-    auto res = bech32::internal::Decode(str, bech32::CharLimit::CODEX32, bech32::CHECKSUM_SIZE);
-
-    if (str.size() > bech32::CharLimit::CODEX32) {
-        m_valid = INVALID_LENGTH;
-        // Early return since if we failed the max size check, Decode did not give us any data.
-        return;
-    } else if (res.first.empty() && res.second.empty()) {
-        m_valid = BECH32_DECODE;
-        return;
-    } else if (res.first != "ms") {
-        m_valid = INVALID_HRP;
-        // Early return since if the HRP is wrong, all bets are off and no point continuing
-        return;
-    }
-    m_hrp = std::move(res.first);
-
-    if (res.second.size() >= 45 && res.second.size() <= 90) {
-        // If, after converting back to base-256, we have 5 or more bits of data
-        // remaining, it means that we had an entire character of useless data,
-        // which shouldn't have been included.
-        if (((res.second.size() - 6 - 13) * 5) % 8 > 4) {
-            m_valid = INVALID_LENGTH;
-        } else if (VerifyChecksum(m_hrp, res.second, CODEX32_GEN, CODEX32_M)) {
-            m_data = data(res.second.begin(), res.second.end() - 13);
-        } else {
-            m_valid = BAD_CHECKSUM;
-        }
-    } else if (res.second.size() >= 96 && res.second.size() <= 124) {
-        if (((res.second.size() - 6 - 15) * 5) % 8 > 4) {
-            m_valid = INVALID_LENGTH;
-        } else if (VerifyChecksum(m_hrp, res.second, CODEX32_LONG_GEN, CODEX32_LONG_M)) {
-            m_data = data(res.second.begin(), res.second.end() - 15);
-        } else {
-            m_valid = BAD_CHECKSUM;
-        }
-    } else {
-        m_valid = INVALID_LENGTH;
-    }
-
-    if (m_valid == OK) {
-        auto k = bech32::internal::CHARSET[res.second[0]];
-        if (k < '0' || k == '1' || k > '9') {
-            m_valid = INVALID_K;
-        }
-        if (k == '0' && m_data[5] != 16) {
-            // If the threshold is 0, the only allowable share is S
-            m_valid = INVALID_SHARE_IDX;
-        }
-    }
-}
-
-Result::Result(std::string&& hrp, size_t k, const std::string& id, char share_idx, const std::vector<unsigned char>& data) {
-    m_valid = OK;
-    if (hrp != "ms") {
-        m_valid = INVALID_HRP;
-    }
-    m_hrp = hrp;
-    if (k == 1 || k > 9) {
-        m_valid = INVALID_K;
-    }
-    if (id.size() != 4) {
-        m_valid = INVALID_ID_LEN;
-    }
-    int8_t sidx = bech32::internal::CHARSET_REV[(unsigned char) share_idx];
-    if (sidx == -1) {
-        m_valid = INVALID_SHARE_IDX;
-    }
-    if (k == 0 && sidx != 16) {
-        // If the threshold is 0, the only allowable share is S
-        m_valid = INVALID_SHARE_IDX;
-    }
-    for (size_t i = 0; i < id.size(); ++i) {
-        if (bech32::internal::CHARSET_REV[(unsigned char) id[i]] == -1) {
-            m_valid = INVALID_ID_CHAR;
-        }
-    }
-
-    if (m_valid != OK) {
-        // early bail before allocating memory
-        return;
-    }
-
-    m_data.reserve(6 + ((data.size() * 8) + 4) / 5);
-    m_data.push_back(bech32::internal::CHARSET_REV['0' + k]);
-    m_data.push_back(bech32::internal::CHARSET_REV[(unsigned char) id[0]]);
-    m_data.push_back(bech32::internal::CHARSET_REV[(unsigned char) id[1]]);
-    m_data.push_back(bech32::internal::CHARSET_REV[(unsigned char) id[2]]);
-    m_data.push_back(bech32::internal::CHARSET_REV[(unsigned char) id[3]]);
-    m_data.push_back(sidx);
-    ConvertBits<8, 5, true>([&](unsigned char c) { m_data.push_back(c); }, data.begin(), data.end());
-}
-
-Result::Result(const std::vector<Result>& shares, char output_idx) {
-    m_valid = OK;
-
-    int8_t oidx = bech32::internal::CHARSET_REV[(unsigned char) output_idx];
-    if (oidx == -1) {
-        m_valid = INVALID_SHARE_IDX;
-    }
-    if (shares.empty()) {
-        m_valid = TOO_FEW_SHARES;
-        return;
-    }
-    size_t k = shares[0].GetK();
-    if (k > shares.size()) {
-        m_valid = TOO_FEW_SHARES;
-    }
-    if (m_valid != OK) {
-        return;
-    }
-
-    std::vector<uint8_t> indices;
-    indices.reserve(shares.size());
-    for (size_t i = 0; i < shares.size(); ++i) {
-        // Currently the only supported hrp is "ms" so it is impossible to violate this
-        assert (shares[0].m_hrp == shares[i].m_hrp);
-        if (shares[0].m_data[0] != shares[i].m_data[0]) {
-            m_valid = MISMATCH_K;
-        }
-        for (size_t j = 1; j < 5; ++j) {
-            if (shares[0].m_data[j] != shares[i].m_data[j]) {
-                m_valid = MISMATCH_ID;
-            }
-        }
-        if (shares[i].m_data.size() != shares[0].m_data.size()) {
-            m_valid = MISMATCH_LENGTH;
-        }
-
-        indices.push_back(shares[i].m_data[5]);
-        for (size_t j = i + 1; j < shares.size(); ++j) {
-            if (shares[i].m_data[5] == shares[j].m_data[5]) {
-                m_valid = DUPLICATE_SHARE;
-            }
-        }
-    }
-
-    m_hrp = shares[0].m_hrp;
-    m_data.reserve(shares[0].m_data.size());
-    for (size_t j = 0; j < shares[0].m_data.size(); ++j) {
-        m_data.push_back(0);
-    }
-
-    for (size_t i = 0; i < shares.size(); ++i) {
-        uint8_t lagrange_coeff = lagrange_coefficient(indices, shares[i].m_data[5], oidx);
-        for (size_t j = 0; j < m_data.size(); ++j) {
-            m_data[j] ^= gf32_mul(lagrange_coeff, shares[i].m_data[j]);
-        }
-    }
-}
-
-std::string Result::GetIdString() const {
-    assert(IsValid());
-
-    std::string ret;
-    ret.reserve(4);
-    ret.push_back(bech32::internal::CHARSET[m_data[1]]);
-    ret.push_back(bech32::internal::CHARSET[m_data[2]]);
-    ret.push_back(bech32::internal::CHARSET[m_data[3]]);
-    ret.push_back(bech32::internal::CHARSET[m_data[4]]);
-    return ret;
-}
-
-size_t Result::GetK() const {
-    assert(IsValid());
-    return bech32::internal::CHARSET[m_data[0]] - '0';
-}
-
-} // namespace codex32
diff --git a/src/codex32.h b/src/codex32.h
deleted file mode 100644
index 93d9f813f9..0000000000
--- a/src/codex32.h
+++ /dev/null
@@ -1,118 +0,0 @@
-// Copyright (c) 2023 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-// codex32 is a string encoding format for BIP-32 seeds. Like bech32 and
-// bech32m, the outputs consist of a human-readable part (alphanumeric),
-// a separator character (1), and a base32 data section. The final 13
-// characters are a checksum.
-//
-// For more information, see BIP 93.
-
-#ifndef BITCOIN_CODEX32_H
-#define BITCOIN_CODEX32_H
-
-#include <assert.h>
-#include <stdint.h>
-#include <array>
-#include <string>
-#include <vector>
-
-#include <bech32.h>
-#include <util/strencodings.h>
-
-namespace codex32
-{
-
-enum Error {
-    OK,
-    BAD_CHECKSUM,
-    BECH32_DECODE,
-    INVALID_HRP,
-    INVALID_ID_LEN,
-    INVALID_ID_CHAR,
-    INVALID_LENGTH,
-    INVALID_K,
-    INVALID_SHARE_IDX,
-    TOO_FEW_SHARES,
-    DUPLICATE_SHARE,
-    MISMATCH_K,
-    MISMATCH_ID,
-    MISMATCH_LENGTH,
-};
-
-std::string ErrorString(Error e);
-
-class Result
-{
-public:
-    /** Construct a codex32 result by parsing a string */
-    Result(const std::string& str);
-
-    /** Construct a codex32 directly from a HRP, k, seed ID, share index and payload
-     *
-     * This constructor requires the hrp to be the lowercase string "ms", but will
-     * ignore the case of `id` and `share_idx`. */
-    Result(std::string&& hrp, size_t k, const std::string& id, char share_idx, const std::vector<unsigned char>& data);
-
-    /** Construct a codex32 result by interpolating a set of input shares to obtain an output share
-     *
-     * Requires that all input shares have the same k and seed ID */
-    Result(const std::vector<Result>& shares, char output_idx);
-
-    /** Boolean indicating whether the data was successfully parsed.
-     *
-     * If this returns false, most of the other methods on this class will assert. */
-    bool IsValid() const {
-        return m_valid == OK;
-    }
-
-    /** Accessor for the specific parsing/construction error */
-    Error error() const {
-        return m_valid;
-    }
-
-    /** Accessor for the human-readable part of the codex32 string */
-    const std::string& GetHrp() const {
-        assert(IsValid());
-        return m_hrp;
-    }
-
-    /** Accessor for the seed ID, in string form */
-    std::string GetIdString() const;
-
-    /** Accessor for the secret sharing threshold; 0 for a bare seed; (size_t)-1 if unavailable/invalid */
-    size_t GetK() const;
-
-    /** Accessor for the share index; (uint8_t)-1 if unavailable/invalid */
-    char GetShareIndex() const {
-        assert(IsValid());
-        return bech32::internal::CHARSET[m_data[5]];
-    }
-
-    /** Accessor for the binary payload data (in base 256, not gf32) */
-    std::vector<unsigned char> GetPayload() const {
-        assert(IsValid());
-
-        std::vector<unsigned char> ret;
-        ret.reserve(((m_data.size() - 6) * 5) / 8);
-        // Note that `ConvertBits` returns a bool indicating whether or not nonzero bits
-        // were discarded. In BIP 93, we discard bits regardless of whether they are 0,
-        // so this is not an error and does not need to be checked.
-        ConvertBits<5, 8, false>([&](unsigned char c) { ret.push_back(c); }, m_data.begin() + 6, m_data.end());
-        return ret;
-    };
-
-    /** (Re-)encode the codex32 data as a hrp string */
-    std::string Encode() const;
-
-private:
-    Error m_valid;               //!< codex32::OK if the string was decoded correctly
-
-    std::string m_hrp;           //!< The human readable part
-    std::vector<uint8_t> m_data; //!< The payload (remaining data, excluding checksum)
-};
-
-} // namespace codex32
-
-#endif // BITCOIN_CODEX32_H
diff --git a/src/common/args.cpp b/src/common/args.cpp
index 2bb3f141d7..a37a16b62b 100644
--- a/src/common/args.cpp
+++ b/src/common/args.cpp
@@ -16,7 +16,6 @@
 #include <util/fs.h>
 #include <util/fs_helpers.h>
 #include <util/strencodings.h>
-#include <util/string.h>
 
 #ifdef WIN32
 #include <codecvt>    /* for codecvt_utf8_utf16 */
@@ -29,18 +28,15 @@
 #include <cstdint>
 #include <cstdlib>
 #include <cstring>
-#include <fstream>
 #include <map>
 #include <optional>
 #include <stdexcept>
 #include <string>
-#include <unordered_set>
 #include <utility>
 #include <variant>
 
 const char * const BITCOIN_CONF_FILENAME = "bitcoin.conf";
 const char * const BITCOIN_SETTINGS_FILENAME = "settings.json";
-const char * const BITCOIN_RW_CONF_FILENAME = "bitcoin_rw.conf";
 
 ArgsManager gArgs;
 
@@ -507,25 +503,6 @@ int64_t SettingToInt(const common::SettingsValue& value, int64_t nDefault)
     return SettingToInt(value).value_or(nDefault);
 }
 
-std::optional<int64_t> ArgsManager::GetFixedPointArg(const std::string& arg, int decimals) const
-{
-    const common::SettingsValue value = GetSetting(arg);
-    return SettingToFixedPoint(value, decimals);
-}
-
-std::optional<int64_t> SettingToFixedPoint(const common::SettingsValue& value, int decimals)
-{
-    if (value.isNull()) return std::nullopt;
-    if (value.isFalse()) return 0;
-    if (value.isTrue()) return 1;
-    if (!value.isNum()) value.get_str();  // throws an exception if type is wrong
-    int64_t v;
-    if (!ParseFixedPoint(value.getValStr(), decimals, &v)) {
-        throw std::runtime_error(strprintf("Parse error ('%s')", value.getValStr()));
-    }
-    return v;
-}
-
 bool ArgsManager::GetBoolArg(const std::string& strArg, bool fDefault) const
 {
     return GetBoolArg(strArg).value_or(fDefault);
@@ -539,21 +516,9 @@ std::optional<bool> ArgsManager::GetBoolArg(const std::string& strArg) const
 
 std::optional<bool> SettingToBool(const common::SettingsValue& value)
 {
-    switch (value.getType()) {
-        case UniValue::VNULL:
-            return std::nullopt;
-        case UniValue::VBOOL:
-            return value.get_bool();
-        case UniValue::VOBJ:
-        case UniValue::VARR:
-            // Throws an exception
-            value.get_str();
-            assert(false);
-        case UniValue::VSTR:
-        case UniValue::VNUM:
-            return InterpretBool(value.getValStr());
-    }
-    assert(false);
+    if (value.isNull()) return std::nullopt;
+    if (value.isBool()) return value.get_bool();
+    return InterpretBool(value.get_str());
 }
 
 bool SettingToBool(const common::SettingsValue& value, bool fDefault)
@@ -578,19 +543,9 @@ bool ArgsManager::SoftSetBoolArg(const std::string& strArg, bool fValue)
 }
 
 void ArgsManager::ForceSetArg(const std::string& strArg, const std::string& strValue)
-{
-    ForceSetArgV(strArg, common::SettingsValue{strValue});
-}
-
-void ArgsManager::ForceSetArg(const std::string& arg, const int64_t value)
-{
-    ForceSetArg(arg, util::ToString(value));
-}
-
-void ArgsManager::ForceSetArgV(const std::string& arg, const common::SettingsValue& value)
 {
     LOCK(cs_args);
-    m_settings.forced_settings[SettingName(arg)] = value;
+    m_settings.forced_settings[SettingName(strArg)] = strValue;
 }
 
 void ArgsManager::AddCommand(const std::string& cmd, const std::string& help)
@@ -626,10 +581,10 @@ void ArgsManager::AddArg(const std::string& name, const std::string& help, unsig
     }
 }
 
-void ArgsManager::AddHiddenArgs(const std::vector<std::string>& names, unsigned int flags)
+void ArgsManager::AddHiddenArgs(const std::vector<std::string>& names)
 {
     for (const std::string& name : names) {
-        AddArg(name, "", flags, OptionsCategory::HIDDEN);
+        AddArg(name, "", ArgsManager::ALLOW_ANY, OptionsCategory::HIDDEN);
     }
 }
 
@@ -680,9 +635,6 @@ std::string ArgsManager::GetHelpMessage() const
             case OptionsCategory::REGISTER_COMMANDS:
                 usage += HelpMessageGroup("Register Commands:");
                 break;
-            case OptionsCategory::STATS:
-                usage += HelpMessageGroup("Statistic options:");
-                break;
             default:
                 break;
         }
@@ -712,8 +664,8 @@ bool HelpRequested(const ArgsManager& args)
 
 void SetupHelpOptions(ArgsManager& args)
 {
-    args.AddArg("-?", "Print this help message and exit", ArgsManager::DISALLOW_NEGATION, OptionsCategory::OPTIONS);
-    args.AddHiddenArgs({"-h", "-help"}, ArgsManager::DISALLOW_NEGATION);
+    args.AddArg("-?", "Print this help message and exit", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
+    args.AddHiddenArgs({"-h", "-help"});
 }
 
 static const int screenWidth = 79;
@@ -794,12 +746,6 @@ void ArgsManager::SetConfigFilePath(fs::path path)
     m_config_path = path;
 }
 
-fs::path ArgsManager::GetRWConfigFilePath() const
-{
-    LOCK(cs_args);
-    return *Assert(m_rwconf_path);
-}
-
 ChainType ArgsManager::GetChainType() const
 {
     std::variant<ChainType, std::string> arg = GetChainArg();
@@ -891,234 +837,9 @@ void ArgsManager::LogArgs() const
     for (const auto& setting : m_settings.rw_settings) {
         LogPrintf("Setting file arg: %s = %s\n", setting.first, setting.second.write());
     }
-    logArgsPrefix("R/W config file arg:", "", m_settings.rw_config);
     logArgsPrefix("Command-line arg:", "", m_settings.command_line_options);
 }
 
-namespace {
-
-    // Like std::getline, but includes the EOL character in the result
-    bool getline_with_eol(std::istream& stream, std::string& result)
-    {
-        int current_char;
-        current_char = stream.get();
-        if (current_char == std::char_traits<char>::eof()) {
-            return false;
-        }
-        result.clear();
-        result.push_back(char(current_char));
-        while (current_char != '\n') {
-            current_char = stream.get();
-            if (current_char == std::char_traits<char>::eof()) {
-                break;
-            }
-            result.push_back(char(current_char));
-        }
-        return true;
-    }
-
-    const char * const ModifyRWConfigFile_ws_chars = " \t\r\n";
-
-    void ModifyRWConfigFile_SanityCheck(const std::string& s)
-    {
-        if (s.empty()) {
-            // Dereferencing .begin or .rbegin below is invalid unless the string has at least one character.
-            return;
-        }
-
-        static const char * const newline_chars = "\r\n";
-        static std::string ws_chars(ModifyRWConfigFile_ws_chars);
-        if (s.find_first_of(newline_chars) != std::string::npos) {
-            throw std::invalid_argument("New-line in config name/value");
-        }
-        if (ws_chars.find(*s.begin()) != std::string::npos || ws_chars.find(*s.rbegin()) != std::string::npos) {
-            throw std::invalid_argument("Config name/value has leading/trailing whitespace");
-        }
-    }
-
-    void ModifyRWConfigFile_WriteRemaining(std::ostream& stream_out, const std::map<std::string, std::string>& settings_to_change, std::set<std::string>& setFound)
-    {
-        for (const auto& setting_pair : settings_to_change) {
-            const std::string& key = setting_pair.first;
-            const std::string& val = setting_pair.second;
-            if (setFound.find(key) != setFound.end()) {
-                continue;
-            }
-            setFound.insert(key);
-            ModifyRWConfigFile_SanityCheck(key);
-            ModifyRWConfigFile_SanityCheck(val);
-            stream_out << key << "=" << val << "\n";
-        }
-    }
-} // namespace
-
-void ModifyRWConfigStream(std::istream& stream_in, std::ostream& stream_out, const std::map<std::string, std::string>& settings_to_change)
-{
-    static const char * const ws_chars = ModifyRWConfigFile_ws_chars;
-    std::set<std::string> setFound;
-    std::string s, lineend, linebegin, key;
-    std::string::size_type n, n2;
-    bool inside_group = false, have_eof_nl = true;
-    std::map<std::string, std::string>::const_iterator iterCS;
-    size_t lineno = 0;
-    while (getline_with_eol(stream_in, s)) {
-        ++lineno;
-
-        have_eof_nl = (!s.empty()) && (*s.rbegin() == '\n');
-        n = s.find('#');
-        const bool has_comment = (n != std::string::npos);
-        if (!has_comment) {
-            n = s.size();
-        }
-        if (n > 0) {
-            n2 = s.find_last_not_of(ws_chars, n - 1);
-            if (n2 != std::string::npos) {
-                n = n2 + 1;
-            }
-        }
-        n2 = s.find_first_not_of(ws_chars);
-        if (n2 == std::string::npos || n2 >= n) {
-            // Blank or comment-only line
-            stream_out << s;
-            continue;
-        }
-        lineend = s.substr(n);
-        linebegin = s.substr(0, n2);
-        s = s.substr(n2, n - n2);
-
-        // It is impossible for s to be empty here, due to the blank line check above
-        if (*s.begin() == '[' && *s.rbegin() == ']') {
-            // We don't use sections, so we could possibly just write out the rest of the file - but we need to check for unparsable lines, so we just set a flag to ignore settings from here on
-            ModifyRWConfigFile_WriteRemaining(stream_out, settings_to_change, setFound);
-            inside_group = true;
-            key.clear();
-
-            stream_out << linebegin << s << lineend;
-            continue;
-        }
-
-        n = s.find('=');
-        if (n == std::string::npos) {
-            // Bad line; this causes boost to throw an exception when parsing, so we comment out the entire file
-            stream_in.seekg(0, std::ios_base::beg);
-            stream_out.seekp(0, std::ios_base::beg);
-            if (!(stream_in.good() && stream_out.good())) {
-                throw std::ios_base::failure("Failed to rewind (to comment out existing file)");
-            }
-            // First, write out all the settings we intend to set
-            setFound.clear();
-            ModifyRWConfigFile_WriteRemaining(stream_out, settings_to_change, setFound);
-            // We then define a category to ensure new settings get added before the invalid stuff
-            stream_out << "[INVALID]\n";
-            // Then, describe the problem in a comment
-            stream_out << "# Error parsing line " << lineno << ": " << s << "\n";
-            // Finally, dump the rest of the file commented out
-            while (getline_with_eol(stream_in, s)) {
-                stream_out << "#" << s;
-            }
-            return;
-        }
-
-        if (!inside_group) {
-            // We don't support/use groups, so once we're inside key is always null to avoid setting anything
-            n2 = s.find_last_not_of(ws_chars, n - 1);
-            if (n2 == std::string::npos) {
-                n2 = n - 1;
-            } else {
-                ++n2;
-            }
-            key = s.substr(0, n2);
-        }
-        if ((!key.empty()) && (iterCS = settings_to_change.find(key)) != settings_to_change.end() && setFound.find(key) == setFound.end()) {
-            // This is the key we want to change
-            const std::string& val = iterCS->second;
-            setFound.insert(key);
-            ModifyRWConfigFile_SanityCheck(val);
-            if (has_comment) {
-                // Rather than change a commented line, comment it out entirely (the existing comment may relate to the value) and replace it
-                stream_out << key << "=" << val << "\n";
-                linebegin.insert(linebegin.begin(), '#');
-            } else {
-                // Just modify the value in-line otherwise
-                n2 = s.find_first_not_of(ws_chars, n + 1);
-                if (n2 == std::string::npos) {
-                    n2 = n + 1;
-                }
-                s = s.substr(0, n2) + val;
-            }
-        }
-        stream_out << linebegin << s << lineend;
-    }
-    if (setFound.size() < settings_to_change.size()) {
-        if (!have_eof_nl) {
-            stream_out << "\n";
-        }
-        ModifyRWConfigFile_WriteRemaining(stream_out, settings_to_change, setFound);
-    }
-}
-
-void ArgsManager::ModifyRWConfigFile(const std::map<std::string, std::string>& settings_to_change, const bool also_settings_json)
-{
-    LOCK(cs_args);
-    fs::path rwconf_path{GetRWConfigFilePath()};
-    fs::path rwconf_new_path{rwconf_path};
-    rwconf_new_path += ".new";
-    try {
-        fs::remove(rwconf_new_path);
-        std::ofstream streamRWConfigOut(rwconf_new_path, std::ios_base::out | std::ios_base::trunc);
-        if (fs::exists(rwconf_path)) {
-            std::ifstream streamRWConfig(rwconf_path);
-            ::ModifyRWConfigStream(streamRWConfig, streamRWConfigOut, settings_to_change);
-        } else {
-            std::istringstream streamIn;
-            ::ModifyRWConfigStream(streamIn, streamRWConfigOut, settings_to_change);
-        }
-    } catch (...) {
-        fs::remove(rwconf_new_path);
-        throw;
-    }
-    if (!RenameOver(rwconf_new_path, rwconf_path)) {
-        fs::remove(rwconf_new_path);
-        throw std::ios_base::failure(strprintf("Failed to replace %s", fs::PathToString(rwconf_new_path)));
-    }
-    for (const auto& setting_change : settings_to_change) {
-        m_settings.rw_config[setting_change.first] = {setting_change.second};
-    }
-    if (also_settings_json && !IsArgNegated("-settings")) {
-        // Also save to settings.json for Core (0.21+) compatibility
-        for (const auto& setting_change : settings_to_change) {
-            m_settings.rw_settings[setting_change.first] = setting_change.second;
-        }
-        WriteSettingsFile();
-    }
-    if (settings_to_change.count("prune")) {
-        m_rwconf_had_prune_option = true;
-    }
-}
-
-void ArgsManager::ModifyRWConfigFile(const std::string& setting_to_change, const std::string& new_value, const bool also_settings_json)
-{
-    std::map<std::string, std::string> settings_to_change;
-    settings_to_change[setting_to_change] = new_value;
-    ModifyRWConfigFile(settings_to_change, also_settings_json);
-}
-
-void ArgsManager::EraseRWConfigFile()
-{
-    LOCK(cs_args);
-    fs::path rwconf_path{GetRWConfigFilePath()};
-    if (!fs::exists(rwconf_path)) {
-        return;
-    }
-    fs::path rwconf_reset_path = rwconf_path;
-    rwconf_reset_path += ".reset";
-    if (!RenameOver(rwconf_path, rwconf_reset_path)) {
-        if (fs::remove(rwconf_path)) {
-            throw std::ios_base::failure(strprintf("Failed to remove %s", fs::PathToString(rwconf_path)));
-        }
-    }
-}
-
 namespace common {
 #ifdef WIN32
 WinCmdLineArgs::WinCmdLineArgs()
diff --git a/src/common/args.h b/src/common/args.h
index 66e2c39460..323a86d8dc 100644
--- a/src/common/args.h
+++ b/src/common/args.h
@@ -25,7 +25,6 @@ class ArgsManager;
 
 extern const char * const BITCOIN_CONF_FILENAME;
 extern const char * const BITCOIN_SETTINGS_FILENAME;
-extern const char * const BITCOIN_RW_CONF_FILENAME;
 
 // Return true if -datadir option points to a valid directory or is not specified.
 bool CheckDataDirOption(const ArgsManager& args);
@@ -64,7 +63,6 @@ enum class OptionsCategory {
     GUI,
     COMMANDS,
     REGISTER_COMMANDS,
-    STATS,
 
     HIDDEN // Always the last option to avoid printing these in the help
 };
@@ -92,13 +90,9 @@ std::optional<std::string> SettingToString(const common::SettingsValue&);
 int64_t SettingToInt(const common::SettingsValue&, int64_t);
 std::optional<int64_t> SettingToInt(const common::SettingsValue&);
 
-std::optional<int64_t> SettingToFixedPoint(const common::SettingsValue&, int decimals);
-
 bool SettingToBool(const common::SettingsValue&, bool);
 std::optional<bool> SettingToBool(const common::SettingsValue&);
 
-void ModifyRWConfigStream(std::istream& stream_in, std::ostream& stream_out, const std::map<std::string, std::string>& settings_to_change);
-
 class ArgsManager
 {
 public:
@@ -144,13 +138,11 @@ protected:
     bool m_accept_any_command GUARDED_BY(cs_args){true};
     std::list<SectionInfo> m_config_sections GUARDED_BY(cs_args);
     std::optional<fs::path> m_config_path GUARDED_BY(cs_args);
-    std::optional<fs::path> m_rwconf_path GUARDED_BY(cs_args);
-    bool m_rwconf_had_prune_option{false};
     mutable fs::path m_cached_blocks_path GUARDED_BY(cs_args);
     mutable fs::path m_cached_datadir_path GUARDED_BY(cs_args);
     mutable fs::path m_cached_network_datadir_path GUARDED_BY(cs_args);
 
-    [[nodiscard]] bool ReadConfigStream(std::istream& stream, const std::string& filepath, std::string& error, bool ignore_invalid_keys = false, std::map<std::string, std::vector<common::SettingsValue>>* settings_target = nullptr);
+    [[nodiscard]] bool ReadConfigStream(std::istream& stream, const std::string& filepath, std::string& error, bool ignore_invalid_keys = false);
 
     /**
      * Returns true if settings values from the default section should be used,
@@ -189,14 +181,8 @@ protected:
      */
     fs::path GetConfigFilePath() const;
     void SetConfigFilePath(fs::path);
-    fs::path GetRWConfigFilePath() const;
     [[nodiscard]] bool ReadConfigFiles(std::string& error, bool ignore_invalid_keys = false);
 
-    bool RWConfigHasPruneOption() const { return m_rwconf_had_prune_option; }
-    void ModifyRWConfigFile(const std::map<std::string, std::string>& settings_to_change, bool also_settings_json = true);
-    void ModifyRWConfigFile(const std::string& setting_to_change, const std::string& new_value, bool also_settings_json = true);
-    void EraseRWConfigFile();
-
     /**
      * Log warnings for options in m_section_only_args when
      * they are specified in the default section but not overridden
@@ -307,15 +293,6 @@ protected:
     int64_t GetIntArg(const std::string& strArg, int64_t nDefault) const;
     std::optional<int64_t> GetIntArg(const std::string& strArg) const;
 
-    /**
-     * Return fixed-point argument
-     *
-     * @param arg Argument to get (e.g. "-foo")
-     * @param decimals Number of fractional decimal digits to accept
-     * @return Command-line argument (0 if invalid number) multiplied by 10**decimals
-     */
-    std::optional<int64_t> GetFixedPointArg(const std::string& arg, int decimals) const;
-
     /**
      * Return boolean argument or default value
      *
@@ -346,9 +323,7 @@ protected:
 
     // Forces an arg setting. Called by SoftSetArg() if the arg hasn't already
     // been set. Also called directly in testing.
-    void ForceSetArg(const std::string& arg, const std::string& value);
-    void ForceSetArg(const std::string& arg, int64_t value);
-    void ForceSetArgV(const std::string& arg, const common::SettingsValue& value);
+    void ForceSetArg(const std::string& strArg, const std::string& strValue);
 
     /**
      * Returns the appropriate chain type from the program arguments.
@@ -377,7 +352,7 @@ protected:
     /**
      * Add many hidden arguments
      */
-    void AddHiddenArgs(const std::vector<std::string>& args, unsigned int flags = ArgsManager::ALLOW_ANY);
+    void AddHiddenArgs(const std::vector<std::string>& args);
 
     /**
      * Clear available arguments
diff --git a/src/common/config.cpp b/src/common/config.cpp
index 8fde9ef637..98223fc3e3 100644
--- a/src/common/config.cpp
+++ b/src/common/config.cpp
@@ -4,7 +4,6 @@
 
 #include <common/args.h>
 
-#include <chainparamsbase.h>
 #include <common/settings.h>
 #include <logging.h>
 #include <sync.h>
@@ -17,7 +16,6 @@
 #include <algorithm>
 #include <cassert>
 #include <cstdlib>
-#include <filesystem>
 #include <fstream>
 #include <iostream>
 #include <list>
@@ -91,7 +89,7 @@ bool IsConfSupported(KeyInfo& key, std::string& error) {
     return true;
 }
 
-bool ArgsManager::ReadConfigStream(std::istream& stream, const std::string& filepath, std::string& error, bool ignore_invalid_keys, std::map<std::string, std::vector<common::SettingsValue>>* settings_target)
+bool ArgsManager::ReadConfigStream(std::istream& stream, const std::string& filepath, std::string& error, bool ignore_invalid_keys)
 {
     LOCK(cs_args);
     std::vector<std::pair<std::string, std::string>> options;
@@ -107,9 +105,6 @@ bool ArgsManager::ReadConfigStream(std::istream& stream, const std::string& file
             if (!value) {
                 return false;
             }
-            if (settings_target) {
-                (*settings_target)[key.name].push_back(*value);
-            } else
             m_settings.ro_config[key.section][key.name].push_back(*value);
         } else {
             if (ignore_invalid_keys) {
@@ -128,25 +123,17 @@ bool ArgsManager::ReadConfigFiles(std::string& error, bool ignore_invalid_keys)
     {
         LOCK(cs_args);
         m_settings.ro_config.clear();
-        m_settings.rw_config.clear();
-        m_rwconf_had_prune_option = false;
         m_config_sections.clear();
         m_config_path = AbsPathForConfigVal(*this, GetPathArg("-conf", BITCOIN_CONF_FILENAME), /*net_specific=*/false);
     }
 
     const auto conf_path{GetConfigFilePath()};
-    std::ifstream stream;
-    if (!conf_path.empty()) { // path is empty when -noconf is specified
-        if (fs::is_directory(conf_path)) {
-            error = strprintf("Config file \"%s\" is a directory.", fs::PathToString(conf_path));
-            return false;
-        }
-        stream = std::ifstream{conf_path};
-        // If the file is explicitly specified, it must be readable
-        if (IsArgSet("-conf") && !stream.good()) {
-            error = strprintf("specified config file \"%s\" could not be opened.", fs::PathToString(conf_path));
-            return false;
-        }
+    std::ifstream stream{conf_path};
+
+    // not ok to have a config file specified that cannot be opened
+    if (IsArgSet("-conf") && !stream.good()) {
+        error = strprintf("specified config file \"%s\" could not be opened.", fs::PathToString(conf_path));
+        return false;
     }
     // ok to not have a config file
     if (stream.good()) {
@@ -188,12 +175,7 @@ bool ArgsManager::ReadConfigFiles(std::string& error, bool ignore_invalid_keys)
             const size_t default_includes = add_includes({});
 
             for (const std::string& conf_file_name : conf_file_names) {
-                const auto include_conf_path{AbsPathForConfigVal(*this, fs::PathFromString(conf_file_name), /*net_specific=*/false)};
-                if (fs::is_directory(include_conf_path)) {
-                    error = strprintf("Included config file \"%s\" is a directory.", fs::PathToString(include_conf_path));
-                    return false;
-                }
-                std::ifstream conf_file_stream{include_conf_path};
+                std::ifstream conf_file_stream{AbsPathForConfigVal(*this, fs::PathFromString(conf_file_name), /*net_specific=*/false)};
                 if (conf_file_stream.good()) {
                     if (!ReadConfigStream(conf_file_stream, conf_file_name, error, ignore_invalid_keys)) {
                         return false;
@@ -220,38 +202,18 @@ bool ArgsManager::ReadConfigFiles(std::string& error, bool ignore_invalid_keys)
         }
     }
 
-    // Check for chain settings (BaseParams() calls are only valid after this clause)
-    try {
-        SelectBaseParams(gArgs.GetChainType());
-    } catch (const std::exception& e) {
-        error = e.what();
-        return false;
-    }
-
     // If datadir is changed in .conf file:
     ClearPathCache();
     if (!CheckDataDirOption(*this)) {
         error = strprintf("specified data directory \"%s\" does not exist.", GetArg("-datadir", ""));
         return false;
     }
-
-    LOCK(cs_args);
-    m_rwconf_path = AbsPathForConfigVal(*this, GetPathArg("-confrw", BITCOIN_RW_CONF_FILENAME));
-    const auto rwconf_path{GetRWConfigFilePath()};
-    std::ifstream rwconf_stream(rwconf_path);
-    if (rwconf_stream.good()) {
-        if (!ReadConfigStream(rwconf_stream, fs::PathToString(rwconf_path), error, ignore_invalid_keys, &m_settings.rw_config)) {
-            return false;
-        }
-        m_rwconf_had_prune_option = m_settings.rw_config.count("prune");
-    }
-
     return true;
 }
 
 fs::path AbsPathForConfigVal(const ArgsManager& args, const fs::path& path, bool net_specific)
 {
-    if (path.is_absolute() || path.empty()) {
+    if (path.is_absolute()) {
         return path;
     }
     return fsbridge::AbsPathJoin(net_specific ? args.GetDataDirNet() : args.GetDataDirBase(), path);
diff --git a/src/common/init.cpp b/src/common/init.cpp
index 76106aa764..412d73aec7 100644
--- a/src/common/init.cpp
+++ b/src/common/init.cpp
@@ -6,10 +6,8 @@
 #include <common/args.h>
 #include <common/init.h>
 #include <logging.h>
-#include <node/interface_ui.h>
 #include <tinyformat.h>
 #include <util/fs.h>
-#include <util/fs_helpers.h>
 #include <util/translation.h>
 
 #include <algorithm>
@@ -63,77 +61,30 @@ std::optional<ConfigError> InitConfig(ArgsManager& args, SettingsAbortFn setting
         if (!fs::exists(net_path)) {
             fs::create_directories(net_path / "wallets");
         }
-#ifdef __APPLE__
-        struct PathCheck {
-            fs::path path;
-            std::string_view description;
-        };
 
-        std::array<PathCheck, 2> paths{{
-            {args.GetDataDirNet(), "data directory"},
-            {args.GetBlocksDirPath(), "blocks directory"}
-        }};
-
-        std::vector<std::string> exfat_paths;
-        std::vector<std::string> error_paths;
-
-        for (const auto& check : paths) {
-            FSType fs_type = GetFilesystemType(check.path);
-            switch(fs_type) {
-                case FSType::EXFAT:
-                    exfat_paths.push_back(strprintf("%s (\"%s\")",
-                        check.description,
-                        fs::PathToString(check.path)));
-                    break;
-                case FSType::ERROR:
-                    error_paths.push_back(strprintf("%s (\"%s\")",
-                        check.description,
-                        fs::PathToString(check.path)));
-                    break;
-                default:
-                    break;
-            }
-        }
-
-        if (!exfat_paths.empty()) {
-            InitWarning(strprintf(_("The following paths are on exFAT which is known to have intermittent corruption problems on MacOS: %s"),
-                util::Join(exfat_paths, ", ")));
-        }
-
-        if (!error_paths.empty()) {
-            LogInfo("Failed to detect filesystem type for: %s\n", util::Join(error_paths, ", "));
-        }
-#endif
-        // Show an error or warn/log if there is a bitcoin.conf file in the
+        // Show an error or warning if there is a bitcoin.conf file in the
         // datadir that is being ignored.
         const fs::path base_config_path = base_path / BITCOIN_CONF_FILENAME;
-        if (fs::exists(base_config_path)) {
-            if (orig_config_path.empty()) {
-                LogInfo(
-                    "Data directory %s contains a %s file which is explicitly ignored using -noconf.",
-                    fs::quoted(fs::PathToString(base_path)),
-                    fs::quoted(BITCOIN_CONF_FILENAME));
-            } else if (!fs::equivalent(orig_config_path, base_config_path)) {
-                const std::string cli_config_path = args.GetArg("-conf", "");
-                const std::string config_source = cli_config_path.empty()
-                    ? strprintf("data directory %s", fs::quoted(fs::PathToString(orig_datadir_path)))
-                    : strprintf("command line argument %s", fs::quoted("-conf=" + cli_config_path));
-                std::string error = strprintf(
-                    "Data directory %1$s contains a %2$s file which is ignored, because a different configuration file "
-                    "%3$s from %4$s is being used instead. Possible ways to address this would be to:\n"
-                    "- Delete or rename the %2$s file in data directory %1$s.\n"
-                    "- Change datadir= or conf= options to specify one configuration file, not two, and use "
-                    "includeconf= to include any other configuration files.",
-                    fs::quoted(fs::PathToString(base_path)),
-                    fs::quoted(BITCOIN_CONF_FILENAME),
-                    fs::quoted(fs::PathToString(orig_config_path)),
-                    config_source);
-                if (args.GetBoolArg("-allowignoredconf", false)) {
-                    LogWarning("%s", error);
-                } else {
-                    error += "\n- Set allowignoredconf=1 option to treat this condition as a warning, not an error.";
-                    return ConfigError{ConfigStatus::FAILED, Untranslated(error)};
-                }
+        if (fs::exists(base_config_path) && !fs::equivalent(orig_config_path, base_config_path)) {
+            const std::string cli_config_path = args.GetArg("-conf", "");
+            const std::string config_source = cli_config_path.empty()
+                ? strprintf("data directory %s", fs::quoted(fs::PathToString(orig_datadir_path)))
+                : strprintf("command line argument %s", fs::quoted("-conf=" + cli_config_path));
+            const std::string error = strprintf(
+                "Data directory %1$s contains a %2$s file which is ignored, because a different configuration file "
+                "%3$s from %4$s is being used instead. Possible ways to address this would be to:\n"
+                "- Delete or rename the %2$s file in data directory %1$s.\n"
+                "- Change datadir= or conf= options to specify one configuration file, not two, and use "
+                "includeconf= to include any other configuration files.\n"
+                "- Set allowignoredconf=1 option to treat this condition as a warning, not an error.",
+                fs::quoted(fs::PathToString(base_path)),
+                fs::quoted(BITCOIN_CONF_FILENAME),
+                fs::quoted(fs::PathToString(orig_config_path)),
+                config_source);
+            if (args.GetBoolArg("-allowignoredconf", false)) {
+                LogPrintf("Warning: %s\n", error);
+            } else {
+                return ConfigError{ConfigStatus::FAILED, Untranslated(error)};
             }
         }
 
diff --git a/src/common/run_command.cpp b/src/common/run_command.cpp
index 16fece02f0..67608b985f 100644
--- a/src/common/run_command.cpp
+++ b/src/common/run_command.cpp
@@ -24,7 +24,7 @@ UniValue RunCommandParseJSON(const std::string& str_command, const std::string&
 
     if (str_command.empty()) return UniValue::VNULL;
 
-    auto c = sp::Popen(str_command, sp::input{sp::PIPE}, sp::output{sp::PIPE}, sp::error{sp::PIPE}, sp::close_fds{true});
+    auto c = sp::Popen(str_command, sp::input{sp::PIPE}, sp::output{sp::PIPE}, sp::error{sp::PIPE});
     if (!str_std_in.empty()) {
         c.send(str_std_in);
     }
diff --git a/src/common/settings.cpp b/src/common/settings.cpp
index 576ef285ac..c1520dacd2 100644
--- a/src/common/settings.cpp
+++ b/src/common/settings.cpp
@@ -24,7 +24,6 @@ namespace {
 enum class Source {
    FORCED,
    COMMAND_LINE,
-   CONFIG_FILE_RW,
    RW_SETTINGS,
    CONFIG_FILE_NETWORK_SECTION,
    CONFIG_FILE_DEFAULT_SECTION
@@ -49,10 +48,6 @@ static void MergeSettings(const Settings& settings, const std::string& section,
     if (auto* values = FindKey(settings.command_line_options, name)) {
         fn(SettingsSpan(*values), Source::COMMAND_LINE);
     }
-    // Merge in the rw config file
-    if (auto* values = FindKey(settings.rw_config, name)) {
-        fn(SettingsSpan(*values), Source::CONFIG_FILE_RW);
-    }
     // Merge in the read-write settings
     if (const SettingsValue* value = FindKey(settings.rw_settings, name)) {
         fn(SettingsSpan(*value), Source::RW_SETTINGS);
@@ -170,7 +165,7 @@ SettingsValue GetSetting(const Settings& settings,
         // the config file the precedence is reversed for all settings except
         // chain type settings.
         const bool reverse_precedence =
-            (source == Source::CONFIG_FILE_RW || source == Source::CONFIG_FILE_NETWORK_SECTION || source == Source::CONFIG_FILE_DEFAULT_SECTION) &&
+            (source == Source::CONFIG_FILE_NETWORK_SECTION || source == Source::CONFIG_FILE_DEFAULT_SECTION) &&
             !get_chain_type;
 
         // Weird behavior preserved for backwards compatibility: Negated
@@ -222,7 +217,7 @@ std::vector<SettingsValue> GetSettingsList(const Settings& settings,
         // settings will be brought back from the dead (but earlier command
         // line settings will still be ignored).
         const bool add_zombie_config_values =
-            (source == Source::CONFIG_FILE_RW || source == Source::CONFIG_FILE_NETWORK_SECTION || source == Source::CONFIG_FILE_DEFAULT_SECTION) &&
+            (source == Source::CONFIG_FILE_NETWORK_SECTION || source == Source::CONFIG_FILE_DEFAULT_SECTION) &&
             !prev_negated_empty;
 
         // Ignore settings in default config section if requested.
diff --git a/src/common/settings.h b/src/common/settings.h
index e00f580314..0e9d376e23 100644
--- a/src/common/settings.h
+++ b/src/common/settings.h
@@ -34,8 +34,6 @@ struct Settings {
     std::map<std::string, SettingsValue> forced_settings;
     //! Map of setting name to list of command line values.
     std::map<std::string, std::vector<SettingsValue>> command_line_options;
-    //! Map of setting name to list of r/w config file values.
-    std::map<std::string, std::vector<SettingsValue>> rw_config;
     //! Map of setting name to read-write file setting value.
     std::map<std::string, SettingsValue> rw_settings;
     //! Map of config section name and setting name to list of config file values.
diff --git a/src/common/signmessage.cpp b/src/common/signmessage.cpp
index 3fcec13d93..1612751e44 100644
--- a/src/common/signmessage.cpp
+++ b/src/common/signmessage.cpp
@@ -4,14 +4,10 @@
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
 #include <common/signmessage.h>
-#include <core_io.h>
 #include <hash.h>
 #include <key.h>
 #include <key_io.h>
-#include <outputtype.h>
 #include <pubkey.h>
-#include <script/interpreter.h>
-#include <streams.h>
 #include <uint256.h>
 #include <util/strencodings.h>
 
@@ -27,115 +23,32 @@
  */
 const std::string MESSAGE_MAGIC = "Bitcoin Signed Message:\n";
 
-/**
- * BIP-322 tagged hash
- */
-static const HashWriter HASHER_BIP322{TaggedHash("BIP0322-signed-message")};
-
-static constexpr unsigned int BIP322_REQUIRED_FLAGS =
-    SCRIPT_VERIFY_CONST_SCRIPTCODE // disallows OP_CODESEPARATOR and FindAndDelete
-|   SCRIPT_VERIFY_LOW_S
-|   SCRIPT_VERIFY_STRICTENC
-|   SCRIPT_VERIFY_NULLFAIL
-|   SCRIPT_VERIFY_MINIMALDATA
-|   SCRIPT_VERIFY_CLEANSTACK
-|   SCRIPT_VERIFY_P2SH
-|   SCRIPT_VERIFY_WITNESS
-|   SCRIPT_VERIFY_TAPROOT
-|   SCRIPT_VERIFY_MINIMALIF;
-
-static constexpr unsigned int BIP322_INCONCLUSIVE_FLAGS =
-    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS
-|   SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS
-|   SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE
-|   SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION
-|   SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM;
-
-MessageVerificationResult MessageVerifyBIP322(
-    CTxDestination& destination,
-    std::vector<unsigned char>& signature,
-    const std::string& message,
-    MessageVerificationResult legacyError)
-{
-    auto txs = BIP322Txs::Create(destination, message, legacyError, signature);
-    if (!txs) return legacyError;
-
-    const CTransaction& to_sign = txs->m_to_sign;
-    const CTransaction& to_spend = txs->m_to_spend;
-
-    const CScript scriptSig = to_sign.vin[0].scriptSig;
-    const CScriptWitness& witness = to_sign.vin[0].scriptWitness;
-
-    PrecomputedTransactionData txdata;
-    txdata.Init(to_sign, {to_spend.vout[0]});
-    TransactionSignatureChecker sigcheck(&to_sign, /* nInIn= */ 0, /* amountIn= */ to_spend.vout[0].nValue, txdata, MissingDataBehavior::ASSERT_FAIL);
-    sigcheck.m_require_sighash_all = true;
-
-    if (!VerifyScript(scriptSig, to_spend.vout[0].scriptPubKey, &witness, BIP322_REQUIRED_FLAGS, sigcheck)) {
-        return MessageVerificationResult::ERR_INVALID;
-    }
-
-    // inconclusive checks
-
-    if (to_sign.version != 0 && to_sign.version != 2) {
-        return MessageVerificationResult::INCONCLUSIVE;
-    }
-
-    if (!VerifyScript(scriptSig, to_spend.vout[0].scriptPubKey, &witness, BIP322_INCONCLUSIVE_FLAGS, sigcheck)) {
-        return MessageVerificationResult::INCONCLUSIVE;
-    }
-
-    return MessageVerificationResult::OK;
-}
-
 MessageVerificationResult MessageVerify(
     const std::string& address,
     const std::string& signature,
     const std::string& message)
 {
-    auto signature_bytes = DecodeBase64(signature);
-    if (!signature_bytes) {
-        return MessageVerificationResult::ERR_MALFORMED_SIGNATURE;
-    }
-
     CTxDestination destination = DecodeDestination(address);
     if (!IsValidDestination(destination)) {
         return MessageVerificationResult::ERR_INVALID_ADDRESS;
     }
 
-    OutputType signed_for_outputtype;
-    if (std::holds_alternative<PKHash>(destination)) {
-        signed_for_outputtype = OutputType::LEGACY;
-    } else if (std::holds_alternative<ScriptHash>(destination)) {
-        signed_for_outputtype = OutputType::P2SH_SEGWIT;
-    } else if (std::holds_alternative<WitnessV0KeyHash>(destination)) {
-        signed_for_outputtype = OutputType::BECH32;
-    } else {
-        return MessageVerifyBIP322(destination, *signature_bytes, message, MessageVerificationResult::ERR_ADDRESS_NO_KEY);
+    if (std::get_if<PKHash>(&destination) == nullptr) {
+        return MessageVerificationResult::ERR_ADDRESS_NO_KEY;
     }
 
-    uint8_t sigtype{(*signature_bytes)[0]};
-    if (sigtype < 27 || sigtype > 42) {
-        return MessageVerifyBIP322(destination, *signature_bytes, message, MessageVerificationResult::ERR_MALFORMED_SIGNATURE);
-    }
-    sigtype = (sigtype - 27) >> 2;
-    if (sigtype == 3) {
-        (*signature_bytes)[0] -= 8;
-        signed_for_outputtype = OutputType::BECH32;
-    } else if (sigtype == 2) {
-        (*signature_bytes)[0] -= 4;
-        signed_for_outputtype = OutputType::P2SH_SEGWIT;
+    auto signature_bytes = DecodeBase64(signature);
+    if (!signature_bytes) {
+        return MessageVerificationResult::ERR_MALFORMED_SIGNATURE;
     }
 
     CPubKey pubkey;
-    if (!pubkey.RecoverCompact(MessageHash(message, MessageSignatureFormat::LEGACY), *signature_bytes)) {
-        return MessageVerifyBIP322(destination, *signature_bytes, message, MessageVerificationResult::ERR_PUBKEY_NOT_RECOVERED);
+    if (!pubkey.RecoverCompact(MessageHash(message), *signature_bytes)) {
+        return MessageVerificationResult::ERR_PUBKEY_NOT_RECOVERED;
     }
 
-    CTxDestination recovered_dest = GetDestinationForKey(pubkey, signed_for_outputtype);
-
-    if (!(recovered_dest == destination)) {
-        return MessageVerifyBIP322(destination, *signature_bytes, message, MessageVerificationResult::ERR_NOT_SIGNED);
+    if (!(PKHash(pubkey) == *std::get_if<PKHash>(&destination))) {
+        return MessageVerificationResult::ERR_NOT_SIGNED;
     }
 
     return MessageVerificationResult::OK;
@@ -148,7 +61,7 @@ bool MessageSign(
 {
     std::vector<unsigned char> signature_bytes;
 
-    if (!privkey.SignCompact(MessageHash(message, MessageSignatureFormat::LEGACY), signature_bytes)) {
+    if (!privkey.SignCompact(MessageHash(message), signature_bytes)) {
         return false;
     }
 
@@ -157,28 +70,12 @@ bool MessageSign(
     return true;
 }
 
-uint256 MessageHash(const std::string& message, MessageSignatureFormat format)
+uint256 MessageHash(const std::string& message)
 {
-    switch (format) {
-    case MessageSignatureFormat::LEGACY:
-        {
     HashWriter hasher{};
     hasher << MESSAGE_MAGIC << message;
 
     return hasher.GetHash();
-        }
-
-    case MessageSignatureFormat::SIMPLE:
-    case MessageSignatureFormat::FULL:
-        {
-            HashWriter hasher{HASHER_BIP322};
-            if (!message.empty()) {
-                hasher.write(AsBytes(Span{message.data(), message.size() * sizeof(char)}));
-            }
-            return hasher.GetSHA256();
-        }
-    }
-    assert(false);
 }
 
 std::string SigningResultString(const SigningResult res)
@@ -194,65 +91,3 @@ std::string SigningResultString(const SigningResult res)
     }
     assert(false);
 }
-
-std::optional<BIP322Txs> BIP322Txs::Create(const CTxDestination& destination, const std::string& message, MessageVerificationResult& result, std::optional<const std::vector<unsigned char>> signature)
-{
-    // attempt to get script pub key for destination
-    CScript message_challenge = GetScriptForDestination(destination);
-    if (message_challenge.size() == 0) {
-        // NoDestination; failure
-        // (use legacy result)
-        return std::nullopt;
-    }
-
-    // prepare message hash
-    uint256 message_hash = MessageHash(message, MessageSignatureFormat::SIMPLE);
-    std::vector<unsigned char> message_hash_vec(message_hash.begin(), message_hash.end());
-
-    // generate to_spend transaction
-    CMutableTransaction to_spend;
-    to_spend.version = 0;
-    to_spend.nLockTime = 0;
-    to_spend.vin.emplace_back(COutPoint(Txid::FromUint256(uint256::ZERO), 0xFFFFFFFF), (CScript() << OP_0 << message_hash_vec), 0);
-    to_spend.vout.emplace_back(0, message_challenge);
-
-    CMutableTransaction to_sign;
-    if (signature.has_value() && DecodeTx(to_sign, signature.value(), /* try_no_witness= */ true, /* try_witness= */ true)) {
-        // validate decoded transaction
-        // multiple inputs (proof of funds) are not supported as we do not have UTXO set access
-        if (to_sign.vin.size() > 1) {
-            result = MessageVerificationResult::ERR_POF;
-            return std::nullopt;
-        }
-        if ((to_sign.vin.size() == 0 || to_sign.vin[0].prevout.hash != to_spend.GetHash()) ||
-            (to_sign.vin[0].prevout.n != 0) ||
-            (to_sign.vout.size() != 1) ||
-            (to_sign.vout[0].nValue != 0) ||
-            (to_sign.vout[0].scriptPubKey != (CScript() << OP_RETURN))) {
-            result = MessageVerificationResult::ERR_INVALID;
-            return std::nullopt;
-        }
-    } else {
-        // signature is missing, or a witness stack only
-        to_sign.version = 0;
-        to_sign.nLockTime = 0;
-        to_sign.vin.emplace_back(COutPoint(to_spend.GetHash(), 0), CScript(), 0);
-        if (signature.has_value()) {
-            try {
-                DataStream ds(signature.value());
-                ds >> to_sign.vin[0].scriptWitness.stack;
-                if (!ds.empty()) {
-                    result = MessageVerificationResult::ERR_INVALID;
-                    return std::nullopt;
-                }
-            } catch (...) {
-                // not a script witness either; fall back to legacy error
-                // (use legacy result)
-                return std::nullopt;
-            }
-        }
-        to_sign.vout.emplace_back(0, CScript() << OP_RETURN);
-    }
-
-    return BIP322Txs{to_spend, to_sign};
-}
diff --git a/src/common/signmessage.h b/src/common/signmessage.h
index 3e276e6137..215b563bbb 100644
--- a/src/common/signmessage.h
+++ b/src/common/signmessage.h
@@ -6,29 +6,14 @@
 #ifndef BITCOIN_COMMON_SIGNMESSAGE_H
 #define BITCOIN_COMMON_SIGNMESSAGE_H
 
-#include <addresstype.h>
-#include <primitives/transaction.h>
 #include <uint256.h>
 
-#include <optional>
 #include <string>
-#include <vector>
 
 class CKey;
 
 extern const std::string MESSAGE_MAGIC;
 
-enum class MessageSignatureFormat {
-    //! Legacy format, which only works on legacy addresses
-    LEGACY,
-
-    //! Simple BIP-322 format, i.e. the script witness stack only
-    SIMPLE,
-
-    //! Full BIP-322 format, i.e. the serialized to_sign transaction in full
-    FULL,
-};
-
 /** The result of a signed message verification.
  * Message verification takes as an input:
  * - address (with whose private key the message is supposed to have been signed)
@@ -52,20 +37,7 @@ enum class MessageVerificationResult {
     ERR_NOT_SIGNED,
 
     //! The message verification was successful.
-    OK,
-
-    //
-    // BIP-322 extensions
-    //
-
-    //! The validator was unable to check the scripts (BIP-322)
-    INCONCLUSIVE,
-
-    //! Some check failed (BIP-322)
-    ERR_INVALID,
-
-    //! Proof of funds require the wallet-enabled verifier (BIP-322)
-    ERR_POF,
+    OK
 };
 
 enum class SigningResult {
@@ -75,7 +47,7 @@ enum class SigningResult {
 };
 
 /** Verify a signed message.
- * @param[in] address Signer's bitcoin address.
+ * @param[in] address Signer's bitcoin address, it must refer to a public key.
  * @param[in] signature The signature in base64 format.
  * @param[in] message The message that was signed.
  * @return result code */
@@ -84,7 +56,7 @@ MessageVerificationResult MessageVerify(
     const std::string& signature,
     const std::string& message);
 
-/** Sign a message using legacy format.
+/** Sign a message.
  * @param[in] privkey Private key to sign with.
  * @param[in] message The message to sign.
  * @param[out] signature Signature, base64 encoded, only set if true is returned.
@@ -98,23 +70,8 @@ bool MessageSign(
  * Hashes a message for signing and verification in a manner that prevents
  * inadvertently signing a transaction.
  */
-uint256 MessageHash(const std::string& message, MessageSignatureFormat format);
+uint256 MessageHash(const std::string& message);
 
 std::string SigningResultString(const SigningResult res);
 
-/**
- * Generate the BIP-322 tx corresponding to the given challenge
- */
-class BIP322Txs {
-private:
-    template<class T1, class T2>
-    BIP322Txs(const T1& to_spend, const T2& to_sign) : m_to_spend{to_spend}, m_to_sign{to_sign} { }
-
-public:
-    static std::optional<BIP322Txs> Create(const CTxDestination& destination, const std::string& message, MessageVerificationResult& result, std::optional<const std::vector<unsigned char>> = std::nullopt);
-
-    const CTransaction m_to_spend;
-    const CTransaction m_to_sign;
-};
-
 #endif // BITCOIN_COMMON_SIGNMESSAGE_H
diff --git a/src/common/system.cpp b/src/common/system.cpp
index ca27dad806..6d04c8a7bc 100644
--- a/src/common/system.cpp
+++ b/src/common/system.cpp
@@ -22,10 +22,6 @@
 #include <malloc.h>
 #endif
 
-#ifdef HAVE_LINUX_SYSINFO
-#include <sys/sysinfo.h>
-#endif
-
 #include <cstdlib>
 #include <locale>
 #include <stdexcept>
@@ -37,12 +33,14 @@ using util::ReplaceAll;
 // Application startup time (used for uptime calculation)
 const int64_t nStartupTime = GetTime();
 
+#ifndef WIN32
 std::string ShellEscape(const std::string& arg)
 {
     std::string escaped = arg;
-    ReplaceAll(escaped, "'", "'\\''");
+    ReplaceAll(escaped, "'", "'\"'\"'");
     return "'" + escaped + "'";
 }
+#endif
 
 #if HAVE_SYSTEM
 void runCommand(const std::string& strCommand)
@@ -112,39 +110,3 @@ int64_t GetStartupTime()
 {
     return nStartupTime;
 }
-
-size_t g_low_memory_threshold = 10 * 1024 * 1024 /* 10 MB */;
-
-bool SystemNeedsMemoryReleased()
-{
-    if (g_low_memory_threshold <= 0) {
-        // Intentionally bypass other metrics when disabled entirely
-        return false;
-    }
-#ifdef WIN32
-    MEMORYSTATUSEX mem_status;
-    mem_status.dwLength = sizeof(mem_status);
-    if (GlobalMemoryStatusEx(&mem_status)) {
-        if (mem_status.dwMemoryLoad >= 99 ||
-            mem_status.ullAvailPhys < g_low_memory_threshold ||
-            mem_status.ullAvailVirtual < g_low_memory_threshold) {
-            LogPrintf("%s: YES: %s%% memory load; %s available physical memory; %s available virtual memory\n", __func__, int(mem_status.dwMemoryLoad), size_t(mem_status.ullAvailPhys), size_t(mem_status.ullAvailVirtual));
-            return true;
-        }
-    }
-#endif
-#ifdef HAVE_LINUX_SYSINFO
-    struct sysinfo sys_info;
-    if (!sysinfo(&sys_info)) {
-        // Explicitly 64-bit in case of 32-bit userspace on 64-bit kernel
-        const uint64_t free_ram = uint64_t(sys_info.freeram) * sys_info.mem_unit;
-        const uint64_t buffer_ram = uint64_t(sys_info.bufferram) * sys_info.mem_unit;
-        if (free_ram + buffer_ram < g_low_memory_threshold) {
-            LogPrintf("%s: YES: %s free RAM + %s buffer RAM\n", __func__, free_ram, buffer_ram);
-            return true;
-        }
-    }
-#endif
-    // NOTE: sysconf(_SC_AVPHYS_PAGES) doesn't account for caches on at least Linux, so not safe to use here
-    return false;
-}
diff --git a/src/common/system.h b/src/common/system.h
index 1cb3729da3..d9115d3b33 100644
--- a/src/common/system.h
+++ b/src/common/system.h
@@ -16,15 +16,13 @@ int64_t GetStartupTime();
 
 void SetupEnvironment();
 [[nodiscard]] bool SetupNetworking();
+#ifndef WIN32
 std::string ShellEscape(const std::string& arg);
+#endif
 #if HAVE_SYSTEM
 void runCommand(const std::string& strCommand);
 #endif
 
-extern size_t g_low_memory_threshold;
-
-bool SystemNeedsMemoryReleased();
-
 /**
  * Return the number of cores available on the current system.
  * @note This does count virtual cores, such as those provided by HyperThreading.
diff --git a/src/consensus/merkle.cpp b/src/consensus/merkle.cpp
index 088e09a01e..af01902c92 100644
--- a/src/consensus/merkle.cpp
+++ b/src/consensus/merkle.cpp
@@ -47,10 +47,7 @@ uint256 ComputeMerkleRoot(std::vector<uint256> hashes, bool* mutated) {
     while (hashes.size() > 1) {
         if (mutated) {
             for (size_t pos = 0; pos + 1 < hashes.size(); pos += 2) {
-                if (hashes[pos] == hashes[pos + 1]) {
-                    mutation = true;
-                    break;
-                }
+                if (hashes[pos] == hashes[pos + 1]) mutation = true;
             }
         }
         if (hashes.size() & 1) {
diff --git a/src/core_io.h b/src/core_io.h
index ec4f8531ee..9305bb7239 100644
--- a/src/core_io.h
+++ b/src/core_io.h
@@ -10,11 +10,9 @@
 
 #include <string>
 #include <vector>
-#include <optional>
 
 class CBlock;
 class CBlockHeader;
-class CFeeRate;
 class CScript;
 class CTransaction;
 struct CMutableTransaction;
@@ -35,7 +33,6 @@ enum class TxVerbosity {
 // core_read.cpp
 CScript ParseScript(const std::string& s);
 std::string ScriptToAsmStr(const CScript& script, const bool fAttemptSighashDecode = false);
-[[nodiscard]] bool DecodeTx(CMutableTransaction& tx, const std::vector<unsigned char>& tx_data, bool try_no_witness, bool try_witness);
 [[nodiscard]] bool DecodeHexTx(CMutableTransaction& tx, const std::string& hex_tx, bool try_no_witness = false, bool try_witness = true);
 [[nodiscard]] bool DecodeHexBlk(CBlock&, const std::string& strHexBlk);
 bool DecodeHexBlockHeader(CBlockHeader&, const std::string& hex_header);
@@ -44,7 +41,6 @@ bool DecodeHexBlockHeader(CBlockHeader&, const std::string& hex_header);
 
 // core_write.cpp
 UniValue ValueFromAmount(const CAmount amount);
-UniValue ValueFromFeeRate(const CFeeRate& fee_rate);
 std::string FormatScript(const CScript& script);
 std::string EncodeHexTx(const CTransaction& tx);
 std::string SighashToStr(unsigned char sighash_type);
diff --git a/src/core_read.cpp b/src/core_read.cpp
index 9579f5e070..23f341c230 100644
--- a/src/core_read.cpp
+++ b/src/core_read.cpp
@@ -122,7 +122,7 @@ static bool CheckTxScriptsSanity(const CMutableTransaction& tx)
     return true;
 }
 
-bool DecodeTx(CMutableTransaction& tx, const std::vector<unsigned char>& tx_data, bool try_no_witness, bool try_witness)
+static bool DecodeTx(CMutableTransaction& tx, const std::vector<unsigned char>& tx_data, bool try_no_witness, bool try_witness)
 {
     // General strategy:
     // - Decode both with extended serialization (which interprets the 0x0001 tag as a marker for
diff --git a/src/core_write.cpp b/src/core_write.cpp
index 2c761ec6e8..253dfde100 100644
--- a/src/core_write.cpp
+++ b/src/core_write.cpp
@@ -9,7 +9,6 @@
 #include <consensus/consensus.h>
 #include <consensus/validation.h>
 #include <key_io.h>
-#include <policy/feerate.h>
 #include <script/descriptor.h>
 #include <script/script.h>
 #include <script/solver.h>
@@ -37,11 +36,6 @@ UniValue ValueFromAmount(const CAmount amount)
             strprintf("%s%d.%08d", amount < 0 ? "-" : "", quotient, remainder));
 }
 
-UniValue ValueFromFeeRate(const CFeeRate& fee_rate)
-{
-    return UniValue(UniValue::VNUM, fee_rate.SatsToString());
-}
-
 std::string FormatScript(const CScript& script)
 {
     std::string ret;
@@ -187,7 +181,6 @@ void TxToUniv(const CTransaction& tx, const uint256& block_hash, UniValue& entry
     entry.pushKV("locktime", (int64_t)tx.nLockTime);
 
     UniValue vin{UniValue::VARR};
-    vin.reserve(tx.vin.size());
 
     // If available, use Undo data to calculate the fee. Note that txundo == nullptr
     // for coinbase transactions and for transactions where undo data is unavailable.
@@ -210,7 +203,6 @@ void TxToUniv(const CTransaction& tx, const uint256& block_hash, UniValue& entry
         }
         if (!tx.vin[i].scriptWitness.IsNull()) {
             UniValue txinwitness(UniValue::VARR);
-            txinwitness.reserve(tx.vin[i].scriptWitness.stack.size());
             for (const auto& item : tx.vin[i].scriptWitness.stack) {
                 txinwitness.push_back(HexStr(item));
             }
@@ -240,7 +232,6 @@ void TxToUniv(const CTransaction& tx, const uint256& block_hash, UniValue& entry
     entry.pushKV("vin", std::move(vin));
 
     UniValue vout(UniValue::VARR);
-    vout.reserve(tx.vout.size());
     for (unsigned int i = 0; i < tx.vout.size(); i++) {
         const CTxOut& txout = tx.vout[i];
 
diff --git a/src/crypto/sha256.cpp b/src/crypto/sha256.cpp
index fb9df7b4e4..deedc0a6d1 100644
--- a/src/crypto/sha256.cpp
+++ b/src/crypto/sha256.cpp
@@ -62,15 +62,6 @@ void Transform_2way(unsigned char* out, const unsigned char* in);
 }
 #endif // DISABLE_OPTIMIZED_SHA256
 
-#if defined(__linux__) && defined(ENABLE_POWER8)
-#include <sys/auxv.h>
-namespace sha256_power8
-{
-void Transform_4way(unsigned char* out, const unsigned char* in);
-}
-#endif
-
-
 // Internal implementation code.
 namespace
 {
@@ -660,13 +651,7 @@ std::string SHA256AutoDetect(sha256_implementation::UseImplementation use_implem
         ret += ",avx2(8way)";
     }
 #endif
-#elif (defined(__linux__)) && defined(ENABLE_POWER8)
-    if (getauxval(AT_HWCAP2) & 0x02000000) {
-        TransformD64_4way = sha256_power8::Transform_4way;
-        assert(SelfTest());
-        return "power8(4way),C(1way)";
-    }
-#endif
+#endif // defined(HAVE_GETCPUID)
 
 #if defined(ENABLE_ARM_SHANI)
     bool have_arm_shani = false;
diff --git a/src/crypto/sha256_avx2.cpp b/src/crypto/sha256_avx2.cpp
index 8d837148fe..df8cb7a6c9 100644
--- a/src/crypto/sha256_avx2.cpp
+++ b/src/crypto/sha256_avx2.cpp
@@ -10,12 +10,6 @@
 #include <attributes.h>
 #include <crypto/common.h>
 
-#if defined(__clang__)
-#pragma clang attribute push(__attribute__((__target__("avx,avx2"))), apply_to = function)
-#elif defined(__GNUC__)
-#pragma GCC target ("avx,avx2")
-#endif
-
 namespace sha256d64_avx2 {
 namespace {
 
@@ -332,8 +326,4 @@ void Transform_8way(unsigned char* out, const unsigned char* in)
 
 }
 
-#if defined(__clang__)
-#pragma clang attribute pop
-#endif
-
 #endif
diff --git a/src/crypto/sha256_power8.cpp b/src/crypto/sha256_power8.cpp
deleted file mode 100644
index 4819f477c7..0000000000
--- a/src/crypto/sha256_power8.cpp
+++ /dev/null
@@ -1,411 +0,0 @@
-// Copyright (c) 2017 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-//
-// This is a translation to GCC extended asm syntax from YASM code by Intel
-// (available at the bottom of this file).
-
-#if defined(HAVE_CONFIG_H)
-#include <config/bitcoin-config.h>
-#endif
-
-#include <stdint.h>
-
-#if defined(HAVE_ENDIAN_H)
-#include <endian.h>
-#elif defined(HAVE_SYS_ENDIAN_H)
-#include <sys/endian.h>
-#endif
-
-#include <altivec.h>
-
-#if defined(__clang__)
-#pragma clang attribute push(__attribute__((__target__("power8-vector"))), apply_to = function)
-#elif defined(__GNUC__)
-#pragma GCC target ("power8-vector")
-#endif
-
-namespace sha256_power8
-{
-
-typedef __vector uint32_t uint32x4_p8;
-typedef __vector uint8_t uint8x16_p8;
-
-//! Gets the first uin32_t from a, b, c, d, converts from BE to host endian, and returns them concatenated
-template<uint8_t OFFS> static inline uint32x4_p8 pack_bytes
-        (const uint8x16_p8 a, const uint8x16_p8 b, const uint8x16_p8 c, const uint8x16_p8 d) {
-    uint8x16_p8 perm1 = {0+OFFS,1+OFFS,2+OFFS,3+OFFS, 16+OFFS,17+OFFS,18+OFFS,19+OFFS, 0,0,0,0, 0,0,0,0};
-#ifdef WORDS_BIGENDIAN
-    uint8x16_p8 perm2 = {0,1,2,3, 4,5,6,7, 16,17,18,19, 20,21,22,23};
-#else
-    uint8x16_p8 perm2 = {3,2,1,0, 7,6,5,4, 19,18,17,16, 23,22,21,20};
-#endif
-    return (uint32x4_p8)vec_perm(vec_perm((uint8x16_p8)a, (uint8x16_p8)b, perm1), vec_perm((uint8x16_p8)c, (uint8x16_p8)d, perm1), perm2);
-}
-
-static const __attribute__((aligned(16))) uint32_t K[] = {
-    0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
-    0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
-    0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
-    0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
-    0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
-    0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
-    0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
-    0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
-    0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
-    0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
-    0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
-    0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
-    0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
-    0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
-    0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
-    0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
-};
-
-#define Ch(x, y, z) vec_sel((z), (y), (x))
-#define Maj(x, y, z) vec_sel((y), (z), vec_xor((x), (y)))
-
-#define KRound(a, b, c, d, e, f, g, h, k, w) \
-    do { \
-        uint32x4_p8 t1 = h + Ch(e, f, g) + __builtin_crypto_vshasigmaw(e, 1, 0xf) + k + w; \
-        uint32x4_p8 t2 = Maj(a, b, c) + __builtin_crypto_vshasigmaw(a, 1, 0); \
-        d += t1; \
-        h = t1 + t2; \
-    } while(false);
-
-#define Round(a, b, c, d, e, f, g, h, k, w) \
-    do { \
-        uint32x4_p8 kay = {k, k, k, k}; \
-        uint32x4_p8 t1 = h + Ch(e, f, g) + __builtin_crypto_vshasigmaw(e, 1, 0xf) + kay + w; \
-        uint32x4_p8 t2 = Maj(a, b, c) + __builtin_crypto_vshasigmaw(a, 1, 0); \
-        d += t1; \
-        h = t1 + t2; \
-    } while(false);
-
-#define KRound2(a, b, c, d, e, f, g, h, k) \
-    do { \
-        uint32x4_p8 t1 = h + Ch(e, f, g) + __builtin_crypto_vshasigmaw(e, 1, 0xf) + k; \
-        uint32x4_p8 t2 = Maj(a, b, c) + __builtin_crypto_vshasigmaw(a, 1, 0); \
-        d += t1; \
-        h = t1 + t2; \
-    } while(false);
-
-#define Round2(a, b, c, d, e, f, g, h, k) \
-    do { \
-        uint32x4_p8 kay = {k, k, k, k}; \
-        uint32x4_p8 t1 = h + Ch(e, f, g) + __builtin_crypto_vshasigmaw(e, 1, 0xf) + kay; \
-        uint32x4_p8 t2 = Maj(a, b, c) + __builtin_crypto_vshasigmaw(a, 1, 0); \
-        d += t1; \
-        h = t1 + t2; \
-    } while(false);
-
-#define sigma0(w) __builtin_crypto_vshasigmaw(w, 0, 0)
-#define sigma1(w) __builtin_crypto_vshasigmaw(w, 0, 0xf)
-
-/** Perform a 4 double-SHA-256 64-byte updates at once*/
-void Transform_4way(unsigned char* out, const unsigned char* in)
-{
-    uint32x4_p8 a = {0x6a09e667ul, 0x6a09e667ul, 0x6a09e667ul, 0x6a09e667ul};
-    uint32x4_p8 b = {0xbb67ae85ul, 0xbb67ae85ul, 0xbb67ae85ul, 0xbb67ae85ul};
-    uint32x4_p8 c = {0x3c6ef372ul, 0x3c6ef372ul, 0x3c6ef372ul, 0x3c6ef372ul};
-    uint32x4_p8 d = {0xa54ff53aul, 0xa54ff53aul, 0xa54ff53aul, 0xa54ff53aul};
-    uint32x4_p8 e = {0x510e527ful, 0x510e527ful, 0x510e527ful, 0x510e527ful};
-    uint32x4_p8 f = {0x9b05688cul, 0x9b05688cul, 0x9b05688cul, 0x9b05688cul};
-    uint32x4_p8 g = {0x1f83d9abul, 0x1f83d9abul, 0x1f83d9abul, 0x1f83d9abul};
-    uint32x4_p8 h = {0x5be0cd19ul, 0x5be0cd19ul, 0x5be0cd19ul, 0x5be0cd19ul};
-
-    uint8x16_p8 w0123_0 = vec_vsx_ld(0 *16 + 0  , in);
-    uint8x16_p8 w4567_0 = vec_vsx_ld(1 *16 + 0  , in);
-    uint8x16_p8 w8901_0 = vec_vsx_ld(2 *16 + 0  , in);
-    uint8x16_p8 w2345_0 = vec_vsx_ld(3 *16 + 0  , in);
-
-    uint8x16_p8 w0123_1 = vec_vsx_ld(0 *16 + 64 , in);
-    uint8x16_p8 w4567_1 = vec_vsx_ld(1 *16 + 64 , in);
-    uint8x16_p8 w8901_1 = vec_vsx_ld(2 *16 + 64 , in);
-    uint8x16_p8 w2345_1 = vec_vsx_ld(3 *16 + 64 , in);
-
-    uint8x16_p8 w0123_2 = vec_vsx_ld(0 *16 + 128, in);
-    uint8x16_p8 w4567_2 = vec_vsx_ld(1 *16 + 128, in);
-    uint8x16_p8 w8901_2 = vec_vsx_ld(2 *16 + 128, in);
-    uint8x16_p8 w2345_2 = vec_vsx_ld(3 *16 + 128, in);
-
-    uint8x16_p8 w0123_3 = vec_vsx_ld(0 *16 + 192, in);
-    uint8x16_p8 w4567_3 = vec_vsx_ld(1 *16 + 192, in);
-    uint8x16_p8 w8901_3 = vec_vsx_ld(2 *16 + 192, in);
-    uint8x16_p8 w2345_3 = vec_vsx_ld(3 *16 + 192, in);
-
-    uint32x4_p8 w0  = pack_bytes<0 >(w0123_0, w0123_1, w0123_2, w0123_3);
-    uint32x4_p8 w1  = pack_bytes<4 >(w0123_0, w0123_1, w0123_2, w0123_3);
-    uint32x4_p8 w2  = pack_bytes<8 >(w0123_0, w0123_1, w0123_2, w0123_3);
-    uint32x4_p8 w3  = pack_bytes<12>(w0123_0, w0123_1, w0123_2, w0123_3);
-
-    uint32x4_p8 w4  = pack_bytes<0 >(w4567_0, w4567_1, w4567_2, w4567_3);
-    uint32x4_p8 w5  = pack_bytes<4 >(w4567_0, w4567_1, w4567_2, w4567_3);
-    uint32x4_p8 w6  = pack_bytes<8 >(w4567_0, w4567_1, w4567_2, w4567_3);
-    uint32x4_p8 w7  = pack_bytes<12>(w4567_0, w4567_1, w4567_2, w4567_3);
-
-    uint32x4_p8 w8  = pack_bytes<0 >(w8901_0, w8901_1, w8901_2, w8901_3);
-    uint32x4_p8 w9  = pack_bytes<4 >(w8901_0, w8901_1, w8901_2, w8901_3);
-    uint32x4_p8 w10 = pack_bytes<8 >(w8901_0, w8901_1, w8901_2, w8901_3);
-    uint32x4_p8 w11 = pack_bytes<12>(w8901_0, w8901_1, w8901_2, w8901_3);
-
-    uint32x4_p8 w12 = pack_bytes<0 >(w2345_0, w2345_1, w2345_2, w2345_3);
-    uint32x4_p8 w13 = pack_bytes<4 >(w2345_0, w2345_1, w2345_2, w2345_3);
-    uint32x4_p8 w14 = pack_bytes<8 >(w2345_0, w2345_1, w2345_2, w2345_3);
-    uint32x4_p8 w15 = pack_bytes<12>(w2345_0, w2345_1, w2345_2, w2345_3);
-
-    uint32x4_p8 k = (uint32x4_p8)vec_ld(0, K);
-    KRound(a, b, c, d, e, f, g, h, vec_splat(k, 0), w0);
-    KRound(h, a, b, c, d, e, f, g, vec_splat(k, 1), w1);
-    KRound(g, h, a, b, c, d, e, f, vec_splat(k, 2), w2);
-    KRound(f, g, h, a, b, c, d, e, vec_splat(k, 3), w3);
-    k = (uint32x4_p8)vec_ld(1*16, K);
-    KRound(e, f, g, h, a, b, c, d, vec_splat(k, 0), w4);
-    KRound(d, e, f, g, h, a, b, c, vec_splat(k, 1), w5);
-    KRound(c, d, e, f, g, h, a, b, vec_splat(k, 2), w6);
-    KRound(b, c, d, e, f, g, h, a, vec_splat(k, 3), w7);
-    k = (uint32x4_p8)vec_ld(2*16, K);
-    KRound(a, b, c, d, e, f, g, h, vec_splat(k, 0), w8);
-    KRound(h, a, b, c, d, e, f, g, vec_splat(k, 1), w9);
-    KRound(g, h, a, b, c, d, e, f, vec_splat(k, 2), w10);
-    KRound(f, g, h, a, b, c, d, e, vec_splat(k, 3), w11);
-    k = (uint32x4_p8)vec_ld(3*16, K);
-    KRound(e, f, g, h, a, b, c, d, vec_splat(k, 0), w12);
-    KRound(d, e, f, g, h, a, b, c, vec_splat(k, 1), w13);
-    KRound(c, d, e, f, g, h, a, b, vec_splat(k, 2), w14);
-    KRound(b, c, d, e, f, g, h, a, vec_splat(k, 3), w15);
-
-    for (int i = 0; i < 3; i++) {
-        k = (uint32x4_p8)vec_ld((4+4*i)*16, K);
-        KRound(a, b, c, d, e, f, g, h, vec_splat(k, 0), (w0 += sigma1(w14) + w9 + sigma0(w1)));
-        KRound(h, a, b, c, d, e, f, g, vec_splat(k, 1), (w1 += sigma1(w15) + w10 + sigma0(w2)));
-        KRound(g, h, a, b, c, d, e, f, vec_splat(k, 2), (w2 += sigma1(w0) + w11 + sigma0(w3)));
-        KRound(f, g, h, a, b, c, d, e, vec_splat(k, 3), (w3 += sigma1(w1) + w12 + sigma0(w4)));
-        k = (uint32x4_p8)vec_ld((5+4*i)*16, K);
-        KRound(e, f, g, h, a, b, c, d, vec_splat(k, 0), (w4 += sigma1(w2) + w13 + sigma0(w5)));
-        KRound(d, e, f, g, h, a, b, c, vec_splat(k, 1), (w5 += sigma1(w3) + w14 + sigma0(w6)));
-        KRound(c, d, e, f, g, h, a, b, vec_splat(k, 2), (w6 += sigma1(w4) + w15 + sigma0(w7)));
-        KRound(b, c, d, e, f, g, h, a, vec_splat(k, 3), (w7 += sigma1(w5) + w0 + sigma0(w8)));
-        k = (uint32x4_p8)vec_ld((6+4*i)*16, K);
-        KRound(a, b, c, d, e, f, g, h, vec_splat(k, 0), (w8 += sigma1(w6) + w1 + sigma0(w9)));
-        KRound(h, a, b, c, d, e, f, g, vec_splat(k, 1), (w9 += sigma1(w7) + w2 + sigma0(w10)));
-        KRound(g, h, a, b, c, d, e, f, vec_splat(k, 2), (w10 += sigma1(w8) + w3 + sigma0(w11)));
-        KRound(f, g, h, a, b, c, d, e, vec_splat(k, 3), (w11 += sigma1(w9) + w4 + sigma0(w12)));
-        k = (uint32x4_p8)vec_ld((7+4*i)*16, K);
-        KRound(e, f, g, h, a, b, c, d, vec_splat(k, 0), (w12 += sigma1(w10) + w5 + sigma0(w13)));
-        KRound(d, e, f, g, h, a, b, c, vec_splat(k, 1), (w13 += sigma1(w11) + w6 + sigma0(w14)));
-        KRound(c, d, e, f, g, h, a, b, vec_splat(k, 2), (w14 += sigma1(w12) + w7 + sigma0(w15)));
-        KRound(b, c, d, e, f, g, h, a, vec_splat(k, 3), (w15 += sigma1(w13) + w8 + sigma0(w0)));
-    }
-
-    a += uint32x4_p8{0x6a09e667ul, 0x6a09e667ul, 0x6a09e667ul, 0x6a09e667ul};
-    b += uint32x4_p8{0xbb67ae85ul, 0xbb67ae85ul, 0xbb67ae85ul, 0xbb67ae85ul};
-    c += uint32x4_p8{0x3c6ef372ul, 0x3c6ef372ul, 0x3c6ef372ul, 0x3c6ef372ul};
-    d += uint32x4_p8{0xa54ff53aul, 0xa54ff53aul, 0xa54ff53aul, 0xa54ff53aul};
-    e += uint32x4_p8{0x510e527ful, 0x510e527ful, 0x510e527ful, 0x510e527ful};
-    f += uint32x4_p8{0x9b05688cul, 0x9b05688cul, 0x9b05688cul, 0x9b05688cul};
-    g += uint32x4_p8{0x1f83d9abul, 0x1f83d9abul, 0x1f83d9abul, 0x1f83d9abul};
-    h += uint32x4_p8{0x5be0cd19ul, 0x5be0cd19ul, 0x5be0cd19ul, 0x5be0cd19ul};
-
-    uint32x4_p8 t0 = a;
-    uint32x4_p8 t1 = b;
-    uint32x4_p8 t2 = c;
-    uint32x4_p8 t3 = d;
-    uint32x4_p8 t4 = e;
-    uint32x4_p8 t5 = f;
-    uint32x4_p8 t6 = g;
-    uint32x4_p8 t7 = h;
-
-    KRound2(a, b, c, d, e, f, g, h, 0xc28a2f98);
-    KRound2(h, a, b, c, d, e, f, g, 0x71374491);
-    KRound2(g, h, a, b, c, d, e, f, 0xb5c0fbcf);
-    KRound2(f, g, h, a, b, c, d, e, 0xe9b5dba5);
-    KRound2(e, f, g, h, a, b, c, d, 0x3956c25b);
-    KRound2(d, e, f, g, h, a, b, c, 0x59f111f1);
-    KRound2(c, d, e, f, g, h, a, b, 0x923f82a4);
-    KRound2(b, c, d, e, f, g, h, a, 0xab1c5ed5);
-    KRound2(a, b, c, d, e, f, g, h, 0xd807aa98);
-    KRound2(h, a, b, c, d, e, f, g, 0x12835b01);
-    KRound2(g, h, a, b, c, d, e, f, 0x243185be);
-    KRound2(f, g, h, a, b, c, d, e, 0x550c7dc3);
-    KRound2(e, f, g, h, a, b, c, d, 0x72be5d74);
-    KRound2(d, e, f, g, h, a, b, c, 0x80deb1fe);
-    KRound2(c, d, e, f, g, h, a, b, 0x9bdc06a7);
-    KRound2(b, c, d, e, f, g, h, a, 0xc19bf374);
-    KRound2(a, b, c, d, e, f, g, h, 0x649b69c1);
-    KRound2(h, a, b, c, d, e, f, g, 0xf0fe4786);
-    KRound2(g, h, a, b, c, d, e, f, 0x0fe1edc6);
-    KRound2(f, g, h, a, b, c, d, e, 0x240cf254);
-    KRound2(e, f, g, h, a, b, c, d, 0x4fe9346f);
-    KRound2(d, e, f, g, h, a, b, c, 0x6cc984be);
-    KRound2(c, d, e, f, g, h, a, b, 0x61b9411e);
-    KRound2(b, c, d, e, f, g, h, a, 0x16f988fa);
-    KRound2(a, b, c, d, e, f, g, h, 0xf2c65152);
-    KRound2(h, a, b, c, d, e, f, g, 0xa88e5a6d);
-    KRound2(g, h, a, b, c, d, e, f, 0xb019fc65);
-    KRound2(f, g, h, a, b, c, d, e, 0xb9d99ec7);
-    KRound2(e, f, g, h, a, b, c, d, 0x9a1231c3);
-    KRound2(d, e, f, g, h, a, b, c, 0xe70eeaa0);
-    KRound2(c, d, e, f, g, h, a, b, 0xfdb1232b);
-    KRound2(b, c, d, e, f, g, h, a, 0xc7353eb0);
-    KRound2(a, b, c, d, e, f, g, h, 0x3069bad5);
-    KRound2(h, a, b, c, d, e, f, g, 0xcb976d5f);
-    KRound2(g, h, a, b, c, d, e, f, 0x5a0f118f);
-    KRound2(f, g, h, a, b, c, d, e, 0xdc1eeefd);
-    KRound2(e, f, g, h, a, b, c, d, 0x0a35b689);
-    KRound2(d, e, f, g, h, a, b, c, 0xde0b7a04);
-    KRound2(c, d, e, f, g, h, a, b, 0x58f4ca9d);
-    KRound2(b, c, d, e, f, g, h, a, 0xe15d5b16);
-    KRound2(a, b, c, d, e, f, g, h, 0x007f3e86);
-    KRound2(h, a, b, c, d, e, f, g, 0x37088980);
-    KRound2(g, h, a, b, c, d, e, f, 0xa507ea32);
-    KRound2(f, g, h, a, b, c, d, e, 0x6fab9537);
-    KRound2(e, f, g, h, a, b, c, d, 0x17406110);
-    KRound2(d, e, f, g, h, a, b, c, 0x0d8cd6f1);
-    KRound2(c, d, e, f, g, h, a, b, 0xcdaa3b6d);
-    KRound2(b, c, d, e, f, g, h, a, 0xc0bbbe37);
-    KRound2(a, b, c, d, e, f, g, h, 0x83613bda);
-    KRound2(h, a, b, c, d, e, f, g, 0xdb48a363);
-    KRound2(g, h, a, b, c, d, e, f, 0x0b02e931);
-    KRound2(f, g, h, a, b, c, d, e, 0x6fd15ca7);
-    KRound2(e, f, g, h, a, b, c, d, 0x521afaca);
-    KRound2(d, e, f, g, h, a, b, c, 0x31338431);
-    KRound2(c, d, e, f, g, h, a, b, 0x6ed41a95);
-    KRound2(b, c, d, e, f, g, h, a, 0x6d437890);
-    KRound2(a, b, c, d, e, f, g, h, 0xc39c91f2);
-    KRound2(h, a, b, c, d, e, f, g, 0x9eccabbd);
-    KRound2(g, h, a, b, c, d, e, f, 0xb5c9a0e6);
-    KRound2(f, g, h, a, b, c, d, e, 0x532fb63c);
-    KRound2(e, f, g, h, a, b, c, d, 0xd2c741c6);
-    KRound2(d, e, f, g, h, a, b, c, 0x07237ea3);
-    KRound2(c, d, e, f, g, h, a, b, 0xa4954b68);
-    KRound2(b, c, d, e, f, g, h, a, 0x4c191d76);
-
-
-    w0 = t0 + a;
-    w1 = t1 + b;
-    w2 = t2 + c;
-    w3 = t3 + d;
-    w4 = t4 + e;
-    w5 = t5 + f;
-    w6 = t6 + g;
-    w7 = t7 + h;
-
-    a = uint32x4_p8{0x6a09e667ul, 0x6a09e667ul, 0x6a09e667ul, 0x6a09e667ul};
-    b = uint32x4_p8{0xbb67ae85ul, 0xbb67ae85ul, 0xbb67ae85ul, 0xbb67ae85ul};
-    c = uint32x4_p8{0x3c6ef372ul, 0x3c6ef372ul, 0x3c6ef372ul, 0x3c6ef372ul};
-    d = uint32x4_p8{0xa54ff53aul, 0xa54ff53aul, 0xa54ff53aul, 0xa54ff53aul};
-    e = uint32x4_p8{0x510e527ful, 0x510e527ful, 0x510e527ful, 0x510e527ful};
-    f = uint32x4_p8{0x9b05688cul, 0x9b05688cul, 0x9b05688cul, 0x9b05688cul};
-    g = uint32x4_p8{0x1f83d9abul, 0x1f83d9abul, 0x1f83d9abul, 0x1f83d9abul};
-    h = uint32x4_p8{0x5be0cd19ul, 0x5be0cd19ul, 0x5be0cd19ul, 0x5be0cd19ul};
-
-    Round(a, b, c, d, e, f, g, h, 0x428a2f98, w0);
-    Round(h, a, b, c, d, e, f, g, 0x71374491, w1);
-    Round(g, h, a, b, c, d, e, f, 0xb5c0fbcf, w2);
-    Round(f, g, h, a, b, c, d, e, 0xe9b5dba5, w3);
-    Round(e, f, g, h, a, b, c, d, 0x3956c25b, w4);
-    Round(d, e, f, g, h, a, b, c, 0x59f111f1, w5);
-    Round(c, d, e, f, g, h, a, b, 0x923f82a4, w6);
-    Round(b, c, d, e, f, g, h, a, 0xab1c5ed5, w7);
-    Round2(a, b, c, d, e, f, g, h, 0x5807aa98);
-    Round2(h, a, b, c, d, e, f, g, 0x12835b01);
-    Round2(g, h, a, b, c, d, e, f, 0x243185be);
-    Round2(f, g, h, a, b, c, d, e, 0x550c7dc3);
-    Round2(e, f, g, h, a, b, c, d, 0x72be5d74);
-    Round2(d, e, f, g, h, a, b, c, 0x80deb1fe);
-    Round2(c, d, e, f, g, h, a, b, 0x9bdc06a7);
-    Round2(b, c, d, e, f, g, h, a, 0xc19bf274);
-    Round(a, b, c, d, e, f, g, h, 0xe49b69c1, (w0 += sigma0(w1)));
-    w1 += uint32x4_p8{0xa00000, 0xa00000, 0xa00000, 0xa00000};
-    Round(h, a, b, c, d, e, f, g, 0xefbe4786, (w1 += sigma0(w2)));
-    Round(g, h, a, b, c, d, e, f, 0x0fc19dc6, (w2 += sigma1(w0) + sigma0(w3)));
-    Round(f, g, h, a, b, c, d, e, 0x240ca1cc, (w3 += sigma1(w1) + sigma0(w4)));
-    Round(e, f, g, h, a, b, c, d, 0x2de92c6f, (w4 += sigma1(w2) + sigma0(w5)));
-    Round(d, e, f, g, h, a, b, c, 0x4a7484aa, (w5 += sigma1(w3) + sigma0(w6)));
-    w6 += uint32x4_p8{0x100, 0x100, 0x100, 0x100};
-    Round(c, d, e, f, g, h, a, b, 0x5cb0a9dc, (w6 += sigma1(w4) + sigma0(w7)));
-    w7 += uint32x4_p8{0x11002000, 0x11002000, 0x11002000, 0x11002000};
-    Round(b, c, d, e, f, g, h, a, 0x76f988da, (w7 += sigma1(w5) + w0));
-    w8 = uint32x4_p8{0x80000000, 0x80000000, 0x80000000, 0x80000000};
-    Round(a, b, c, d, e, f, g, h, 0x983e5152, (w8 += sigma1(w6) + w1));
-    Round(h, a, b, c, d, e, f, g, 0xa831c66d, (w9 = sigma1(w7) + w2));
-    Round(g, h, a, b, c, d, e, f, 0xb00327c8, (w10 = sigma1(w8) + w3));
-    Round(f, g, h, a, b, c, d, e, 0xbf597fc7, (w11 = sigma1(w9) + w4));
-    Round(e, f, g, h, a, b, c, d, 0xc6e00bf3, (w12 = sigma1(w10) + w5));
-    Round(d, e, f, g, h, a, b, c, 0xd5a79147, (w13 = sigma1(w11) + w6));
-    w14 = uint32x4_p8{0x400022, 0x400022, 0x400022, 0x400022};
-    Round(c, d, e, f, g, h, a, b, 0x06ca6351, (w14 += sigma1(w12) + w7));
-    w15 = uint32x4_p8{0x100, 0x100, 0x100, 0x100};
-    Round(b, c, d, e, f, g, h, a, 0x14292967, (w15 += sigma1(w13) + w8 + sigma0(w0)));
-    Round(a, b, c, d, e, f, g, h, 0x27b70a85, (w0 += sigma1(w14) + w9 + sigma0(w1)));
-    Round(h, a, b, c, d, e, f, g, 0x2e1b2138, (w1 += sigma1(w15) + w10 + sigma0(w2)));
-    Round(g, h, a, b, c, d, e, f, 0x4d2c6dfc, (w2 += sigma1(w0) + w11 + sigma0(w3)));
-    Round(f, g, h, a, b, c, d, e, 0x53380d13, (w3 += sigma1(w1) + w12 + sigma0(w4)));
-    Round(e, f, g, h, a, b, c, d, 0x650a7354, (w4 += sigma1(w2) + w13 + sigma0(w5)));
-    Round(d, e, f, g, h, a, b, c, 0x766a0abb, (w5 += sigma1(w3) + w14 + sigma0(w6)));
-    Round(c, d, e, f, g, h, a, b, 0x81c2c92e, (w6 += sigma1(w4) + w15 + sigma0(w7)));
-    Round(b, c, d, e, f, g, h, a, 0x92722c85, (w7 += sigma1(w5) + w0 + sigma0(w8)));
-    Round(a, b, c, d, e, f, g, h, 0xa2bfe8a1, (w8 += sigma1(w6) + w1 + sigma0(w9)));
-    Round(h, a, b, c, d, e, f, g, 0xa81a664b, (w9 += sigma1(w7) + w2 + sigma0(w10)));
-    Round(g, h, a, b, c, d, e, f, 0xc24b8b70, (w10 += sigma1(w8) + w3 + sigma0(w11)));
-    Round(f, g, h, a, b, c, d, e, 0xc76c51a3, (w11 += sigma1(w9) + w4 + sigma0(w12)));
-    Round(e, f, g, h, a, b, c, d, 0xd192e819, (w12 += sigma1(w10) + w5 + sigma0(w13)));
-    Round(d, e, f, g, h, a, b, c, 0xd6990624, (w13 += sigma1(w11) + w6 + sigma0(w14)));
-    Round(c, d, e, f, g, h, a, b, 0xf40e3585, (w14 += sigma1(w12) + w7 + sigma0(w15)));
-    Round(b, c, d, e, f, g, h, a, 0x106aa070, (w15 += sigma1(w13) + w8 + sigma0(w0)));
-    Round(a, b, c, d, e, f, g, h, 0x19a4c116, (w0 += sigma1(w14) + w9 + sigma0(w1)));
-    Round(h, a, b, c, d, e, f, g, 0x1e376c08, (w1 += sigma1(w15) + w10 + sigma0(w2)));
-    Round(g, h, a, b, c, d, e, f, 0x2748774c, (w2 += sigma1(w0) + w11 + sigma0(w3)));
-    Round(f, g, h, a, b, c, d, e, 0x34b0bcb5, (w3 += sigma1(w1) + w12 + sigma0(w4)));
-    Round(e, f, g, h, a, b, c, d, 0x391c0cb3, (w4 += sigma1(w2) + w13 + sigma0(w5)));
-    Round(d, e, f, g, h, a, b, c, 0x4ed8aa4a, (w5 += sigma1(w3) + w14 + sigma0(w6)));
-    Round(c, d, e, f, g, h, a, b, 0x5b9cca4f, (w6 += sigma1(w4) + w15 + sigma0(w7)));
-    Round(b, c, d, e, f, g, h, a, 0x682e6ff3, (w7 += sigma1(w5) + w0 + sigma0(w8)));
-    Round(a, b, c, d, e, f, g, h, 0x748f82ee, (w8 += sigma1(w6) + w1 + sigma0(w9)));
-    Round(h, a, b, c, d, e, f, g, 0x78a5636f, (w9 += sigma1(w7) + w2 + sigma0(w10)));
-    Round(g, h, a, b, c, d, e, f, 0x84c87814, (w10 += sigma1(w8) + w3 + sigma0(w11)));
-    Round(f, g, h, a, b, c, d, e, 0x8cc70208, (w11 += sigma1(w9) + w4 + sigma0(w12)));
-    Round(e, f, g, h, a, b, c, d, 0x90befffa, (w12 += sigma1(w10) + w5 + sigma0(w13)));
-    Round(d, e, f, g, h, a, b, c, 0xa4506ceb, (w13 += sigma1(w11) + w6 + sigma0(w14)));
-    Round(c, d, e, f, g, h, a, b, 0xbef9a3f7, (w14 + sigma1(w12) + w7 + sigma0(w15)));
-    Round(b, c, d, e, f, g, h, a, 0xc67178f2, (w15 + sigma1(w13) + w8 + sigma0(w0)));
-
-    a += uint32x4_p8{0x6a09e667ul, 0x6a09e667ul, 0x6a09e667ul, 0x6a09e667ul};
-    b += uint32x4_p8{0xbb67ae85ul, 0xbb67ae85ul, 0xbb67ae85ul, 0xbb67ae85ul};
-    c += uint32x4_p8{0x3c6ef372ul, 0x3c6ef372ul, 0x3c6ef372ul, 0x3c6ef372ul};
-    d += uint32x4_p8{0xa54ff53aul, 0xa54ff53aul, 0xa54ff53aul, 0xa54ff53aul};
-    e += uint32x4_p8{0x510e527ful, 0x510e527ful, 0x510e527ful, 0x510e527ful};
-    f += uint32x4_p8{0x9b05688cul, 0x9b05688cul, 0x9b05688cul, 0x9b05688cul};
-    g += uint32x4_p8{0x1f83d9abul, 0x1f83d9abul, 0x1f83d9abul, 0x1f83d9abul};
-    h += uint32x4_p8{0x5be0cd19ul, 0x5be0cd19ul, 0x5be0cd19ul, 0x5be0cd19ul};
-
-    w0123_0 = (uint8x16_p8)pack_bytes<0 >((uint8x16_p8)a, (uint8x16_p8)b, (uint8x16_p8)c, (uint8x16_p8)d);
-    w4567_0 = (uint8x16_p8)pack_bytes<0 >((uint8x16_p8)e, (uint8x16_p8)f, (uint8x16_p8)g, (uint8x16_p8)h);
-
-    w0123_1 = (uint8x16_p8)pack_bytes<4 >((uint8x16_p8)a, (uint8x16_p8)b, (uint8x16_p8)c, (uint8x16_p8)d);
-    w4567_1 = (uint8x16_p8)pack_bytes<4 >((uint8x16_p8)e, (uint8x16_p8)f, (uint8x16_p8)g, (uint8x16_p8)h);
-
-    w0123_2 = (uint8x16_p8)pack_bytes<8 >((uint8x16_p8)a, (uint8x16_p8)b, (uint8x16_p8)c, (uint8x16_p8)d);
-    w4567_2 = (uint8x16_p8)pack_bytes<8 >((uint8x16_p8)e, (uint8x16_p8)f, (uint8x16_p8)g, (uint8x16_p8)h);
-
-    w0123_3 = (uint8x16_p8)pack_bytes<12>((uint8x16_p8)a, (uint8x16_p8)b, (uint8x16_p8)c, (uint8x16_p8)d);
-    w4567_3 = (uint8x16_p8)pack_bytes<12>((uint8x16_p8)e, (uint8x16_p8)f, (uint8x16_p8)g, (uint8x16_p8)h);
-
-    vec_vsx_st(w0123_0, 0 *16 + 0 , out);
-    vec_vsx_st(w4567_0, 1 *16 + 0 , out);
-
-    vec_vsx_st(w0123_1, 0 *16 + 32, out);
-    vec_vsx_st(w4567_1, 1 *16 + 32, out);
-
-    vec_vsx_st(w0123_2, 0 *16 + 64, out);
-    vec_vsx_st(w4567_2, 1 *16 + 64, out);
-
-    vec_vsx_st(w0123_3, 0 *16 + 96, out);
-    vec_vsx_st(w4567_3, 1 *16 + 96, out);
-}
-}
-
-#if defined(__clang__)
-#pragma clang attribute pop
-#endif
diff --git a/src/crypto/sha256_sse41.cpp b/src/crypto/sha256_sse41.cpp
index 145cc1c01b..d041fdfefc 100644
--- a/src/crypto/sha256_sse41.cpp
+++ b/src/crypto/sha256_sse41.cpp
@@ -10,12 +10,6 @@
 #include <attributes.h>
 #include <crypto/common.h>
 
-#if defined(__clang__)
-#pragma clang attribute push(__attribute__((__target__("sse4.1"))), apply_to = function)
-#elif defined(__GNUC__)
-#pragma GCC target ("sse4.1")
-#endif
-
 namespace sha256d64_sse41 {
 namespace {
 
@@ -324,8 +318,4 @@ void Transform_4way(unsigned char* out, const unsigned char* in)
 
 }
 
-#if defined(__clang__)
-#pragma clang attribute pop
-#endif
-
 #endif
diff --git a/src/crypto/sha256_x86_shani.cpp b/src/crypto/sha256_x86_shani.cpp
index 98a372e8e0..7471828193 100644
--- a/src/crypto/sha256_x86_shani.cpp
+++ b/src/crypto/sha256_x86_shani.cpp
@@ -13,12 +13,6 @@
 
 #include <attributes.h>
 
-#if defined(__clang__)
-#pragma clang attribute push(__attribute__((__target__("sse4,sse4.1,sha"))), apply_to = function)
-#elif defined(__GNUC__)
-#pragma GCC target ("sse4,sse4.1,sha")
-#endif
-
 namespace {
 
 alignas(__m128i) const uint8_t MASK[16] = {0x03, 0x02, 0x01, 0x00, 0x07, 0x06, 0x05, 0x04, 0x0b, 0x0a, 0x09, 0x08, 0x0f, 0x0e, 0x0d, 0x0c};
@@ -361,8 +355,4 @@ void Transform_2way(unsigned char* out, const unsigned char* in)
 
 }
 
-#if defined(__clang__)
-#pragma clang attribute pop
-#endif
-
 #endif
diff --git a/src/crypto/sha3.cpp b/src/crypto/sha3.cpp
index 56aaa4615e..770500bfe2 100644
--- a/src/crypto/sha3.cpp
+++ b/src/crypto/sha3.cpp
@@ -105,9 +105,9 @@ void KeccakF(uint64_t (&st)[25])
 
 SHA3_256& SHA3_256::Write(Span<const unsigned char> data)
 {
-    if (m_bufsize && data.size() >= sizeof(m_buffer) - m_bufsize) {
+    if (m_bufsize && m_bufsize + data.size() >= sizeof(m_buffer)) {
         // Fill the buffer and process it.
-        std::copy(data.begin(), data.begin() + (sizeof(m_buffer) - m_bufsize), m_buffer + m_bufsize);
+        std::copy(data.begin(), data.begin() + sizeof(m_buffer) - m_bufsize, m_buffer + m_bufsize);
         data = data.subspan(sizeof(m_buffer) - m_bufsize);
         m_state[m_pos++] ^= ReadLE64(m_buffer);
         m_bufsize = 0;
diff --git a/src/crypto/siphash.cpp b/src/crypto/siphash.cpp
index 2554d27a34..8004a0548e 100644
--- a/src/crypto/siphash.cpp
+++ b/src/crypto/siphash.cpp
@@ -2,10 +2,8 @@
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
-#include <crypto/common.h>
 #include <crypto/siphash.h>
 
-#include <algorithm>
 #include <bit>
 
 #define SIPROUND do { \
@@ -47,57 +45,31 @@ CSipHasher& CSipHasher::Write(uint64_t data)
     return *this;
 }
 
-
-/// Load a uint64_t from 0 to 7 bytes.
-inline uint64_t ReadU64ByLenLE(const unsigned char* data, size_t len)
-{
-    assert(len < 8);
-    uint64_t out = 0;
-    for (size_t i = 0; i < len; ++i) {
-        out |= (uint64_t)data[i] << (i * 8);
-    }
-    return out;
-}
-
 CSipHasher& CSipHasher::Write(Span<const unsigned char> data)
 {
     uint64_t v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];
-    auto ntail = count & 0x07;
-    count += data.size();
-
-    size_t needed = 0;
-
-    if (ntail != 0) {
-        needed = 8 - ntail;
-        tmp |= ReadU64ByLenLE(data.data(), std::min(data.size(), needed)) << 8 * ntail;
-        if (data.size() < needed) {
-            return *this;
-        } else {
-            v3 ^= tmp;
+    uint64_t t = tmp;
+    uint8_t c = count;
+
+    while (data.size() > 0) {
+        t |= uint64_t{data.front()} << (8 * (c % 8));
+        c++;
+        if ((c & 7) == 0) {
+            v3 ^= t;
             SIPROUND;
             SIPROUND;
-            v0 ^= tmp;
+            v0 ^= t;
+            t = 0;
         }
-    }
-
-    size_t len = data.size() - needed;
-    auto left = len & 0x07;
-
-    auto i = needed;
-    while (i < len - left) {
-        uint64_t mi = ReadLE64(data.data() + i);
-        v3 ^= mi;
-        SIPROUND;
-        SIPROUND;
-        v0 ^= mi;
-        i += 8;
+        data = data.subspan(1);
     }
 
     v[0] = v0;
     v[1] = v1;
     v[2] = v2;
     v[3] = v3;
-    tmp = ReadU64ByLenLE(data.data() + i, left);
+    count = c;
+    tmp = t;
 
     return *this;
 }
diff --git a/src/dbwrapper.cpp b/src/dbwrapper.cpp
index f268e09489..479064d468 100644
--- a/src/dbwrapper.cpp
+++ b/src/dbwrapper.cpp
@@ -6,26 +6,23 @@
 
 #include <logging.h>
 #include <random.h>
-#include <node/interface_ui.h>
 #include <serialize.h>
 #include <span.h>
 #include <streams.h>
 #include <util/fs.h>
 #include <util/fs_helpers.h>
 #include <util/strencodings.h>
-#include <util/translation.h>
 
 #include <algorithm>
 #include <cassert>
 #include <cstdarg>
 #include <cstdint>
 #include <cstdio>
-#include <leveldb/c.h>
 #include <leveldb/cache.h>
 #include <leveldb/db.h>
 #include <leveldb/env.h>
 #include <leveldb/filter_policy.h>
-#include <memenv.h>
+#include <leveldb/helpers/memenv/memenv.h>
 #include <leveldb/iterator.h>
 #include <leveldb/options.h>
 #include <leveldb/slice.h>
@@ -54,42 +51,6 @@ static void HandleError(const leveldb::Status& status)
     throw dbwrapper_error(errmsg);
 }
 
-bool dbwrapper_SanityCheck()
-{
-    unsigned long header_version = (leveldb::kMajorVersion << 16) | leveldb::kMinorVersion;
-    unsigned long library_version = (leveldb_major_version() << 16) | leveldb_minor_version();
-
-    if (header_version != library_version) {
-        InitError(Untranslated(strprintf("Compiled with LevelDB %d.%d, but linked with LevelDB %d.%d (incompatible).",
-            leveldb::kMajorVersion, leveldb::kMinorVersion,
-            leveldb_major_version(), leveldb_minor_version()
-        )));
-        return false;
-    }
-
-    return true;
-}
-
-#ifndef WIN32
-namespace leveldb {
-class EnvPosixTestHelper {
-    static void SetReadOnlyMMapLimit(int limit);
-public:
-    static inline void SetReadOnlyMMapLimitForBitcoin(int limit) { SetReadOnlyMMapLimit(limit); }
-};
-}
-
-class BitcoinLevelDBInit {
-public:
-    BitcoinLevelDBInit() {
-        if (sizeof(void*) >= 8) {
-            leveldb::EnvPosixTestHelper::SetReadOnlyMMapLimitForBitcoin(4096);
-        }
-    }
-};
-static BitcoinLevelDBInit g_bitcoin_leveldb_init;
-#endif
-
 class CBitcoinLevelDBLogger : public leveldb::Logger {
 public:
     // This code is adapted from posix_logger.h, which is why it is using vsprintf.
@@ -266,7 +227,6 @@ CDBWrapper::CDBWrapper(const DBParams& params)
     DBContext().iteroptions.fill_cache = false;
     DBContext().syncoptions.sync = true;
     DBContext().options = GetOptions(params.cache_bytes);
-    DBContext().options.max_file_size = params.options.max_file_size;
     DBContext().options.create_if_missing = true;
     if (params.memory_only) {
         DBContext().penv = leveldb::NewMemEnv(leveldb::Env::Default());
diff --git a/src/dbwrapper.h b/src/dbwrapper.h
index e5e88646a6..63c2f99d2a 100644
--- a/src/dbwrapper.h
+++ b/src/dbwrapper.h
@@ -20,19 +20,13 @@
 #include <string>
 #include <vector>
 
-bool dbwrapper_SanityCheck();
-
 static const size_t DBWRAPPER_PREALLOC_KEY_SIZE = 64;
 static const size_t DBWRAPPER_PREALLOC_VALUE_SIZE = 1024;
 
-static constexpr size_t DEFAULT_DB_FILE_SIZE{64};
-
 //! User-controlled performance and debug options.
 struct DBOptions {
     //! Compact database on startup.
     bool force_compact = false;
-    //! Target size of files.
-    size_t max_file_size{DEFAULT_DB_FILE_SIZE << 20};
 };
 
 //! Application-specific storage settings.
diff --git a/src/dummywallet.cpp b/src/dummywallet.cpp
index c58bf2ced6..42282c32d1 100644
--- a/src/dummywallet.cpp
+++ b/src/dummywallet.cpp
@@ -45,7 +45,6 @@ void DummyWalletInit::AddWalletOptions(ArgsManager& argsman) const
         "-wallet=<path>",
         "-walletbroadcast",
         "-walletdir=<dir>",
-        "-walletimplicitsegwit",
         "-walletnotify=<cmd>",
         "-walletrbf",
         "-dblogsize=<n>",
diff --git a/src/httprpc.cpp b/src/httprpc.cpp
index 5df8a9f2f5..af809eaf38 100644
--- a/src/httprpc.cpp
+++ b/src/httprpc.cpp
@@ -18,14 +18,12 @@
 #include <walletinitinterface.h>
 
 #include <algorithm>
-#include <fstream>
 #include <iterator>
 #include <map>
 #include <memory>
 #include <optional>
 #include <set>
 #include <string>
-#include <utility>
 #include <vector>
 
 using util::SplitString;
@@ -103,7 +101,7 @@ static void JSONErrorReply(HTTPRequest* req, UniValue objError, const JSONRPCReq
 
 //This function checks username and password against -rpcauth
 //entries from config file.
-static bool multiUserAuthorized(std::string strUserPass, std::string& out_wallet_restriction)
+static bool multiUserAuthorized(std::string strUserPass)
 {
     if (strUserPass.find(':') == std::string::npos) {
         return false;
@@ -128,15 +126,16 @@ static bool multiUserAuthorized(std::string strUserPass, std::string& out_wallet
         std::string strHashFromPass = HexStr(hexvec);
 
         if (TimingResistantEqual(strHashFromPass, strHash)) {
-            out_wallet_restriction = (vFields.size() > 3) ? vFields[3] : "";
             return true;
         }
     }
     return false;
 }
 
-static bool RPCAuthorized(const std::string& strAuth, std::string& strAuthUsernameOut, std::string& out_wallet_restriction)
+static bool RPCAuthorized(const std::string& strAuth, std::string& strAuthUsernameOut)
 {
+    if (strRPCUserColonPass.empty()) // Belt-and-suspenders measure if InitRPCAuthentication was not called
+        return false;
     if (strAuth.substr(0, 6) != "Basic ")
         return false;
     std::string_view strUserPass64 = TrimStringView(std::string_view{strAuth}.substr(6));
@@ -148,13 +147,11 @@ static bool RPCAuthorized(const std::string& strAuth, std::string& strAuthUserna
     if (strUserPass.find(':') != std::string::npos)
         strAuthUsernameOut = strUserPass.substr(0, strUserPass.find(':'));
 
-    // Check if authorized under single-user field.
-    // (strRPCUserColonPass is empty when -norpccookiefile is specified).
-    if (!strRPCUserColonPass.empty() && TimingResistantEqual(strUserPass, strRPCUserColonPass)) {
-        out_wallet_restriction = "";
+    //Check if authorized under single-user field
+    if (TimingResistantEqual(strUserPass, strRPCUserColonPass)) {
         return true;
     }
-    return multiUserAuthorized(strUserPass, out_wallet_restriction);
+    return multiUserAuthorized(strUserPass);
 }
 
 static bool HTTPReq_JSONRPC(const std::any& context, HTTPRequest* req)
@@ -175,7 +172,7 @@ static bool HTTPReq_JSONRPC(const std::any& context, HTTPRequest* req)
     JSONRPCRequest jreq;
     jreq.context = context;
     jreq.peerAddr = req->GetPeer().ToStringAddrPort();
-    if (!RPCAuthorized(authHeader.second, jreq.authUser, jreq.m_wallet_restriction)) {
+    if (!RPCAuthorized(authHeader.second, jreq.authUser)) {
         LogPrintf("ThreadRPCServer incorrect password attempt from %s\n", jreq.peerAddr);
 
         /* Deter brute-forcing
@@ -297,73 +294,40 @@ static bool InitRPCAuthentication()
 {
     if (gArgs.GetArg("-rpcpassword", "") == "")
     {
+        LogInfo("Using random cookie authentication.\n");
+
         std::optional<fs::perms> cookie_perms{std::nullopt};
         auto cookie_perms_arg{gArgs.GetArg("-rpccookieperms")};
         if (cookie_perms_arg) {
-            if (*cookie_perms_arg == "0") {
-                cookie_perms = std::nullopt;
-            } else if (cookie_perms_arg->empty() || *cookie_perms_arg == "1") {
-                // leave at default
-            } else {
-                auto perm_opt = InterpretPermString(*cookie_perms_arg);
-                if (!perm_opt) {
-                    LogError("Invalid -rpccookieperms=%s; must be one of 'owner', 'group', or 'all'.", *cookie_perms_arg);
-                    return false;
-                }
-                cookie_perms = *perm_opt;
+            auto perm_opt = InterpretPermString(*cookie_perms_arg);
+            if (!perm_opt) {
+                LogInfo("Invalid -rpccookieperms=%s; must be one of 'owner', 'group', or 'all'.\n", *cookie_perms_arg);
+                return false;
             }
+            cookie_perms = *perm_opt;
         }
 
-        assert(strRPCUserColonPass.empty()); // Only support initializing once
-        if (!GenerateAuthCookie(&strRPCUserColonPass, std::make_pair(cookie_perms, bool(cookie_perms_arg)))) {
+        if (!GenerateAuthCookie(&strRPCUserColonPass, cookie_perms)) {
             return false;
         }
-        if (strRPCUserColonPass.empty()) {
-            LogInfo("RPC authentication cookie file generation is disabled.");
-        } else {
-            LogInfo("Using random cookie authentication.");
-        }
     } else {
         LogPrintf("Config options rpcuser and rpcpassword will soon be deprecated. Locally-run instances may remove rpcuser to use cookie-based auth, or may be replaced with rpcauth. Please see share/rpcauth for rpcauth auth generation.\n");
         strRPCUserColonPass = gArgs.GetArg("-rpcuser", "") + ":" + gArgs.GetArg("-rpcpassword", "");
     }
-    constexpr auto AddRPCAuth = [](const std::string& rpcauth) {
-        std::vector<std::string> fields{SplitString(rpcauth, ':')};
-        if (fields.size() < 2 || fields.size() > 3) {
-            return false;
-        }
-        const std::vector<std::string> salt_hmac{SplitString(fields[1], '$')};
-        if (salt_hmac.size() == 2) {
-            fields.erase(fields.begin() + 1);
-            fields.insert(fields.begin() + 1, salt_hmac.begin(), salt_hmac.end());
-            g_rpcauth.push_back(fields);
-        } else {
-            return false;
-        }
-        return true;
-    };
-    if (!(gArgs.IsArgNegated("-rpcauth") || (gArgs.GetArgs("-rpcauth").empty() && gArgs.GetArgs("-rpcauthfile").empty()))) {
+    if (gArgs.GetArg("-rpcauth", "") != "") {
         LogPrintf("Using rpcauth authentication.\n");
         for (const std::string& rpcauth : gArgs.GetArgs("-rpcauth")) {
-            if (rpcauth.empty()) continue;
-            if (!AddRPCAuth(rpcauth)) {
+            std::vector<std::string> fields{SplitString(rpcauth, ':')};
+            const std::vector<std::string> salt_hmac{SplitString(fields.back(), '$')};
+            if (fields.size() == 2 && salt_hmac.size() == 2) {
+                fields.pop_back();
+                fields.insert(fields.end(), salt_hmac.begin(), salt_hmac.end());
+                g_rpcauth.push_back(fields);
+            } else {
                 LogPrintf("Invalid -rpcauth argument.\n");
                 return false;
             }
         }
-        for (const std::string& path : gArgs.GetArgs("-rpcauthfile")) {
-            std::ifstream file;
-            file.open(path);
-            if (!file.is_open()) continue;
-            std::string rpcauth;
-            size_t lineno = 0;
-            while (std::getline(file, rpcauth)) {
-                ++lineno;
-                if (!AddRPCAuth(rpcauth)) {
-                    LogPrintf("WARNING: Invalid line %s in -rpcauthfile=%s; ignoring\n", lineno, path);
-                }
-            }
-        }
     }
 
     g_rpc_whitelist_default = gArgs.GetBoolArg("-rpcwhitelistdefault", gArgs.IsArgSet("-rpcwhitelist"));
@@ -426,20 +390,3 @@ void StopHTTPRPC()
         httpRPCTimerInterface.reset();
     }
 }
-
-std::set<std::string> GetWhitelistedRpcs(const std::string& user_name)
-{
-    if (auto it = g_rpc_whitelist.find(user_name); it != g_rpc_whitelist.end()) {
-        return it->second;
-    }
-    if (g_rpc_whitelist_default) {
-        return std::set<std::string>();
-    }
-
-    // Build a list of every method
-    std::set<std::string> allowed_methods;
-    for (const auto& method_name : tableRPC.listCommands()) {
-        allowed_methods.insert(method_name);
-    }
-    return allowed_methods;
-}
diff --git a/src/httprpc.h b/src/httprpc.h
index 55a1e271dd..404d13083f 100644
--- a/src/httprpc.h
+++ b/src/httprpc.h
@@ -6,8 +6,6 @@
 #define BITCOIN_HTTPRPC_H
 
 #include <any>
-#include <set>
-#include <string>
 
 /** Start HTTP RPC subsystem.
  * Precondition; HTTP and RPC has been started.
@@ -33,8 +31,4 @@ void InterruptREST();
  */
 void StopREST();
 
-/** Returns a collection of whitelisted RPCs for the given user
- */
-std::set<std::string> GetWhitelistedRpcs(const std::string& user_name);
-
 #endif // BITCOIN_HTTPRPC_H
diff --git a/src/httpserver.cpp b/src/httpserver.cpp
index 6e3021bcac..b6c6db8b35 100644
--- a/src/httpserver.cpp
+++ b/src/httpserver.cpp
@@ -354,100 +354,16 @@ static void ThreadHTTP(struct event_base* base)
     LogPrint(BCLog::HTTP, "Exited http event loop\n");
 }
 
-static struct evhttp_bound_socket *
-my_bind_socket_with_handle(struct evhttp *http, const char *address, ev_uint16_t port, bool& ignorable_error)
-{
-    evutil_socket_t fd;
-    struct evhttp_bound_socket *bound;
-    int serrno;
-
-    struct evutil_addrinfo *aitop = nullptr;
-
-    if (address == nullptr && port == 0) {
-        fd = socket(AF_INET, SOCK_STREAM, 0);
-        if (fd == -1) {
-            LogPrintf("libevent: socket: %s\n", evutil_socket_error_to_string(evutil_socket_geterror(-1)));
-            return nullptr;
-        }
-    } else {
-        struct evutil_addrinfo hints = {};
-        int ai_result;
-
-        hints.ai_family = AF_UNSPEC;
-        hints.ai_socktype = SOCK_STREAM;
-        hints.ai_flags = EVUTIL_AI_PASSIVE|EVUTIL_AI_ADDRCONFIG;
-        const std::string strport = strprintf("%d", port);
-        ai_result = evutil_getaddrinfo(address, strport.c_str(), &hints, &aitop);
-        if (ai_result || !aitop) {
-            switch (ai_result) {
-            case 0:
-                break;
-            case EVUTIL_EAI_SYSTEM:
-                LogPrintf("libevent: getaddrinfo\n");
-                break;
-            case EVUTIL_EAI_NODATA:
-                LogPrintf("evutil_getaddrinfo doesn't support IPv6; cannot bind %s:%d\n", address, port);
-                [[fallthrough]];
-            case EVUTIL_EAI_ADDRFAMILY:
-            case EVUTIL_EAI_FAMILY:
-            case EVUTIL_EAI_SOCKTYPE:
-                ignorable_error = true;
-                break;
-            default:
-                LogPrintf("libevent: getaddrinfo: %s\n", evutil_gai_strerror(ai_result));
-            }
-            return nullptr;
-        }
-
-        fd = socket(aitop->ai_family, SOCK_STREAM, 0);
-        if (fd == -1) {
-            evutil_freeaddrinfo(aitop);
-            return nullptr;
-        }
-        evutil_make_listen_socket_reuseable(fd);
-    }
-
-    const int on = 1;
-    setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (sockopt_arg_type)&on, sizeof(on));
-
-    bool listen_failed = false;
-    if (evutil_make_socket_nonblocking(fd) < 0 ||
-        evutil_make_socket_closeonexec(fd) < 0 ||
-        (aitop && bind(fd, aitop->ai_addr, aitop->ai_addrlen) == -1) ||
-        (listen_failed = (listen(fd, 128) == -1))
-    ) {
-        serrno = EVUTIL_SOCKET_ERROR();
-        if (listen_failed) LogPrintf("libevent: %s: listen\n", __func__);
-        evutil_closesocket(fd);
-        if (aitop) evutil_freeaddrinfo(aitop);
-        EVUTIL_SET_SOCKET_ERROR(serrno);
-        return nullptr;
-    }
-
-    if (aitop) evutil_freeaddrinfo(aitop);
-
-    bound = evhttp_accept_socket_with_handle(http, fd);
-    if (bound == nullptr) {
-        evutil_closesocket(fd);
-        return nullptr;
-    }
-
-    LogPrint(BCLog::LIBEVENT, "libevent: Bound to port %d - Awaiting connections ... \n", port);
-    return bound;
-}
-
 /** Bind HTTP server to specified addresses */
 static bool HTTPBindAddresses(struct evhttp* http)
 {
     uint16_t http_port{static_cast<uint16_t>(gArgs.GetIntArg("-rpcport", BaseParams().RPCPort()))};
     std::vector<std::pair<std::string, uint16_t>> endpoints;
-    bool is_default = false;
 
     // Determine what addresses to bind to
     if (!(gArgs.IsArgSet("-rpcallowip") && gArgs.IsArgSet("-rpcbind"))) { // Default to loopback if not allowing external IPs
         endpoints.emplace_back("::1", http_port);
         endpoints.emplace_back("127.0.0.1", http_port);
-        is_default = true;
         if (gArgs.IsArgSet("-rpcallowip")) {
             LogPrintf("WARNING: option -rpcallowip was specified without -rpcbind; this doesn't usually make sense\n");
         }
@@ -464,45 +380,20 @@ static bool HTTPBindAddresses(struct evhttp* http)
     }
 
     // Bind addresses
-    int num_fail = 0;
     for (std::vector<std::pair<std::string, uint16_t> >::iterator i = endpoints.begin(); i != endpoints.end(); ++i) {
         LogPrintf("Binding RPC on address %s port %i\n", i->first, i->second);
-        bool ignorable_error = false;
-        evhttp_bound_socket *bind_handle = my_bind_socket_with_handle(http, i->first.empty() ? nullptr : i->first.c_str(), i->second, ignorable_error);
+        evhttp_bound_socket *bind_handle = evhttp_bind_socket_with_handle(http, i->first.empty() ? nullptr : i->first.c_str(), i->second);
         if (bind_handle) {
             const std::optional<CNetAddr> addr{LookupHost(i->first, false)};
             if (i->first.empty() || (addr.has_value() && addr->IsBindAny())) {
                 LogPrintf("WARNING: the RPC server is not safe to expose to untrusted networks such as the public internet\n");
             }
-            // Set the no-delay option (disable Nagle's algorithm) on the TCP socket.
-            evutil_socket_t fd = evhttp_bound_socket_get_fd(bind_handle);
-            int one = 1;
-            if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (sockopt_arg_type)&one, sizeof(one)) == SOCKET_ERROR) {
-                LogInfo("WARNING: Unable to set TCP_NODELAY on RPC server socket, continuing anyway\n");
-            }
             boundSockets.push_back(bind_handle);
         } else {
-            int err = EVUTIL_SOCKET_ERROR();
-            if (!is_default || (err != EADDRNOTAVAIL && err != ENOENT && err != EOPNOTSUPP && !ignorable_error)) {
-                LogPrintf("Binding RPC on address %s port %i failed (Error: %s).\n", i->first, i->second, NetworkErrorString(err));
-                num_fail += 1;
-            } else {
-                // Don't count failure if binding was not explicitly configured
-                // (default settings) and the address is not available.
-                // (for example: Travis without IPv6 localhost will return ENOENT)
-                LogPrintf("Binding RPC on address %s port %i failed, error ignored because interface was unavailable.\n", i->first, i->second);
-            }
-        }
-    }
-    if (num_fail != 0) {
-        // In case of an error, clean up listening sockets that succeeded to
-        // avoid leak
-        for (evhttp_bound_socket *socket : boundSockets) {
-            evhttp_del_accept_socket(http, socket);
+            LogPrintf("Binding RPC on address %s port %i failed.\n", i->first, i->second);
         }
-        boundSockets.clear();
     }
-    return num_fail == 0;
+    return !boundSockets.empty();
 }
 
 /** Simple wrapper to set thread name and run work queue */
@@ -565,7 +456,7 @@ bool InitHTTPServer(const util::SignalInterrupt& interrupt)
     evhttp_set_gencb(http, http_request_cb, (void*)&interrupt);
 
     if (!HTTPBindAddresses(http)) {
-        LogPrintf("Unable to bind all endpoints for RPC server\n");
+        LogPrintf("Unable to bind any endpoint for RPC server\n");
         return false;
     }
 
diff --git a/src/httpserver.h b/src/httpserver.h
index 4d119a1e22..33216a0119 100644
--- a/src/httpserver.h
+++ b/src/httpserver.h
@@ -14,8 +14,8 @@ namespace util {
 class SignalInterrupt;
 } // namespace util
 
-static const int DEFAULT_HTTP_THREADS{16};
-static const int DEFAULT_HTTP_WORKQUEUE{64};
+static const int DEFAULT_HTTP_THREADS=4;
+static const int DEFAULT_HTTP_WORKQUEUE=16;
 static const int DEFAULT_HTTP_SERVER_TIMEOUT=30;
 
 struct evhttp_request;
diff --git a/src/index/blockfilterindex.cpp b/src/index/blockfilterindex.cpp
index c29c066fd7..26de7eee32 100644
--- a/src/index/blockfilterindex.cpp
+++ b/src/index/blockfilterindex.cpp
@@ -151,7 +151,7 @@ bool BlockFilterIndex::CustomCommit(CDBBatch& batch)
         LogError("%s: Failed to open filter file %d\n", __func__, pos.nFile);
         return false;
     }
-    if (!file.Commit() || file.fclose() != 0) {
+    if (!file.Commit()) {
         LogError("%s: Failed to commit filter file %d\n", __func__, pos.nFile);
         return false;
     }
@@ -205,7 +205,7 @@ size_t BlockFilterIndex::WriteFilterToDisk(FlatFilePos& pos, const BlockFilter&
             LogPrintf("%s: Failed to truncate filter file %d\n", __func__, pos.nFile);
             return 0;
         }
-        if (!last_file.Commit() || last_file.fclose() != 0) {
+        if (!last_file.Commit()) {
             LogPrintf("%s: Failed to commit filter file %d\n", __func__, pos.nFile);
             return 0;
         }
@@ -229,12 +229,6 @@ size_t BlockFilterIndex::WriteFilterToDisk(FlatFilePos& pos, const BlockFilter&
     }
 
     fileout << filter.GetBlockHash() << filter.GetEncodedFilter();
-
-    if (fileout.fclose() != 0) {
-        LogPrintf("%s: Failed to close filter file %d\n", __func__, pos.nFile);
-        return 0;
-    }
-
     return data_size;
 }
 
diff --git a/src/init.cpp b/src/init.cpp
index 64ed601bc1..541b75ce95 100644
--- a/src/init.cpp
+++ b/src/init.cpp
@@ -19,7 +19,6 @@
 #include <common/args.h>
 #include <common/system.h>
 #include <consensus/amount.h>
-#include <dbwrapper.h>
 #include <deploymentstatus.h>
 #include <hash.h>
 #include <httprpc.h>
@@ -66,7 +65,6 @@
 #include <rpc/util.h>
 #include <scheduler.h>
 #include <script/sigcache.h>
-#include <stats/stats.h>
 #include <sync.h>
 #include <torcontrol.h>
 #include <txdb.h>
@@ -140,15 +138,11 @@ using util::Join;
 using util::ReplaceAll;
 using util::ToString;
 
-static constexpr bool DEFAULT_COREPOLICY{false};
 static constexpr bool DEFAULT_PROXYRANDOMIZE{true};
 static constexpr bool DEFAULT_REST_ENABLE{false};
 static constexpr bool DEFAULT_I2P_ACCEPT_INCOMING{true};
 static constexpr bool DEFAULT_STOPAFTERBLOCKIMPORT{false};
 
-//! Check if initial sync is done with no change in block height or queued downloads every 30s
-static constexpr auto SYNC_CHECK_INTERVAL{30s};
-
 #ifdef WIN32
 // Win32 LevelDB doesn't use filedescriptors, and the ones used for
 // accessing block files don't count towards the fd_set size limit
@@ -177,8 +171,6 @@ static fs::path GetPidFile(const ArgsManager& args)
 
 [[nodiscard]] static bool CreatePidFile(const ArgsManager& args)
 {
-    if (args.IsArgNegated("-pid")) return true;
-
     std::ofstream file{GetPidFile(args)};
     if (file) {
 #ifdef WIN32
@@ -494,20 +486,12 @@ void SetupServerArgs(ArgsManager& argsman)
     argsman.AddArg("-blocksonly", strprintf("Whether to reject transactions from network peers. Disables automatic broadcast and rebroadcast of transactions, unless the source peer has the 'forcerelay' permission. RPC transactions are not affected. (default: %u)", DEFAULT_BLOCKSONLY), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
     argsman.AddArg("-coinstatsindex", strprintf("Maintain coinstats index used by the gettxoutsetinfo RPC (default: %u)", DEFAULT_COINSTATSINDEX), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
     argsman.AddArg("-conf=<file>", strprintf("Specify path to read-only configuration file. Relative paths will be prefixed by datadir location (only useable from command line, not configuration file) (default: %s)", BITCOIN_CONF_FILENAME), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
-    argsman.AddArg("-confrw=<file>", strprintf("Specify read/write configuration file. Relative paths will be prefixed by the network-specific datadir location (default: %s)", BITCOIN_RW_CONF_FILENAME), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
-    argsman.AddArg("-corepolicy", strprintf("Use Bitcoin Core policy defaults (default: %u)", DEFAULT_COREPOLICY), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
     argsman.AddArg("-datadir=<dir>", "Specify data directory", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
     argsman.AddArg("-dbbatchsize", strprintf("Maximum database write batch size in bytes (default: %u)", nDefaultDbBatchSize), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::OPTIONS);
     argsman.AddArg("-dbcache=<n>", strprintf("Maximum database cache size <n> MiB (%d to %d, default: %d). In addition, unused mempool memory is shared for this cache (see -maxmempool).", nMinDbCache, nMaxDbCache, nDefaultDbCache), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
-    argsman.AddArg("-dbfilesize",
-                   strprintf("Target size of files within databases, in MiB (%u to %u, default: %u).",
-                             1, 1024,
-                             DEFAULT_DB_FILE_SIZE),
-                   ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::OPTIONS);
     argsman.AddArg("-includeconf=<file>", "Specify additional configuration file, relative to the -datadir path (only useable from configuration file, not command line)", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
     argsman.AddArg("-allowignoredconf", strprintf("For backwards compatibility, treat an unused %s file in the datadir as a warning, not an error.", BITCOIN_CONF_FILENAME), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
     argsman.AddArg("-loadblock=<file>", "Imports blocks from external file on startup", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
-    argsman.AddArg("-lowmem=<n>", strprintf("If system available memory falls below <n> MiB, flush caches (0 to disable, default: %s)", g_low_memory_threshold / 1024 / 1024), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
     argsman.AddArg("-maxmempool=<n>", strprintf("Keep the transaction memory pool below <n> megabytes (default: %u)", DEFAULT_MAX_MEMPOOL_SIZE_MB), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
     argsman.AddArg("-maxorphantx=<n>", strprintf("Keep at most <n> unconnectable transactions in memory (default: %u)", DEFAULT_MAX_ORPHAN_TRANSACTIONS), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
     argsman.AddArg("-mempoolexpiry=<n>", strprintf("Do not keep transactions in the mempool longer than <n> hours (default: %u)", DEFAULT_MEMPOOL_EXPIRY_HOURS), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
@@ -524,13 +508,9 @@ void SetupServerArgs(ArgsManager& argsman)
     argsman.AddArg("-prune=<n>", strprintf("Reduce storage requirements by enabling pruning (deleting) of old blocks. This allows the pruneblockchain RPC to be called to delete specific blocks and enables automatic pruning of old blocks if a target size in MiB is provided. This mode is incompatible with -txindex. "
             "Warning: Reverting this setting requires re-downloading the entire blockchain. "
             "(default: 0 = disable pruning blocks, 1 = allow manual pruning via RPC, >=%u = automatically prune block files to stay under the specified target size in MiB)", MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
-    argsman.AddArg("-pruneduringinit", "Temporarily adjusts the -prune setting until initial sync completes."
-        " Ignored if pruning is disabled."
-        " (default: -1 = same value as -prune)", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
-    argsman.AddArg("-reindex", "If enabled, wipe chain state and block index, and rebuild them from blk*.dat files on disk. Also wipe and rebuild other optional indexes that are active. If an assumeutxo snapshot was loaded, its chainstate will be wiped as well. The snapshot can then be reloaded via RPC. Setting this to auto automatically reindexes the block database if it is corrupted.", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
+    argsman.AddArg("-reindex", "If enabled, wipe chain state and block index, and rebuild them from blk*.dat files on disk. Also wipe and rebuild other optional indexes that are active. If an assumeutxo snapshot was loaded, its chainstate will be wiped as well. The snapshot can then be reloaded via RPC.", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
     argsman.AddArg("-reindex-chainstate", "If enabled, wipe chain state, and rebuild it from blk*.dat files on disk. If an assumeutxo snapshot was loaded, its chainstate will be wiped as well. The snapshot can then be reloaded via RPC.", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
     argsman.AddArg("-settings=<file>", strprintf("Specify path to dynamic settings data file. Can be disabled with -nosettings. File is written at runtime and not meant to be edited by users (use %s instead for custom settings). Relative paths will be prefixed by datadir location. (default: %s)", BITCOIN_CONF_FILENAME, BITCOIN_SETTINGS_FILENAME), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
-    argsman.AddArg("-softwareexpiry", strprintf("Stop working after this POSIX timestamp (default: %s)", DEFAULT_SOFTWARE_EXPIRY), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::OPTIONS);
 #if HAVE_SYSTEM
     argsman.AddArg("-startupnotify=<cmd>", "Execute command on startup.", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
     argsman.AddArg("-shutdownnotify=<cmd>", "Execute command immediately before beginning shutdown. The need for shutdown may be urgent, so be careful not to delay it long (if the command doesn't require interaction with the server, consider having it fork into the background).", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
@@ -538,7 +518,7 @@ void SetupServerArgs(ArgsManager& argsman)
     argsman.AddArg("-txindex", strprintf("Maintain a full transaction index, used by the getrawtransaction rpc call (default: %u)", DEFAULT_TXINDEX), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
     argsman.AddArg("-blockfilterindex=<type>",
                  strprintf("Maintain an index of compact filters by block (default: %s, values: %s).", DEFAULT_BLOCKFILTERINDEX, ListBlockFilterTypes()) +
-                 " If <type> is not supplied or if <type> = 1, certain indexes are enabled (currently just basic).",
+                 " If <type> is not supplied or if <type> = 1, indexes for all known types are enabled.",
                  ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
 
     argsman.AddArg("-addnode=<ip>", strprintf("Add a node to connect to and attempt to keep the connection open (see the addnode RPC help for more info). This option can be specified multiple times to add multiple nodes; connections are limited to %u at a time and are counted separately from the -maxconnections limit.", MAX_ADDNODE_CONNECTIONS), ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);
@@ -551,7 +531,6 @@ void SetupServerArgs(ArgsManager& argsman)
     argsman.AddArg("-dns", strprintf("Allow DNS lookups for -addnode, -seednode and -connect (default: %u)", DEFAULT_NAME_LOOKUP), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
     argsman.AddArg("-dnsseed", strprintf("Query for peer addresses via DNS lookup, if low on addresses (default: %u unless -connect used or -maxconnections=0)", DEFAULT_DNSSEED), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
     argsman.AddArg("-externalip=<ip>", "Specify your own public address", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
-    argsman.AddArg("-feefilter", strprintf("Tell other nodes to filter invs to us by our mempool min fee (default: %u)", DEFAULT_FEEFILTER), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::CONNECTION);
     argsman.AddArg("-fixedseeds", strprintf("Allow fixed seeds if DNS seeds don't provide peers (default: %u)", DEFAULT_FIXEDSEEDS), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
     argsman.AddArg("-forcednsseed", strprintf("Always query for peer addresses via DNS lookup (default: %u)", DEFAULT_FORCEDNSSEED), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
     argsman.AddArg("-listen", strprintf("Accept connections from outside (default: %u if no -proxy, -connect or -maxconnections=0)", DEFAULT_LISTEN), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
@@ -569,7 +548,6 @@ void SetupServerArgs(ArgsManager& argsman)
     argsman.AddArg("-i2pacceptincoming", strprintf("Whether to accept inbound I2P connections (default: %i). Ignored if -i2psam is not set. Listening for inbound I2P connections is done through the SAM proxy, not by binding to a local address and port.", DEFAULT_I2P_ACCEPT_INCOMING), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
     argsman.AddArg("-onlynet=<net>", "Make automatic outbound connections only to network <net> (" + Join(GetNetworkNames(), ", ") + "). Inbound and manual connections are not affected by this option. It can be specified multiple times to allow multiple networks.", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
     argsman.AddArg("-v2transport", strprintf("Support v2 transport (default: %u)", DEFAULT_V2_TRANSPORT), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
-    argsman.AddArg("-v2onlyclearnet", strprintf("Disallow outbound v1 connections on IPV4/IPV6 (default: %u). Enable this option only if you really need it. Use -listen=0 to disable inbound connections since they can be unencrypted.", false), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::CONNECTION);
     argsman.AddArg("-peerbloomfilters", strprintf("Support filtering of blocks and transaction with bloom filters (default: %u)", DEFAULT_PEERBLOOMFILTERS), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
     argsman.AddArg("-peerblockfilters", strprintf("Serve compact block filters to peers per BIP 157 (default: %u)", DEFAULT_PEERBLOCKFILTERS), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
     argsman.AddArg("-txreconciliation", strprintf("Enable transaction reconciliations per BIP 330 (default: %d)", DEFAULT_TXRECONCILIATION_ENABLE), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::CONNECTION);
@@ -585,11 +563,6 @@ void SetupServerArgs(ArgsManager& argsman)
     argsman.AddArg("-timeout=<n>", strprintf("Specify socket connection timeout in milliseconds. If an initial attempt to connect is unsuccessful after this amount of time, drop it (minimum: 1, default: %d)", DEFAULT_CONNECT_TIMEOUT), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
     argsman.AddArg("-peertimeout=<n>", strprintf("Specify a p2p connection timeout delay in seconds. After connecting to a peer, wait this amount of time before considering disconnection based on inactivity (minimum: 1, default: %d)", DEFAULT_PEER_CONNECT_TIMEOUT), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::CONNECTION);
     argsman.AddArg("-torcontrol=<ip>:<port>", strprintf("Tor control host and port to use if onion listening enabled (default: %s). If no port is specified, the default port of %i will be used.", DEFAULT_TOR_CONTROL, DEFAULT_TOR_CONTROL_PORT), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
-#ifdef HAVE_TOR_SUBPROCESS
-    argsman.AddArg("-torexecute=<command>", strprintf("Tor command to use if not already running (default: %s)", DEFAULT_TOR_EXECUTE), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
-#else
-    hidden_args.emplace_back("-torexecute=<command>");
-#endif
     argsman.AddArg("-torpassword=<pass>", "Tor control port password (default: empty)", ArgsManager::ALLOW_ANY | ArgsManager::SENSITIVE, OptionsCategory::CONNECTION);
 #ifdef USE_UPNP
     argsman.AddArg("-upnp", strprintf("Use UPnP to map the listening port (default: %u)", DEFAULT_UPNP), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
@@ -608,7 +581,7 @@ void SetupServerArgs(ArgsManager& argsman)
     argsman.AddArg("-whitelist=<[permissions@]IP address or network>", "Add permission flags to the peers using the given IP address (e.g. 1.2.3.4) or "
         "CIDR-notated network (e.g. 1.2.3.0/24). Uses the same permissions as "
         "-whitebind. "
-        "Additional flags \"in\" and \"out\" control whether permissions apply to incoming connections and/or outgoing (default: incoming only). "
+        "Additional flags \"in\" and \"out\" control whether permissions apply to incoming connections and/or manual (default: incoming only). "
         "Can be specified multiple times.", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
 
     g_wallet_init_interface.AddWalletOptions(argsman);
@@ -616,32 +589,24 @@ void SetupServerArgs(ArgsManager& argsman)
 #ifdef ENABLE_ZMQ
     argsman.AddArg("-zmqpubhashblock=<address>", "Enable publish hash block in <address>", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
     argsman.AddArg("-zmqpubhashtx=<address>", "Enable publish hash transaction in <address>", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
-    argsman.AddArg("-zmqpubhashwallettx=<address>", "Enable publish hash wallet transaction in <address>", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
     argsman.AddArg("-zmqpubrawblock=<address>", "Enable publish raw block in <address>", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
     argsman.AddArg("-zmqpubrawtx=<address>", "Enable publish raw transaction in <address>", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
-    argsman.AddArg("-zmqpubrawwallettx=<address>", "Enable publish raw wallet transaction in <address>", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
     argsman.AddArg("-zmqpubsequence=<address>", "Enable publish hash block and tx sequence in <address>", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
     argsman.AddArg("-zmqpubhashblockhwm=<n>", strprintf("Set publish hash block outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
     argsman.AddArg("-zmqpubhashtxhwm=<n>", strprintf("Set publish hash transaction outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
-    argsman.AddArg("-zmqpubhashwallettxhwm=<n>", strprintf("Set publish hash wallet transaction outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
     argsman.AddArg("-zmqpubrawblockhwm=<n>", strprintf("Set publish raw block outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
     argsman.AddArg("-zmqpubrawtxhwm=<n>", strprintf("Set publish raw transaction outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
-    argsman.AddArg("-zmqpubrawwallettxhwm=<n>", strprintf("Set publish raw wallet transaction outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
     argsman.AddArg("-zmqpubsequencehwm=<n>", strprintf("Set publish hash sequence message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
 #else
     hidden_args.emplace_back("-zmqpubhashblock=<address>");
     hidden_args.emplace_back("-zmqpubhashtx=<address>");
-    hidden_args.emplace_back("-zmqpubhashwallettx=<address>");
     hidden_args.emplace_back("-zmqpubrawblock=<address>");
     hidden_args.emplace_back("-zmqpubrawtx=<address>");
-    hidden_args.emplace_back("-zmqpubrawwallettx=<address>");
     hidden_args.emplace_back("-zmqpubsequence=<n>");
     hidden_args.emplace_back("-zmqpubhashblockhwm=<n>");
     hidden_args.emplace_back("-zmqpubhashtxhwm=<n>");
-    hidden_args.emplace_back("-zmqpubhashwallettxhwm=<n>");
     hidden_args.emplace_back("-zmqpubrawblockhwm=<n>");
     hidden_args.emplace_back("-zmqpubrawtxhwm=<n>");
-    hidden_args.emplace_back("-zmqpubrawwallettxhwm=<n>");
     hidden_args.emplace_back("-zmqpubsequencehwm=<n>");
 #endif
 
@@ -666,70 +631,38 @@ void SetupServerArgs(ArgsManager& argsman)
                    strprintf("Maximum tip age in seconds to consider node in initial block download (default: %u)",
                              Ticks<std::chrono::seconds>(DEFAULT_MAX_TIP_AGE)),
                    ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);
-    argsman.AddArg("-printpriority", strprintf("Log transaction priority and fee rate in " + CURRENCY_UNIT + "/kvB when mining blocks (default: %u)", DEFAULT_PRINT_MODIFIED_FEE), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);
-    argsman.AddArg("-uaappend=<cmt>", "Append literal to the user agent string (should only be used for software embedding)", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
+    argsman.AddArg("-printpriority", strprintf("Log transaction fee rate in " + CURRENCY_UNIT + "/kvB when mining blocks (default: %u)", DEFAULT_PRINT_MODIFIED_FEE), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);
     argsman.AddArg("-uacomment=<cmt>", "Append comment to the user agent string", ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);
 
     SetupChainParamsBaseOptions(argsman);
 
-    argsman.AddArg("-acceptnonstddatacarrier",
-                   strprintf("Relay and mine non-OP_RETURN datacarrier injection (default: %u)",
-                             DEFAULT_ACCEPT_NON_STD_DATACARRIER),
-                   ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);
-    argsman.AddArg("-acceptnonstdtxn", strprintf("Relay and mine \"non-standard\" transactions (default: %u)", DEFAULT_ACCEPT_NON_STD_TXN), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);
+    argsman.AddArg("-acceptnonstdtxn", strprintf("Relay and mine \"non-standard\" transactions (test networks only; default: %u)", DEFAULT_ACCEPT_NON_STD_TXN), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::NODE_RELAY);
     argsman.AddArg("-incrementalrelayfee=<amt>", strprintf("Fee rate (in %s/kvB) used to define cost of relay, used for mempool limiting and replacement policy. (default: %s)", CURRENCY_UNIT, FormatMoney(DEFAULT_INCREMENTAL_RELAY_FEE)), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::NODE_RELAY);
-    argsman.AddArg("-dustrelayfee=<amt>", strprintf("Fee rate (in %s/kvB) used to define dust, the value of an output such that it will cost more than its value in fees at this fee rate to spend it. (default: %s)", CURRENCY_UNIT, FormatMoney(DUST_RELAY_TX_FEE)), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);
-    argsman.AddArg("-dustdynamic=off|[<multiplier>*]target:<blocks>|[<multiplier>*]mempool:<kvB>",
-                   strprintf("Automatically raise dustrelayfee based on either the expected fee to be mined within <blocks> blocks, or to be within the best <kvB> kvB of this node's mempool. If unspecified, multiplier is %s. (default: %s)",
-                             DEFAULT_DUST_RELAY_MULTIPLIER / 1000.,
-                             DEFAULT_DUST_DYNAMIC), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);
+    argsman.AddArg("-dustrelayfee=<amt>", strprintf("Fee rate (in %s/kvB) used to define dust, the value of an output such that it will cost more than its value in fees at this fee rate to spend it. (default: %s)", CURRENCY_UNIT, FormatMoney(DUST_RELAY_TX_FEE)), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::NODE_RELAY);
     argsman.AddArg("-acceptstalefeeestimates", strprintf("Read fee estimates even if they are stale (%sdefault: %u) fee estimates are considered stale if they are %s hours old", "regtest only; ", DEFAULT_ACCEPT_STALE_FEE_ESTIMATES, Ticks<std::chrono::hours>(MAX_FILE_AGE)), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);
     argsman.AddArg("-bytespersigop", strprintf("Equivalent bytes per sigop in transactions for relay and mining (default: %u)", DEFAULT_BYTES_PER_SIGOP), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);
-    argsman.AddArg("-bytespersigopstrict", strprintf("Minimum bytes per sigop in transactions we relay and mine (default: %u)", DEFAULT_BYTES_PER_SIGOP_STRICT), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);
     argsman.AddArg("-datacarrier", strprintf("Relay and mine data carrier transactions (default: %u)", DEFAULT_ACCEPT_DATACARRIER), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);
-    argsman.AddArg("-datacarriercost", strprintf("Treat extra data in transactions as at least N vbytes per actual byte (default: %s)", DEFAULT_WEIGHT_PER_DATA_BYTE / 4.0), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);
-    argsman.AddArg("-datacarrierfullcount", strprintf("Apply datacarriersize limit to all known datacarrier methods (default: %u)", DEFAULT_DATACARRIER_FULLCOUNT), ArgsManager::ALLOW_ANY | (DEFAULT_DATACARRIER_FULLCOUNT ? uint32_t{ArgsManager::DEBUG_ONLY} : 0), OptionsCategory::NODE_RELAY);
     argsman.AddArg("-datacarriersize",
-                   strprintf("Maximum size of data in data carrier transactions we relay and mine, in bytes (default: %u)",
+                   strprintf("Relay and mine transactions whose data-carrying raw scriptPubKey "
+                             "is of this size or less (default: %u)",
                              MAX_OP_RETURN_RELAY),
                    ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);
-    argsman.AddArg("-maxscriptsize", strprintf("Maximum size of scripts we relay and mine, in bytes (default: %s)", DEFAULT_SCRIPT_SIZE_POLICY_LIMIT), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);
-    argsman.AddArg("-mempoolfullrbf", strprintf("Accept transaction replace-by-fee without requiring replaceability signaling (default: %u)", (DEFAULT_MEMPOOL_RBF_POLICY == RBFPolicy::Always)), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);
-    argsman.AddArg("-mempoolreplacement", strprintf("Set to 0 to disable RBF entirely, \"fee,optin\" to honour RBF opt-out signal, or \"fee,-optin\" to always RBF aka full RBF (default: %s)", "fee,-optin"), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);
-    argsman.AddArg("-mempooltruc", strprintf("Behaviour for transactions requesting TRUC limits: \"reject\" the transactions entirely, \"accept\" them just like any other, or \"enforce\" to impose their requested restrictions (default: %s)", "accept"), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);
-    argsman.AddArg("-permitbarepubkey", strprintf("Relay legacy pubkey outputs (default: %u)", DEFAULT_PERMIT_BAREPUBKEY), ArgsManager::ALLOW_ANY,
-                   OptionsCategory::NODE_RELAY);
+    argsman.AddArg("-mempoolfullrbf", strprintf("(DEPRECATED) Accept transaction replace-by-fee without requiring replaceability signaling (default: %u)", DEFAULT_MEMPOOL_FULL_RBF), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);
     argsman.AddArg("-permitbaremultisig", strprintf("Relay transactions creating non-P2SH multisig outputs (default: %u)", DEFAULT_PERMIT_BAREMULTISIG), ArgsManager::ALLOW_ANY,
                    OptionsCategory::NODE_RELAY);
     argsman.AddArg("-minrelaytxfee=<amt>", strprintf("Fees (in %s/kvB) smaller than this are considered zero fee for relaying, mining and transaction creation (default: %s)",
         CURRENCY_UNIT, FormatMoney(DEFAULT_MIN_RELAY_TX_FEE)), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);
-    argsman.AddArg("-rejectparasites", strprintf("Refuse to relay or mine parasitic overlay protocols (default: %u)", DEFAULT_REJECT_PARASITES), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);
-    argsman.AddArg("-rejecttokens",
-                   strprintf("Refuse to relay or mine transactions involving non-bitcoin tokens (default: %u)",
-                             DEFAULT_REJECT_TOKENS),
-                   ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);
-    argsman.AddArg("-spkreuse=<policy>", strprintf("Either \"allow\" to relay/mine transactions reusing addresses or other pubkey scripts, or \"conflict\" to treat them as exclusive prior to being mined (default: %s)", DEFAULT_SPKREUSE), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);
     argsman.AddArg("-whitelistforcerelay", strprintf("Add 'forcerelay' permission to whitelisted peers with default permissions. This will relay transactions even if the transactions were already in the mempool. (default: %d)", DEFAULT_WHITELISTFORCERELAY), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);
     argsman.AddArg("-whitelistrelay", strprintf("Add 'relay' permission to whitelisted peers with default permissions. This will accept relayed transactions even when not relaying transactions (default: %d)", DEFAULT_WHITELISTRELAY), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);
 
 
-    argsman.AddArg("-blockmaxsize=<n>", strprintf("Set maximum block size in bytes (default: %d)", DEFAULT_BLOCK_MAX_SIZE), ArgsManager::ALLOW_ANY, OptionsCategory::BLOCK_CREATION);
     argsman.AddArg("-blockmaxweight=<n>", strprintf("Set maximum BIP141 block weight (default: %d)", DEFAULT_BLOCK_MAX_WEIGHT), ArgsManager::ALLOW_ANY, OptionsCategory::BLOCK_CREATION);
     argsman.AddArg("-blockmintxfee=<amt>", strprintf("Set lowest fee rate (in %s/kvB) for transactions to be included in block creation. (default: %s)", CURRENCY_UNIT, FormatMoney(DEFAULT_BLOCK_MIN_TX_FEE)), ArgsManager::ALLOW_ANY, OptionsCategory::BLOCK_CREATION);
-    argsman.AddArg("-blockprioritysize=<n>", strprintf("Set maximum size of high-priority/low-fee transactions in bytes (default: %d)", DEFAULT_BLOCK_PRIORITY_SIZE), ArgsManager::ALLOW_ANY, OptionsCategory::BLOCK_CREATION);
     argsman.AddArg("-blockversion=<n>", "Override block version to test forking scenarios", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::BLOCK_CREATION);
 
     argsman.AddArg("-rest", strprintf("Accept public REST requests (default: %u)", DEFAULT_REST_ENABLE), ArgsManager::ALLOW_ANY, OptionsCategory::RPC);
     argsman.AddArg("-rpcallowip=<ip>", "Allow JSON-RPC connections from specified source. Valid values for <ip> are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0), a network/CIDR (e.g. 1.2.3.4/24), all ipv4 (0.0.0.0/0), or all ipv6 (::/0). This option can be specified multiple times", ArgsManager::ALLOW_ANY, OptionsCategory::RPC);
-    argsman.AddArg("-rpcauth=<userpw>[:wallet]",
-                   "Username and HMAC-SHA-256 hashed password for JSON-RPC connections. "
-                   "The field <userpw> comes in the format: <USERNAME>:<SALT>$<HASH>. "
-                   "A canonical python script is included in share/rpcauth. "
-                   "The client then connects normally using the rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. "
-                   "A single wallet name can also be specified to restrict access to only that wallet, or '-' to deny all wallet access. "
-                   "This option can be specified multiple times",
-                   ArgsManager::ALLOW_ANY | ArgsManager::SENSITIVE, OptionsCategory::RPC);
-    argsman.AddArg("-rpcauthfile=<userpw>", "A file with a single lines with same format as rpcauth. This option can be specified multiple times", ArgsManager::ALLOW_ANY, OptionsCategory::RPC);
+    argsman.AddArg("-rpcauth=<userpw>", "Username and HMAC-SHA-256 hashed password for JSON-RPC connections. The field <userpw> comes in the format: <USERNAME>:<SALT>$<HASH>. A canonical python script is included in share/rpcauth. The client then connects normally using the rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. This option can be specified multiple times", ArgsManager::ALLOW_ANY | ArgsManager::SENSITIVE, OptionsCategory::RPC);
     argsman.AddArg("-rpcbind=<addr>[:port]", "Bind to given address to listen for JSON-RPC connections. Do not expose the RPC server to untrusted networks such as the public internet! This option is ignored unless -rpcallowip is also passed. Port is optional and overrides -rpcport. Use [host]:port notation for IPv6. This option can be specified multiple times (default: 127.0.0.1 and ::1 i.e., localhost)", ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::RPC);
     argsman.AddArg("-rpcdoccheck", strprintf("Throw a non-fatal error at runtime if the documentation for an RPC is incorrect (default: %u)", DEFAULT_RPC_DOC_CHECK), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::RPC);
     argsman.AddArg("-rpccookiefile=<loc>", "Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)", ArgsManager::ALLOW_ANY, OptionsCategory::RPC);
@@ -752,8 +685,6 @@ void SetupServerArgs(ArgsManager& argsman)
     hidden_args.emplace_back("-daemonwait");
 #endif
 
-    CStats::AddStatsOptions();
-
     // Add the hidden options
     argsman.AddHiddenArgs(hidden_args);
 }
@@ -776,8 +707,9 @@ static void BlockNotifyGenesisWait(const CBlockIndex* pBlockIndex)
 #if HAVE_SYSTEM
 static void StartupNotify(const ArgsManager& args)
 {
-    for (const std::string& command : args.GetArgs("-startupnotify")) {
-        std::thread t(runCommand, command);
+    std::string cmd = args.GetArg("-startupnotify", "");
+    if (!cmd.empty()) {
+        std::thread t(runCommand, cmd);
         t.detach(); // thread runs free
     }
 }
@@ -803,23 +735,6 @@ static bool AppInitServers(NodeContext& node)
 // Parameter interaction based on rules
 void InitParameterInteraction(ArgsManager& args)
 {
-    if (args.GetBoolArg("-corepolicy", DEFAULT_COREPOLICY)) {
-        args.SoftSetArg("-acceptnonstddatacarrier", "1");
-        args.SoftSetArg("-bytespersigopstrict", "0");
-        args.SoftSetArg("-permitbarepubkey", "1");
-        args.SoftSetArg("-permitbaremultisig", "1");
-        args.SoftSetArg("-rejectparasites", "0");
-        args.SoftSetArg("-datacarriercost", "0.25");
-        args.SoftSetArg("-datacarrierfullcount", "0");
-        args.SoftSetArg("-datacarriersize", "83");
-        args.SoftSetArg("-maxscriptsize", strprintf("%s", std::numeric_limits<unsigned int>::max()));
-        args.SoftSetArg("-mempooltruc", "enforce");
-        args.SoftSetArg("-spkreuse", "allow");
-        args.SoftSetArg("-blockprioritysize", "0");
-        args.SoftSetArg("-blockmaxsize", "4000000");
-        args.SoftSetArg("-blockmaxweight", "3996000");
-    }
-
     // when specifying an explicit binding address, you want to listen on it
     // even when -connect or -proxy is specified
     if (args.IsArgSet("-bind")) {
@@ -1022,7 +937,7 @@ bool AppInitParameterInteraction(const ArgsManager& args)
     // parse and validate enabled filter types
     std::string blockfilterindex_value = args.GetArg("-blockfilterindex", DEFAULT_BLOCKFILTERINDEX);
     if (blockfilterindex_value == "" || blockfilterindex_value == "1") {
-        g_enabled_filter_types = {BlockFilterType::BASIC};
+        g_enabled_filter_types = AllBlockFilterTypes();
     } else if (blockfilterindex_value != "0") {
         const std::vector<std::string> names = args.GetArgs("-blockfilterindex");
         for (const auto& name : names) {
@@ -1037,8 +952,6 @@ bool AppInitParameterInteraction(const ArgsManager& args)
     // Signal NODE_P2P_V2 if BIP324 v2 transport is enabled.
     if (args.GetBoolArg("-v2transport", DEFAULT_V2_TRANSPORT)) {
         nLocalServices = ServiceFlags(nLocalServices | NODE_P2P_V2);
-    } else if (args.GetBoolArg("-v2onlyclearnet", false)) {
-        return InitError(_("Cannot set -v2onlyclearnet to true when v2transport is disabled."));
     }
 
     // Signal NODE_COMPACT_FILTERS if peerblockfilters and basic filters index are both enabled.
@@ -1118,27 +1031,10 @@ bool AppInitParameterInteraction(const ArgsManager& args)
         }
     }
 
-    if (auto parsed = args.GetFixedPointArg("-datacarriercost", 2)) {
-        g_weight_per_data_byte = ((*parsed * WITNESS_SCALE_FACTOR) + 99) / 100;
-    }
-
-    g_script_size_policy_limit = args.GetIntArg("-maxscriptsize", g_script_size_policy_limit);
-
     nBytesPerSigOp = args.GetIntArg("-bytespersigop", nBytesPerSigOp);
-    nBytesPerSigOpStrict = args.GetIntArg("-bytespersigopstrict", nBytesPerSigOpStrict);
 
     if (!g_wallet_init_interface.ParameterInteraction()) return false;
 
-    {
-        std::string strSpkReuse = gArgs.GetArg("-spkreuse", DEFAULT_SPKREUSE);
-        // Uses string values so future versions can implement other modes
-        if (strSpkReuse == "allow" || gArgs.GetBoolArg("-spkreuse", false)) {
-            SpkReuseMode = SRM_ALLOW;
-        } else {
-            SpkReuseMode = SRM_REJECT;
-        }
-    }
-
     // Option to startup with mocktime set (used for regression testing):
     SetMockTime(args.GetIntArg("-mocktime", 0)); // SetMockTime(0) is a no-op
 
@@ -1184,14 +1080,13 @@ bool AppInitParameterInteraction(const ArgsManager& args)
         }
     }
 
-    if (!CStats::parameterInteraction()) return false;
-
     return true;
 }
 
-static bool LockDirectory(const fs::path& datadir, bool probeOnly)
+static bool LockDataDirectory(bool probeOnly)
 {
     // Make sure only a single Bitcoin process is using the data directory.
+    const fs::path& datadir = gArgs.GetDataDirNet();
     switch (util::LockDirectory(datadir, ".lock", probeOnly)) {
     case util::LockResult::ErrorWrite:
         return InitError(strprintf(_("Cannot write to data directory '%s'; check permissions."), fs::PathToString(datadir)));
@@ -1201,11 +1096,6 @@ static bool LockDirectory(const fs::path& datadir, bool probeOnly)
     } // no default case, so the compiler can warn about missing cases
     assert(false);
 }
-static bool LockDataDirectory(bool probeOnly)
-{
-    return LockDirectory(gArgs.GetDataDirNet(), probeOnly) && \
-           LockDirectory(gArgs.GetBlocksDirPath(), probeOnly);
-}
 
 bool AppInitSanityChecks(const kernel::Context& kernel)
 {
@@ -1238,44 +1128,6 @@ bool AppInitLockDataDirectory()
     return true;
 }
 
-/**
- * Once initial block sync is finished and no change in block height or queued downloads,
- * sync utxo state to protect against data loss
- */
-static void SyncCoinsTipAfterChainSync(const NodeContext& node)
-{
-    LOCK(node.chainman->GetMutex());
-    if (node.chainman->IsInitialBlockDownload()) {
-        LogDebug(BCLog::COINDB, "Node is still in IBD, rescheduling post-IBD chainstate disk sync...\n");
-        node.scheduler->scheduleFromNow([&node] {
-            SyncCoinsTipAfterChainSync(node);
-        }, SYNC_CHECK_INTERVAL);
-        return;
-    }
-
-    static auto last_chain_height{-1};
-    const auto current_height{node.chainman->ActiveHeight()};
-    if (last_chain_height != current_height) {
-        LogDebug(BCLog::COINDB, "Chain height updated since last check, rescheduling post-IBD chainstate disk sync...\n");
-        last_chain_height = current_height;
-        node.scheduler->scheduleFromNow([&node] {
-            SyncCoinsTipAfterChainSync(node);
-        }, SYNC_CHECK_INTERVAL);
-        return;
-    }
-
-    if (node.peerman->GetNumberOfPeersWithValidatedDownloads() > 0) {
-        LogDebug(BCLog::COINDB, "Still downloading blocks from peers, rescheduling post-IBD chainstate disk sync...\n");
-        node.scheduler->scheduleFromNow([&node] {
-            SyncCoinsTipAfterChainSync(node);
-        }, SYNC_CHECK_INTERVAL);
-        return;
-    }
-
-    LogDebug(BCLog::COINDB, "Finished syncing to tip, syncing chainstate to disk\n");
-    node.chainman->ActiveChainstate().CoinsTip().Sync();
-}
-
 bool AppInitInterfaces(NodeContext& node)
 {
     node.chain = node.init->makeChain();
@@ -1438,6 +1290,9 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)
     // as they would never get updated.
     if (!peerman_opts.ignore_incoming_txs) {
         bool read_stale_estimates = args.GetBoolArg("-acceptstalefeeestimates", DEFAULT_ACCEPT_STALE_FEE_ESTIMATES);
+        if (read_stale_estimates && (chainparams.GetChainType() != ChainType::REGTEST)) {
+            return InitError(strprintf(_("acceptstalefeeestimates is not supported on %s chain."), chainparams.GetChainTypeString()));
+        }
         node.fee_estimator = std::make_unique<CBlockPolicyEstimator>(FeeestPath(args), read_stale_estimates);
 
         // Flush estimates to disk periodically
@@ -1473,8 +1328,6 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)
         {"-zmqpubrawblock",         true},
         {"-zmqpubrawtx",            true},
         {"-zmqpubsequence",         true},
-        {"-zmqpubhashwallettx",     true},
-        {"-zmqpubrawwallettx",      true},
     }) {
         for (const std::string& socket_addr : args.GetArgs(arg)) {
             std::string host_out;
@@ -1482,7 +1335,7 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)
             if (!SplitHostPort(socket_addr, port_out, host_out)) {
 #ifdef HAVE_SOCKADDR_UN
                 // Allow unix domain sockets for some options e.g. unix:/some/file/path
-                if (!unix || (socket_addr.find(ADDR_PREFIX_UNIX) != 0 && socket_addr.rfind("ipc:", 0) != 0)) {
+                if (!unix || socket_addr.find(ADDR_PREFIX_UNIX) != 0) {
                     return InitError(InvalidPortErrMsg(arg, socket_addr));
                 }
 #else
@@ -1509,10 +1362,6 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)
         uacomments.push_back(cmt);
     }
     strSubVersion = FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, uacomments);
-    for (auto append : gArgs.GetArgs("-uaappend")) {
-        if (append.back() != '/') append += '/';
-        strSubVersion += append;
-    }
     if (strSubVersion.size() > MAX_SUBVERSION_LENGTH) {
         return InitError(strprintf(_("Total length of network version string (%i) exceeds maximum length (%i). Reduce the number or size of uacomments."),
             strSubVersion.size(), MAX_SUBVERSION_LENGTH));
@@ -1680,8 +1529,6 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)
     assert(!node.chainman);
 
     CTxMemPool::Options mempool_opts{
-        .estimator = node.fee_estimator.get(),
-        .scheduler = &*node.scheduler,
         .check_ratio = chainparams.DefaultConsistencyChecks() ? 1 : 0,
         .signals = &validation_signals,
     };
@@ -1690,22 +1537,9 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)
         return InitError(util::ErrorString(result));
     }
 
-    // If reindex=auto, then this returns false, which is intentional,
-    // because we check for auto only if corruption is detected
     bool do_reindex{args.GetBoolArg("-reindex", false)};
     const bool do_reindex_chainstate{args.GetBoolArg("-reindex-chainstate", false)};
 
-    if (gArgs.IsArgSet("-lowmem")) {
-        g_low_memory_threshold = gArgs.GetIntArg("-lowmem", 0 /* not used */) * 1024 * 1024;
-    }
-    if (g_low_memory_threshold > 0) {
-        LogPrintf("* Flushing caches if available system memory drops below %s MiB\n", g_low_memory_threshold / 1024 / 1024);
-    }
-
-    if (mempool_opts.rbf_policy == RBFPolicy::Always) {
-        nLocalServices = ServiceFlags(nLocalServices | NODE_REPLACE_BY_FEE);
-    }
-
     for (bool fLoaded = false; !fLoaded && !ShutdownRequested(node);) {
         bilingual_str mempool_error;
         node.mempool = std::make_unique<CTxMemPool>(mempool_opts, mempool_error);
@@ -1788,20 +1622,12 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)
         }
 
         if (!fLoaded && !ShutdownRequested(node)) {
-            // If reindex=auto, directly start the reindex
-            bool fAutoReindex = (args.GetArg("-reindex", "0") == "auto");
+            // first suggest a reindex
             if (!do_reindex) {
-                bool fRet;
-                if(!fAutoReindex) {
-                    // suggest a reindex to GUI users
-                    fRet = uiInterface.ThreadSafeQuestion(
-                        error + Untranslated(".\n\n") + _("Do you want to rebuild the block database now?"),
-                        error.original + ".\nPlease restart with -reindex or -reindex-chainstate to recover.",
-                        "", CClientUIInterface::MSG_ERROR | CClientUIInterface::BTN_ABORT);
-                } else {
-                    LogPrintf("Automatically running a reindex.\n");
-                    fRet = true;
-                }
+                bool fRet = uiInterface.ThreadSafeQuestion(
+                    error + Untranslated(".\n\n") + _("Do you want to rebuild the block database now?"),
+                    error.original + ".\nPlease restart with -reindex or -reindex-chainstate to recover.",
+                    "", CClientUIInterface::MSG_ERROR | CClientUIInterface::BTN_ABORT);
                 if (fRet) {
                     do_reindex = true;
                     if (!Assert(node.shutdown)->reset()) {
@@ -1898,7 +1724,7 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)
 
     // On first startup, warn on low block storage space
     if (!do_reindex && !do_reindex_chainstate && chain_active_height <= 1) {
-        uint64_t assumed_chain_bytes{chainparams.AssumedBlockchainSize() * 1'000'000'000};
+        uint64_t assumed_chain_bytes{chainparams.AssumedBlockchainSize() * 1024 * 1024 * 1024};
         uint64_t additional_bytes_needed{
             chainman.m_blockman.IsPruneMode() ?
                 std::min(chainman.m_blockman.GetPruneTarget(), assumed_chain_bytes) :
@@ -1910,7 +1736,7 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)
                     "Approximately %u GB of data will be stored in this directory."
                 ),
                 fs::quoted(fs::PathToString(args.GetBlocksDirPath())),
-                additional_bytes_needed / 1'000'000'000
+                chainparams.AssumedBlockchainSize()
             ));
         }
     }
@@ -1925,17 +1751,14 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)
     }
 
 #if HAVE_SYSTEM
-    if (args.IsArgSet("-blocknotify")) {
-        auto blocknotify_commands = args.GetArgs("-blocknotify");
-        uiInterface.NotifyBlockTip_connect([blocknotify_commands](SynchronizationState sync_state, const CBlockIndex* pBlockIndex) {
+    const std::string block_notify = args.GetArg("-blocknotify", "");
+    if (!block_notify.empty()) {
+        uiInterface.NotifyBlockTip_connect([block_notify](SynchronizationState sync_state, const CBlockIndex* pBlockIndex) {
             if (sync_state != SynchronizationState::POST_INIT || !pBlockIndex) return;
-            const std::string blockhash_hex = pBlockIndex->GetBlockHash().GetHex();
-            for (std::string command : blocknotify_commands) {
-                ReplaceAll(command, "%s", blockhash_hex);
-
-                std::thread t(runCommand, command);
-                t.detach(); // thread runs free
-            }
+            std::string command = block_notify;
+            ReplaceAll(command, "%s", pBlockIndex->GetBlockHash().GetHex());
+            std::thread t(runCommand, command);
+            t.detach(); // thread runs free
         });
     }
 #endif
@@ -1965,9 +1788,7 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)
         }
         // Load mempool from disk
         if (auto* pool{chainman.ActiveChainstate().GetMempool()}) {
-            LoadMempool(*pool, ShouldPersistMempool(args) ? MempoolPath(args) : fs::path{}, chainman.ActiveChainstate(), {
-                .load_knots_data = true,
-            });
+            LoadMempool(*pool, ShouldPersistMempool(args) ? MempoolPath(args) : fs::path{}, chainman.ActiveChainstate(), {});
             pool->SetLoadTried(!chainman.m_interrupt);
         }
     });
@@ -2026,7 +1847,6 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)
     connOptions.m_peer_connect_timeout = peer_connect_timeout;
     connOptions.whitelist_forcerelay = args.GetBoolArg("-whitelistforcerelay", DEFAULT_WHITELISTFORCERELAY);
     connOptions.whitelist_relay = args.GetBoolArg("-whitelistrelay", DEFAULT_WHITELISTRELAY);
-    connOptions.disable_v1conn_clearnet = args.GetBoolArg("-v2onlyclearnet", false);
 
     // Port to bind to if `-bind=addr` is provided without a `:port` suffix.
     const uint16_t default_bind_port =
@@ -2068,13 +1888,10 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)
         return InitError(ResolveErrMsg("bind", bind_arg));
     }
 
-    NetPermissionFlags all_permission_flags{NetPermissionFlags::None};
-
     for (const std::string& strBind : args.GetArgs("-whitebind")) {
         NetWhitebindPermissions whitebind;
         bilingual_str error;
         if (!NetWhitebindPermissions::TryParse(strBind, whitebind, error)) return InitError(error);
-        NetPermissions::AddFlag(all_permission_flags, whitebind.m_flags);
         connOptions.vWhiteBinds.push_back(whitebind);
     }
 
@@ -2121,7 +1938,6 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)
         ConnectionDirection connection_direction;
         bilingual_str error;
         if (!NetWhitelistPermissions::TryParse(net, subnet, connection_direction, error)) return InitError(error);
-        NetPermissions::AddFlag(all_permission_flags, subnet.m_flags);
         if (connection_direction & ConnectionDirection::In) {
             connOptions.vWhitelistedRangeIncoming.push_back(subnet);
         }
@@ -2130,12 +1946,6 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)
         }
     }
 
-    if (NetPermissions::HasFlag(all_permission_flags, NetPermissionFlags::BlockFilters_Explicit)) {
-        if (g_enabled_filter_types.count(BlockFilterType::BASIC) != 1) {
-            return InitError(_("Cannot grant blockfilters permission without -blockfilterindex."));
-        }
-    }
-
     connOptions.vSeedNodes = args.GetArgs("-seednode");
 
     // Initiate outbound connections unless connect=0
@@ -2206,12 +2016,6 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)
     StartupNotify(args);
 #endif
 
-    if (node.chainman->IsInitialBlockDownload()) {
-        node.scheduler->scheduleFromNow([&node] {
-            SyncCoinsTipAfterChainSync(node);
-        }, SYNC_CHECK_INTERVAL);
-    }
-
     return true;
 }
 
diff --git a/src/init/common.cpp b/src/init/common.cpp
index fefb29c9ac..36142c2b9a 100644
--- a/src/init/common.cpp
+++ b/src/init/common.cpp
@@ -17,7 +17,6 @@
 #include <util/translation.h>
 
 #include <algorithm>
-#include <filesystem>
 #include <string>
 #include <vector>
 
@@ -123,28 +122,16 @@ bool StartLogging(const ArgsManager& args)
 
     // Only log conf file usage message if conf file actually exists.
     fs::path config_file_path = args.GetConfigFilePath();
-    if (args.IsArgNegated("-conf")) {
-        LogInfo("Config file: <disabled>");
-    } else if (fs::is_directory(config_file_path)) {
-        LogWarning("Config file: %s (is directory, not file)", fs::PathToString(config_file_path));
-    } else if (fs::exists(config_file_path)) {
+    if (fs::exists(config_file_path)) {
         LogPrintf("Config file: %s\n", fs::PathToString(config_file_path));
     } else if (args.IsArgSet("-conf")) {
+        // Warn if no conf file exists at path provided by user
         InitWarning(strprintf(_("The specified config file %s does not exist"), fs::PathToString(config_file_path)));
     } else {
         // Not categorizing as "Warning" because it's the default behavior
         LogPrintf("Config file: %s (not found, skipping)\n", fs::PathToString(config_file_path));
     }
 
-    fs::path rwconfig_file_path = args.GetRWConfigFilePath();
-    if (fs::exists(rwconfig_file_path)) {
-        LogPrintf("R/W Config file: %s\n", fs::PathToString(rwconfig_file_path));
-    } else if (gArgs.IsArgSet("-confrw")) {
-        InitWarning(strprintf(_("The specified R/W config file %s does not exist"), fs::PathToString(rwconfig_file_path)));
-    } else {
-        LogPrintf("R/W Config file: %s (not found, skipping)\n", fs::PathToString(rwconfig_file_path));
-    }
-
     // Log the config arguments to debug.log
     args.LogArgs();
 
diff --git a/src/interfaces/chain.h b/src/interfaces/chain.h
index e8d264645e..be596b1765 100644
--- a/src/interfaces/chain.h
+++ b/src/interfaces/chain.h
@@ -10,7 +10,6 @@
 #include <primitives/transaction.h> // For CTransactionRef
 #include <util/result.h>
 
-#include <any>
 #include <functional>
 #include <memory>
 #include <optional>
@@ -35,7 +34,6 @@ struct CBlockLocator;
 struct FeeCalculation;
 namespace node {
 struct NodeContext;
-struct PruneLockInfo;
 } // namespace node
 
 namespace interfaces {
@@ -150,10 +148,6 @@ public:
     //! pruned), and contains transactions.
     virtual bool haveBlockOnDisk(int height) = 0;
 
-    virtual bool pruneLockExists(const std::string& name) const = 0;
-    virtual bool updatePruneLock(const std::string& name, const node::PruneLockInfo& lock_info, bool sync=false) = 0;
-    virtual bool deletePruneLock(const std::string& name) = 0;
-
     //! Get locator for the current chain tip.
     virtual CBlockLocator getTipLocator() = 0;
 
@@ -319,9 +313,6 @@ public:
     //! Send init error.
     virtual void initError(const bilingual_str& message) = 0;
 
-    //! Ask init question.
-    virtual bool initQuestion(const bilingual_str& message, const bilingual_str& non_interactive_message, const bilingual_str& caption, unsigned int style) = 0;
-
     //! Send progress indicator.
     virtual void showProgress(const std::string& title, int progress, bool resume_possible) = 0;
 
@@ -400,8 +391,6 @@ class ChainClient
 public:
     virtual ~ChainClient() = default;
 
-    virtual void assignContextHACK(std::any&) {};
-
     //! Register rpcs.
     virtual void registerRpcs() = 0;
 
diff --git a/src/interfaces/mining.h b/src/interfaces/mining.h
index 1577a4cc50..cebe97edb7 100644
--- a/src/interfaces/mining.h
+++ b/src/interfaces/mining.h
@@ -40,14 +40,13 @@ public:
     virtual std::optional<uint256> getTipHash() = 0;
 
    /**
-     * Construct a new block template. For the createNewBlock variant, subclass options (if any) are silently lost and overridden by any config args. For createNewBlock2, the options are assumed to be complete.
+     * Construct a new block template
      *
      * @param[in] script_pub_key the coinbase output
      * @param[in] options options for creating the block
      * @returns a block template
      */
-    virtual std::shared_ptr<node::CBlockTemplate> createNewBlock(const CScript& script_pub_key, const node::BlockCreateOptions& options={}) = 0;
-    virtual std::shared_ptr<node::CBlockTemplate> createNewBlock2(const CScript& script_pub_key, const node::BlockCreateOptions& assemble_options) = 0;
+    virtual std::unique_ptr<node::CBlockTemplate> createNewBlock(const CScript& script_pub_key, const node::BlockCreateOptions& options={}) = 0;
 
     /**
      * Processes new block. A valid new block is automatically relayed to peers.
diff --git a/src/interfaces/node.h b/src/interfaces/node.h
index 74fc18a7f8..81844c6185 100644
--- a/src/interfaces/node.h
+++ b/src/interfaces/node.h
@@ -20,13 +20,11 @@
 #include <stdint.h>
 #include <string>
 #include <tuple>
-#include <variant>
 #include <vector>
 
 class BanMan;
 class CFeeRate;
 class CNodeStats;
-class CTxMemPool;
 class Coin;
 class RPCTimerInterface;
 class UniValue;
@@ -158,8 +156,6 @@ public:
     //! Get total bytes sent.
     virtual int64_t getTotalBytesSent() = 0;
 
-    virtual CTxMemPool& mempool() = 0;
-
     //! Get mempool size.
     virtual size_t getMempoolSize() = 0;
 
@@ -218,7 +214,7 @@ public:
     virtual std::optional<Coin> getUnspentOutput(const COutPoint& output) = 0;
 
     //! Broadcast transaction.
-    virtual node::TransactionError broadcastTransaction(CTransactionRef tx, const std::variant<CAmount, CFeeRate>& max_tx_fee, std::string& err_string) = 0;
+    virtual node::TransactionError broadcastTransaction(CTransactionRef tx, CAmount max_tx_fee, std::string& err_string) = 0;
 
     //! Get wallet loader.
     virtual WalletLoader& walletLoader() = 0;
@@ -255,10 +251,6 @@ public:
     using NotifyNetworkActiveChangedFn = std::function<void(bool network_active)>;
     virtual std::unique_ptr<Handler> handleNotifyNetworkActiveChanged(NotifyNetworkActiveChangedFn fn) = 0;
 
-    //! Register handler for network local changed messages.
-    using NotifyNetworkLocalChangedFn = std::function<void()>;
-    virtual std::unique_ptr<Handler> handleNotifyNetworkLocalChanged(NotifyNetworkLocalChangedFn fn) = 0;
-
     //! Register handler for notify alert messages.
     using NotifyAlertChangedFn = std::function<void()>;
     virtual std::unique_ptr<Handler> handleNotifyAlertChanged(NotifyAlertChangedFn fn) = 0;
diff --git a/src/interfaces/wallet.h b/src/interfaces/wallet.h
index 035c7800bf..df1ced48a7 100644
--- a/src/interfaces/wallet.h
+++ b/src/interfaces/wallet.h
@@ -48,11 +48,6 @@ struct WalletContext;
 using isminefilter = std::underlying_type<isminetype>::type;
 } // namespace wallet
 
-enum class WalletBackupFormat {
-    Raw,   // Literal db copy
-    DbDump,  // DumpWallet plaintext low-level db dump
-};
-
 namespace interfaces {
 
 class Handler;
@@ -94,10 +89,8 @@ public:
     //! Abort a rescan.
     virtual void abortRescan() = 0;
 
-    virtual bool canBackupToDbDump() = 0;
-
     //! Back up wallet.
-    virtual bool backupWallet(const std::string& filename, const WalletBackupFormat format, bilingual_str& error) = 0;
+    virtual bool backupWallet(const std::string& filename) = 0;
 
     //! Get wallet name.
     virtual std::string getWalletName() = 0;
@@ -109,7 +102,7 @@ public:
     virtual bool getPubKey(const CScript& script, const CKeyID& address, CPubKey& pub_key) = 0;
 
     //! Sign message
-    virtual SigningResult signMessage(const MessageSignatureFormat format, const std::string& message, const CTxDestination& address, std::string& str_sig) = 0;
+    virtual SigningResult signMessage(const std::string& message, const PKHash& pkhash, std::string& str_sig) = 0;
 
     //! Return whether wallet has private key.
     virtual bool isSpendable(const CTxDestination& dest) = 0;
@@ -141,9 +134,6 @@ public:
     //! Display address on external signer
     virtual util::Result<void> displayAddress(const CTxDestination& dest) = 0;
 
-    virtual bool checkAddressForUsage(const std::vector<std::string>& addresses) const = 0;
-    virtual bool findAddressUsage(const std::vector<std::string>& addresses, std::function<void(const std::string&, const WalletTx&, uint32_t)> callback) const = 0;
-
     //! Lock coin.
     virtual bool lockCoin(const COutPoint& output, const bool write_to_db) = 0;
 
@@ -436,8 +426,6 @@ struct WalletTxStatus
     bool is_abandoned;
     bool is_coinbase;
     bool is_in_main_chain;
-    // The block containing this transaction is assumed valid
-    bool is_assumed;
 };
 
 //! Wallet transaction output.
diff --git a/src/kernel/blockmanager_opts.h b/src/kernel/blockmanager_opts.h
index 47a07bc89f..261ec3be58 100644
--- a/src/kernel/blockmanager_opts.h
+++ b/src/kernel/blockmanager_opts.h
@@ -24,7 +24,6 @@ struct BlockManagerOpts {
     const CChainParams& chainparams;
     bool use_xor{DEFAULT_XOR_BLOCKSDIR};
     uint64_t prune_target{0};
-    int64_t prune_target_during_init{-1};
     bool fast_prune{false};
     const fs::path blocks_dir;
     Notifications& notifications;
diff --git a/src/kernel/chainparams.cpp b/src/kernel/chainparams.cpp
index 66c8391a79..c995225064 100644
--- a/src/kernel/chainparams.cpp
+++ b/src/kernel/chainparams.cpp
@@ -115,8 +115,8 @@ public:
         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nTimeout = 1628640000; // August 11th, 2021
         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].min_activation_height = 709632; // Approximately November 12th, 2021
 
-        consensus.nMinimumChainWork = uint256{"0000000000000000000000000000000000000000b08ea5865bede3101629fa0e"};
-        consensus.defaultAssumeValid = uint256{"000000000000000000006e926737e6a349f7581525ad36e743dfe5f4bc3abbb7"}; // 885248
+        consensus.nMinimumChainWork = uint256{"000000000000000000000000000000000000000088e186b70e0862c193ec44d6"};
+        consensus.defaultAssumeValid = uint256{"000000000000000000011c5890365bdbe5d25b97ce0057589acaef4f1a57263f"}; // 856760
 
         /**
          * The message start string is designed to be unlikely to occur in normal data.
@@ -129,7 +129,7 @@ public:
         pchMessageStart[3] = 0xd9;
         nDefaultPort = 8333;
         nPruneAfterHeight = 100000;
-        m_assumed_blockchain_size = 810;
+        m_assumed_blockchain_size = 620;
         m_assumed_chain_state_size = 14;
 
         genesis = CreateGenesisBlock(1231006505, 2083236893, 0x1d00ffff, 1, 50 * COIN);
@@ -180,31 +180,6 @@ public:
                 {250000, uint256{"000000000000003887df1f29024b06fc2200b55f8af8f35453d7be294df2d214"}},
                 {279000, uint256{"0000000000000001ae8c72a0b0c301f67e3afca10e819efa9041e458e9bd7e40"}},
                 {295000, uint256{"00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983"}},
-                {393216, uint256{"00000000000000000390df7d2bdc06b9fcb260b39e3fb15b4bc9f62572553924"}},
-                {421888, uint256{"000000000000000004b232ad9492d0729d7f9d6737399ffcdaac1c8160db5ef6"}},
-                {438784, uint256{"0000000000000000040d6ef667d7a52caf93d8e0d1e40fd7155c787b42667179"}},
-                {451840, uint256{"0000000000000000029103c8ade7786e7379623465c72d71d84624eb9c159bea"}},
-                {469766, uint256{"000000000000000000130b2bd812c6a7ae9c02a74fc111806b1dd11e8975da45"}},
-                {481824, uint256{"0000000000000000001c8018d9cb3b742ef25114f27563e3fc4a1902167f9893"}},
-                {514048, uint256{"00000000000000000022fe630be397a62c58972bb81f0a2d1ae8c968511a4659"}},
-                {553472, uint256{"0000000000000000000e06b6698a4f65ab9915f24b23ca2f9d1abf30cc3e9173"}},
-                {571392, uint256{"00000000000000000019c18b43077775fc299a6646ab0e9dbbd5770bf6ca392d"}},
-                {596000, uint256{"0000000000000000000706f93dc673ca366c810f317e7cfe8d951c0107b65223"}},
-                {601723, uint256{"000000000000000000009837f74796532b21d8ccf7def3dcfcb45aa92cd86b9e"}},
-                {617056, uint256{"0000000000000000000ca51b293fb2be2fbaf1acc76dcbbbff7e4d7796380b9e"}},
-                {632549, uint256{"00000000000000000001bae1b2b73ec3fde475c1ed7fdd382c2c49860ec19920"}},
-                {643700, uint256{"00000000000000000002959e9b44507120453344794df09bd1276eb325ed7110"}},
-                {667811, uint256{"00000000000000000007888a9d01313d69d6335df46ea33e875ee6832670c596"}},
-                {688888, uint256{"0000000000000000000e1e3bd783ce0de7b0cdabf2034723595dbcd5a28cf831"}},
-                {704256, uint256{"0000000000000000000465f5acfcd603337994261a4d67a647cb49866c98b538"}},
-                {714000, uint256{"0000000000000000000184f9b9da75c3ab764438f4f3ecd766637648a3a44d0d"}},
-                {737232, uint256{"0000000000000000000709881cc8d33f84815fe8ea1baad9889042146b4d3042"}},
-                {803584, uint256{"000000000000000000003d97a46dbbb4cca4b3e23c39c446df75cfe726163bb5"}},
-                {832080, uint256{"00000000000000000003349bda23ed5efc98145c10620c247ec93896ac249e22"}},
-                {843264, uint256{"0000000000000000000101209b4ab3570862dc3fac8633eb62938a541c55a2ff"}},
-                {846679, uint256{"000000000000000000032b91acdaaf16f8c40d46afeb835c3ac604860f905d56"}},
-                {855000, uint256{"0000000000000000000233ea80aa10d38aa4486cd7033fffc2c4df556d0b9138"}},
-                {885248, uint256{"000000000000000000006e926737e6a349f7581525ad36e743dfe5f4bc3abbb7"}},
             }
         };
 
@@ -214,20 +189,14 @@ public:
                 .hash_serialized = AssumeutxoHash{uint256{"a2a5521b1b5ab65f67818e5e8eccabb7171a517f9e2382208f77687310768f96"}},
                 .m_chain_tx_count = 991032194,
                 .blockhash = consteval_ctor(uint256{"0000000000000000000320283a032748cef8227873ff4872689bf23f1cda83a5"}),
-            },
-            {
-                .height = 880'000,
-                .hash_serialized = AssumeutxoHash{uint256{"dbd190983eaf433ef7c15f78a278ae42c00ef52e0fd2a54953782175fbadcea9"}},
-                .m_chain_tx_count = 1145604538,
-                .blockhash = consteval_ctor(uint256{"000000000000000000010b17283c3c400507969a9c2afd1dcf2082ec5cca2880"}),
             }
         };
 
         chainTxData = ChainTxData{
-            // Data from RPC: getchaintxstats 4096 00000000000000000000ab8f76c0f2786ee0272b394ef8ee677f340918fb567a
-            .nTime    = 1740536534,
-            .tx_count = 1160003905,
-            .dTxRate  = 6.721086701157182,  // held back due to present abnormal tx rate
+            // Data from RPC: getchaintxstats 4096 000000000000000000011c5890365bdbe5d25b97ce0057589acaef4f1a57263f
+            .nTime    = 1723649144,
+            .tx_count = 1059312821,
+            .dTxRate  = 6.721086701157182,
         };
     }
 };
@@ -490,7 +459,7 @@ public:
         consensus.CSVHeight = 1;
         consensus.SegwitHeight = 1;
         consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks
-        consensus.nPowTargetSpacing = options.pow_target_spacing;
+        consensus.nPowTargetSpacing = 10 * 60;
         consensus.fPowAllowMinDifficultyBlocks = false;
         consensus.enforce_BIP94 = false;
         consensus.fPowNoRetargeting = false;
diff --git a/src/kernel/chainparams.h b/src/kernel/chainparams.h
index 2438742f04..c4584600fd 100644
--- a/src/kernel/chainparams.h
+++ b/src/kernel/chainparams.h
@@ -33,12 +33,6 @@ struct CCheckpointData {
         const auto& final_checkpoint = mapCheckpoints.rbegin();
         return final_checkpoint->first /* height */;
     }
-
-    bool CheckBlock(int height, const uint256& hash) const {
-        const auto i = mapCheckpoints.find(height);
-        if (i == mapCheckpoints.end()) return true;
-        return hash == i->second;
-    }
 };
 
 struct AssumeutxoHash : public BaseHash<uint256> {
@@ -143,7 +137,6 @@ public:
     struct SigNetOptions {
         std::optional<std::vector<uint8_t>> challenge{};
         std::optional<std::vector<std::string>> seeds{};
-        int64_t pow_target_spacing{10 * 60};
     };
 
     /**
diff --git a/src/kernel/checks.cpp b/src/kernel/checks.cpp
index 5b9eda48ac..e4a13ee4cc 100644
--- a/src/kernel/checks.cpp
+++ b/src/kernel/checks.cpp
@@ -4,7 +4,6 @@
 
 #include <kernel/checks.h>
 
-#include <dbwrapper.h>
 #include <random.h>
 #include <util/result.h>
 #include <util/translation.h>
@@ -13,30 +12,8 @@
 
 namespace kernel {
 
-bool Clang_IndVarSimplify_Bug_SanityCheck() {
-    // See https://github.com/llvm/llvm-project/issues/96267
-    const char s[] = {0, 0x75};
-    signed int last = 0xff;
-    for (const char *it = s; it < &s[2]; ++it) {
-        if (*it <= 0x4e) {
-        } else if (*it == 0x75 && last <= 0x4e) {
-            return true;
-        }
-        last = *it;
-    }
-    return false;
-}
-
 util::Result<void> SanityChecks(const Context&)
 {
-    if (!dbwrapper_SanityCheck()) {
-        return util::Error{Untranslated("Database sanity check failure. Aborting.")};
-    }
-
-    if (!Clang_IndVarSimplify_Bug_SanityCheck()) {
-        return util::Error{Untranslated("Compiler optimization sanity check failure. Aborting.")};
-    }
-
     if (!Random_SanityCheck()) {
         return util::Error{Untranslated("OS cryptographic RNG sanity check failure. Aborting.")};
     }
diff --git a/src/kernel/checks.h b/src/kernel/checks.h
index 28b112df18..fd8c167015 100644
--- a/src/kernel/checks.h
+++ b/src/kernel/checks.h
@@ -11,8 +11,6 @@ namespace kernel {
 
 struct Context;
 
-[[nodiscard]] bool Clang_IndVarSimplify_Bug_SanityCheck();
-
 /**
  *  Ensure a usable environment with all necessary library support.
  */
diff --git a/src/kernel/mempool_entry.h b/src/kernel/mempool_entry.h
index 19030235b1..2adeaea652 100644
--- a/src/kernel/mempool_entry.h
+++ b/src/kernel/mempool_entry.h
@@ -8,14 +8,12 @@
 #include <consensus/amount.h>
 #include <consensus/validation.h>
 #include <core_memusage.h>
-#include <policy/coin_age_priority.h>
 #include <policy/policy.h>
 #include <policy/settings.h>
 #include <primitives/transaction.h>
 #include <util/epochguard.h>
 #include <util/overflow.h>
 
-#include <cassert>
 #include <chrono>
 #include <functional>
 #include <memory>
@@ -37,15 +35,6 @@ struct LockPoints {
     CBlockIndex* maxInputBlock{nullptr};
 };
 
-enum MemPool_SPK_State {
-    MSS_UNSEEN  = 0,
-    MSS_SPENT   = 1,  // .second
-    MSS_CREATED = 2,  // .first
-    MSS_BOTH    = 3,
-};
-
-typedef std::map<uint160, enum MemPool_SPK_State> SPKStates_t;
-
 struct CompareIteratorByHash {
     // SFINAE for T where T is either a pointer type (e.g., a txiter) or a reference_wrapper<T>
     // (e.g. a wrapped CTxMemPoolEntry&)
@@ -95,15 +84,9 @@ private:
     const size_t nUsageSize;        //!< ... and total memory usage
     const int64_t nTime;            //!< Local time when entering the mempool
     const uint64_t entry_sequence;  //!< Sequence number used to determine whether this transaction is too recent for relay
-    const int64_t sigOpCost;        //!< Total sigop cost
-    const int32_t m_extra_weight;   //!< Policy-only additional transaction weight beyond nTxWeight
-    const size_t nModSize;          //!< Cached modified size for priority
-    const double entryPriority;     //!< Priority when entering the mempool
     const unsigned int entryHeight; //!< Chain height when entering the mempool
-    double cachedPriority;          //!< Last calculated priority
-    unsigned int cachedHeight;      //!< Height at which priority was last calculated
-    CAmount inChainInputValue;      //!< Sum of all txin values that are already in blockchain
     const bool spendsCoinbase;      //!< keep track of transactions that spend a coinbase
+    const int64_t sigOpCost;        //!< Total sigop cost
     CAmount m_modified_fee;         //!< Used for determining the priority of the transaction for mining in a block
     mutable LockPoints lockPoints;  //!< Track the height and time at which tx was final
 
@@ -125,10 +108,7 @@ private:
 public:
     CTxMemPoolEntry(const CTransactionRef& tx, CAmount fee,
                     int64_t time, unsigned int entry_height, uint64_t entry_sequence,
-                    double entry_tx_inputs_coin_age,
-                    CAmount in_chain_input_value,
                     bool spends_coinbase,
-                    int32_t extra_weight,
                     int64_t sigops_cost, LockPoints lp)
         : tx{tx},
           nFee{fee},
@@ -136,26 +116,16 @@ public:
           nUsageSize{RecursiveDynamicUsage(tx)},
           nTime{time},
           entry_sequence{entry_sequence},
-          sigOpCost{sigops_cost},
-          m_extra_weight{extra_weight},
-          nModSize{CalculateModifiedSize(*tx, GetTxSize())},
-          entryPriority{ComputePriority2(entry_tx_inputs_coin_age, nModSize)},
           entryHeight{entry_height},
-          cachedPriority{entryPriority},
-          // Since entries arrive *after* the tip's height, their entry priority is for the height+1
-          cachedHeight{entry_height + 1},
-          inChainInputValue{in_chain_input_value},
           spendsCoinbase{spends_coinbase},
+          sigOpCost{sigops_cost},
           m_modified_fee{nFee},
           lockPoints{lp},
           nSizeWithDescendants{GetTxSize()},
           nModFeesWithDescendants{nFee},
           nSizeWithAncestors{GetTxSize()},
           nModFeesWithAncestors{nFee},
-          nSigOpCostWithAncestors{sigOpCost} {
-            CAmount nValueIn = tx->GetValueOut() + nFee;
-            assert(inChainInputValue <= nValueIn);
-        }
+          nSigOpCostWithAncestors{sigOpCost} {}
 
     CTxMemPoolEntry(ExplicitCopyTag, const CTxMemPoolEntry& entry) : CTxMemPoolEntry(entry) {}
     CTxMemPoolEntry& operator=(const CTxMemPoolEntry&) = delete;
@@ -166,21 +136,10 @@ public:
 
     const CTransaction& GetTx() const { return *this->tx; }
     CTransactionRef GetSharedTx() const { return this->tx; }
-    double GetStartingPriority() const {return entryPriority; }
-    /**
-     * Fast calculation of priority as update from cached value, but only valid if
-     * currentHeight is greater than last height it was recalculated.
-     */
-    double GetPriority(unsigned int currentHeight) const;
-    /**
-     * Recalculate the cached priority as of currentHeight and adjust inChainInputValue by
-     * valueInCurrentBlock which represents input that was just added to or removed from the blockchain.
-     */
-    void UpdateCachedPriority(unsigned int currentHeight, CAmount valueInCurrentBlock);
     const CAmount& GetFee() const { return nFee; }
     int32_t GetTxSize() const
     {
-        return GetVirtualTransactionSize(nTxWeight + m_extra_weight, sigOpCost, ::nBytesPerSigOp);
+        return GetVirtualTransactionSize(nTxWeight, sigOpCost, ::nBytesPerSigOp);
     }
     int32_t GetTxWeight() const { return nTxWeight; }
     std::chrono::seconds GetTime() const { return std::chrono::seconds{nTime}; }
@@ -227,8 +186,6 @@ public:
 
     mutable size_t idx_randomized; //!< Index in mempool's txns_randomized
     mutable Epoch::Marker m_epoch_marker; //!< epoch when last touched, useful for graph algorithms
-
-    SPKStates_t mapSPK;
 };
 
 using CTxMemPoolEntryRef = CTxMemPoolEntry::CTxMemPoolEntryRef;
@@ -269,7 +226,7 @@ struct NewMempoolTransactionInfo {
      * This boolean indicates whether the transaction was added
      * without enforcing mempool fee limits.
      */
-    const ignore_rejects_type m_ignore_rejects;
+    const bool m_mempool_limit_bypassed;
     /* This boolean indicates whether the transaction is part of a package. */
     const bool m_submitted_in_package;
     /*
@@ -282,11 +239,11 @@ struct NewMempoolTransactionInfo {
 
     explicit NewMempoolTransactionInfo(const CTransactionRef& tx, const CAmount& fee,
                                        const int64_t vsize, const unsigned int height,
-                                       const ignore_rejects_type& ignore_rejects, const bool submitted_in_package,
+                                       const bool mempool_limit_bypassed, const bool submitted_in_package,
                                        const bool chainstate_is_current,
                                        const bool has_no_mempool_parents)
         : info{tx, fee, vsize, height},
-          m_ignore_rejects{ignore_rejects},
+          m_mempool_limit_bypassed{mempool_limit_bypassed},
           m_submitted_in_package{submitted_in_package},
           m_chainstate_is_current{chainstate_is_current},
           m_has_no_mempool_parents{has_no_mempool_parents} {}
diff --git a/src/kernel/mempool_options.h b/src/kernel/mempool_options.h
index 8fab5d2ec3..4e1e24a11d 100644
--- a/src/kernel/mempool_options.h
+++ b/src/kernel/mempool_options.h
@@ -13,27 +13,18 @@
 #include <cstdint>
 #include <optional>
 
-class CBlockPolicyEstimator;
-class CScheduler;
 class ValidationSignals;
 
-enum class RBFPolicy { Never, OptIn, Always };
-enum class TRUCPolicy { Reject, Accept, Enforce };
-
 /** Default for -maxmempool, maximum megabytes of mempool memory usage */
 static constexpr unsigned int DEFAULT_MAX_MEMPOOL_SIZE_MB{300};
 /** Default for -maxmempool when blocksonly is set */
 static constexpr unsigned int DEFAULT_BLOCKSONLY_MAX_MEMPOOL_SIZE_MB{5};
 /** Default for -mempoolexpiry, expiration time for mempool transactions in hours */
 static constexpr unsigned int DEFAULT_MEMPOOL_EXPIRY_HOURS{336};
-/** Default for -mempoolreplacement; must update docs in init.cpp manually */
-static constexpr RBFPolicy DEFAULT_MEMPOOL_RBF_POLICY{RBFPolicy::Always};
-/** Default for -mempooltruc; must update docs in init.cpp manually */
-static constexpr TRUCPolicy DEFAULT_MEMPOOL_TRUC_POLICY{TRUCPolicy::Accept};
+/** Default for -mempoolfullrbf, if the transaction replaceability signaling is ignored */
+static constexpr bool DEFAULT_MEMPOOL_FULL_RBF{true};
 /** Whether to fall back to legacy V1 serialization when writing mempool.dat */
 static constexpr bool DEFAULT_PERSIST_V1_DAT{false};
-/** Default for -acceptnonstddatacarrier */
-static constexpr bool DEFAULT_ACCEPT_NON_STD_DATACARRIER{false};
 /** Default for -acceptnonstdtxn */
 static constexpr bool DEFAULT_ACCEPT_NON_STD_TXN{false};
 
@@ -46,9 +37,6 @@ namespace kernel {
  * Most of the time, this struct should be referenced as CTxMemPool::Options.
  */
 struct MemPoolOptions {
-    /* Used to estimate appropriate transaction fees. */
-    CBlockPolicyEstimator* estimator{nullptr};
-    CScheduler* scheduler{nullptr};
     /* The ratio used to determine how often sanity checks will run.  */
     int check_ratio{0};
     int64_t max_size_bytes{DEFAULT_MAX_MEMPOOL_SIZE_MB * 1'000'000};
@@ -57,11 +45,6 @@ struct MemPoolOptions {
     /** A fee rate smaller than this is considered zero fee (for relaying, mining and transaction creation) */
     CFeeRate min_relay_feerate{DEFAULT_MIN_RELAY_TX_FEE};
     CFeeRate dust_relay_feerate{DUST_RELAY_TX_FEE};
-    CFeeRate dust_relay_feerate_floor{DUST_RELAY_TX_FEE};
-    /** Negative for a target number of blocks, positive for target kB into current mempool. */
-    int32_t dust_relay_target{0};
-    /** Multiplier for dustdynamic assignments, in thousandths. */
-    int dust_relay_multiplier{DEFAULT_DUST_RELAY_MULTIPLIER};
     /**
      * A data carrying output is an unspendable output containing data. The script
      * type is designated as TxoutType::NULL_DATA.
@@ -70,15 +53,9 @@ struct MemPoolOptions {
      * If nullopt, any size is nonstandard.
      */
     std::optional<unsigned> max_datacarrier_bytes{DEFAULT_ACCEPT_DATACARRIER ? std::optional{MAX_OP_RETURN_RELAY} : std::nullopt};
-    bool datacarrier_fullcount{DEFAULT_DATACARRIER_FULLCOUNT};
-    bool permit_bare_pubkey{DEFAULT_PERMIT_BAREPUBKEY};
     bool permit_bare_multisig{DEFAULT_PERMIT_BAREMULTISIG};
-    bool reject_parasites{DEFAULT_REJECT_PARASITES};
-    bool reject_tokens{DEFAULT_REJECT_TOKENS};
-    bool accept_non_std_datacarrier{DEFAULT_ACCEPT_NON_STD_DATACARRIER};
     bool require_standard{true};
-    RBFPolicy rbf_policy{DEFAULT_MEMPOOL_RBF_POLICY};
-    TRUCPolicy truc_policy{DEFAULT_MEMPOOL_TRUC_POLICY};
+    bool full_rbf{DEFAULT_MEMPOOL_FULL_RBF};
     bool persist_v1_dat{DEFAULT_PERSIST_V1_DAT};
     MemPoolLimits limits{};
 
diff --git a/src/kernel/notifications_interface.h b/src/kernel/notifications_interface.h
index 516ad0f967..ef72d9bdb6 100644
--- a/src/kernel/notifications_interface.h
+++ b/src/kernel/notifications_interface.h
@@ -40,7 +40,7 @@ public:
     [[nodiscard]] virtual InterruptResult blockTip(SynchronizationState state, CBlockIndex& index) { return {}; }
     virtual void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) {}
     virtual void progress(const bilingual_str& title, int progress_percent, bool resume_possible) {}
-    virtual void warningSet(Warning id, const bilingual_str& message, bool update=false) {}
+    virtual void warningSet(Warning id, const bilingual_str& message) {}
     virtual void warningUnset(Warning id) {}
 
     //! The flush error notification is sent to notify the user that an error
diff --git a/src/kernel/warning.h b/src/kernel/warning.h
index ee26ffcdac..453f36c552 100644
--- a/src/kernel/warning.h
+++ b/src/kernel/warning.h
@@ -9,8 +9,6 @@ namespace kernel {
 enum class Warning {
     UNKNOWN_NEW_RULES_ACTIVATED,
     LARGE_WORK_INVALID_CHAIN,
-    UNKNOWN_NEW_RULES_SIGNAL_VBITS,
-    UNKNOWN_NEW_RULES_SIGNAL_INTVER,
 };
 } // namespace kernel
 #endif // BITCOIN_KERNEL_WARNING_H
diff --git a/src/leveldb/util/hash.cc b/src/leveldb/util/hash.cc
index 5432b6180d..dd47c110ee 100644
--- a/src/leveldb/util/hash.cc
+++ b/src/leveldb/util/hash.cc
@@ -27,7 +27,7 @@ uint32_t Hash(const char* data, size_t n, uint32_t seed) {
   uint32_t h = seed ^ (n * m);
 
   // Pick up four bytes at a time
-  while (limit - data >= 4) {
+  while (data + 4 <= limit) {
     uint32_t w = DecodeFixed32(data);
     data += 4;
     h += w;
diff --git a/src/logging.cpp b/src/logging.cpp
index 65f8f7caf9..9a54a12b42 100644
--- a/src/logging.cpp
+++ b/src/logging.cpp
@@ -369,8 +369,6 @@ static size_t MemUsage(const BCLog::Logger::BufferedLog& buflog)
 
 void BCLog::Logger::FormatLogStrInPlace(std::string& str, BCLog::LogFlags category, BCLog::Level level, std::string_view source_file, int source_line, std::string_view logging_function, std::string_view threadname, SystemClock::time_point now, std::chrono::seconds mocktime) const
 {
-    if (!str.ends_with('\n')) str.push_back('\n');
-
     str.insert(0, GetLogPrefix(category, level));
 
     if (m_log_sourcelocations) {
diff --git a/src/net.cpp b/src/net.cpp
index 1404e99110..05b98d1029 100644
--- a/src/net.cpp
+++ b/src/net.cpp
@@ -273,17 +273,14 @@ bool AddLocal(const CService& addr_, int nScore)
     if (!fDiscover && nScore < LOCAL_MANUAL)
         return false;
 
-    // IPv4 and IPv6 cannot be connected to unless their networks are reachable, but Tor is not necessarily bidirectional
-    if (!(g_reachable_nets.Contains(addr) || addr.IsTor()))
+    if (!g_reachable_nets.Contains(addr))
         return false;
 
     LogPrintf("AddLocal(%s,%i)\n", addr.ToStringAddrPort(), nScore);
 
-    bool fAlready;
     {
         LOCK(g_maplocalhost_mutex);
         const auto [it, is_newly_added] = mapLocalHost.emplace(addr, LocalServiceInfo());
-        fAlready = !is_newly_added;
         LocalServiceInfo &info = it->second;
         if (is_newly_added || nScore >= info.nScore) {
             info.nScore = nScore + (is_newly_added ? 0 : 1);
@@ -291,10 +288,6 @@ bool AddLocal(const CService& addr_, int nScore)
         }
     }
 
-    if (!fAlready) {
-        uiInterface.NotifyNetworkLocalChanged();
-    }
-
     return true;
 }
 
@@ -305,12 +298,9 @@ bool AddLocal(const CNetAddr &addr, int nScore)
 
 void RemoveLocal(const CService& addr)
 {
-    {
-        LOCK(g_maplocalhost_mutex);
-        LogPrintf("RemoveLocal(%s)\n", addr.ToStringAddrPort());
-        mapLocalHost.erase(addr);
-    }
-    uiInterface.NotifyNetworkLocalChanged();
+    LOCK(g_maplocalhost_mutex);
+    LogPrintf("RemoveLocal(%s)\n", addr.ToStringAddrPort());
+    mapLocalHost.erase(addr);
 }
 
 /** vote for a local address */
@@ -462,9 +452,6 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo
     std::unique_ptr<i2p::sam::Session> i2p_transient_session;
 
     for (auto& target_addr: connect_to) {
-        if (DisableV1OnClearnet(target_addr.GetNetClass()) && !use_v2transport) {
-            continue;
-        }
         if (target_addr.IsValid()) {
             const bool use_proxy{GetProxy(target_addr.GetNetwork(), proxy)};
             bool proxyConnectionFailed = false;
@@ -524,7 +511,8 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo
         }
 
         NetPermissionFlags permission_flags = NetPermissionFlags::None;
-        AddWhitelistPermissionFlags(permission_flags, target_addr, vWhitelistedRangeOutgoing);
+        std::vector<NetWhitelistPermissions> whitelist_permissions = conn_type == ConnectionType::MANUAL ? vWhitelistedRangeOutgoing : std::vector<NetWhitelistPermissions>{};
+        AddWhitelistPermissionFlags(permission_flags, target_addr, whitelist_permissions);
 
         // Add node
         NodeId id = GetNewNodeId();
@@ -581,7 +569,6 @@ void CConnman::AddWhitelistPermissionFlags(NetPermissionFlags& flags, const CNet
         if (whitelist_relay) NetPermissions::AddFlag(flags, NetPermissionFlags::Relay);
         NetPermissions::AddFlag(flags, NetPermissionFlags::Mempool);
         NetPermissions::AddFlag(flags, NetPermissionFlags::NoBan);
-        NetPermissions::AddFlag(flags, NetPermissionFlags::Addr);
     }
 }
 
@@ -646,7 +633,6 @@ void CNode::CopyStats(CNodeStats& stats)
         if (info.session_id) stats.m_session_id = HexStr(*info.session_id);
     }
     X(m_permission_flags);
-    X(m_forced_inbound);
 
     X(m_last_ping_time);
     X(m_min_ping_time);
@@ -656,8 +642,6 @@ void CNode::CopyStats(CNodeStats& stats)
     stats.addrLocal = addrLocalUnlocked.IsValid() ? addrLocalUnlocked.ToStringAddrPort() : "";
 
     X(m_conn_type);
-
-    X(m_cpu_time);
 }
 #undef X
 
@@ -1669,7 +1653,7 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const
  *   to forge.  In order to partition a node the attacker must be
  *   simultaneously better at all of them than honest peers.
  */
-bool CConnman::AttemptToEvictConnection(bool force)
+bool CConnman::AttemptToEvictConnection()
 {
     std::vector<NodeEvictionCandidate> vEvictionCandidates;
     {
@@ -1697,7 +1681,7 @@ bool CConnman::AttemptToEvictConnection(bool force)
             vEvictionCandidates.push_back(candidate);
         }
     }
-    const std::optional<NodeId> node_id_to_evict = SelectNodeToEvict(std::move(vEvictionCandidates), force);
+    const std::optional<NodeId> node_id_to_evict = SelectNodeToEvict(std::move(vEvictionCandidates));
     if (!node_id_to_evict) {
         return false;
     }
@@ -1790,19 +1774,13 @@ void CConnman::CreateNodeFromAcceptedSocket(std::unique_ptr<Sock>&& sock,
         return;
     }
 
-    bool forced{false};
     if (nInbound >= m_max_inbound)
     {
-        // If the inbound connection attempt is granted ForceInbound permission, try a little harder
-        // to make room by evicting a peer we may not have otherwise evicted.
-        if (!AttemptToEvictConnection(NetPermissions::HasFlag(permission_flags, NetPermissionFlags::ForceInbound))) {
+        if (!AttemptToEvictConnection()) {
             // No connection to evict, disconnect the new connection
             LogPrint(BCLog::NET, "failed to find an eviction candidate - connection dropped (full)\n");
             return;
         }
-
-        // We kicked someone out
-        forced = true;
     }
 
     NodeId id = GetNewNodeId();
@@ -1826,7 +1804,6 @@ void CConnman::CreateNodeFromAcceptedSocket(std::unique_ptr<Sock>&& sock,
                              CNodeOptions{
                                  .permission_flags = permission_flags,
                                  .prefer_evict = discouraged,
-                                 .forced_inbound = forced,
                                  .recv_flood_size = nReceiveFloodSize,
                                  .use_v2transport = use_v2transport,
                              });
@@ -1913,7 +1890,7 @@ void CConnman::DisconnectNodes()
                 // Add to reconnection list if appropriate. We don't reconnect right here, because
                 // the creation of a connection is a blocking operation (up to several seconds),
                 // and we don't want to hold up the socket handler thread for that long.
-                if (pnode->m_transport->ShouldReconnectV1() && !DisableV1OnClearnet(pnode->addr.GetNetClass())) {
+                if (pnode->m_transport->ShouldReconnectV1()) {
                     reconnections_to_add.push_back({
                         .addr_connect = pnode->addr,
                         .grant = std::move(pnode->grantOutbound),
@@ -2456,11 +2433,6 @@ bool CConnman::MultipleManualOrFullOutboundConns(Network net) const
     return m_network_conn_counts[net] > 1;
 }
 
-bool CConnman::DisableV1OnClearnet(Network net) const
-{
-    return disable_v1conn_clearnet && (net == NET_IPV4 || net == NET_IPV6);
-}
-
 bool CConnman::MaybePickPreferredNetwork(std::optional<Network>& network)
 {
     std::array<Network, 5> nets{NET_IPV4, NET_IPV6, NET_ONION, NET_I2P, NET_CJDNS};
@@ -2979,8 +2951,6 @@ void CConnman::ThreadMessageHandler()
                 if (pnode->fDisconnect)
                     continue;
 
-                CpuTimer timer{[&pnode](std::chrono::nanoseconds elapsed) { pnode->m_cpu_time += elapsed; }};
-
                 // Receive messages
                 bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc);
                 fMoreWork |= (fMoreNodeWork && !pnode->fPauseSend);
@@ -3255,29 +3225,7 @@ bool CConnman::InitBinds(const Options& options)
         inaddr_any.s_addr = htonl(INADDR_ANY);
         const CService ipv4_any{inaddr_any, GetListenPort()}; // 0.0.0.0
         if (!Bind(ipv4_any, BF_REPORT_ERROR, NetPermissionFlags::None)) {
-            int defaultPort = Params().GetDefaultPort();
-            // If listening failed and another port than the standard port was specified,
-            // ask if the user wants to connect via the standard port for the network instead
-            if (GetListenPort() != defaultPort) {
-                bool fRet = uiInterface.ThreadSafeQuestion(
-                    strprintf(_("Do you want to use the standard network port for %s (port %s) instead?"), PACKAGE_NAME, defaultPort),
-                    strprintf(_("Listen on port %s failed.").translated, GetListenPort()),
-                    "", CClientUIInterface::MSG_INFORMATION | CClientUIInterface::MODAL | CClientUIInterface::BTN_OK | CClientUIInterface::BTN_ABORT);
-
-                if (fRet) {
-                    // FIXME: Unbind IPv6 on the other port
-
-                    gArgs.ForceSetArg("-port", defaultPort);
-                    // Attempt to use standard port
-                    struct in6_addr inaddr6_any = IN6ADDR_ANY_INIT;
-                    Bind(CService(inaddr6_any, defaultPort), BF_NONE, NetPermissionFlags::None);
-                    struct in_addr inaddr_any;
-                    inaddr_any.s_addr = INADDR_ANY;
-                    if (!Bind(CService(inaddr_any, defaultPort), BF_REPORT_ERROR, NetPermissionFlags::None)) {
-                        return false;
-                    }
-                }
-            }
+            return false;
         }
     }
     return true;
@@ -3548,17 +3496,12 @@ std::vector<CAddress> CConnman::GetAddresses(CNode& requestor, size_t max_addres
 
 bool CConnman::AddNode(const AddedNodeParams& add)
 {
-    const CService resolved{MaybeFlipIPv6toCJDNS(LookupNumeric(add.m_added_node, GetDefaultPort(add.m_added_node)))};
-    const bool resolved_invalid{!resolved.IsValid()};
+    const CService resolved(LookupNumeric(add.m_added_node, GetDefaultPort(add.m_added_node)));
+    const bool resolved_is_valid{resolved.IsValid()};
 
     LOCK(m_added_nodes_mutex);
     for (const auto& it : m_added_node_params) {
-        if (add.m_added_node == it.m_added_node) return false;
-        if (resolved_invalid) continue;
-        const CService service{MaybeFlipIPv6toCJDNS(LookupNumeric(it.m_added_node, GetDefaultPort(it.m_added_node)))};
-        if (resolved == service) return false;
-        // Check if CJDNS address matches regardless of port to detect already-connected inbound peers.
-        if (resolved.IsCJDNS() && static_cast<CNetAddr>(resolved) == static_cast<CNetAddr>(service)) return false;
+        if (add.m_added_node == it.m_added_node || (resolved_is_valid && resolved == LookupNumeric(it.m_added_node, GetDefaultPort(it.m_added_node)))) return false;
     }
 
     m_added_node_params.push_back(add);
@@ -3694,13 +3637,6 @@ void CConnman::RecordBytesSent(uint64_t bytes)
     nMaxOutboundTotalBytesSentInCycle += bytes;
 }
 
-void CConnman::SetMaxOutboundTarget(uint64_t limit)
-{
-    AssertLockNotHeld(m_total_bytes_sent_mutex);
-    LOCK(m_total_bytes_sent_mutex);
-    nMaxOutboundLimit = limit;
-}
-
 uint64_t CConnman::GetMaxOutboundTarget() const
 {
     AssertLockNotHeld(m_total_bytes_sent_mutex);
@@ -3812,7 +3748,6 @@ CNode::CNode(NodeId idIn,
       m_dest(addrNameIn),
       m_inbound_onion{inbound_onion},
       m_prefer_evict{node_opts.prefer_evict},
-      m_forced_inbound{node_opts.forced_inbound},
       nKeyedNetGroup{nKeyedNetGroupIn},
       m_conn_type{conn_type_in},
       id{idIn},
@@ -4012,11 +3947,6 @@ static void CaptureMessageToFile(const CAddress& addr,
     uint32_t size = data.size();
     ser_writedata32(f, size);
     f << data;
-
-    if (f.fclose() != 0) {
-        throw std::ios_base::failure(
-            strprintf("Error closing %s after write, file contents is likely incomplete", fs::PathToString(path)));
-    }
 }
 
 std::function<void(const CAddress& addr,
diff --git a/src/net.h b/src/net.h
index d85e44d638..b04b73e696 100644
--- a/src/net.h
+++ b/src/net.h
@@ -31,7 +31,6 @@
 #include <util/check.h>
 #include <util/sock.h>
 #include <util/threadinterrupt.h>
-#include <util/time.h>
 
 #include <atomic>
 #include <condition_variable>
@@ -221,10 +220,6 @@ public:
     TransportProtocolType m_transport_type;
     /** BIP324 session id string in hex, if any. */
     std::string m_session_id;
-    /** whether this peer forced its connection by evicting another */
-    bool m_forced_inbound;
-    /** CPU time spent processing messages from this node and crafting messages for it. */
-    std::chrono::nanoseconds m_cpu_time;
 };
 
 
@@ -666,8 +661,6 @@ struct CNodeOptions
     NetPermissionFlags permission_flags = NetPermissionFlags::None;
     std::unique_ptr<i2p::sam::Session> i2p_sam_session = nullptr;
     bool prefer_evict = false;
-    // True if ForceInbound connection required evicting a peer
-    bool forced_inbound{false};
     size_t recv_flood_size{DEFAULT_MAXRECEIVEBUFFER * 1000};
     bool use_v2transport = false;
 };
@@ -725,7 +718,6 @@ public:
      */
     std::string cleanSubVer GUARDED_BY(m_subver_mutex){};
     const bool m_prefer_evict{false}; // This peer is preferred for eviction.
-    const bool m_forced_inbound{false}; // This peer forced an inbound connection
     bool HasPermission(NetPermissionFlags permission) const {
         return NetPermissions::HasFlag(m_permission_flags, permission);
     }
@@ -950,25 +942,6 @@ public:
 
     void CopyStats(CNodeStats& stats) EXCLUSIVE_LOCKS_REQUIRED(!m_subver_mutex, !m_addr_local_mutex, !cs_vSend, !cs_vRecv);
 
-    bool PunishInvalidBlocks() const
-    {
-        if (HasPermission(NetPermissionFlags::NoBan)) {
-            return false;
-        }
-        switch (m_conn_type) {
-            case ConnectionType::INBOUND:
-            case ConnectionType::MANUAL:
-            case ConnectionType::FEELER:
-                return false;
-            case ConnectionType::OUTBOUND_FULL_RELAY:
-            case ConnectionType::BLOCK_RELAY:
-            case ConnectionType::ADDR_FETCH:
-                return true;
-        } // no default case, so the compiler can warn about missing cases
-
-        assert(false);
-    }
-
     std::string ConnectionTypeAsString() const { return ::ConnectionTypeAsString(m_conn_type); }
 
     /** A ping-pong round trip has completed successfully. Update latest and minimum ping times. */
@@ -977,9 +950,6 @@ public:
         m_min_ping_time = std::min(m_min_ping_time.load(), ping_time);
     }
 
-    /** CPU time spent processing messages from this node and crafting messages for it. */
-    std::atomic<std::chrono::nanoseconds> m_cpu_time;
-
 private:
     const NodeId id;
     const uint64_t nLocalHostNonce;
@@ -1089,7 +1059,6 @@ public:
         bool m_i2p_accept_incoming;
         bool whitelist_forcerelay = DEFAULT_WHITELISTFORCERELAY;
         bool whitelist_relay = DEFAULT_WHITELISTRELAY;
-        bool disable_v1conn_clearnet = false;
     };
 
     void Init(const Options& connOptions) EXCLUSIVE_LOCKS_REQUIRED(!m_added_nodes_mutex, !m_total_bytes_sent_mutex)
@@ -1127,7 +1096,6 @@ public:
         m_onion_binds = connOptions.onion_binds;
         whitelist_forcerelay = connOptions.whitelist_forcerelay;
         whitelist_relay = connOptions.whitelist_relay;
-        disable_v1conn_clearnet = connOptions.disable_v1conn_clearnet;
     }
 
     CConnman(uint64_t seed0, uint64_t seed1, AddrMan& addrman, const NetGroupManager& netgroupman,
@@ -1258,8 +1226,6 @@ public:
     void AddLocalServices(ServiceFlags services) { nLocalServices = ServiceFlags(nLocalServices | services); };
     void RemoveLocalServices(ServiceFlags services) { nLocalServices = ServiceFlags(nLocalServices & ~services); }
 
-    //! set the max outbound target in bytes
-    void SetMaxOutboundTarget(uint64_t limit) EXCLUSIVE_LOCKS_REQUIRED(!m_total_bytes_sent_mutex);
     uint64_t GetMaxOutboundTarget() const EXCLUSIVE_LOCKS_REQUIRED(!m_total_bytes_sent_mutex);
     std::chrono::seconds GetMaxOutboundTimeframe() const;
 
@@ -1287,9 +1253,6 @@ public:
 
     bool MultipleManualOrFullOutboundConns(Network net) const EXCLUSIVE_LOCKS_REQUIRED(m_nodes_mutex);
 
-    /* Returns true if outbound v1 connections need to be disabled on IPV4/IPV6 network. */
-    bool DisableV1OnClearnet(Network net) const;
-
 private:
     struct ListenSocket {
     public:
@@ -1380,14 +1343,7 @@ private:
      */
     bool AlreadyConnectedToAddress(const CAddress& addr);
 
-    /**
-     * Attempt to disconnect a connected peer.
-     * Used to make room for new inbound connections, returns true if successful.
-     * @param[in] force     Try to evict a random inbound ban-able peer if
-     *                      all connections are otherwise protected.
-     */
-    bool AttemptToEvictConnection(bool force);
-
+    bool AttemptToEvictConnection();
     CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, ConnectionType conn_type, bool use_v2transport) EXCLUSIVE_LOCKS_REQUIRED(!m_unused_i2p_sessions_mutex);
     void AddWhitelistPermissionFlags(NetPermissionFlags& flags, const CNetAddr &addr, const std::vector<NetWhitelistPermissions>& ranges) const;
 
@@ -1616,13 +1572,6 @@ private:
      */
     bool whitelist_relay;
 
-    /**
-     * option for disabling outbound v1 connections on IPV4 and IPV6.
-     * outbound connections on IPV4/IPV6 need to be v2 connections.
-     * outbound connections on Tor/I2P/CJDNS can be v1 or v2 connections.
-     */
-    bool disable_v1conn_clearnet;
-
     /**
      * Mutex protecting m_i2p_sam_sessions.
      */
diff --git a/src/net_permissions.cpp b/src/net_permissions.cpp
index 458f82ac4c..8f0042c141 100644
--- a/src/net_permissions.cpp
+++ b/src/net_permissions.cpp
@@ -12,14 +12,12 @@ using common::ResolveErrMsg;
 
 const std::vector<std::string> NET_PERMISSIONS_DOC{
     "bloomfilter (allow requesting BIP37 filtered blocks and transactions)",
-    "blockfilters (serve compact block filters to peers per BIP157)",
     "noban (do not ban for misbehavior; implies download)",
     "forcerelay (relay transactions that are already in the mempool; implies relay)",
     "relay (relay even in -blocksonly mode, and unlimited transaction announcements)",
     "mempool (allow requesting BIP35 mempool contents)",
     "download (allow getheaders during IBD, no disconnect after maxuploadtarget limit)",
-    "addr (responses to GETADDR avoid hitting the cache and contain random records with the most up-to-date info)",
-    "forceinbound (when connections are full, attempt to evict a random unprotected inbound peer to open a slot; implies noban)"
+    "addr (responses to GETADDR avoid hitting the cache and contain random records with the most up-to-date info)"
 };
 
 namespace {
@@ -50,7 +48,6 @@ static bool TryParsePermissionFlags(const std::string& str, NetPermissionFlags&
             if (commaSeparator != std::string::npos) readen++; // We read ","
 
             if (permission == "bloomfilter" || permission == "bloom") NetPermissions::AddFlag(flags, NetPermissionFlags::BloomFilter);
-            else if (permission == "blockfilters" || permission == "compactfilters" || permission == "cfilters") NetPermissions::AddFlag(flags, NetPermissionFlags::BlockFilters_Explicit);
             else if (permission == "noban") NetPermissions::AddFlag(flags, NetPermissionFlags::NoBan);
             else if (permission == "forcerelay") NetPermissions::AddFlag(flags, NetPermissionFlags::ForceRelay);
             else if (permission == "mempool") NetPermissions::AddFlag(flags, NetPermissionFlags::Mempool);
@@ -58,7 +55,6 @@ static bool TryParsePermissionFlags(const std::string& str, NetPermissionFlags&
             else if (permission == "all") NetPermissions::AddFlag(flags, NetPermissionFlags::All);
             else if (permission == "relay") NetPermissions::AddFlag(flags, NetPermissionFlags::Relay);
             else if (permission == "addr") NetPermissions::AddFlag(flags, NetPermissionFlags::Addr);
-            else if (permission == "forceinbound") NetPermissions::AddFlag(flags, NetPermissionFlags::ForceInbound);
             else if (permission == "in") connection_direction |= ConnectionDirection::In;
             else if (permission == "out") {
                 if (output_connection_direction == nullptr) {
@@ -96,7 +92,6 @@ static bool TryParsePermissionFlags(const std::string& str, NetPermissionFlags&
 std::vector<std::string> NetPermissions::ToStrings(NetPermissionFlags flags)
 {
     std::vector<std::string> strings;
-    if (NetPermissions::HasFlag(flags, NetPermissionFlags::BlockFilters)) strings.emplace_back("blockfilters");
     if (NetPermissions::HasFlag(flags, NetPermissionFlags::BloomFilter)) strings.emplace_back("bloomfilter");
     if (NetPermissions::HasFlag(flags, NetPermissionFlags::NoBan)) strings.emplace_back("noban");
     if (NetPermissions::HasFlag(flags, NetPermissionFlags::ForceRelay)) strings.emplace_back("forcerelay");
diff --git a/src/net_permissions.h b/src/net_permissions.h
index 0bce0a6b60..33babd6204 100644
--- a/src/net_permissions.h
+++ b/src/net_permissions.h
@@ -40,19 +40,11 @@ enum class NetPermissionFlags : uint32_t {
     // Can request addrs without hitting a privacy-preserving cache, and send us
     // unlimited amounts of addrs.
     Addr = (1U << 7),
-    // Try harder to evict an existing connection if needed to open
-    // an inbound slot from this peer
-    ForceInbound = (1U << 10) | NoBan,
-
-    // Can query compact filters even if -peerblockfilters is false
-    BlockFilters = (1U << 8),
-    // Used to avoid an error when All is used to set BlockFilters
-    BlockFilters_Explicit = BlockFilters | (1U << 9),
 
     // True if the user did not specifically set fine-grained permissions with
     // the -whitebind or -whitelist configuration options.
     Implicit = (1U << 31),
-    All = BloomFilter | ForceRelay | Relay | NoBan | Mempool | Download | Addr | BlockFilters | ForceInbound,
+    All = BloomFilter | ForceRelay | Relay | NoBan | Mempool | Download | Addr,
 };
 static inline constexpr NetPermissionFlags operator|(NetPermissionFlags a, NetPermissionFlags b)
 {
diff --git a/src/net_processing.cpp b/src/net_processing.cpp
index d46800547e..13ea3a29be 100644
--- a/src/net_processing.cpp
+++ b/src/net_processing.cpp
@@ -10,7 +10,6 @@
 #include <blockencodings.h>
 #include <blockfilter.h>
 #include <chainparams.h>
-#include <common/args.h>
 #include <consensus/amount.h>
 #include <consensus/validation.h>
 #include <deploymentstatus.h>
@@ -151,7 +150,7 @@ static constexpr auto INBOUND_INVENTORY_BROADCAST_INTERVAL{5s};
 static constexpr auto OUTBOUND_INVENTORY_BROADCAST_INTERVAL{2s};
 /** Maximum rate of inventory items to send per second.
  *  Limits the impact of low-fee transaction floods. */
-static constexpr unsigned int INVENTORY_BROADCAST_PER_SECOND{14};
+static constexpr unsigned int INVENTORY_BROADCAST_PER_SECOND = 7;
 /** Target number of tx inventory items to send per transmission. */
 static constexpr unsigned int INVENTORY_BROADCAST_TARGET = INVENTORY_BROADCAST_PER_SECOND * count_seconds(INBOUND_INVENTORY_BROADCAST_INTERVAL);
 /** Maximum number of inventory items to send per transmission. */
@@ -515,12 +514,10 @@ public:
     /** Implement PeerManager */
     void StartScheduledTasks(CScheduler& scheduler) override;
     void CheckForStaleTipAndEvictPeers() override;
-    std::optional<std::string> FetchBlock(NodeId peer_id, const uint256& hash, const CBlockIndex* block_index) override
+    std::optional<std::string> FetchBlock(NodeId peer_id, const CBlockIndex& block_index) override
         EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex);
     bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) const override EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex);
-    std::vector<TxOrphanage::OrphanTxBase> GetOrphanTransactions() override EXCLUSIVE_LOCKS_REQUIRED(!m_tx_download_mutex);
     PeerManagerInfo GetInfo() const override EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex);
-    void LimitOrphanTxSize(unsigned int nMaxOrphans) override EXCLUSIVE_LOCKS_REQUIRED(!m_tx_download_mutex);
     void SendPings() override EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex);
     void RelayTransaction(const uint256& txid, const uint256& wtxid) override EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex);
     void SetBestBlock(int height, std::chrono::seconds time) override
@@ -534,7 +531,6 @@ public:
         EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex, !m_most_recent_block_mutex, !m_headers_presync_mutex, g_msgproc_mutex, !m_tx_download_mutex);
     void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds) override;
     ServiceFlags GetDesirableServiceFlags(ServiceFlags services) const override;
-    int GetNumberOfPeersWithValidatedDownloads() const override EXCLUSIVE_LOCKS_REQUIRED(::cs_main);
 
 private:
     /** Consider evicting an outbound peer based on the amount of time they've been behind our tip */
@@ -1019,9 +1015,6 @@ private:
     /** Have we requested this block from an outbound peer */
     bool IsBlockRequestedFromOutbound(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
 
-    /** Have we requested this block from a specific peer */
-    bool IsBlockRequestedFromPeer(const uint256& hash, NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
-
     /** Remove this block from our tracked requested blocks. Called if:
      *  - the block has been received from a peer
      *  - the request for the block has timed out
@@ -1314,16 +1307,6 @@ bool PeerManagerImpl::IsBlockRequestedFromOutbound(const uint256& hash)
     return false;
 }
 
-bool PeerManagerImpl::IsBlockRequestedFromPeer(const uint256& hash, NodeId peer)
-{
-    for (auto range = mapBlocksInFlight.equal_range(hash); range.first != range.second; range.first++) {
-        auto [nodeid, block_it] = range.first->second;
-        if (nodeid == peer) return true;
-    }
-
-    return false;
-}
-
 void PeerManagerImpl::RemoveBlockRequest(const uint256& hash, std::optional<NodeId> from_peer)
 {
     auto range = mapBlocksInFlight.equal_range(hash);
@@ -1745,9 +1728,6 @@ void PeerManagerImpl::InitializeNode(const CNode& node, ServiceFlags our_service
     if (NetPermissions::HasFlag(node.m_permission_flags, NetPermissionFlags::BloomFilter)) {
         our_services = static_cast<ServiceFlags>(our_services | NODE_BLOOM);
     }
-    if (NetPermissions::HasFlag(node.m_permission_flags, NetPermissionFlags::BlockFilters)) {
-        our_services = static_cast<ServiceFlags>(our_services | NODE_COMPACT_FILTERS);
-    }
 
     PeerRef peer = std::make_shared<Peer>(nodeid, our_services);
     {
@@ -1934,17 +1914,10 @@ bool PeerManagerImpl::GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) c
         }
     }
     stats.time_offset = peer->m_time_offset;
-    stats.m_misbehavior_score = WITH_LOCK(peer->m_misbehavior_mutex, return peer->m_should_discourage) ? 100 : 0;
 
     return true;
 }
 
-std::vector<TxOrphanage::OrphanTxBase> PeerManagerImpl::GetOrphanTransactions()
-{
-    LOCK(m_tx_download_mutex);
-    return m_orphanage.GetOrphanTransactions();
-}
-
 PeerManagerInfo PeerManagerImpl::GetInfo() const
 {
     return PeerManagerInfo{
@@ -1953,19 +1926,6 @@ PeerManagerInfo PeerManagerImpl::GetInfo() const
     };
 }
 
-void PeerManagerImpl::LimitOrphanTxSize(unsigned int nMaxOrphans)
-{
-    LOCK(g_msgproc_mutex);
-    LOCK2(cs_main, m_tx_download_mutex);
-    m_orphanage.LimitOrphans(nMaxOrphans, m_rng);
-}
-
-int PeerManagerImpl::GetNumberOfPeersWithValidatedDownloads() const
-{
-    AssertLockHeld(m_chainman.GetMutex());
-    return m_peers_downloading_from;
-}
-
 void PeerManagerImpl::AddToCompactExtraTransactions(const CTransactionRef& tx)
 {
     if (m_opts.max_extra_txs <= 0)
@@ -1985,23 +1945,10 @@ void PeerManagerImpl::Misbehaving(Peer& peer, const std::string& message)
     LogPrint(BCLog::NET, "Misbehaving: peer=%d%s\n", peer.m_id, message_prefixed);
 }
 
-static void HandleDoSPunishment(CConnman& connman, NodeId node_id, const int nDoS, const char * const what_is_it) {
-    // We never actually DoS ban for invalid blocks, merely disconnect nodes if we're relying on them as a primary node
-    const std::string msg = strprintf("peer=%d got DoS score %d on invalid %s", node_id, nDoS, what_is_it);
-    connman.ForNode(node_id, [msg](CNode* node) {
-        if (node->PunishInvalidBlocks()) {
-            LogPrint(BCLog::NET, "%s; simply disconnecting\n", msg);
-            node->fDisconnect = true;
-        } else {
-            LogPrint(BCLog::NET, "%s; tolerating\n", msg);
-        }
-        return true;
-    });
-}
-
 void PeerManagerImpl::MaybePunishNodeForBlock(NodeId nodeid, const BlockValidationState& state,
                                               bool via_compact_block, const std::string& message)
 {
+    PeerRef peer{GetPeerRef(nodeid)};
     switch (state.GetResult()) {
     case BlockValidationResult::BLOCK_RESULT_UNSET:
         break;
@@ -2013,7 +1960,7 @@ void PeerManagerImpl::MaybePunishNodeForBlock(NodeId nodeid, const BlockValidati
     case BlockValidationResult::BLOCK_CONSENSUS:
     case BlockValidationResult::BLOCK_MUTATED:
         if (!via_compact_block) {
-            HandleDoSPunishment(m_connman, nodeid, 100, "block");
+            if (peer) Misbehaving(*peer, message);
             return;
         }
         break;
@@ -2028,7 +1975,7 @@ void PeerManagerImpl::MaybePunishNodeForBlock(NodeId nodeid, const BlockValidati
             // Discourage outbound (but not inbound) peers if on an invalid chain.
             // Exempt HB compact block peers. Manual connections are always protected from discouragement.
             if (!via_compact_block && !node_state->m_is_inbound) {
-                HandleDoSPunishment(m_connman, nodeid, 100, "block");
+                if (peer) Misbehaving(*peer, message);
                 return;
             }
             break;
@@ -2036,11 +1983,11 @@ void PeerManagerImpl::MaybePunishNodeForBlock(NodeId nodeid, const BlockValidati
     case BlockValidationResult::BLOCK_INVALID_HEADER:
     case BlockValidationResult::BLOCK_CHECKPOINT:
     case BlockValidationResult::BLOCK_INVALID_PREV:
-        HandleDoSPunishment(m_connman, nodeid, 100, "block header");
+        if (peer) Misbehaving(*peer, message);
         return;
     // Conflicting (but not necessarily invalid) data or different policy:
     case BlockValidationResult::BLOCK_MISSING_PREV:
-        HandleDoSPunishment(m_connman, nodeid, 100, "block header");
+        if (peer) Misbehaving(*peer, message);
         return;
     case BlockValidationResult::BLOCK_RECENT_CONSENSUS_CHANGE:
     case BlockValidationResult::BLOCK_TIME_FUTURE:
@@ -2059,7 +2006,7 @@ void PeerManagerImpl::MaybePunishNodeForTx(NodeId nodeid, const TxValidationStat
         break;
     // The node is providing invalid data:
     case TxValidationResult::TX_CONSENSUS:
-        HandleDoSPunishment(m_connman, nodeid, 100, "transaction");
+        if (peer) Misbehaving(*peer, "");
         return;
     // Conflicting (but not necessarily invalid) data or different policy:
     case TxValidationResult::TX_RECENT_CONSENSUS_CHANGE:
@@ -2087,7 +2034,7 @@ bool PeerManagerImpl::BlockRequestAllowed(const CBlockIndex* pindex)
            (GetBlockProofEquivalentTime(*m_chainman.m_best_header, *pindex, *m_chainman.m_best_header, m_chainparams.GetConsensus()) < STALE_RELAY_AGE_LIMIT);
 }
 
-std::optional<std::string> PeerManagerImpl::FetchBlock(NodeId peer_id, const uint256& hash, const CBlockIndex* block_index)
+std::optional<std::string> PeerManagerImpl::FetchBlock(NodeId peer_id, const CBlockIndex& block_index)
 {
     if (m_chainman.m_blockman.LoadingBlocks()) return "Loading blocks ...";
 
@@ -2100,18 +2047,14 @@ std::optional<std::string> PeerManagerImpl::FetchBlock(NodeId peer_id, const uin
 
     LOCK(cs_main);
 
-    if (IsBlockRequestedFromPeer(hash, peer_id)) return "Already requested from this peer";
-
-    // Mark block as in-flight unless we don't have the header.
-    if (block_index != nullptr) {
     // Forget about all prior requests
-    RemoveBlockRequest(hash, std::nullopt);
+    RemoveBlockRequest(block_index.GetBlockHash(), std::nullopt);
 
     // Mark block as in-flight
-        Assume(BlockRequested(peer_id, *block_index));
-    }
+    if (!BlockRequested(peer_id, block_index)) return "Already requested from this peer";
 
     // Construct message to request the block
+    const uint256& hash{block_index.GetBlockHash()};
     std::vector<CInv> invs{CInv(MSG_BLOCK | MSG_WITNESS_FLAG, hash)};
 
     // Send block request message to the peer
@@ -2127,12 +2070,6 @@ std::optional<std::string> PeerManagerImpl::FetchBlock(NodeId peer_id, const uin
     return std::nullopt;
 }
 
-std::optional<std::string> PeerManager::FetchBlock(NodeId peer_id, const CBlockIndex& block_index)
-{
-    const uint256& hash{block_index.GetBlockHash()};
-    return FetchBlock(peer_id, hash, &block_index);
-}
-
 std::unique_ptr<PeerManager> PeerManager::make(CConnman& connman, AddrMan& addrman,
                                                BanMan* banman, ChainstateManager& chainman,
                                                CTxMemPool& pool, node::Warnings& warnings, Options opts)
@@ -2546,7 +2483,7 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv&
         }
         // disconnect node in case we have reached the outbound limit for serving historical blocks
         if (m_connman.OutboundTargetReached(true) &&
-            (((m_chainman.m_best_header != nullptr) && (m_chainman.m_best_header->GetBlockTime() - pindex->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.IsMsgFilteredBlk() || inv.IsMsgFilteredWitnessBlk()) &&
+            (((m_chainman.m_best_header != nullptr) && (m_chainman.m_best_header->GetBlockTime() - pindex->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.IsMsgFilteredBlk()) &&
             !pfrom.HasPermission(NetPermissionFlags::Download) // nodes with the download permission may exceed target
         ) {
             LogPrint(BCLog::NET, "historical block serving limit reached, disconnect peer=%d\n", pfrom.GetId());
@@ -2579,7 +2516,7 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv&
         // Fast-path: in this case it is possible to serve the block directly from disk,
         // as the network format matches the format on disk
         std::vector<uint8_t> block_data;
-        if (!m_chainman.m_blockman.ReadRawBlockFromDisk(block_data, block_pos, /*lowprio=*/true)) {
+        if (!m_chainman.m_blockman.ReadRawBlockFromDisk(block_data, block_pos)) {
             if (WITH_LOCK(m_chainman.GetMutex(), return m_chainman.m_blockman.IsBlockPruned(*pindex))) {
                 LogPrint(BCLog::NET, "Block was pruned before it could be read, disconnect peer=%s\n", pfrom.GetId());
             } else {
@@ -2593,7 +2530,7 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv&
     } else {
         // Send block from disk
         std::shared_ptr<CBlock> pblockRead = std::make_shared<CBlock>();
-        if (!m_chainman.m_blockman.ReadBlockFromDisk(*pblockRead, block_pos, /*lowprio=*/true)) {
+        if (!m_chainman.m_blockman.ReadBlockFromDisk(*pblockRead, block_pos)) {
             if (WITH_LOCK(m_chainman.GetMutex(), return m_chainman.m_blockman.IsBlockPruned(*pindex))) {
                 LogPrint(BCLog::NET, "Block was pruned before it could be read, disconnect peer=%s\n", pfrom.GetId());
             } else {
@@ -2609,7 +2546,7 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv&
             MakeAndPushMessage(pfrom, NetMsgType::BLOCK, TX_NO_WITNESS(*pblock));
         } else if (inv.IsMsgWitnessBlk()) {
             MakeAndPushMessage(pfrom, NetMsgType::BLOCK, TX_WITH_WITNESS(*pblock));
-        } else if (inv.IsMsgFilteredBlk() || inv.IsMsgFilteredWitnessBlk()) {
+        } else if (inv.IsMsgFilteredBlk()) {
             bool sendMerkleBlock = false;
             CMerkleBlock merkleBlock;
             if (auto tx_relay = peer.GetTxRelay(); tx_relay != nullptr) {
@@ -2627,10 +2564,9 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv&
                 // they must either disconnect and retry or request the full block.
                 // Thus, the protocol spec specified allows for us to provide duplicate txn here,
                 // however we MUST always provide at least what the remote peer needs
-                const auto maybe_with_witness = (inv.IsMsgFilteredWitnessBlk() ? TX_WITH_WITNESS : TX_NO_WITNESS);
                 typedef std::pair<unsigned int, uint256> PairType;
                 for (PairType& pair : merkleBlock.vMatchedTxn)
-                    MakeAndPushMessage(pfrom, NetMsgType::TX, maybe_with_witness(*pblock->vtx[pair.first]));
+                    MakeAndPushMessage(pfrom, NetMsgType::TX, TX_NO_WITNESS(*pblock->vtx[pair.first]));
             }
             // else
             // no response
@@ -2831,10 +2767,6 @@ void PeerManagerImpl::HandleUnconnectingHeaders(CNode& pfrom, Peer& peer,
     // eventually get the headers - even from a different peer -
     // we can use this peer to download.
     WITH_LOCK(cs_main, UpdateBlockAvailability(pfrom.GetId(), headers.back().GetHash()));
-
-    if (pfrom.PunishInvalidBlocks()) {
-        pfrom.fDisconnect = true;
-    }
 }
 
 bool PeerManagerImpl::CheckHeadersAreContinuous(const std::vector<CBlockHeader>& headers) const
@@ -3844,7 +3776,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,
         if (!vRecv.empty()) {
             std::string strSubVer;
             vRecv >> LIMITED_STRING(strSubVer, MAX_SUBVERSION_LENGTH);
-            cleanSubVer = SanitizeString(strSubVer, SAFE_CHARS_PRINTABLE);
+            cleanSubVer = SanitizeString(strSubVer);
         }
         if (!vRecv.empty()) {
             vRecv >> starting_height;
@@ -3873,10 +3805,6 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,
         // Change version
         const int greatest_common_version = std::min(nVersion, PROTOCOL_VERSION);
         pfrom.SetCommonVersion(greatest_common_version);
-        {
-            LOCK(pfrom.m_subver_mutex);
-            pfrom.cleanSubVer = cleanSubVer;
-        }
         pfrom.nVersion = nVersion;
 
         if (greatest_common_version >= WTXID_RELAY_VERSION) {
@@ -3895,6 +3823,10 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,
         pfrom.m_has_all_wanted_services = HasAllDesirableServiceFlags(nServices);
         peer->m_their_services = nServices;
         pfrom.SetAddrLocal(addrMe);
+        {
+            LOCK(pfrom.m_subver_mutex);
+            pfrom.cleanSubVer = cleanSubVer;
+        }
         peer->m_starting_height = starting_height;
 
         // Only initialize the Peer::TxRelay m_relay_txs data structure if:
@@ -3985,7 +3917,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,
 
         const auto mapped_as{m_connman.GetMappedAS(pfrom.addr)};
         LogPrint(BCLog::NET, "receive version message: %s: version %d, blocks=%d, us=%s, txrelay=%d, peer=%d%s%s\n",
-                  SanitizeString(cleanSubVer, SAFE_CHARS_DEFAULT, true), pfrom.nVersion,
+                  cleanSubVer, pfrom.nVersion,
                   peer->m_starting_height, addrMe.ToStringAddrPort(), fRelay, pfrom.GetId(),
                   remoteAddr, (mapped_as ? strprintf(", mapped_as=%d", mapped_as) : ""));
 
@@ -4502,7 +4434,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,
 
         if (!block_pos.IsNull()) {
             CBlock block;
-            const bool ret{m_chainman.m_blockman.ReadBlockFromDisk(block, block_pos, /*lowprio=*/true)};
+            const bool ret{m_chainman.m_blockman.ReadBlockFromDisk(block, block_pos)};
             // If height is above MAX_BLOCKTXN_DEPTH then this block cannot get
             // pruned after we release cs_main above, so this read should never fail.
             assert(ret);
@@ -5850,7 +5782,6 @@ void PeerManagerImpl::MaybeSendFeefilter(CNode& pto, Peer& peer, std::chrono::mi
 {
     if (m_opts.ignore_incoming_txs) return;
     if (pto.GetCommonVersion() < FEEFILTER_VERSION) return;
-    if (!gArgs.GetBoolArg("-feefilter", DEFAULT_FEEFILTER)) return;
     // peers with the forcerelay permission should not filter txs to us
     if (pto.HasPermission(NetPermissionFlags::ForceRelay)) return;
     // Don't send feefilter messages to outbound block-relay-only peers since they should never announce
@@ -6121,7 +6052,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)
                         PushMessage(*pto, std::move(cached_cmpctblock_msg.value()));
                     } else {
                         CBlock block;
-                        const bool ret{m_chainman.m_blockman.ReadBlockFromDisk(block, *pBestIndex, /*lowprio=*/true)};
+                        const bool ret{m_chainman.m_blockman.ReadBlockFromDisk(block, *pBestIndex)};
                         assert(ret);
                         CBlockHeaderAndShortTxIDs cmpctblock{block, m_rng.rand64()};
                         MakeAndPushMessage(*pto, NetMsgType::CMPCTBLOCK, cmpctblock);
diff --git a/src/net_processing.h b/src/net_processing.h
index 3aac9873f0..a413db98e8 100644
--- a/src/net_processing.h
+++ b/src/net_processing.h
@@ -7,8 +7,6 @@
 #define BITCOIN_NET_PROCESSING_H
 
 #include <net.h>
-#include <threadsafety.h>
-#include <txorphanage.h>
 #include <validationinterface.h>
 
 #include <chrono>
@@ -29,7 +27,7 @@ static const uint32_t DEFAULT_MAX_ORPHAN_TRANSACTIONS{100};
 /** Default number of non-mempool transactions to keep around for block reconstruction. Includes
     orphan, replaced, and rejected transactions. */
 static const uint32_t DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN{100};
-static const bool DEFAULT_PEERBLOOMFILTERS = true;
+static const bool DEFAULT_PEERBLOOMFILTERS = false;
 static const bool DEFAULT_PEERBLOCKFILTERS = false;
 /** Maximum number of outstanding CMPCTBLOCK requests for the same block. */
 static const unsigned int MAX_CMPCTBLOCKS_INFLIGHT_PER_BLOCK = 3;
@@ -48,7 +46,6 @@ struct CNodeStateStats {
     ServiceFlags their_services;
     int64_t presync_height{-1};
     std::chrono::seconds time_offset{0};
-    int m_misbehavior_score{0};
 };
 
 struct PeerManagerInfo {
@@ -82,23 +79,19 @@ public:
     virtual ~PeerManager() = default;
 
     /**
-     * Attempt to manually fetch block from a given peer.
+     * Attempt to manually fetch block from a given peer. We must already have the header.
      *
      * @param[in]  peer_id      The peer id
      * @param[in]  block_index  The blockindex
      * @returns std::nullopt if a request was successfully made, otherwise an error message
      */
-    std::optional<std::string> FetchBlock(NodeId peer_id, const CBlockIndex& block_index);
-    virtual std::optional<std::string> FetchBlock(NodeId peer_id, const uint256& hash, const CBlockIndex* block_index) = 0;
+    virtual std::optional<std::string> FetchBlock(NodeId peer_id, const CBlockIndex& block_index) = 0;
 
     /** Begin running background tasks, should only be called once */
     virtual void StartScheduledTasks(CScheduler& scheduler) = 0;
 
     /** Get statistics from node state */
     virtual bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) const = 0;
-    virtual void LimitOrphanTxSize(unsigned int nMaxOrphans) = 0;
-
-    virtual std::vector<TxOrphanage::OrphanTxBase> GetOrphanTransactions() = 0;
 
     /** Get peer manager info. */
     virtual PeerManagerInfo GetInfo() const = 0;
@@ -150,9 +143,6 @@ public:
      * we do not have a confirmed set of service flags.
     */
     virtual ServiceFlags GetDesirableServiceFlags(ServiceFlags services) const = 0;
-
-    /** Get number of peers from which we're downloading blocks */
-    virtual int GetNumberOfPeersWithValidatedDownloads() const EXCLUSIVE_LOCKS_REQUIRED(::cs_main) = 0;
 };
 
 #endif // BITCOIN_NET_PROCESSING_H
diff --git a/src/node/blockmanager_args.cpp b/src/node/blockmanager_args.cpp
index 1117e8f9df..0fc4e1646a 100644
--- a/src/node/blockmanager_args.cpp
+++ b/src/node/blockmanager_args.cpp
@@ -11,50 +11,26 @@
 #include <util/translation.h>
 #include <validation.h>
 
-#include <algorithm>
 #include <cstdint>
-#include <string_view>
 
 namespace node {
-util::Result<uint64_t> ParsePruneOption(const int64_t nPruneArg, const std::string_view opt_name)
-{
-    // block pruning; get the amount of disk space (in MiB) to allot for block & undo files
-    if (nPruneArg < 0) {
-        return util::Error{strprintf(_("%s cannot be configured with a negative value."), opt_name)};
-    } else if (nPruneArg == 0) { // pruning disabled
-        return 0;
-    } else if (nPruneArg == 1) { // manual pruning: -prune=1
-        return BlockManager::PRUNE_TARGET_MANUAL;
-    }
-    const uint64_t nPruneTarget{uint64_t(nPruneArg) * 1024 * 1024};
-    if (nPruneTarget < MIN_DISK_SPACE_FOR_BLOCK_FILES) {
-        return util::Error{strprintf(_("%s configured below the minimum of %d MiB.  Please use a higher number."), opt_name, MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024)};
-    }
-    return nPruneTarget;
-}
-
 util::Result<void> ApplyArgsManOptions(const ArgsManager& args, BlockManager::Options& opts)
 {
     if (auto value{args.GetBoolArg("-blocksxor")}) opts.use_xor = *value;
-
     // block pruning; get the amount of disk space (in MiB) to allot for block & undo files
     int64_t nPruneArg{args.GetIntArg("-prune", opts.prune_target)};
-    if (const auto prune_parsed = ParsePruneOption(nPruneArg, "Prune")) {
-        opts.prune_target = *prune_parsed;
-    } else {
-        return util::Error{util::ErrorString(prune_parsed)};
+    if (nPruneArg < 0) {
+        return util::Error{_("Prune cannot be configured with a negative value.")};
     }
-
-    if (const auto prune_during_init{args.GetIntArg("-pruneduringinit")}) {
-        if (*prune_during_init == -1) {
-            opts.prune_target_during_init = -1;
-        } else if (const auto prune_parsed = ParsePruneOption(*prune_during_init, "-pruneduringinit")) {
-            // NOTE: PRUNE_TARGET_MANUAL is >int64 max
-            opts.prune_target_during_init = std::min(std::numeric_limits<int64_t>::max(), (int64_t)*prune_parsed);
-        } else {
-            return util::Error{util::ErrorString(prune_parsed)};
+    uint64_t nPruneTarget{uint64_t(nPruneArg) * 1024 * 1024};
+    if (nPruneArg == 1) { // manual pruning: -prune=1
+        nPruneTarget = BlockManager::PRUNE_TARGET_MANUAL;
+    } else if (nPruneTarget) {
+        if (nPruneTarget < MIN_DISK_SPACE_FOR_BLOCK_FILES) {
+            return util::Error{strprintf(_("Prune configured below the minimum of %d MiB.  Please use a higher number."), MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024)};
         }
     }
+    opts.prune_target = nPruneTarget;
 
     if (auto value{args.GetBoolArg("-fastprune")}) opts.fast_prune = *value;
 
diff --git a/src/node/blockstorage.cpp b/src/node/blockstorage.cpp
index 30602c2faf..65d51417b1 100644
--- a/src/node/blockstorage.cpp
+++ b/src/node/blockstorage.cpp
@@ -31,8 +31,6 @@
 #include <util/batchpriority.h>
 #include <util/check.h>
 #include <util/fs.h>
-#include <util/ioprio.h>
-#include <util/overflow.h>
 #include <util/signalinterrupt.h>
 #include <util/strencodings.h>
 #include <util/translation.h>
@@ -48,7 +46,6 @@ static constexpr uint8_t DB_BLOCK_INDEX{'b'};
 static constexpr uint8_t DB_FLAG{'F'};
 static constexpr uint8_t DB_REINDEX_FLAG{'R'};
 static constexpr uint8_t DB_LAST_BLOCK{'l'};
-static constexpr uint8_t DB_PRUNE_LOCK{'L'};
 // Keys used in previous version that might still be found in the DB:
 // BlockTreeDB::DB_TXINDEX_BLOCK{'T'};
 // BlockTreeDB::DB_TXINDEX{'t'}
@@ -78,7 +75,7 @@ bool BlockTreeDB::ReadLastBlockFile(int& nFile)
     return Read(DB_LAST_BLOCK, nFile);
 }
 
-bool BlockTreeDB::WriteBatchSync(const std::vector<std::pair<int, const CBlockFileInfo*>>& fileInfo, int nLastFile, const std::vector<const CBlockIndex*>& blockinfo, const std::unordered_map<std::string, node::PruneLockInfo>& prune_locks)
+bool BlockTreeDB::WriteBatchSync(const std::vector<std::pair<int, const CBlockFileInfo*>>& fileInfo, int nLastFile, const std::vector<const CBlockIndex*>& blockinfo)
 {
     CDBBatch batch(*this);
     for (const auto& [file, info] : fileInfo) {
@@ -88,41 +85,9 @@ bool BlockTreeDB::WriteBatchSync(const std::vector<std::pair<int, const CBlockFi
     for (const CBlockIndex* bi : blockinfo) {
         batch.Write(std::make_pair(DB_BLOCK_INDEX, bi->GetBlockHash()), CDiskBlockIndex{bi});
     }
-    for (const auto& prune_lock : prune_locks) {
-        if (prune_lock.second.temporary) continue;
-        batch.Write(std::make_pair(DB_PRUNE_LOCK, prune_lock.first), prune_lock.second);
-    }
     return WriteBatch(batch, true);
 }
 
-bool BlockTreeDB::WritePruneLock(const std::string& name, const node::PruneLockInfo& lock_info) {
-    if (lock_info.temporary) return true;
-    return Write(std::make_pair(DB_PRUNE_LOCK, name), lock_info);
-}
-
-bool BlockTreeDB::DeletePruneLock(const std::string& name) {
-    return Erase(std::make_pair(DB_PRUNE_LOCK, name));
-}
-
-bool BlockTreeDB::LoadPruneLocks(std::unordered_map<std::string, node::PruneLockInfo>& prune_locks, const util::SignalInterrupt& interrupt) {
-    std::unique_ptr<CDBIterator> pcursor(NewIterator());
-    for (pcursor->Seek(DB_PRUNE_LOCK); pcursor->Valid(); pcursor->Next()) {
-        if (interrupt) return false;
-
-        std::pair<uint8_t, std::string> key;
-        if ((!pcursor->GetKey(key)) || key.first != DB_PRUNE_LOCK) break;
-
-        node::PruneLockInfo& lock_info = prune_locks[key.second];
-        if (!pcursor->GetValue(lock_info)) {
-            LogError("%s: failed to %s prune lock '%s'\n", __func__, "read", key.second);
-            return false;
-        }
-        lock_info.temporary = false;
-    }
-
-    return true;
-}
-
 bool BlockTreeDB::WriteFlag(const std::string& name, bool fValue)
 {
     return Write(std::make_pair(DB_FLAG, name), fValue ? uint8_t{'1'} : uint8_t{'0'});
@@ -211,13 +176,6 @@ bool CBlockIndexHeightOnlyComparator::operator()(const CBlockIndex* pa, const CB
     return pa->nHeight < pb->nHeight;
 }
 
-/** The number of blocks to keep below the deepest prune lock.
- *  There is nothing special about this number. It is higher than what we
- *  expect to see in regular mainnet reorgs, but not so high that it would
- *  noticeably interfere with the pruning mechanism.
- * */
-static constexpr int PRUNE_LOCK_BUFFER{10};
-
 std::vector<CBlockIndex*> BlockManager::GetAllBlockIndices()
 {
     AssertLockHeld(cs_main);
@@ -311,24 +269,6 @@ void BlockManager::PruneOneBlockFile(const int fileNumber)
     m_dirty_fileinfo.insert(fileNumber);
 }
 
-bool BlockManager::DoPruneLocksForbidPruning(const CBlockFileInfo& block_file_info)
-{
-    AssertLockHeld(cs_main);
-    for (const auto& prune_lock : m_prune_locks) {
-        if (prune_lock.second.height_first == std::numeric_limits<uint64_t>::max()) continue;
-        // Remove the buffer and one additional block here to get actual height that is outside of the buffer
-        const uint64_t lock_height{(prune_lock.second.height_first <= PRUNE_LOCK_BUFFER + 1) ? 1 : (prune_lock.second.height_first - PRUNE_LOCK_BUFFER - 1)};
-        const uint64_t lock_height_last{SaturatingAdd(prune_lock.second.height_last, (uint64_t)PRUNE_LOCK_BUFFER)};
-        if (block_file_info.nHeightFirst > lock_height_last) continue;
-        if (block_file_info.nHeightLast <= lock_height) continue;
-        // TODO: Check each block within the file against the prune_lock range
-
-        LogPrint(BCLog::PRUNE, "%s limited pruning to height %d\n", prune_lock.first, lock_height);
-        return true;
-    }
-    return false;
-}
-
 void BlockManager::FindFilesToPruneManual(
     std::set<int>& setFilesToPrune,
     int nManualPruneHeight,
@@ -351,8 +291,6 @@ void BlockManager::FindFilesToPruneManual(
             continue;
         }
 
-        if (DoPruneLocksForbidPruning(m_blockfile_info[fileNumber])) continue;
-
         PruneOneBlockFile(fileNumber);
         setFilesToPrune.insert(fileNumber);
         count++;
@@ -361,26 +299,6 @@ void BlockManager::FindFilesToPruneManual(
         chain.GetRole(), last_block_can_prune, count);
 }
 
-uint64_t BlockManager::GetPruneTargetForChainstate(const Chainstate& chain, ChainstateManager& chainman) const
-{
-    const auto number_of_chainstates{chainman.GetAll().size()};
-    const uint64_t min_overall_target{MIN_DISK_SPACE_FOR_BLOCK_FILES * number_of_chainstates};
-    auto target = std::max(min_overall_target, GetPruneTarget());
-    uint64_t target_boost{0};
-    if (m_opts.prune_target_during_init > -1 && chainman.IsInitialBlockDownload()) {
-        if ((uint64_t)m_opts.prune_target_during_init <= target) {
-            target = std::max(min_overall_target, (uint64_t)m_opts.prune_target_during_init);
-        } else if (chain.GetRole() != ChainstateRole::ASSUMEDVALID) {
-            // Only the background/normal gets the benefit
-            // NOTE: This assumes only one such chainstate exists
-            target_boost = m_opts.prune_target_during_init - target;
-        }
-    }
-    // Distribute our -prune budget over all chainstates.
-    target = (target / number_of_chainstates) + target_boost;
-    return target;
-}
-
 void BlockManager::FindFilesToPrune(
     std::set<int>& setFilesToPrune,
     int last_prune,
@@ -388,7 +306,9 @@ void BlockManager::FindFilesToPrune(
     ChainstateManager& chainman)
 {
     LOCK2(cs_main, cs_LastBlockFile);
-    const auto target{GetPruneTargetForChainstate(chain, chainman)};
+    // Distribute our -prune budget over all chainstates.
+    const auto target = std::max(
+        MIN_DISK_SPACE_FOR_BLOCK_FILES, GetPruneTarget() / chainman.GetAll().size());
     const uint64_t target_sync_height = chainman.m_best_header->nHeight;
 
     if (chain.m_chain.Height() < 0 || target == 0) {
@@ -439,8 +359,6 @@ void BlockManager::FindFilesToPrune(
                 continue;
             }
 
-            if (DoPruneLocksForbidPruning(m_blockfile_info[fileNumber])) continue;
-
             PruneOneBlockFile(fileNumber);
             // Queue up the files for removal
             setFilesToPrune.insert(fileNumber);
@@ -455,41 +373,9 @@ void BlockManager::FindFilesToPrune(
              min_block_to_prune, last_block_can_prune, count);
 }
 
-bool BlockManager::PruneLockExists(const std::string& name) const {
-    return m_prune_locks.count(name);
-}
-
-bool BlockManager::UpdatePruneLock(const std::string& name, const PruneLockInfo& lock_info, const bool sync) {
+void BlockManager::UpdatePruneLock(const std::string& name, const PruneLockInfo& lock_info) {
     AssertLockHeld(::cs_main);
-    if (sync) {
-        if (!m_block_tree_db->WritePruneLock(name, lock_info)) {
-            LogError("%s: failed to %s prune lock '%s'\n", __func__, "write", name);
-            return false;
-        }
-    }
-    PruneLockInfo& stored_lock_info = m_prune_locks[name];
-    if (lock_info.temporary && !stored_lock_info.temporary) {
-        // Erase non-temporary lock from disk
-        if (!m_block_tree_db->DeletePruneLock(name)) {
-            LogError("%s: failed to %s prune lock '%s'\n", __func__, "erase", name);
-            return false;
-        }
-    }
-    stored_lock_info = lock_info;
-    return true;
-}
-
-bool BlockManager::DeletePruneLock(const std::string& name)
-{
-    AssertLockHeld(::cs_main);
-    m_prune_locks.erase(name);
-
-    // Since there is no reasonable expectation for any follow-up to this prune lock, actually ensure it gets committed to disk immediately
-    if (!m_block_tree_db->DeletePruneLock(name)) {
-        LogError("%s: failed to %s prune lock '%s'\n", __func__, "erase", name);
-        return false;
-    }
-    return true;
+    m_prune_locks[name] = lock_info;
 }
 
 CBlockIndex* BlockManager::InsertBlockIndex(const uint256& hash)
@@ -515,8 +401,6 @@ bool BlockManager::LoadBlockIndex(const std::optional<uint256>& snapshot_blockha
         return false;
     }
 
-    if (!m_block_tree_db->LoadPruneLocks(m_prune_locks, m_interrupt)) return false;
-
     if (snapshot_blockhash) {
         const std::optional<AssumeutxoData> maybe_au_data = GetParams().AssumeutxoForBlockhash(*snapshot_blockhash);
         if (!maybe_au_data) {
@@ -605,7 +489,7 @@ bool BlockManager::WriteBlockIndexDB()
         m_dirty_blockindex.erase(it++);
     }
     int max_blockfile = WITH_LOCK(cs_LastBlockFile, return this->MaxBlockfileNum());
-    if (!m_block_tree_db->WriteBatchSync(vFiles, max_blockfile, vBlocks, m_prune_locks)) {
+    if (!m_block_tree_db->WriteBatchSync(vFiles, max_blockfile, vBlocks)) {
         return false;
     }
     return true;
@@ -781,7 +665,7 @@ void BlockManager::CleanupBlockRevFiles() const
 CBlockFileInfo* BlockManager::GetBlockFileInfo(size_t n)
 {
     LOCK(cs_LastBlockFile);
-    if (n > m_blockfile_info.size()-1) return nullptr;
+
     return &m_blockfile_info.at(n);
 }
 
@@ -813,11 +697,6 @@ bool BlockManager::UndoWriteToDisk(const CBlockUndo& blockundo, FlatFilePos& pos
     hasher << blockundo;
     fileout << hasher.GetHash();
 
-    if (fileout.fclose() != 0) {
-        LogError("%s: fclose failed\n", __func__);
-        return false;
-    }
-
     return true;
 }
 
@@ -1110,11 +989,6 @@ bool BlockManager::WriteBlockToDisk(const CBlock& block, FlatFilePos& pos) const
     pos.nPos = (unsigned int)fileOutPos;
     fileout << TX_WITH_WITNESS(block);
 
-    if (fileout.fclose() != 0) {
-        LogError("WriteBlockToDisk: fclose failed\n");
-        return false;
-    }
-
     return true;
 }
 
@@ -1160,13 +1034,10 @@ bool BlockManager::WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValid
     return true;
 }
 
-bool BlockManager::ReadBlockFromDisk(CBlock& block, const FlatFilePos& pos, const bool lowprio) const
+bool BlockManager::ReadBlockFromDisk(CBlock& block, const FlatFilePos& pos) const
 {
     block.SetNull();
 
-    {
-    IOPRIO_IDLER(lowprio);
-
     // Open history file to read
     AutoFile filein{OpenBlockFile(pos, true)};
     if (filein.IsNull()) {
@@ -1174,8 +1045,6 @@ bool BlockManager::ReadBlockFromDisk(CBlock& block, const FlatFilePos& pos, cons
         return false;
     }
 
-    if (lowprio) filein.SetIdlePriority();
-
     // Read block
     try {
         filein >> TX_WITH_WITNESS(block);
@@ -1184,8 +1053,6 @@ bool BlockManager::ReadBlockFromDisk(CBlock& block, const FlatFilePos& pos, cons
         return false;
     }
 
-    }  // end IOPRIO_IDLER scope
-
     // Check the header
     if (!CheckProofOfWork(block.GetHash(), block.nBits, GetConsensus())) {
         LogError("%s: Errors in block header at %s\n", __func__, pos.ToString());
@@ -1201,11 +1068,11 @@ bool BlockManager::ReadBlockFromDisk(CBlock& block, const FlatFilePos& pos, cons
     return true;
 }
 
-bool BlockManager::ReadBlockFromDisk(CBlock& block, const CBlockIndex& index, const bool lowprio) const
+bool BlockManager::ReadBlockFromDisk(CBlock& block, const CBlockIndex& index) const
 {
     const FlatFilePos block_pos{WITH_LOCK(cs_main, return index.GetBlockPos())};
 
-    if (!ReadBlockFromDisk(block, block_pos, lowprio)) {
+    if (!ReadBlockFromDisk(block, block_pos)) {
         return false;
     }
     if (block.GetHash() != index.GetBlockHash()) {
@@ -1215,7 +1082,7 @@ bool BlockManager::ReadBlockFromDisk(CBlock& block, const CBlockIndex& index, co
     return true;
 }
 
-bool BlockManager::ReadRawBlockFromDisk(std::vector<uint8_t>& block, const FlatFilePos& pos, const bool lowprio) const
+bool BlockManager::ReadRawBlockFromDisk(std::vector<uint8_t>& block, const FlatFilePos& pos) const
 {
     FlatFilePos hpos = pos;
     // If nPos is less than 8 the pos is null and we don't have the block data
@@ -1225,17 +1092,12 @@ bool BlockManager::ReadRawBlockFromDisk(std::vector<uint8_t>& block, const FlatF
         return false;
     }
     hpos.nPos -= 8; // Seek back 8 bytes for meta header
-
-    IOPRIO_IDLER(lowprio);
-
     AutoFile filein{OpenBlockFile(hpos, true)};
     if (filein.IsNull()) {
         LogError("%s: OpenBlockFile failed for %s\n", __func__, pos.ToString());
         return false;
     }
 
-    if (lowprio) filein.SetIdlePriority();
-
     try {
         MessageStartChars blk_start;
         unsigned int blk_size;
@@ -1289,19 +1151,7 @@ static auto InitBlocksdirXorKey(const BlockManager::Options& opts)
     // size of the XOR-key file.
     std::array<std::byte, 8> xor_key{};
 
-    // Consider this to be the first run if the blocksdir contains only hidden
-    // files (those which start with a .). Checking for a fully-empty dir would
-    // be too aggressive as a .lock file may have already been written.
-    bool first_run = true;
-    for (const auto& entry : fs::directory_iterator(opts.blocks_dir)) {
-        const std::string path = fs::PathToString(entry.path().filename());
-        if (!entry.is_regular_file() || !path.starts_with('.')) {
-            first_run = false;
-            break;
-        }
-    }
-
-    if (opts.use_xor && first_run) {
+    if (opts.use_xor && fs::is_empty(opts.blocks_dir)) {
         // Only use random fresh key when the boolean option is set and on the
         // very first start of the program.
         FastRandomContext{}.fillrand(xor_key);
@@ -1322,11 +1172,6 @@ static auto InitBlocksdirXorKey(const BlockManager::Options& opts)
 #endif
         )};
         xor_key_file << xor_key;
-        if (xor_key_file.fclose() != 0) {
-            throw std::runtime_error{strprintf("Error closing XOR key file %s: %s\n",
-                                               fs::PathToString(xor_key_path),
-                                               SysErrorString(errno))};
-        }
     }
     // If the user disabled the key, it must be zero.
     if (!opts.use_xor && xor_key != decltype(xor_key){}) {
diff --git a/src/node/blockstorage.h b/src/node/blockstorage.h
index ab7d79289a..821bbf5109 100644
--- a/src/node/blockstorage.h
+++ b/src/node/blockstorage.h
@@ -41,9 +41,6 @@ class ChainstateManager;
 namespace Consensus {
 struct Params;
 }
-namespace node {
-struct PruneLockInfo;
-};
 namespace util {
 class SignalInterrupt;
 } // namespace util
@@ -54,18 +51,15 @@ class BlockTreeDB : public CDBWrapper
 {
 public:
     using CDBWrapper::CDBWrapper;
-    bool WriteBatchSync(const std::vector<std::pair<int, const CBlockFileInfo*>>& fileInfo, int nLastFile, const std::vector<const CBlockIndex*>& blockinfo, const std::unordered_map<std::string, node::PruneLockInfo>& prune_locks);
+    bool WriteBatchSync(const std::vector<std::pair<int, const CBlockFileInfo*>>& fileInfo, int nLastFile, const std::vector<const CBlockIndex*>& blockinfo);
     bool ReadBlockFileInfo(int nFile, CBlockFileInfo& info);
     bool ReadLastBlockFile(int& nFile);
     bool WriteReindexing(bool fReindexing);
     void ReadReindexing(bool& fReindexing);
-    bool WritePruneLock(const std::string& name, const node::PruneLockInfo&);
-    bool DeletePruneLock(const std::string& name);
     bool WriteFlag(const std::string& name, bool fValue);
     bool ReadFlag(const std::string& name, bool& fValue);
     bool LoadBlockIndexGuts(const Consensus::Params& consensusParams, std::function<CBlockIndex*(const uint256&)> insertBlockIndex, const util::SignalInterrupt& interrupt)
         EXCLUSIVE_LOCKS_REQUIRED(::cs_main);
-    bool LoadPruneLocks(std::unordered_map<std::string, node::PruneLockInfo>& prune_locks, const util::SignalInterrupt& interrupt);
 };
 } // namespace kernel
 
@@ -98,17 +92,7 @@ struct CBlockIndexHeightOnlyComparator {
 };
 
 struct PruneLockInfo {
-    std::string desc; //! Arbitrary human-readable description of the lock purpose
-    uint64_t height_first{std::numeric_limits<uint64_t>::max()}; //! Height of earliest block that should be kept and not pruned
-    uint64_t height_last{std::numeric_limits<uint64_t>::max()}; //! Height of latest block that should be kept and not pruned
-    bool temporary{true};
-
-    SERIALIZE_METHODS(PruneLockInfo, obj)
-    {
-        READWRITE(obj.desc);
-        READWRITE(VARINT(obj.height_first));
-        READWRITE(VARINT(obj.height_last));
-    }
+    int height_first{std::numeric_limits<int>::max()}; //! Height of earliest block that should be kept and not pruned
 };
 
 enum BlockfileType {
@@ -193,8 +177,6 @@ private:
     bool WriteBlockToDisk(const CBlock& block, FlatFilePos& pos) const;
     bool UndoWriteToDisk(const CBlockUndo& blockundo, FlatFilePos& pos, const uint256& hashBlock) const;
 
-    bool DoPruneLocksForbidPruning(const CBlockFileInfo& block_file_info) EXCLUSIVE_LOCKS_REQUIRED(::cs_main);
-
     /* Calculate the block/rev files to delete based on height specified by user with RPC command pruneblockchain */
     void FindFilesToPruneManual(
         std::set<int>& setFilesToPrune,
@@ -266,17 +248,14 @@ private:
     /** Dirty block file entries. */
     std::set<int> m_dirty_fileinfo;
 
-public:
     /**
      * Map from external index name to oldest block that must not be pruned.
      *
-     * @note Internally, only blocks before height (height_first - PRUNE_LOCK_BUFFER - 1) and
-     * after height (height_last + PRUNE_LOCK_BUFFER) will be pruned, but callers should
-     * avoid assuming any particular buffer size.
+     * @note Internally, only blocks at height (height_first - PRUNE_LOCK_BUFFER - 1) and
+     * below will be pruned, but callers should avoid assuming any particular buffer size.
      */
     std::unordered_map<std::string, PruneLockInfo> m_prune_locks GUARDED_BY(::cs_main);
 
-private:
     BlockfileType BlockfileTypeForHeight(int height);
 
     const kernel::BlockManagerOpts m_opts;
@@ -377,7 +356,6 @@ public:
 
     /** Attempt to stay below this number of bytes of block files. */
     [[nodiscard]] uint64_t GetPruneTarget() const { return m_opts.prune_target; }
-    [[nodiscard]] uint64_t GetPruneTargetForChainstate(const Chainstate& chain, ChainstateManager& chainman) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);
     static constexpr auto PRUNE_TARGET_MANUAL{std::numeric_limits<uint64_t>::max()};
 
     [[nodiscard]] bool LoadingBlocks() const { return m_importing || !m_blockfiles_indexed; }
@@ -427,10 +405,8 @@ public:
     //! Check whether the block associated with this index entry is pruned or not.
     bool IsBlockPruned(const CBlockIndex& block) const EXCLUSIVE_LOCKS_REQUIRED(::cs_main);
 
-    bool PruneLockExists(const std::string& name) const SHARED_LOCKS_REQUIRED(::cs_main);
     //! Create or update a prune lock identified by its name
-    bool UpdatePruneLock(const std::string& name, const PruneLockInfo& lock_info, bool sync=false) EXCLUSIVE_LOCKS_REQUIRED(::cs_main);
-    bool DeletePruneLock(const std::string& name) EXCLUSIVE_LOCKS_REQUIRED(::cs_main);
+    void UpdatePruneLock(const std::string& name, const PruneLockInfo& lock_info) EXCLUSIVE_LOCKS_REQUIRED(::cs_main);
 
     /** Open a block file (blk?????.dat) */
     AutoFile OpenBlockFile(const FlatFilePos& pos, bool fReadOnly = false) const;
@@ -444,9 +420,9 @@ public:
     void UnlinkPrunedFiles(const std::set<int>& setFilesToPrune) const;
 
     /** Functions for disk access for blocks */
-    bool ReadBlockFromDisk(CBlock& block, const FlatFilePos& pos, bool lowprio = false) const;
-    bool ReadBlockFromDisk(CBlock& block, const CBlockIndex& index, bool lowprio = false) const;
-    bool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const FlatFilePos& pos, bool lowprio = false) const;
+    bool ReadBlockFromDisk(CBlock& block, const FlatFilePos& pos) const;
+    bool ReadBlockFromDisk(CBlock& block, const CBlockIndex& index) const;
+    bool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const FlatFilePos& pos) const;
 
     bool UndoReadFromDisk(CBlockUndo& blockundo, const CBlockIndex& index) const;
 
diff --git a/src/node/chainstate.cpp b/src/node/chainstate.cpp
index 1ee168b626..d7e6176be1 100644
--- a/src/node/chainstate.cpp
+++ b/src/node/chainstate.cpp
@@ -95,12 +95,11 @@ static ChainstateLoadResult CompleteChainstateInitialization(
     assert(chainman.m_total_coinstip_cache > 0);
     assert(chainman.m_total_coinsdb_cache > 0);
 
-    // If running with multiple chainstates, limit the cache sizes with a
-    // discount factor. If discounted the actual cache size will be
-    // recalculated by `chainman.MaybeRebalanceCaches()`. The discount factor
-    // is conservatively chosen such that the sum of the caches does not exceed
-    // the allowable amount during this temporary initialization state.
-    double init_cache_fraction = chainman.GetAll().size() > 1 ? 0.2 : 1.0;
+    // Conservative value which is arbitrarily chosen, as it will ultimately be changed
+    // by a call to `chainman.MaybeRebalanceCaches()`. We just need to make sure
+    // that the sum of the two caches (40%) does not exceed the allowable amount
+    // during this temporary initialization state.
+    double init_cache_fraction = 0.2;
 
     // At this point we're either in reindex or we've loaded a useful
     // block tree into BlockIndex()!
diff --git a/src/node/database_args.cpp b/src/node/database_args.cpp
index 0b9080aa5e..aba3c38ff3 100644
--- a/src/node/database_args.cpp
+++ b/src/node/database_args.cpp
@@ -14,6 +14,5 @@ void ReadDatabaseArgs(const ArgsManager& args, DBOptions& options)
     // databases), but it'd be easy to parse database-specific options by adding
     // a database_type string or enum parameter to this function.
     if (auto value = args.GetBoolArg("-forcecompactdb")) options.force_compact = *value;
-    if (auto value = args.GetIntArg("-dbfilesize")) options.max_file_size = (*value) << 20;
 }
 } // namespace node
diff --git a/src/node/eviction.cpp b/src/node/eviction.cpp
index 7c34692026..33406931d4 100644
--- a/src/node/eviction.cpp
+++ b/src/node/eviction.cpp
@@ -3,7 +3,6 @@
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
 #include <node/eviction.h>
-#include <random.h>
 
 #include <algorithm>
 #include <array>
@@ -176,7 +175,7 @@ void ProtectEvictionCandidatesByRatio(std::vector<NodeEvictionCandidate>& evicti
     EraseLastKElements(eviction_candidates, ReverseCompareNodeTimeConnected, remaining_to_protect);
 }
 
-[[nodiscard]] std::optional<NodeId> SelectNodeToEvict(std::vector<NodeEvictionCandidate>&& vEvictionCandidates, bool force)
+[[nodiscard]] std::optional<NodeId> SelectNodeToEvict(std::vector<NodeEvictionCandidate>&& vEvictionCandidates)
 {
     // Protect connections with certain characteristics
 
@@ -184,15 +183,6 @@ void ProtectEvictionCandidatesByRatio(std::vector<NodeEvictionCandidate>& evicti
 
     ProtectOutboundConnections(vEvictionCandidates);
 
-    if (vEvictionCandidates.empty()) return std::nullopt;
-
-    // Hang on to one random node to evict if forced
-    std::optional<NodeId> force_evict;
-    if (force) {
-        uint64_t randpos{FastRandomContext().randrange(vEvictionCandidates.size())};
-        force_evict = vEvictionCandidates.at(randpos).id;
-    }
-
     // Deterministically select 4 peers to protect by netgroup.
     // An attacker cannot predict which netgroups will be protected
     EraseLastKElements(vEvictionCandidates, CompareNetGroupKeyed, 4);
@@ -214,8 +204,7 @@ void ProtectEvictionCandidatesByRatio(std::vector<NodeEvictionCandidate>& evicti
     // or disadvantaged characteristics.
     ProtectEvictionCandidatesByRatio(vEvictionCandidates);
 
-    // May still return nullopt is `force` argument is false
-    if (vEvictionCandidates.empty()) return force_evict;
+    if (vEvictionCandidates.empty()) return std::nullopt;
 
     // If any remaining peers are preferred for eviction consider only them.
     // This happens after the other preferences since if a peer is really the best by other criteria (esp relaying blocks)
diff --git a/src/node/eviction.h b/src/node/eviction.h
index 4727e05f0e..1bb32e5327 100644
--- a/src/node/eviction.h
+++ b/src/node/eviction.h
@@ -38,12 +38,8 @@ struct NodeEvictionCandidate {
  * fixed numbers of desirable peers per various criteria, followed by (mostly)
  * ratios of desirable or disadvantaged peers. If any eviction candidates
  * remain, the selection logic chooses a peer to evict.
- * @param[in]   force   Attempt to evict a random peer if no candidates
- *                      are available among inbound no-ban connections.
- *                      (see CConman::AttemptToEvictConnection())
- *                      Default: false
  */
-[[nodiscard]] std::optional<NodeId> SelectNodeToEvict(std::vector<NodeEvictionCandidate>&& vEvictionCandidates, bool force = false);
+[[nodiscard]] std::optional<NodeId> SelectNodeToEvict(std::vector<NodeEvictionCandidate>&& vEvictionCandidates);
 
 /** Protect desirable or disadvantaged inbound peers from eviction by ratio.
  *
diff --git a/src/node/interface_ui.cpp b/src/node/interface_ui.cpp
index 1e07419dc5..4f4d240d1b 100644
--- a/src/node/interface_ui.cpp
+++ b/src/node/interface_ui.cpp
@@ -21,7 +21,6 @@ struct UISignals {
     boost::signals2::signal<CClientUIInterface::InitWalletSig> InitWallet;
     boost::signals2::signal<CClientUIInterface::NotifyNumConnectionsChangedSig> NotifyNumConnectionsChanged;
     boost::signals2::signal<CClientUIInterface::NotifyNetworkActiveChangedSig> NotifyNetworkActiveChanged;
-    boost::signals2::signal<CClientUIInterface::NotifyNetworkLocalChangedSig> NotifyNetworkLocalChanged;
     boost::signals2::signal<CClientUIInterface::NotifyAlertChangedSig> NotifyAlertChanged;
     boost::signals2::signal<CClientUIInterface::ShowProgressSig> ShowProgress;
     boost::signals2::signal<CClientUIInterface::NotifyBlockTipSig> NotifyBlockTip;
@@ -42,7 +41,6 @@ ADD_SIGNALS_IMPL_WRAPPER(InitMessage);
 ADD_SIGNALS_IMPL_WRAPPER(InitWallet);
 ADD_SIGNALS_IMPL_WRAPPER(NotifyNumConnectionsChanged);
 ADD_SIGNALS_IMPL_WRAPPER(NotifyNetworkActiveChanged);
-ADD_SIGNALS_IMPL_WRAPPER(NotifyNetworkLocalChanged);
 ADD_SIGNALS_IMPL_WRAPPER(NotifyAlertChanged);
 ADD_SIGNALS_IMPL_WRAPPER(ShowProgress);
 ADD_SIGNALS_IMPL_WRAPPER(NotifyBlockTip);
@@ -55,7 +53,6 @@ void CClientUIInterface::InitMessage(const std::string& message) { return g_ui_s
 void CClientUIInterface::InitWallet() { return g_ui_signals.InitWallet(); }
 void CClientUIInterface::NotifyNumConnectionsChanged(int newNumConnections) { return g_ui_signals.NotifyNumConnectionsChanged(newNumConnections); }
 void CClientUIInterface::NotifyNetworkActiveChanged(bool networkActive) { return g_ui_signals.NotifyNetworkActiveChanged(networkActive); }
-void CClientUIInterface::NotifyNetworkLocalChanged() { return g_ui_signals.NotifyNetworkLocalChanged(); }
 void CClientUIInterface::NotifyAlertChanged() { return g_ui_signals.NotifyAlertChanged(); }
 void CClientUIInterface::ShowProgress(const std::string& title, int nProgress, bool resume_possible) { return g_ui_signals.ShowProgress(title, nProgress, resume_possible); }
 void CClientUIInterface::NotifyBlockTip(SynchronizationState s, const CBlockIndex* i) { return g_ui_signals.NotifyBlockTip(s, i); }
diff --git a/src/node/interface_ui.h b/src/node/interface_ui.h
index 4b781d3b94..85c34f5834 100644
--- a/src/node/interface_ui.h
+++ b/src/node/interface_ui.h
@@ -91,9 +91,6 @@ public:
     /** Network activity state changed. */
     ADD_SIGNALS_DECL_WRAPPER(NotifyNetworkActiveChanged, void, bool networkActive);
 
-    /** Network local addresses changed. */
-    ADD_SIGNALS_DECL_WRAPPER(NotifyNetworkLocalChanged, void, );
-
     /**
      * Status bar alerts changed.
      */
diff --git a/src/node/interfaces.cpp b/src/node/interfaces.cpp
index 2f87717736..54b986c926 100644
--- a/src/node/interfaces.cpp
+++ b/src/node/interfaces.cpp
@@ -343,7 +343,6 @@ public:
         req.params = params;
         req.strMethod = command;
         req.URI = uri;
-        req.m_wallet_restriction.clear();
         return ::tableRPC.execute(req);
     }
     std::vector<std::string> listRpcCommands() override { return ::tableRPC.listCommands(); }
@@ -356,7 +355,7 @@ public:
         if (chainman().ActiveChainstate().CoinsTip().GetCoin(output, coin)) return coin;
         return {};
     }
-    TransactionError broadcastTransaction(CTransactionRef tx, const std::variant<CAmount, CFeeRate>& max_tx_fee, std::string& err_string) override
+    TransactionError broadcastTransaction(CTransactionRef tx, CAmount max_tx_fee, std::string& err_string) override
     {
         return BroadcastTransaction(*m_context, std::move(tx), err_string, max_tx_fee, /*relay=*/ true, /*wait_callback=*/ false);
     }
@@ -392,10 +391,6 @@ public:
     {
         return MakeSignalHandler(::uiInterface.NotifyNetworkActiveChanged_connect(fn));
     }
-    std::unique_ptr<Handler> handleNotifyNetworkLocalChanged(NotifyNetworkLocalChangedFn fn) override
-    {
-        return MakeSignalHandler(::uiInterface.NotifyNetworkLocalChanged_connect(fn));
-    }
     std::unique_ptr<Handler> handleNotifyAlertChanged(NotifyAlertChangedFn fn) override
     {
         return MakeSignalHandler(::uiInterface.NotifyAlertChanged_connect(fn));
@@ -425,7 +420,6 @@ public:
     }
     ArgsManager& args() { return *Assert(Assert(m_context)->args); }
     ChainstateManager& chainman() { return *Assert(m_context->chainman); }
-    CTxMemPool& mempool() override { return *Assert(m_context->mempool); }
     NodeContext* m_context{nullptr};
 };
 
@@ -560,24 +554,6 @@ public:
         const CBlockIndex* block{chainman().ActiveChain()[height]};
         return block && ((block->nStatus & BLOCK_HAVE_DATA) != 0) && block->nTx > 0;
     }
-    bool pruneLockExists(const std::string& name) const override
-    {
-        LOCK(cs_main);
-        auto& blockman = m_node.chainman->m_blockman;
-        return blockman.PruneLockExists(name);
-    }
-    bool updatePruneLock(const std::string& name, const node::PruneLockInfo& lock_info, bool sync) override
-    {
-        LOCK(cs_main);
-        auto& blockman = m_node.chainman->m_blockman;
-        return blockman.UpdatePruneLock(name, lock_info, sync);
-    }
-    bool deletePruneLock(const std::string& name) override
-    {
-        LOCK(cs_main);
-        auto& blockman = m_node.chainman->m_blockman;
-        return blockman.DeletePruneLock(name);
-    }
     CBlockLocator getTipLocator() override
     {
         LOCK(::cs_main);
@@ -750,7 +726,7 @@ public:
     {
         if (!m_node.mempool) return {};
         LockPoints lp;
-        CTxMemPoolEntry entry(tx, 0, 0, 0, 0, 0, 0, false, /*extra_weight=*/0, 0, lp);
+        CTxMemPoolEntry entry(tx, 0, 0, 0, 0, false, 0, lp);
         LOCK(m_node.mempool->cs);
         return m_node.mempool->CheckPackageLimits({tx}, entry.GetTxSize());
     }
@@ -798,9 +774,6 @@ public:
     void initMessage(const std::string& message) override { ::uiInterface.InitMessage(message); }
     void initWarning(const bilingual_str& message) override { InitWarning(message); }
     void initError(const bilingual_str& message) override { InitError(message); }
-    bool initQuestion(const bilingual_str& message, const bilingual_str& non_interactive_message, const bilingual_str& caption, unsigned int style) override {
-        return uiInterface.ThreadSafeQuestion(message, non_interactive_message.translated, caption.translated, style);
-    }
     void showProgress(const std::string& title, int progress, bool resume_possible) override
     {
         ::uiInterface.ShowProgress(title, progress, resume_possible);
@@ -936,16 +909,11 @@ public:
         return TestBlockValidity(state, chainman().GetParams(), chainman().ActiveChainstate(), block, tip, /*fCheckPOW=*/false, check_merkle_root);
     }
 
-    std::shared_ptr<CBlockTemplate> createNewBlock(const CScript& script_pub_key, const BlockCreateOptions& options) override
+    std::unique_ptr<CBlockTemplate> createNewBlock(const CScript& script_pub_key, const BlockCreateOptions& options) override
     {
         BlockAssembler::Options assemble_options{options};
         ApplyArgsManOptions(*Assert(m_node.args), assemble_options);
-        return createNewBlock2(script_pub_key, assemble_options);
-    }
-
-    std::shared_ptr<CBlockTemplate> createNewBlock2(const CScript& script_pub_key, const BlockCreateOptions& assemble_options) override
-    {
-        return BlockAssembler{chainman().ActiveChainstate(), context()->mempool.get(), assemble_options, m_node}.CreateNewBlock(script_pub_key);
+        return BlockAssembler{chainman().ActiveChainstate(), context()->mempool.get(), assemble_options}.CreateNewBlock(script_pub_key);
     }
 
     NodeContext* context() override { return &m_node; }
diff --git a/src/node/kernel_notifications.cpp b/src/node/kernel_notifications.cpp
index cedd45aac4..9894052a3a 100644
--- a/src/node/kernel_notifications.cpp
+++ b/src/node/kernel_notifications.cpp
@@ -30,7 +30,8 @@ using util::ReplaceAll;
 static void AlertNotify(const std::string& strMessage)
 {
 #if HAVE_SYSTEM
-    if (!gArgs.IsArgSet("-alertnotify")) return;
+    std::string strCmd = gArgs.GetArg("-alertnotify", "");
+    if (strCmd.empty()) return;
 
     // Alert text should be plain ascii coming from a trusted source, but to
     // be safe we first strip anything not in safeChars, then add single quotes around
@@ -38,13 +39,10 @@ static void AlertNotify(const std::string& strMessage)
     std::string singleQuote("'");
     std::string safeStatus = SanitizeString(strMessage);
     safeStatus = singleQuote+safeStatus+singleQuote;
+    ReplaceAll(strCmd, "%s", safeStatus);
 
-    for (std::string command : gArgs.GetArgs("-alertnotify")) {
-        ReplaceAll(command, "%s", safeStatus);
-
-        std::thread t(runCommand, command);
-        t.detach(); // thread runs free
-    }
+    std::thread t(runCommand, strCmd);
+    t.detach(); // thread runs free
 #endif
 }
 
@@ -72,9 +70,9 @@ void KernelNotifications::progress(const bilingual_str& title, int progress_perc
     uiInterface.ShowProgress(title.translated, progress_percent, resume_possible);
 }
 
-void KernelNotifications::warningSet(kernel::Warning id, const bilingual_str& message, const bool update)
+void KernelNotifications::warningSet(kernel::Warning id, const bilingual_str& message)
 {
-    if (m_warnings.Set(id, message, update)) {
+    if (m_warnings.Set(id, message)) {
         AlertNotify(message.original);
     }
 }
diff --git a/src/node/kernel_notifications.h b/src/node/kernel_notifications.h
index 9d7b1c82ae..e37f4d4e1e 100644
--- a/src/node/kernel_notifications.h
+++ b/src/node/kernel_notifications.h
@@ -40,7 +40,7 @@ public:
 
     void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override;
 
-    void warningSet(kernel::Warning id, const bilingual_str& message, bool update) override;
+    void warningSet(kernel::Warning id, const bilingual_str& message) override;
 
     void warningUnset(kernel::Warning id) override;
 
diff --git a/src/node/mempool_args.cpp b/src/node/mempool_args.cpp
index 52c16227a0..a488c1b149 100644
--- a/src/node/mempool_args.cpp
+++ b/src/node/mempool_args.cpp
@@ -12,22 +12,14 @@
 #include <consensus/amount.h>
 #include <kernel/chainparams.h>
 #include <logging.h>
-#include <node/interface_ui.h>
 #include <policy/feerate.h>
-#include <policy/fees.h>
 #include <policy/policy.h>
 #include <tinyformat.h>
 #include <util/moneystr.h>
-#include <util/result.h>
-#include <util/strencodings.h>
-#include <util/string.h>
 #include <util/translation.h>
 
 #include <chrono>
-#include <cstdint>
 #include <memory>
-#include <string_view>
-#include <utility>
 
 using common::AmountErrMsg;
 using kernel::MemPoolLimits;
@@ -46,51 +38,6 @@ void ApplyArgsManOptions(const ArgsManager& argsman, MemPoolLimits& mempool_limi
 }
 }
 
-util::Result<std::pair<int32_t, int>> ParseDustDynamicOpt(std::string_view optstr, const unsigned int max_fee_estimate_blocks)
-{
-    if (optstr == "0" || optstr == "off") {
-        return std::pair<int32_t, int>(0, DEFAULT_DUST_RELAY_MULTIPLIER);
-    }
-
-    int multiplier{DEFAULT_DUST_RELAY_MULTIPLIER};
-    if (auto pos = optstr.find('*'); pos != optstr.npos) {
-        int64_t parsed;
-        if ((!ParseFixedPoint(optstr.substr(0, pos), 3, &parsed)) || parsed > std::numeric_limits<int>::max() || parsed < 1) {
-            return util::Error{_("failed to parse multiplier")};
-        }
-        multiplier = parsed;
-        optstr.remove_prefix(pos + 1);
-    }
-
-    if (optstr.rfind("target:", 0) == 0) {
-        if (!max_fee_estimate_blocks) {
-            return util::Error{_("\"target\" mode requires fee estimator (disabled)")};
-        }
-        const auto val = ToIntegral<uint16_t>(optstr.substr(7));
-        if (!val) {
-            return util::Error{_("failed to parse target block count")};
-        }
-        if (*val < 2) {
-            return util::Error{_("target must be at least 2 blocks")};
-        }
-        if (*val > max_fee_estimate_blocks) {
-            return util::Error{strprintf(_("target can only be at most %s blocks"), max_fee_estimate_blocks)};
-        }
-        return std::pair<int32_t, int>(-*val, multiplier);
-    } else if (optstr.rfind("mempool:", 0) == 0) {
-        const auto val = ToIntegral<int32_t>(optstr.substr(8));
-        if (!val) {
-            return util::Error{_("failed to parse mempool position")};
-        }
-        if (*val < 1) {
-            return util::Error{_("mempool position must be at least 1 kB")};
-        }
-        return std::pair<int32_t, int>(*val, multiplier);
-    } else {
-        return util::Error{strprintf(_("\"%s\""), optstr)};
-    }
-}
-
 util::Result<void> ApplyArgsManOptions(const ArgsManager& argsman, const CChainParams& chainparams, MemPoolOptions& mempool_opts)
 {
     mempool_opts.check_ratio = argsman.GetIntArg("-checkmempool", mempool_opts.check_ratio);
@@ -131,115 +78,23 @@ util::Result<void> ApplyArgsManOptions(const ArgsManager& argsman, const CChainP
             return util::Error{AmountErrMsg("dustrelayfee", argsman.GetArg("-dustrelayfee", ""))};
         }
     }
-    if (argsman.IsArgSet("-dustdynamic")) {
-        const auto optstr = argsman.GetArg("-dustdynamic", DEFAULT_DUST_DYNAMIC);
-        const auto max_fee_estimate_blocks = mempool_opts.estimator ? mempool_opts.estimator->HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE) : (unsigned int)0;
-        const auto parsed = ParseDustDynamicOpt(optstr, max_fee_estimate_blocks);
-        if (!parsed) {
-            return util::Error{strprintf(_("Invalid mode for dustdynamic: %s"), util::ErrorString(parsed))};
-        }
-        mempool_opts.dust_relay_target = parsed->first;
-        mempool_opts.dust_relay_multiplier = parsed->second;
-    }
-
-    mempool_opts.permit_bare_pubkey = argsman.GetBoolArg("-permitbarepubkey", DEFAULT_PERMIT_BAREPUBKEY);
 
     mempool_opts.permit_bare_multisig = argsman.GetBoolArg("-permitbaremultisig", DEFAULT_PERMIT_BAREMULTISIG);
 
-    mempool_opts.reject_parasites = argsman.GetBoolArg("-rejectparasites", DEFAULT_REJECT_PARASITES);
-
-    mempool_opts.reject_tokens = argsman.GetBoolArg("-rejecttokens", DEFAULT_REJECT_TOKENS);
-
     if (argsman.GetBoolArg("-datacarrier", DEFAULT_ACCEPT_DATACARRIER)) {
         mempool_opts.max_datacarrier_bytes = argsman.GetIntArg("-datacarriersize", MAX_OP_RETURN_RELAY);
     } else {
         mempool_opts.max_datacarrier_bytes = std::nullopt;
     }
-    mempool_opts.datacarrier_fullcount = argsman.GetBoolArg("-datacarrierfullcount", DEFAULT_DATACARRIER_FULLCOUNT);
-    mempool_opts.accept_non_std_datacarrier = argsman.GetBoolArg("-acceptnonstddatacarrier", DEFAULT_ACCEPT_NON_STD_DATACARRIER);
 
     mempool_opts.require_standard = !argsman.GetBoolArg("-acceptnonstdtxn", DEFAULT_ACCEPT_NON_STD_TXN);
-
-    if (argsman.IsArgSet("-mempoolreplacement") || argsman.IsArgSet("-mempoolfullrbf")) {
-        // Generally, mempoolreplacement overrides mempoolfullrbf, but the latter is used to infer intent in some cases
-        std::optional<bool> optin_flag;
-        bool fee_flag{false};
-        if (argsman.GetBoolArg("-mempoolreplacement", false)) {
-            fee_flag = true;
-        } else {
-            for (auto& opt : util::SplitString(argsman.GetArg("-mempoolreplacement", ""), ",+")) {
-                if (opt == "optin") {
-                    optin_flag = true;
-                } else if (opt == "-optin") {
-                    optin_flag = false;
-                } else if (opt == "fee") {
-                    fee_flag = true;
-                }
-            }
-        }
-        if (optin_flag.value_or(false)) {
-            // "optin" is explicitly specified
-            mempool_opts.rbf_policy = RBFPolicy::OptIn;
-        } else if (argsman.GetBoolArg("-mempoolfullrbf", false)) {
-            const bool mempoolreplacement_false{argsman.IsArgSet("-mempoolreplacement") && !(fee_flag || optin_flag.has_value())};
-            if (mempoolreplacement_false) {
-                // This is a contradiction, but override rather than error
-                InitWarning(_("False mempoolreplacement option contradicts true mempoolfullrbf; disallowing all RBF"));
-                mempool_opts.rbf_policy = RBFPolicy::Never;
-            } else {
-                mempool_opts.rbf_policy = RBFPolicy::Always;
-            }
-        } else if (!optin_flag.value_or(true)) {
-            // "-optin" is explicitly specified
-            mempool_opts.rbf_policy = fee_flag ? RBFPolicy::Always : RBFPolicy::Never;
-        } else if (fee_flag) {
-            // Just "fee" by itself
-            if (!argsman.GetBoolArg("-mempoolfullrbf", true)) {
-                mempool_opts.rbf_policy = RBFPolicy::OptIn;
-            } else {
-                // Fallback to default, unless it's been changed to Never
-                if (mempool_opts.rbf_policy == RBFPolicy::Never) {
-                    mempool_opts.rbf_policy = RBFPolicy::Always;
-                }
-            }
-        } else if (!argsman.IsArgSet("-mempoolreplacement")) {
-            // mempoolfullrbf is always explicitly false here
-            // Fallback to default, as long as it isn't Always
-            if (mempool_opts.rbf_policy == RBFPolicy::Always) {
-                mempool_opts.rbf_policy = RBFPolicy::OptIn;
-            }
-        } else {
-            // mempoolreplacement is explicitly false here
-            mempool_opts.rbf_policy = RBFPolicy::Never;
-        }
+    if (!chainparams.IsTestChain() && !mempool_opts.require_standard) {
+        return util::Error{strprintf(Untranslated("acceptnonstdtxn is not currently supported for %s chain"), chainparams.GetChainTypeString())};
     }
 
-    if (argsman.IsArgSet("-mempooltruc")) {
-        std::optional<bool> accept_flag, enforce_flag;
-        if (argsman.GetBoolArg("-mempooltruc", false)) {
-            enforce_flag = true;
-        }
-        for (auto& opt : util::SplitString(argsman.GetArg("-mempooltruc", ""), ",+")) {
-            if (opt == "optin" || opt == "enforce") {
-                enforce_flag = true;
-            } else if (opt == "-optin" || opt == "-enforce") {
-                enforce_flag = false;
-            } else if (opt == "accept") {
-                accept_flag = true;
-            } else if (opt == "reject" || opt == "0") {
-                accept_flag = false;
-            }
-        }
-
-        if (accept_flag && !*accept_flag) {  // reject
-            mempool_opts.truc_policy = TRUCPolicy::Reject;
-        } else if (enforce_flag && *enforce_flag) {  // enforce
-            mempool_opts.truc_policy = TRUCPolicy::Enforce;
-        } else if ((!accept_flag) && !enforce_flag) {
-            // nothing specified, leave at default
-        } else {  // accept or -enforce
-            mempool_opts.truc_policy = TRUCPolicy::Accept;
-        }
+    mempool_opts.full_rbf = argsman.GetBoolArg("-mempoolfullrbf", mempool_opts.full_rbf);
+    if (!mempool_opts.full_rbf) {
+        LogInfo("Warning: mempoolfullrbf=0 set but deprecated and will be removed in a future release\n");
     }
 
     mempool_opts.persist_v1_dat = argsman.GetBoolArg("-persistmempoolv1", mempool_opts.persist_v1_dat);
diff --git a/src/node/mempool_args.h b/src/node/mempool_args.h
index 9da673d71a..630fee6421 100644
--- a/src/node/mempool_args.h
+++ b/src/node/mempool_args.h
@@ -7,10 +7,6 @@
 
 #include <util/result.h>
 
-#include <cstdint>
-#include <string_view>
-#include <utility>
-
 class ArgsManager;
 class CChainParams;
 struct bilingual_str;
@@ -18,8 +14,6 @@ namespace kernel {
 struct MemPoolOptions;
 };
 
-[[nodiscard]] util::Result<std::pair<int32_t, int>> ParseDustDynamicOpt(std::string_view optstr, unsigned int max_fee_estimate_blocks);
-
 /**
  * Overlay the options set in \p argsman on top of corresponding members in \p mempool_opts.
  * Returns an error if one was encountered.
diff --git a/src/node/mempool_persist.cpp b/src/node/mempool_persist.cpp
index a07456a09c..ff7de8c64a 100644
--- a/src/node/mempool_persist.cpp
+++ b/src/node/mempool_persist.cpp
@@ -16,9 +16,7 @@
 #include <uint256.h>
 #include <util/fs.h>
 #include <util/fs_helpers.h>
-#include <util/serfloat.h>
 #include <util/signalinterrupt.h>
-#include <util/syserror.h>
 #include <util/time.h>
 #include <validation.h>
 
@@ -39,39 +37,6 @@ namespace node {
 
 static const uint64_t MEMPOOL_DUMP_VERSION_NO_XOR_KEY{1};
 static const uint64_t MEMPOOL_DUMP_VERSION{2};
-static constexpr uint64_t MEMPOOL_KNOTS_DUMP_VERSION = 0;
-
-bool LoadMempoolKnots(CTxMemPool& pool, const fs::path& knots_filepath, FopenFn mockable_fopen_function)
-{
-    AutoFile file{mockable_fopen_function(knots_filepath, "rb")};
-    if (file.IsNull()) {
-        // Typically missing if there's nothing to save
-        return false;
-    }
-
-    try {
-        uint64_t version;
-        file >> version;
-        if (version != MEMPOOL_KNOTS_DUMP_VERSION) {
-            return false;
-        }
-
-        const unsigned int priority_deltas_count = ReadCompactSize(file);
-        uint256 txid;
-        uint64_t encoded_priority;
-        for (unsigned int i = 0; i < priority_deltas_count; ++i) {
-            Unserialize(file, txid);
-            Unserialize(file, encoded_priority);
-            const double priority = DecodeDouble(encoded_priority);
-            pool.PrioritiseTransaction(txid, priority, 0);
-        }
-    } catch (const std::exception& e) {
-        LogInfo("Failed to deserialize mempool-knots data on file: %s. Continuing anyway.\n", e.what());
-        return false;
-    }
-
-    return true;
-}
 
 bool LoadMempool(CTxMemPool& pool, const fs::path& load_path, Chainstate& active_chainstate, ImportMempoolOptions&& opts)
 {
@@ -133,7 +98,7 @@ bool LoadMempool(CTxMemPool& pool, const fs::path& load_path, Chainstate& active
             }
             if (nTime > TicksSinceEpoch<std::chrono::seconds>(now - pool.m_opts.expiry)) {
                 LOCK(cs_main);
-                const auto& accepted = AcceptToMemoryPool(active_chainstate, tx, nTime, empty_ignore_rejects, /*test_accept=*/false);
+                const auto& accepted = AcceptToMemoryPool(active_chainstate, tx, nTime, /*bypass_limits=*/false, /*test_accept=*/false);
                 if (accepted.m_result_type == MempoolAcceptResult::ResultType::VALID) {
                     ++count;
                 } else {
@@ -177,12 +142,6 @@ bool LoadMempool(CTxMemPool& pool, const fs::path& load_path, Chainstate& active
         return false;
     }
 
-    if (opts.load_knots_data) {
-        auto knots_filepath = load_path;
-        knots_filepath.replace_filename("mempool-knots.dat");
-        LoadMempoolKnots(pool, knots_filepath, opts.mockable_fopen_function);
-    }
-
     LogInfo("Imported mempool transactions from file: %i succeeded, %i failed, %i expired, %i already there, %i waiting for initial broadcast\n", count, failed, expired, already_there, unbroadcast);
     return true;
 }
@@ -192,7 +151,6 @@ bool DumpMempool(const CTxMemPool& pool, const fs::path& dump_path, FopenFn mock
     auto start = SteadyClock::now();
 
     std::map<uint256, CAmount> mapDeltas;
-    std::map<uint256, double> priority_deltas;
     std::vector<TxMempoolInfo> vinfo;
     std::set<uint256> unbroadcast_txids;
 
@@ -202,12 +160,7 @@ bool DumpMempool(const CTxMemPool& pool, const fs::path& dump_path, FopenFn mock
     {
         LOCK(pool.cs);
         for (const auto &i : pool.mapDeltas) {
-            if (i.second.first) {   // priority delta
-                priority_deltas[i.first] = i.second.first;
-            }
-            if (i.second.second) {  // fee delta
-                mapDeltas[i.first] = i.second.second;
-            }
+            mapDeltas[i.first] = i.second;
         }
         vinfo = pool.infoAll();
         unbroadcast_txids = pool.GetUnbroadcastTxs();
@@ -248,44 +201,7 @@ bool DumpMempool(const CTxMemPool& pool, const fs::path& dump_path, FopenFn mock
 
         if (!skip_file_commit && !file.Commit())
             throw std::runtime_error("Commit failed");
-        if (file.fclose() != 0) {
-            const fs::path file_fspath{dump_path + ".new"};
-            throw std::runtime_error(
-                strprintf("Error closing %s: %s", fs::PathToString(file_fspath), SysErrorString(errno)));
-        }
-
-        auto knots_filepath = dump_path;
-        knots_filepath.replace_filename("mempool-knots.dat");
-        LogInfo("Writing %u mempool prioritizations to file...\n", priority_deltas.size());
-        if (priority_deltas.size()) {
-            auto knots_tmppath = knots_filepath;
-            knots_tmppath += ".new";
-
-            AutoFile file{mockable_fopen_function(knots_tmppath, "wb")};
-            if (file.IsNull()) return false;
-
-            uint64_t version = MEMPOOL_KNOTS_DUMP_VERSION;
-            file << version;
-
-            WriteCompactSize(file, priority_deltas.size());
-            for (const auto& [txid, priority] : priority_deltas) {
-                Serialize(file, txid);
-                const uint64_t encoded_priority = EncodeDouble(priority);
-                Serialize(file, encoded_priority);
-            }
-
-            if (!file.Commit()) throw std::runtime_error("Commit failed");
-            if (file.fclose() != 0) {
-                throw std::runtime_error(
-                    strprintf("Error closing %s: %s", fs::PathToString(knots_tmppath), SysErrorString(errno)));
-            }
-            if (!RenameOver(knots_tmppath, knots_filepath)) {
-                throw std::runtime_error("Rename failed (mempool-knots.dat)");
-            }
-        } else {
-            fs::remove(knots_filepath);
-        }
-
+        file.fclose();
         if (!RenameOver(dump_path + ".new", dump_path)) {
             throw std::runtime_error("Rename failed");
         }
@@ -294,11 +210,9 @@ bool DumpMempool(const CTxMemPool& pool, const fs::path& dump_path, FopenFn mock
         LogInfo("Dumped mempool: %.3fs to copy, %.3fs to dump, %d bytes dumped to file\n",
                   Ticks<SecondsDouble>(mid - start),
                   Ticks<SecondsDouble>(last - mid),
-                  (priority_deltas.empty() ? 0 : fs::file_size(knots_filepath)) +
                   fs::file_size(dump_path));
     } catch (const std::exception& e) {
         LogInfo("Failed to dump mempool: %s. Continuing anyway.\n", e.what());
-        (void)file.fclose();
         return false;
     }
     return true;
diff --git a/src/node/mempool_persist.h b/src/node/mempool_persist.h
index 8e8bfe72b8..7c5754a90c 100644
--- a/src/node/mempool_persist.h
+++ b/src/node/mempool_persist.h
@@ -22,7 +22,6 @@ struct ImportMempoolOptions {
     bool use_current_time{false};
     bool apply_fee_delta_priority{true};
     bool apply_unbroadcast_set{true};
-    bool load_knots_data{false};
 };
 /** Import the file and attempt to add its contents to the mempool. */
 bool LoadMempool(CTxMemPool& pool, const fs::path& load_path,
diff --git a/src/node/miner.cpp b/src/node/miner.cpp
index 4b50012362..5c476e154f 100644
--- a/src/node/miner.cpp
+++ b/src/node/miner.cpp
@@ -16,7 +16,6 @@
 #include <consensus/validation.h>
 #include <deploymentstatus.h>
 #include <logging.h>
-#include <node/context.h>
 #include <policy/feerate.h>
 #include <policy/policy.h>
 #include <pow.h>
@@ -24,7 +23,6 @@
 #include <util/moneystr.h>
 #include <util/time.h>
 #include <validation.h>
-#include <validationinterface.h>
 
 #include <algorithm>
 #include <utility>
@@ -35,7 +33,7 @@ int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParam
     int64_t nOldTime = pblock->nTime;
     int64_t nNewTime{std::max<int64_t>(pindexPrev->GetMedianTimePast() + 1, TicksSinceEpoch<std::chrono::seconds>(NodeClock::now()))};
 
-    {
+    if (consensusParams.enforce_BIP94) {
         // Height of block to be mined.
         const int height{pindexPrev->nHeight + 1};
         if (height % consensusParams.DifficultyAdjustmentInterval() == 0) {
@@ -67,52 +65,28 @@ void RegenerateCommitments(CBlock& block, ChainstateManager& chainman)
     block.hashMerkleRoot = BlockMerkleRoot(block);
 }
 
-BlockCreateOptions BlockCreateOptions::Clamped() const
+static BlockAssembler::Options ClampOptions(BlockAssembler::Options options)
 {
-    BlockAssembler::Options options = *this;
-    constexpr size_t theoretical_min_gentx_sz = 1+4+1+36+1+1+4+1+4;
-    constexpr size_t theoretical_min_gentx_weight = theoretical_min_gentx_sz * WITNESS_SCALE_FACTOR;
-    CHECK_NONFATAL(options.coinbase_max_additional_size <= MAX_BLOCK_SERIALIZED_SIZE - 1000);
-    CHECK_NONFATAL(options.coinbase_max_additional_weight <= MAX_BLOCK_WEIGHT - 4000);
-    CHECK_NONFATAL(options.coinbase_max_additional_weight >= theoretical_min_gentx_weight);
-    CHECK_NONFATAL(options.coinbase_output_max_additional_sigops <= MAX_BLOCK_SIGOPS_COST);
-    // Limit size to between coinbase_max_additional_size and MAX_BLOCK_SERIALIZED_SIZE-1K for sanity:
-    options.nBlockMaxSize = std::clamp<size_t>(options.nBlockMaxSize, options.coinbase_max_additional_size, MAX_BLOCK_SERIALIZED_SIZE - 1000);
-    // Limit weight to between coinbase_max_additional_weight and MAX_BLOCK_WEIGHT for sanity:
+    Assert(options.coinbase_max_additional_weight <= DEFAULT_BLOCK_MAX_WEIGHT);
+    Assert(options.coinbase_output_max_additional_sigops <= MAX_BLOCK_SIGOPS_COST);
+    // Limit weight to between coinbase_max_additional_weight and DEFAULT_BLOCK_MAX_WEIGHT for sanity:
     // Coinbase (reserved) outputs can safely exceed -blockmaxweight, but the rest of the block template will be empty.
-    options.nBlockMaxWeight = std::clamp<size_t>(options.nBlockMaxWeight, options.coinbase_max_additional_weight, MAX_BLOCK_WEIGHT);
+    options.nBlockMaxWeight = std::clamp<size_t>(options.nBlockMaxWeight, options.coinbase_max_additional_weight, DEFAULT_BLOCK_MAX_WEIGHT);
     return options;
 }
 
-BlockAssembler::BlockAssembler(Chainstate& chainstate, const CTxMemPool* mempool, const Options& options, const NodeContext& node)
+BlockAssembler::BlockAssembler(Chainstate& chainstate, const CTxMemPool* mempool, const Options& options)
     : chainparams{chainstate.m_chainman.GetParams()},
       m_mempool{options.use_mempool ? mempool : nullptr},
       m_chainstate{chainstate},
-      m_node{node},
-      m_options{options.Clamped()}
+      m_options{ClampOptions(options)}
 {
-    // Whether we need to account for byte usage (in addition to weight usage)
-    fNeedSizeAccounting = (options.nBlockMaxSize < MAX_BLOCK_SERIALIZED_SIZE - 1000);
 }
 
 void ApplyArgsManOptions(const ArgsManager& args, BlockAssembler::Options& options)
 {
     // Block resource limits
-    // If neither -blockmaxsize or -blockmaxweight is given, limit to DEFAULT_BLOCK_MAX_*
-    // If only one is given, only restrict the specified resource.
-    // If both are given, restrict both.
-    bool fWeightSet = false;
-    if (args.IsArgSet("-blockmaxweight")) {
-        options.nBlockMaxWeight = args.GetIntArg("-blockmaxweight", DEFAULT_BLOCK_MAX_WEIGHT);
-        options.nBlockMaxSize = MAX_BLOCK_SERIALIZED_SIZE;
-        fWeightSet = true;
-    }
-    if (args.IsArgSet("-blockmaxsize")) {
-        options.nBlockMaxSize = args.GetIntArg("-blockmaxsize", DEFAULT_BLOCK_MAX_SIZE);
-        if (!fWeightSet) {
-            options.nBlockMaxWeight = options.nBlockMaxSize * WITNESS_SCALE_FACTOR;
-        }
-    }
+    options.nBlockMaxWeight = args.GetIntArg("-blockmaxweight", options.nBlockMaxWeight);
     if (const auto blockmintxfee{args.GetArg("-blockmintxfee")}) {
         if (const auto parsed{ParseMoney(*blockmintxfee)}) options.blockMinFeeRate = CFeeRate{*parsed};
     }
@@ -124,19 +98,15 @@ void BlockAssembler::resetBlock()
     inBlock.clear();
 
     // Reserve space for coinbase tx
-    nBlockSize = m_options.coinbase_max_additional_size;
     nBlockWeight = m_options.coinbase_max_additional_weight;
     nBlockSigOpsCost = m_options.coinbase_output_max_additional_sigops;
 
     // These counters do not include coinbase tx
     nBlockTx = 0;
     nFees = 0;
-
-    lastFewTxs = 0;
-    blockFinished = false;
 }
 
-std::shared_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)
+std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)
 {
     const auto time_start{SteadyClock::now()};
 
@@ -153,9 +123,6 @@ std::shared_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc
     pblock->vtx.emplace_back();
     pblocktemplate->vTxFees.push_back(-1); // updated at end
     pblocktemplate->vTxSigOpsCost.push_back(-1); // updated at end
-    if (m_options.print_modified_fee) {
-        pblocktemplate->vTxPriorities.push_back(-1);  // n/a
-    }
 
     LOCK(::cs_main);
     CBlockIndex* pindexPrev = m_chainstate.m_chain.Tip();
@@ -176,7 +143,6 @@ std::shared_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc
     int nDescendantsUpdated = 0;
     if (m_mempool) {
         LOCK(m_mempool->cs);
-        addPriorityTxs(*m_mempool, nPackagesSelected);
         addPackageTxs(*m_mempool, nPackagesSelected, nDescendantsUpdated);
     }
 
@@ -184,11 +150,6 @@ std::shared_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc
 
     m_last_block_num_txs = nBlockTx;
     m_last_block_weight = nBlockWeight;
-    if (fNeedSizeAccounting) {
-        m_last_block_size = nBlockSize;
-    } else {
-        m_last_block_size = std::nullopt;
-    }
 
     // Create coinbase transaction.
     CMutableTransaction coinbaseTx;
@@ -202,8 +163,7 @@ std::shared_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc
     pblocktemplate->vchCoinbaseCommitment = m_chainstate.m_chainman.GenerateCoinbaseCommitment(*pblock, pindexPrev);
     pblocktemplate->vTxFees[0] = -nFees;
 
-    uint64_t nSerializeSize = GetSerializeSize(TX_WITH_WITNESS(*pblock));
-    LogPrintf("CreateNewBlock(): total size: %u block weight: %u txs: %u fees: %ld sigops %d\n", nSerializeSize, GetBlockWeight(*pblock), nBlockTx, nFees, nBlockSigOpsCost);
+    LogPrintf("CreateNewBlock(): block weight: %u txs: %u fees: %ld sigops %d\n", GetBlockWeight(*pblock), nBlockTx, nFees, nBlockSigOpsCost);
 
     // Fill in header
     pblock->hashPrevBlock  = pindexPrev->GetBlockHash();
@@ -224,8 +184,6 @@ std::shared_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc
              Ticks<MillisecondsDouble>(time_2 - time_1),
              Ticks<MillisecondsDouble>(time_2 - time_start));
 
-    if (m_node.validation_signals) m_node.validation_signals->NewBlockTemplate(pblocktemplate);
-
     return std::move(pblocktemplate);
 }
 
@@ -233,7 +191,7 @@ void BlockAssembler::onlyUnconfirmed(CTxMemPool::setEntries& testSet)
 {
     for (CTxMemPool::setEntries::iterator iit = testSet.begin(); iit != testSet.end(); ) {
         // Only test txs not already in the block
-        if (inBlock.count(*iit)) {
+        if (inBlock.count((*iit)->GetSharedTx()->GetHash())) {
             testSet.erase(iit++);
         } else {
             iit++;
@@ -255,48 +213,31 @@ bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost
 
 // Perform transaction-level checks before adding to block:
 // - transaction finality (locktime)
-// - serialized size (in case -blockmaxsize is in use)
 bool BlockAssembler::TestPackageTransactions(const CTxMemPool::setEntries& package) const
 {
-    uint64_t nPotentialBlockSize = nBlockSize; // only used with fNeedSizeAccounting
     for (CTxMemPool::txiter it : package) {
         if (!IsFinalTx(it->GetTx(), nHeight, m_lock_time_cutoff)) {
             return false;
         }
-        if (fNeedSizeAccounting) {
-            uint64_t nTxSize = ::GetSerializeSize(TX_WITH_WITNESS(it->GetTx()));
-            if (nPotentialBlockSize + nTxSize >= m_options.nBlockMaxSize) {
-                return false;
-            }
-            nPotentialBlockSize += nTxSize;
-        }
     }
     return true;
 }
 
-void BlockAssembler::AddToBlock(const CTxMemPool& mempool, CTxMemPool::txiter iter)
+void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)
 {
     pblocktemplate->block.vtx.emplace_back(iter->GetSharedTx());
     pblocktemplate->vTxFees.push_back(iter->GetFee());
     pblocktemplate->vTxSigOpsCost.push_back(iter->GetSigOpCost());
-    if (fNeedSizeAccounting) {
-        nBlockSize += ::GetSerializeSize(TX_WITH_WITNESS(iter->GetTx()));
-    }
     nBlockWeight += iter->GetTxWeight();
     ++nBlockTx;
     nBlockSigOpsCost += iter->GetSigOpCost();
     nFees += iter->GetFee();
-    inBlock.insert(iter);
+    inBlock.insert(iter->GetSharedTx()->GetHash());
 
     if (m_options.print_modified_fee) {
-        double dPriority = iter->GetPriority(nHeight);
-        CAmount dummy;
-        mempool.ApplyDeltas(iter->GetTx().GetHash(), dPriority, dummy);
-        LogPrintf("priority %.1f fee rate %s txid %s\n",
-                  dPriority,
+        LogPrintf("fee rate %s txid %s\n",
                   CFeeRate(iter->GetModifiedFee(), iter->GetTxSize()).ToString(),
                   iter->GetTx().GetHash().ToString());
-        pblocktemplate->vTxPriorities.push_back(dPriority);
     }
 }
 
@@ -359,11 +300,8 @@ void BlockAssembler::addPackageTxs(const CTxMemPool& mempool, int& nPackagesSele
     // because some of their txs are already in the block
     indexed_modified_transaction_set mapModifiedTx;
     // Keep track of entries that failed inclusion, to avoid duplicate work
-    CTxMemPool::setEntries failedTx;
+    std::set<Txid> failedTx;
 
-    // Start by adding all descendants of previously added txs to mapModifiedTx
-    // and modifying them for their already included ancestors
-    nDescendantsUpdated += UpdatePackagesForAdded(mempool, inBlock, mapModifiedTx);
     CTxMemPool::indexed_transaction_set::index<ancestor_score>::type::iterator mi = mempool.mapTx.get<ancestor_score>().begin();
     CTxMemPool::txiter iter;
 
@@ -390,7 +328,7 @@ void BlockAssembler::addPackageTxs(const CTxMemPool& mempool, int& nPackagesSele
         if (mi != mempool.mapTx.get<ancestor_score>().end()) {
             auto it = mempool.mapTx.project<0>(mi);
             assert(it != mempool.mapTx.end());
-            if (mapModifiedTx.count(it) || inBlock.count(it) || failedTx.count(it)) {
+            if (mapModifiedTx.count(it) || inBlock.count(it->GetSharedTx()->GetHash()) || failedTx.count(it->GetSharedTx()->GetHash())) {
                 ++mi;
                 continue;
             }
@@ -424,7 +362,7 @@ void BlockAssembler::addPackageTxs(const CTxMemPool& mempool, int& nPackagesSele
 
         // We skip mapTx entries that are inBlock, and mapModifiedTx shouldn't
         // contain anything that is inBlock.
-        assert(!inBlock.count(iter));
+        assert(!inBlock.count(iter->GetSharedTx()->GetHash()));
 
         uint64_t packageSize = iter->GetSizeWithAncestors();
         CAmount packageFees = iter->GetModFeesWithAncestors();
@@ -446,7 +384,7 @@ void BlockAssembler::addPackageTxs(const CTxMemPool& mempool, int& nPackagesSele
                 // we must erase failed entries so that we can consider the
                 // next best entry on the next loop iteration
                 mapModifiedTx.get<ancestor_score>().erase(modit);
-                failedTx.insert(iter);
+                failedTx.insert(iter->GetSharedTx()->GetHash());
             }
 
             ++nConsecutiveFailed;
@@ -468,16 +406,7 @@ void BlockAssembler::addPackageTxs(const CTxMemPool& mempool, int& nPackagesSele
         if (!TestPackageTransactions(ancestors)) {
             if (fUsingModified) {
                 mapModifiedTx.get<ancestor_score>().erase(modit);
-                failedTx.insert(iter);
-            }
-
-            if (fNeedSizeAccounting) {
-                ++nConsecutiveFailed;
-
-                if (nConsecutiveFailed > MAX_CONSECUTIVE_FAILURES && nBlockSize > m_options.nBlockMaxSize - m_options.coinbase_max_additional_size) {
-                    // Give up if we're close to full and haven't succeeded in a while
-                    break;
-                }
+                failedTx.insert(iter->GetSharedTx()->GetHash());
             }
             continue;
         }
@@ -490,7 +419,7 @@ void BlockAssembler::addPackageTxs(const CTxMemPool& mempool, int& nPackagesSele
         SortForBlock(ancestors, sortedEntries);
 
         for (size_t i = 0; i < sortedEntries.size(); ++i) {
-            AddToBlock(mempool, sortedEntries[i]);
+            AddToBlock(sortedEntries[i]);
             // Erase from the modified set, if present
             mapModifiedTx.erase(sortedEntries[i]);
         }
diff --git a/src/node/miner.h b/src/node/miner.h
index 0b79bc0af2..1b82943766 100644
--- a/src/node/miner.h
+++ b/src/node/miner.h
@@ -29,16 +29,15 @@ class Chainstate;
 class ChainstateManager;
 
 namespace Consensus { struct Params; };
-namespace node { struct NodeContext; };
 
 namespace node {
+static const bool DEFAULT_PRINT_MODIFIED_FEE = false;
 
 struct CBlockTemplate
 {
     CBlock block;
     std::vector<CAmount> vTxFees;
     std::vector<int64_t> vTxSigOpsCost;
-    std::vector<double> vTxPriorities;
     std::vector<unsigned char> vchCoinbaseCommitment;
 };
 
@@ -141,17 +140,14 @@ class BlockAssembler
 {
 private:
     // The constructed block template
-    std::shared_ptr<CBlockTemplate> pblocktemplate;
-
-    bool fNeedSizeAccounting;
+    std::unique_ptr<CBlockTemplate> pblocktemplate;
 
     // Information on the current status of the block
     uint64_t nBlockWeight;
-    uint64_t nBlockSize;
     uint64_t nBlockTx;
     uint64_t nBlockSigOpsCost;
     CAmount nFees;
-    CTxMemPool::setEntries inBlock;
+    std::unordered_set<Txid, SaltedTxidHasher> inBlock;
 
     // Chain context for the block
     int nHeight;
@@ -160,23 +156,24 @@ private:
     const CChainParams& chainparams;
     const CTxMemPool* const m_mempool;
     Chainstate& m_chainstate;
-    const NodeContext& m_node;
-
-    // Variables used for addPriorityTxs
-    int lastFewTxs;
-    bool blockFinished;
 
 public:
-    using Options = BlockCreateOptions;
+    struct Options : BlockCreateOptions {
+        // Configuration parameters for the block size
+        size_t nBlockMaxWeight{DEFAULT_BLOCK_MAX_WEIGHT};
+        CFeeRate blockMinFeeRate{DEFAULT_BLOCK_MIN_TX_FEE};
+        // Whether to call TestBlockValidity() at the end of CreateNewBlock().
+        bool test_block_validity{true};
+        bool print_modified_fee{DEFAULT_PRINT_MODIFIED_FEE};
+    };
 
-    explicit BlockAssembler(Chainstate& chainstate, const CTxMemPool* mempool, const Options& options, const NodeContext& node);
+    explicit BlockAssembler(Chainstate& chainstate, const CTxMemPool* mempool, const Options& options);
 
     /** Construct a new block template with coinbase to scriptPubKeyIn */
-    std::shared_ptr<CBlockTemplate> CreateNewBlock(const CScript& scriptPubKeyIn);
+    std::unique_ptr<CBlockTemplate> CreateNewBlock(const CScript& scriptPubKeyIn);
 
     inline static std::optional<int64_t> m_last_block_num_txs{};
     inline static std::optional<int64_t> m_last_block_weight{};
-    inline static std::optional<int64_t> m_last_block_size{};
 
 private:
     const Options m_options;
@@ -185,22 +182,14 @@ private:
     /** Clear the block's state and prepare for assembling a new block */
     void resetBlock();
     /** Add a tx to the block */
-    void AddToBlock(const CTxMemPool& mempool, CTxMemPool::txiter iter) EXCLUSIVE_LOCKS_REQUIRED(mempool.cs);
+    void AddToBlock(CTxMemPool::txiter iter);
 
     // Methods for how to add transactions to a block.
-    /** Add transactions based on tx "priority" */
-    void addPriorityTxs(const CTxMemPool& mempool, int &nPackagesSelected) EXCLUSIVE_LOCKS_REQUIRED(mempool.cs);
     /** Add transactions based on feerate including unconfirmed ancestors
       * Increments nPackagesSelected / nDescendantsUpdated with corresponding
       * statistics from the package selection (for logging statistics). */
     void addPackageTxs(const CTxMemPool& mempool, int& nPackagesSelected, int& nDescendantsUpdated) EXCLUSIVE_LOCKS_REQUIRED(mempool.cs);
 
-    // helper function for addPriorityTxs
-    /** Test if tx will still "fit" in the block */
-    bool TestForBlock(CTxMemPool::txiter iter);
-    /** Test if tx still has unconfirmed parents not yet in block */
-    bool isStillDependent(const CTxMemPool& mempool, CTxMemPool::txiter iter) EXCLUSIVE_LOCKS_REQUIRED(mempool.cs);
-
     // helper functions for addPackageTxs()
     /** Remove confirmed (inBlock) entries from given set */
     void onlyUnconfirmed(CTxMemPool::setEntries& testSet);
diff --git a/src/node/psbt.cpp b/src/node/psbt.cpp
index 37b8bd02cc..51e252bffc 100644
--- a/src/node/psbt.cpp
+++ b/src/node/psbt.cpp
@@ -5,7 +5,6 @@
 #include <coins.h>
 #include <consensus/amount.h>
 #include <consensus/tx_verify.h>
-#include <consensus/validation.h>
 #include <node/psbt.h>
 #include <policy/policy.h>
 #include <policy/settings.h>
@@ -138,7 +137,7 @@ PSBTAnalysis AnalyzePSBT(PartiallySignedTransaction psbtx)
 
         if (success) {
             CTransaction ctx = CTransaction(mtx);
-            size_t size(GetVirtualTransactionSize(GetTransactionWeight(ctx) + CalculateExtraTxWeight(ctx, view, ::g_weight_per_data_byte), GetTransactionSigOpCost(ctx, view, STANDARD_SCRIPT_VERIFY_FLAGS), ::nBytesPerSigOp));
+            size_t size(GetVirtualTransactionSize(ctx, GetTransactionSigOpCost(ctx, view, STANDARD_SCRIPT_VERIFY_FLAGS), ::nBytesPerSigOp));
             result.estimated_vsize = size;
             // Estimate fee rate
             CFeeRate feerate(fee, size);
diff --git a/src/node/transaction.cpp b/src/node/transaction.cpp
index 64933d8a22..0f45da45db 100644
--- a/src/node/transaction.cpp
+++ b/src/node/transaction.cpp
@@ -31,7 +31,7 @@ static TransactionError HandleATMPError(const TxValidationState& state, std::str
     }
 }
 
-TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef tx, std::string& err_string, const std::variant<CAmount, CFeeRate>& max_tx_fee, bool relay, bool wait_callback, const ignore_rejects_type& ignore_rejects)
+TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef tx, std::string& err_string, const CAmount& max_tx_fee, bool relay, bool wait_callback)
 {
     // BroadcastTransaction can be called by RPC or by the wallet.
     // chainman, mempool and peerman are initialized before the RPC server and wallet are started
@@ -69,30 +69,18 @@ TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef t
             wtxid = mempool_tx->GetWitnessHash();
         } else {
             // Transaction is not already in the mempool.
-            bool max_tx_fee_set{(std::holds_alternative<CAmount>(max_tx_fee) ? std::get<CAmount>(max_tx_fee) : std::get<CFeeRate>(max_tx_fee).GetFeePerK()) > 0};
-            if (ignore_rejects.count("absurdly-high-fee") || ignore_rejects.count("max-fee-exceeded")) {
-                max_tx_fee_set = false;
-            }
-            if (max_tx_fee_set) {
+            if (max_tx_fee > 0) {
                 // First, call ATMP with test_accept and check the fee. If ATMP
                 // fails here, return error immediately.
-                const MempoolAcceptResult result = node.chainman->ProcessTransaction(tx, /*test_accept=*/ true, ignore_rejects);
+                const MempoolAcceptResult result = node.chainman->ProcessTransaction(tx, /*test_accept=*/ true);
                 if (result.m_result_type != MempoolAcceptResult::ResultType::VALID) {
                     return HandleATMPError(result.m_state, err_string);
-                } else {
-                    CAmount max_tx_fee_abs;
-                    if (std::holds_alternative<CFeeRate>(max_tx_fee)) {
-                        max_tx_fee_abs = std::get<CFeeRate>(max_tx_fee).GetFee(*Assert(result.m_vsize));
-                    } else {
-                        max_tx_fee_abs = std::get<CAmount>(max_tx_fee);
-                    }
-                    if (result.m_base_fees.value() > max_tx_fee_abs) {
-                        return TransactionError::MAX_FEE_EXCEEDED;
-                    }
+                } else if (result.m_base_fees.value() > max_tx_fee) {
+                    return TransactionError::MAX_FEE_EXCEEDED;
                 }
             }
             // Try to submit the transaction to the mempool.
-            const MempoolAcceptResult result = node.chainman->ProcessTransaction(tx, /*test_accept=*/ false, ignore_rejects);
+            const MempoolAcceptResult result = node.chainman->ProcessTransaction(tx, /*test_accept=*/ false);
             if (result.m_result_type != MempoolAcceptResult::ResultType::VALID) {
                 return HandleATMPError(result.m_state, err_string);
             }
diff --git a/src/node/transaction.h b/src/node/transaction.h
index 5bc4273484..5f524f4e28 100644
--- a/src/node/transaction.h
+++ b/src/node/transaction.h
@@ -8,9 +8,6 @@
 #include <common/messages.h>
 #include <policy/feerate.h>
 #include <primitives/transaction.h>
-#include <policy/policy.h>
-
-#include <variant>
 
 class CBlockIndex;
 class CTxMemPool;
@@ -52,7 +49,7 @@ static const CAmount DEFAULT_MAX_BURN_AMOUNT{0};
  * @param[in]  wait_callback wait until callbacks have been processed to avoid stale result due to a sequentially RPC.
  * return error
  */
-[[nodiscard]] TransactionError BroadcastTransaction(NodeContext& node, CTransactionRef tx, std::string& err_string, const std::variant<CAmount, CFeeRate>& max_tx_fee, bool relay, bool wait_callback, const ignore_rejects_type& ignore_rejects=empty_ignore_rejects);
+[[nodiscard]] TransactionError BroadcastTransaction(NodeContext& node, CTransactionRef tx, std::string& err_string, const CAmount& max_tx_fee, bool relay, bool wait_callback);
 
 /**
  * Return transaction with a given hash.
diff --git a/src/node/types.h b/src/node/types.h
index 059aa045bf..1302f1b127 100644
--- a/src/node/types.h
+++ b/src/node/types.h
@@ -13,9 +13,6 @@
 #ifndef BITCOIN_NODE_TYPES_H
 #define BITCOIN_NODE_TYPES_H
 
-#include <policy/feerate.h>
-#include <policy/policy.h>
-
 #include <cstddef>
 
 namespace node {
@@ -30,19 +27,11 @@ enum class TransactionError {
     INVALID_PACKAGE,
 };
 
-static const bool DEFAULT_PRINT_MODIFIED_FEE = false;
-
 struct BlockCreateOptions {
     /**
      * Set false to omit mempool transactions
      */
     bool use_mempool{true};
-    /**
-     * The maximum additional size which the miner will add to the coinbase
-     * scriptSig, witness and outputs. This must include any additional
-     * size needed for larger CompactSize encoded lengths.
-     */
-    size_t coinbase_max_additional_size{1000};
     /**
      * The maximum additional weight which the pool will add to the coinbase
      * scriptSig, witness and outputs. This must include any additional
@@ -54,18 +43,6 @@ struct BlockCreateOptions {
      * transaction outputs.
      */
     size_t coinbase_output_max_additional_sigops{400};
-
-    // Configuration parameters for the block size
-    size_t nBlockMaxWeight{DEFAULT_BLOCK_MAX_WEIGHT};
-    size_t nBlockMaxSize{DEFAULT_BLOCK_MAX_SIZE};
-    CFeeRate blockMinFeeRate{DEFAULT_BLOCK_MIN_TX_FEE};
-    // Whether to call TestBlockValidity() at the end of CreateNewBlock().
-    bool test_block_validity{true};
-    bool print_modified_fee{DEFAULT_PRINT_MODIFIED_FEE};
-
-    BlockCreateOptions Clamped() const;
-
-    friend bool operator==(const BlockCreateOptions& a, const BlockCreateOptions& b) noexcept = default;
 };
 } // namespace node
 
diff --git a/src/node/warnings.cpp b/src/node/warnings.cpp
index c899828573..87389e472b 100644
--- a/src/node/warnings.cpp
+++ b/src/node/warnings.cpp
@@ -11,7 +11,6 @@
 #include <node/interface_ui.h>
 #include <sync.h>
 #include <univalue.h>
-#include <util/string.h>
 #include <util/translation.h>
 
 #include <utility>
@@ -27,20 +26,9 @@ Warnings::Warnings()
              _("This is a pre-release test build - use at your own risk - do not use for mining or merchant applications")});
     }
 }
-bool Warnings::Set(warning_type id, bilingual_str message, const bool update)
+bool Warnings::Set(warning_type id, bilingual_str message)
 {
-    bool inserted{false};
-    if (update) {
-        LOCK(m_mutex);
-        auto& warning_msg = m_warnings[id];
-        if (warning_msg.original != message.original) {
-            warning_msg = message;
-            inserted = true;
-        }
-    } else {
-        const auto& [_, inserted_res]{WITH_LOCK(m_mutex, return m_warnings.insert({id, std::move(message)}))};
-        inserted = inserted_res;
-    }
+    const auto& [_, inserted]{WITH_LOCK(m_mutex, return m_warnings.insert({id, std::move(message)}))};
     if (inserted) uiInterface.NotifyAlertChanged();
     return inserted;
 }
@@ -67,7 +55,7 @@ UniValue GetWarningsForRpc(const Warnings& warnings, bool use_deprecated)
 {
     if (use_deprecated) {
         const auto all_messages{warnings.GetMessages()};
-        return all_messages.empty() ? "" : util::Join(all_messages, Untranslated("\n")).original;
+        return all_messages.empty() ? "" : all_messages.back().original;
     }
 
     UniValue messages{UniValue::VARR};
diff --git a/src/node/warnings.h b/src/node/warnings.h
index a473c6591f..24aeb8a922 100644
--- a/src/node/warnings.h
+++ b/src/node/warnings.h
@@ -53,20 +53,14 @@ public:
      *        `id` is already active, false is returned and the new
      *        warning is ignored. If `id` does not yet exist, the
      *        warning is set, the UI is updated, and true is returned.
-     *        If `update` is true, already active warnings will be
-     *        updated with the new `message`, and this method will
-     *        return true unless there has been no change (only the
-     *        untranslated/original string is compared).
      *
      * @param[in]   id  Unique identifier of the warning.
      * @param[in]   message Warning message to be shown.
-     * @param[in]   update  Whether an existing warning should be
-     *              updated.
      *
      * @returns true if the warning was indeed set (i.e. there is no
      *          active warning with this `id`), otherwise false.
      */
-    bool Set(warning_type id, bilingual_str message, bool update=false) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex);
+    bool Set(warning_type id, bilingual_str message) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex);
     /**
      * @brief Unset a warning message. If a warning with the specified
      *        `id` is active, it is unset, the UI is updated, and true
diff --git a/src/outputtype.cpp b/src/outputtype.cpp
index 8825aaea27..8c2b76494b 100644
--- a/src/outputtype.cpp
+++ b/src/outputtype.cpp
@@ -72,7 +72,7 @@ std::vector<CTxDestination> GetAllDestinationsForKey(const CPubKey& key)
 {
     PKHash keyid(key);
     CTxDestination p2pkh{keyid};
-    if (key.IsCompressed() && g_implicit_segwit) {
+    if (key.IsCompressed()) {
         CTxDestination segwit = WitnessV0KeyHash(keyid);
         CTxDestination p2sh = ScriptHash(GetScriptForDestination(segwit));
         return Vector(std::move(p2pkh), std::move(p2sh), std::move(segwit));
diff --git a/src/policy/coin_age_priority.cpp b/src/policy/coin_age_priority.cpp
deleted file mode 100644
index 162e0a234d..0000000000
--- a/src/policy/coin_age_priority.cpp
+++ /dev/null
@@ -1,256 +0,0 @@
-// Copyright (c) 2012-2017 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#include <policy/coin_age_priority.h>
-
-#include <coins.h>
-#include <common/args.h>
-#include <consensus/validation.h>
-#include <node/miner.h>
-#include <policy/policy.h>
-#include <primitives/transaction.h>
-#include <txmempool.h>
-#include <util/check.h>
-#include <validation.h>
-
-using node::BlockAssembler;
-
-unsigned int CalculateModifiedSize(const CTransaction& tx, unsigned int nTxSize)
-{
-    // In order to avoid disincentivizing cleaning up the UTXO set we don't count
-    // the constant overhead for each txin and up to 110 bytes of scriptSig (which
-    // is enough to cover a compressed pubkey p2sh redemption) for priority.
-    // Providing any more cleanup incentive than making additional inputs free would
-    // risk encouraging people to create junk outputs to redeem later.
-    Assert(nTxSize > 0);
-    for (std::vector<CTxIn>::const_iterator it(tx.vin.begin()); it != tx.vin.end(); ++it)
-    {
-        unsigned int offset = 41U + std::min(110U, (unsigned int)it->scriptSig.size());
-        if (nTxSize > offset)
-            nTxSize -= offset;
-    }
-    return nTxSize;
-}
-
-double ComputePriority2(double inputs_coin_age, unsigned int mod_vsize)
-{
-    if (mod_vsize == 0) return 0.0;
-
-    return inputs_coin_age / mod_vsize;
-}
-
-double GetCoinAge(const CTransaction &tx, const CCoinsViewCache& view, int nHeight, CAmount &inChainInputValue)
-{
-    inChainInputValue = 0;
-    if (tx.IsCoinBase())
-        return 0.0;
-    double dResult = 0.0;
-    for (const CTxIn& txin : tx.vin)
-    {
-        const Coin& coin = view.AccessCoin(txin.prevout);
-        if (coin.IsSpent()) {
-            continue;
-        }
-        if (coin.nHeight <= nHeight) {
-            dResult += (double)(coin.out.nValue) * (nHeight - coin.nHeight);
-            inChainInputValue += coin.out.nValue;
-        }
-    }
-    return dResult;
-}
-
-void CTxMemPoolEntry::UpdateCachedPriority(unsigned int currentHeight, CAmount valueInCurrentBlock)
-{
-    int heightDiff = int(currentHeight) - int(cachedHeight);
-    double deltaPriority = ((double)heightDiff*inChainInputValue)/nModSize;
-    cachedPriority += deltaPriority;
-    cachedHeight = currentHeight;
-    inChainInputValue += valueInCurrentBlock;
-    assert(MoneyRange(inChainInputValue));
-}
-
-struct update_priority
-{
-    update_priority(unsigned int _height, CAmount _value) :
-        height(_height), value(_value)
-    {}
-
-    void operator() (CTxMemPoolEntry &e)
-    { e.UpdateCachedPriority(height, value); }
-
-    private:
-        unsigned int height;
-        CAmount value;
-};
-
-void CTxMemPool::UpdateDependentPriorities(const CTransaction &tx, unsigned int nBlockHeight, bool addToChain)
-{
-    LOCK(cs);
-    for (unsigned int i = 0; i < tx.vout.size(); i++) {
-        auto it = mapNextTx.find(COutPoint(tx.GetHash(), i));
-        if (it == mapNextTx.end())
-            continue;
-        uint256 hash = it->second->GetHash();
-        txiter iter = mapTx.find(hash);
-        mapTx.modify(iter, update_priority(nBlockHeight, addToChain ? tx.vout[i].nValue : -tx.vout[i].nValue));
-    }
-}
-
-double
-CTxMemPoolEntry::GetPriority(unsigned int currentHeight) const
-{
-    // This will only return accurate results when currentHeight >= the heights
-    // at which all the in-chain inputs of the tx were included in blocks.
-    // Typical usage of GetPriority with chainActive.Height() will ensure this.
-    int heightDiff = currentHeight - cachedHeight;
-    double deltaPriority = ((double)heightDiff*inChainInputValue)/nModSize;
-    double dResult = cachedPriority + deltaPriority;
-    if (dResult < 0) // This should only happen if it was called with an invalid height
-        dResult = 0;
-    return dResult;
-}
-
-// We want to sort transactions by coin age priority
-typedef std::pair<double, CTxMemPool::txiter> TxCoinAgePriority;
-
-struct TxCoinAgePriorityCompare
-{
-    bool operator()(const TxCoinAgePriority& a, const TxCoinAgePriority& b)
-    {
-        if (a.first == b.first)
-            return CompareTxMemPoolEntryByScore()(*(b.second), *(a.second)); //Reverse order to make sort less than
-        return a.first < b.first;
-    }
-};
-
-bool BlockAssembler::isStillDependent(const CTxMemPool& mempool, CTxMemPool::txiter iter)
-{
-    assert(iter != mempool.mapTx.end());
-    for (const auto& parent : iter->GetMemPoolParentsConst()) {
-        auto parent_it = mempool.mapTx.iterator_to(parent);
-        if (!inBlock.count(parent_it)) {
-            return true;
-        }
-    }
-    return false;
-}
-
-bool BlockAssembler::TestForBlock(CTxMemPool::txiter iter)
-{
-    uint64_t packageSize = iter->GetSizeWithAncestors();
-    int64_t packageSigOps = iter->GetSigOpCostWithAncestors();
-    if (!TestPackage(packageSize, packageSigOps)) {
-        // If the block is so close to full that no more txs will fit
-        // or if we've tried more than 50 times to fill remaining space
-        // then flag that the block is finished
-        if (nBlockWeight > m_options.nBlockMaxWeight - 400 || nBlockSigOpsCost > MAX_BLOCK_SIGOPS_COST - 8 || lastFewTxs > 50) {
-             blockFinished = true;
-             return false;
-        }
-        // Once we're within 4000 weight of a full block, only look at 50 more txs
-        // to try to fill the remaining space.
-        if (nBlockWeight > m_options.nBlockMaxWeight - 4000) {
-            ++lastFewTxs;
-        }
-        return false;
-    }
-
-    CTxMemPool::setEntries package;
-    package.insert(iter);
-    if (!TestPackageTransactions(package)) {
-        if (nBlockSize > m_options.nBlockMaxSize - 100 || lastFewTxs > 50) {
-            blockFinished = true;
-            return false;
-        }
-        if (nBlockSize > m_options.nBlockMaxSize - 1000) {
-            ++lastFewTxs;
-        }
-        return false;
-    }
-
-    return true;
-}
-
-void BlockAssembler::addPriorityTxs(const CTxMemPool& mempool, int &nPackagesSelected)
-{
-    AssertLockHeld(mempool.cs);
-
-    // How much of the block should be dedicated to high-priority transactions,
-    // included regardless of the fees they pay
-    uint64_t nBlockPrioritySize = gArgs.GetIntArg("-blockprioritysize", DEFAULT_BLOCK_PRIORITY_SIZE);
-    if (m_options.nBlockMaxSize < nBlockPrioritySize) {
-        nBlockPrioritySize = m_options.nBlockMaxSize;
-    }
-
-    if (nBlockPrioritySize <= 0) {
-        return;
-    }
-
-    bool fSizeAccounting = fNeedSizeAccounting;
-    fNeedSizeAccounting = true;
-
-    // This vector will be sorted into a priority queue:
-    std::vector<TxCoinAgePriority> vecPriority;
-    TxCoinAgePriorityCompare pricomparer;
-    std::map<CTxMemPool::txiter, double, CompareIteratorByHash> waitPriMap;
-    typedef std::map<CTxMemPool::txiter, double, CompareIteratorByHash>::iterator waitPriIter;
-    double actualPriority = -1;
-
-    vecPriority.reserve(mempool.mapTx.size());
-    for (auto mi = mempool.mapTx.begin(); mi != mempool.mapTx.end(); ++mi) {
-        double dPriority = mi->GetPriority(nHeight);
-        CAmount dummy;
-        mempool.ApplyDeltas(mi->GetTx().GetHash(), dPriority, dummy);
-        vecPriority.emplace_back(dPriority, mi);
-    }
-    std::make_heap(vecPriority.begin(), vecPriority.end(), pricomparer);
-
-    CTxMemPool::txiter iter;
-    while (!vecPriority.empty() && !blockFinished) { // add a tx from priority queue to fill the blockprioritysize
-        iter = vecPriority.front().second;
-        actualPriority = vecPriority.front().first;
-        std::pop_heap(vecPriority.begin(), vecPriority.end(), pricomparer);
-        vecPriority.pop_back();
-
-        // If tx already in block, skip
-        if (inBlock.count(iter)) {
-            assert(false); // shouldn't happen for priority txs
-            continue;
-        }
-
-        // If tx is dependent on other mempool txs which haven't yet been included
-        // then put it in the waitSet
-        if (isStillDependent(mempool, iter)) {
-            waitPriMap.insert(std::make_pair(iter, actualPriority));
-            continue;
-        }
-
-        // If this tx fits in the block add it, otherwise keep looping
-        if (TestForBlock(iter)) {
-            AddToBlock(mempool, iter);
-
-            ++nPackagesSelected;
-
-            // If now that this txs is added we've surpassed our desired priority size
-            // or have dropped below the minimum priority threshold, then we're done adding priority txs
-            if (nBlockSize >= nBlockPrioritySize || actualPriority <= MINIMUM_TX_PRIORITY) {
-                break;
-            }
-
-            // This tx was successfully added, so
-            // add transactions that depend on this one to the priority queue to try again
-            for (const auto& child : iter->GetMemPoolChildrenConst())
-            {
-                auto child_it = mempool.mapTx.iterator_to(child);
-                waitPriIter wpiter = waitPriMap.find(child_it);
-                if (wpiter != waitPriMap.end()) {
-                    vecPriority.emplace_back(wpiter->second, child_it);
-                    std::push_heap(vecPriority.begin(), vecPriority.end(), pricomparer);
-                    waitPriMap.erase(wpiter);
-                }
-            }
-        }
-    }
-    fNeedSizeAccounting = fSizeAccounting;
-}
diff --git a/src/policy/coin_age_priority.h b/src/policy/coin_age_priority.h
deleted file mode 100644
index e741039127..0000000000
--- a/src/policy/coin_age_priority.h
+++ /dev/null
@@ -1,28 +0,0 @@
-// Copyright (c) 2012-2017 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#ifndef BITCOIN_POLICY_COIN_AGE_PRIORITY_H
-#define BITCOIN_POLICY_COIN_AGE_PRIORITY_H
-
-#include <consensus/amount.h>
-
-class CCoinsViewCache;
-class CTransaction;
-
-// Compute modified tx vsize for priority calculation
-unsigned int CalculateModifiedSize(const CTransaction& tx, unsigned int nTxSize);
-
-// Compute priority, given sum coin-age of inputs and modified tx vsize
-// CAUTION: Original ComputePriority accepted UNMODIFIED tx vsize and did the modification internally
-double ComputePriority2(double inputs_coin_age, unsigned int mod_vsize);
-
-/**
- * Return sum coin-age of tx inputs at height nHeight. Also calculate the sum of the values of the inputs
- * that are already in the chain.  These are the inputs that will age and increase priority as
- * new blocks are added to the chain.
- * CAUTION: Original GetPriority also called ComputePriority and returned the final coin-age priority
- */
-double GetCoinAge(const CTransaction &tx, const CCoinsViewCache& view, int nHeight, CAmount &inChainInputValue);
-
-#endif // BITCOIN_POLICY_COIN_AGE_PRIORITY_H
diff --git a/src/policy/feerate.cpp b/src/policy/feerate.cpp
index 34795a84fc..eb0cba5c67 100644
--- a/src/policy/feerate.cpp
+++ b/src/policy/feerate.cpp
@@ -43,7 +43,3 @@ std::string CFeeRate::ToString(const FeeEstimateMode& fee_estimate_mode) const
     default:                      return strprintf("%d.%08d %s/kvB", nSatoshisPerK / COIN, nSatoshisPerK % COIN, CURRENCY_UNIT);
     }
 }
-
-std::string CFeeRate::SatsToString() const {
-    return strprintf("%d.%03d", nSatoshisPerK / 1000, nSatoshisPerK % 1000);
-}
diff --git a/src/policy/feerate.h b/src/policy/feerate.h
index 17527db69d..d742a43acc 100644
--- a/src/policy/feerate.h
+++ b/src/policy/feerate.h
@@ -68,13 +68,9 @@ public:
     friend bool operator>=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK >= b.nSatoshisPerK; }
     friend bool operator!=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK != b.nSatoshisPerK; }
     CFeeRate& operator+=(const CFeeRate& a) { nSatoshisPerK += a.nSatoshisPerK; return *this; }
-    /** Return the fee rate in sat/vB or BTC/kvB, with units, as a string. */
     std::string ToString(const FeeEstimateMode& fee_estimate_mode = FeeEstimateMode::BTC_KVB) const;
-    /** Return the fee rate in sat/vB, without units, as a string. */
-    std::string SatsToString() const;
     friend CFeeRate operator*(const CFeeRate& f, int a) { return CFeeRate(a * f.nSatoshisPerK); }
     friend CFeeRate operator*(int a, const CFeeRate& f) { return CFeeRate(a * f.nSatoshisPerK); }
-    friend CFeeRate operator/(const CFeeRate& f, int a) { return CFeeRate(f.nSatoshisPerK / a); }
 
     SERIALIZE_METHODS(CFeeRate, obj) { READWRITE(obj.nSatoshisPerK); }
 };
diff --git a/src/policy/fees.cpp b/src/policy/fees.cpp
index 7ab69784be..5f1d15c5f2 100644
--- a/src/policy/fees.cpp
+++ b/src/policy/fees.cpp
@@ -612,7 +612,7 @@ void CBlockPolicyEstimator::processTransaction(const NewMempoolTransactionInfo&
     // - the node is not behind
     // - the transaction is not dependent on any other transactions in the mempool
     // - it's not part of a package.
-    const bool validForFeeEstimation = tx.m_ignore_rejects.empty() && !tx.m_submitted_in_package && tx.m_chainstate_is_current && tx.m_has_no_mempool_parents;
+    const bool validForFeeEstimation = !tx.m_mempool_limit_bypassed && !tx.m_submitted_in_package && tx.m_chainstate_is_current && tx.m_has_no_mempool_parents;
 
     // Only want to be updating estimates when our blockchain is synced,
     // otherwise we'll miscalculate how many blocks its taking to get included.
@@ -947,15 +947,13 @@ void CBlockPolicyEstimator::Flush() {
     FlushFeeEstimates();
 }
 
-bool CBlockPolicyEstimator::FlushFeeEstimates() const
+void CBlockPolicyEstimator::FlushFeeEstimates()
 {
     AutoFile est_file{fsbridge::fopen(m_estimation_filepath, "wb")};
-    if (est_file.IsNull() || !Write(est_file) || est_file.fclose() != 0) {
+    if (est_file.IsNull() || !Write(est_file)) {
         LogPrintf("Failed to write fee estimates to %s. Continue anyway.\n", fs::PathToString(m_estimation_filepath));
-        return false;
     } else {
         LogPrintf("Flushed fee estimates to %s.\n", fs::PathToString(m_estimation_filepath.filename()));
-        return true;
     }
 }
 
diff --git a/src/policy/fees.h b/src/policy/fees.h
index 73a65d9c5e..a95cc19dd4 100644
--- a/src/policy/fees.h
+++ b/src/policy/fees.h
@@ -256,7 +256,7 @@ public:
         EXCLUSIVE_LOCKS_REQUIRED(!m_cs_fee_estimator);
 
     /** Record current fee estimations. */
-    bool FlushFeeEstimates() const
+    void FlushFeeEstimates()
         EXCLUSIVE_LOCKS_REQUIRED(!m_cs_fee_estimator);
 
     /** Calculates the age of the file, since last modified */
diff --git a/src/policy/policy.cpp b/src/policy/policy.cpp
index 28cf2e1657..68d879b5b8 100644
--- a/src/policy/policy.cpp
+++ b/src/policy/policy.cpp
@@ -11,9 +11,7 @@
 #include <consensus/amount.h>
 #include <consensus/consensus.h>
 #include <consensus/validation.h>
-#include <kernel/mempool_options.h>
 #include <policy/feerate.h>
-#include <policy/settings.h>
 #include <primitives/transaction.h>
 #include <script/interpreter.h>
 #include <script/script.h>
@@ -23,11 +21,8 @@
 
 #include <algorithm>
 #include <cstddef>
-#include <utility>
 #include <vector>
 
-unsigned int g_script_size_policy_limit{DEFAULT_SCRIPT_SIZE_POLICY_LIMIT};
-
 CAmount GetDustThreshold(const CTxOut& txout, const CFeeRate& dustRelayFeeIn)
 {
     // "Dust" is defined in terms of dustRelayFee,
@@ -72,10 +67,6 @@ bool IsDust(const CTxOut& txout, const CFeeRate& dustRelayFeeIn)
     return (txout.nValue < GetDustThreshold(txout, dustRelayFeeIn));
 }
 
-/**
- * Note this must assign whichType even if returning false, in case
- * IsStandardTx ignores the "scriptpubkey" rejection.
- */
 bool IsStandard(const CScript& scriptPubKey, const std::optional<unsigned>& max_datacarrier_bytes, TxoutType& whichType)
 {
     std::vector<std::vector<unsigned char> > vSolutions;
@@ -100,27 +91,11 @@ bool IsStandard(const CScript& scriptPubKey, const std::optional<unsigned>& max_
     return true;
 }
 
-static inline bool MaybeReject_(std::string& out_reason, const std::string& reason, const std::string& reason_prefix, const ignore_rejects_type& ignore_rejects) {
-    if (ignore_rejects.count(reason_prefix + reason)) {
-        return false;
-    }
-
-    out_reason = reason_prefix + reason;
-    return true;
-}
-
-#define MaybeReject(reason)  do {  \
-    if (MaybeReject_(out_reason, reason, reason_prefix, ignore_rejects)) {  \
-        return false;  \
-    }  \
-} while(0)
-
-bool IsStandardTx(const CTransaction& tx, const kernel::MemPoolOptions& opts, std::string& out_reason, const ignore_rejects_type& ignore_rejects)
+bool IsStandardTx(const CTransaction& tx, const std::optional<unsigned>& max_datacarrier_bytes, bool permit_bare_multisig, const CFeeRate& dust_relay_fee, std::string& reason)
 {
-    const std::string reason_prefix;
-
     if (tx.version > TX_MAX_STANDARD_VERSION || tx.version < 1) {
-        MaybeReject("version");
+        reason = "version";
+        return false;
     }
 
     // Extremely large transactions with lots of inputs can cost the network
@@ -129,11 +104,8 @@ bool IsStandardTx(const CTransaction& tx, const kernel::MemPoolOptions& opts, st
     // to MAX_STANDARD_TX_WEIGHT mitigates CPU exhaustion attacks.
     unsigned int sz = GetTransactionWeight(tx);
     if (sz > MAX_STANDARD_TX_WEIGHT) {
-        MaybeReject("tx-size");
-    }
-
-    if (tx.nLockTime == 21 && opts.reject_parasites) {
-        MaybeReject("parasite-cat21");
+        reason = "tx-size";
+        return false;
     }
 
     for (const CTxIn& txin : tx.vin)
@@ -146,50 +118,39 @@ bool IsStandardTx(const CTransaction& tx, const kernel::MemPoolOptions& opts, st
         // some minor future-proofing. That's also enough to spend a
         // 20-of-20 CHECKMULTISIG scriptPubKey, though such a scriptPubKey
         // is not considered standard.
-        if (txin.scriptSig.size() > std::min(MAX_STANDARD_SCRIPTSIG_SIZE, g_script_size_policy_limit)) {
-            MaybeReject("scriptsig-size");
+        if (txin.scriptSig.size() > MAX_STANDARD_SCRIPTSIG_SIZE) {
+            reason = "scriptsig-size";
+            return false;
         }
         if (!txin.scriptSig.IsPushOnly()) {
-            MaybeReject("scriptsig-not-pushonly");
+            reason = "scriptsig-not-pushonly";
+            return false;
         }
     }
 
     unsigned int nDataOut = 0;
     TxoutType whichType;
     for (const CTxOut& txout : tx.vout) {
-        if (txout.scriptPubKey.size() > g_script_size_policy_limit) {
-            MaybeReject("scriptpubkey-size");
-        }
-
-        if (!::IsStandard(txout.scriptPubKey, opts.max_datacarrier_bytes, whichType)) {
-            if (whichType == TxoutType::WITNESS_UNKNOWN) {
-                MaybeReject("scriptpubkey-unknown-witnessversion");
-            } else {
-                MaybeReject("scriptpubkey");
-            }
+        if (!::IsStandard(txout.scriptPubKey, max_datacarrier_bytes, whichType)) {
+            reason = "scriptpubkey";
+            return false;
         }
 
-        if (whichType == TxoutType::NULL_DATA) {
-            if (txout.scriptPubKey.size() > 2 && txout.scriptPubKey[1] == OP_13 && opts.reject_tokens) {
-                MaybeReject("tokens-runes");
-            }
+        if (whichType == TxoutType::NULL_DATA)
             nDataOut++;
-            continue;
-        }
-        else if ((whichType == TxoutType::PUBKEY) && (!opts.permit_bare_pubkey)) {
-            MaybeReject("bare-pubkey");
-        }
-        else if ((whichType == TxoutType::MULTISIG) && (!opts.permit_bare_multisig)) {
-            MaybeReject("bare-multisig");
-        }
-        if (IsDust(txout, opts.dust_relay_feerate)) {
-            MaybeReject("dust");
+        else if ((whichType == TxoutType::MULTISIG) && (!permit_bare_multisig)) {
+            reason = "bare-multisig";
+            return false;
+        } else if (IsDust(txout, dust_relay_fee)) {
+            reason = "dust";
+            return false;
         }
     }
 
     // only one OP_RETURN txout is permitted
     if (nDataOut > 1) {
-        MaybeReject("multi-op-return");
+        reason = "multi-op-return";
+        return false;
     }
 
     return true;
@@ -213,7 +174,7 @@ bool IsStandardTx(const CTransaction& tx, const kernel::MemPoolOptions& opts, st
  *
  * Note that only the non-witness portion of the transaction is checked here.
  */
-bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs, const std::string& reason_prefix, std::string& out_reason, const ignore_rejects_type& ignore_rejects)
+bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)
 {
     if (tx.IsCoinBase()) {
         return true; // Coinbases don't use vin normally
@@ -222,47 +183,24 @@ bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs,
     for (unsigned int i = 0; i < tx.vin.size(); i++) {
         const CTxOut& prev = mapInputs.AccessCoin(tx.vin[i].prevout).out;
 
-        if (prev.scriptPubKey.size() > g_script_size_policy_limit) {
-            MaybeReject("script-size");
-        }
-
         std::vector<std::vector<unsigned char> > vSolutions;
         TxoutType whichType = Solver(prev.scriptPubKey, vSolutions);
-        if (whichType == TxoutType::NONSTANDARD) {
-            MaybeReject("script-unknown");
-        } else if (whichType == TxoutType::WITNESS_UNKNOWN) {
+        if (whichType == TxoutType::NONSTANDARD || whichType == TxoutType::WITNESS_UNKNOWN) {
             // WITNESS_UNKNOWN failures are typically also caught with a policy
             // flag in the script interpreter, but it can be helpful to catch
             // this type of NONSTANDARD transaction earlier in transaction
             // validation.
-            MaybeReject("witness-unknown");
+            return false;
         } else if (whichType == TxoutType::SCRIPTHASH) {
-            if (!tx.vin[i].scriptSig.IsPushOnly()) {
-                // The only way we got this far, is if the user ignored scriptsig-not-pushonly.
-                // However, this case is invalid, and will be caught later on.
-                // But for now, we don't want to run the [possibly expensive] script here.
-                continue;
-            }
             std::vector<std::vector<unsigned char> > stack;
             // convert the scriptSig into a stack, so we can inspect the redeemScript
             if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SigVersion::BASE))
-            {
-                // This case is also invalid or a bug
-                out_reason = reason_prefix + "scriptsig-failure";
                 return false;
-            }
             if (stack.empty())
-            {
-                // Also invalid
-                out_reason = reason_prefix + "scriptcheck-missing";
                 return false;
-            }
             CScript subscript(stack.back().begin(), stack.back().end());
-            if (subscript.size() > g_script_size_policy_limit) {
-                MaybeReject("scriptcheck-size");
-            }
             if (subscript.GetSigOpCount(true) > MAX_P2SH_SIGOPS) {
-                MaybeReject("scriptcheck-sigops");
+                return false;
             }
         }
     }
@@ -270,7 +208,7 @@ bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs,
     return true;
 }
 
-bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs, const std::string& reason_prefix, std::string& out_reason, const ignore_rejects_type& ignore_rejects)
+bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)
 {
     if (tx.IsCoinBase())
         return true; // Coinbases are skipped
@@ -289,7 +227,7 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs,
 
         // witness stuffing detected
         if (prevScript.IsPayToAnchor()) {
-            MaybeReject("anchor-not-empty");
+            return false;
         }
 
         bool p2sh = false;
@@ -299,15 +237,9 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs,
             // into a stack. We do not check IsPushOnly nor compare the hash as these will be done later anyway.
             // If the check fails at this stage, we know that this txid must be a bad one.
             if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SigVersion::BASE))
-            {
-                out_reason = reason_prefix + "scriptsig-failure";
                 return false;
-            }
             if (stack.empty())
-            {
-                out_reason = reason_prefix + "scriptcheck-missing";
                 return false;
-            }
             prevScript = CScript(stack.back().begin(), stack.back().end());
             p2sh = true;
         }
@@ -317,21 +249,18 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs,
 
         // Non-witness program must not be associated with any witness
         if (!prevScript.IsWitnessProgram(witnessversion, witnessprogram))
-        {
-            out_reason = reason_prefix + "nonwitness-input";
             return false;
-        }
 
         // Check P2WSH standard limits
         if (witnessversion == 0 && witnessprogram.size() == WITNESS_V0_SCRIPTHASH_SIZE) {
-            if (tx.vin[i].scriptWitness.stack.back().size() > std::min(MAX_STANDARD_P2WSH_SCRIPT_SIZE, g_script_size_policy_limit))
-                MaybeReject("script-size");
+            if (tx.vin[i].scriptWitness.stack.back().size() > MAX_STANDARD_P2WSH_SCRIPT_SIZE)
+                return false;
             size_t sizeWitnessStack = tx.vin[i].scriptWitness.stack.size() - 1;
             if (sizeWitnessStack > MAX_STANDARD_P2WSH_STACK_ITEMS)
-                MaybeReject("stackitem-count");
+                return false;
             for (unsigned int j = 0; j < sizeWitnessStack; j++) {
                 if (tx.vin[i].scriptWitness.stack[j].size() > MAX_STANDARD_P2WSH_STACK_ITEM_SIZE)
-                    MaybeReject("stackitem-size");
+                    return false;
             }
         }
 
@@ -343,31 +272,17 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs,
             Span stack{tx.vin[i].scriptWitness.stack};
             if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {
                 // Annexes are nonstandard as long as no semantics are defined for them.
-                MaybeReject("taproot-annex");
-                // If reject reason is ignored, continue as if the annex wasn't there.
-                SpanPopBack(stack);
+                return false;
             }
             if (stack.size() >= 2) {
                 // Script path spend (2 or more stack elements after removing optional annex)
                 const auto& control_block = SpanPopBack(stack);
-                const auto& tapscript = SpanPopBack(stack);
-                if (control_block.empty()) {
-                    // Empty control block is invalid
-                    out_reason = reason_prefix + "taproot-control-missing";
-                    return false;
-                }
-                if (tapscript.size() > g_script_size_policy_limit) {
-                    MaybeReject("script-size");
-                }
+                SpanPopBack(stack); // Ignore script
+                if (control_block.empty()) return false; // Empty control block is invalid
                 if ((control_block[0] & TAPROOT_LEAF_MASK) == TAPROOT_LEAF_TAPSCRIPT) {
                     // Leaf version 0xc0 (aka Tapscript, see BIP 342)
-                    if (!ignore_rejects.count(reason_prefix + "taproot-stackitem-size")) {
                     for (const auto& item : stack) {
-                            if (item.size() > MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE) {
-                                out_reason = reason_prefix + "taproot-stackitem-size";
-                                return false;
-                            }
-                        }
+                        if (item.size() > MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE) return false;
                     }
                 }
             } else if (stack.size() == 1) {
@@ -375,7 +290,6 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs,
                 // (no policy rules apply)
             } else {
                 // 0 stack elements; this is already invalid by consensus rules
-                out_reason = reason_prefix + "taproot-witness-missing";
                 return false;
             }
         }
@@ -397,95 +311,3 @@ int64_t GetVirtualTransactionInputSize(const CTxIn& txin, int64_t nSigOpCost, un
 {
     return GetVirtualTransactionSize(GetTransactionInputWeight(txin), nSigOpCost, bytes_per_sigop);
 }
-
-std::pair<CScript, unsigned int> GetScriptForTransactionInput(CScript prevScript, const CTxIn& txin)
-{
-    bool p2sh = false;
-    if (prevScript.IsPayToScriptHash()) {
-        std::vector <std::vector<unsigned char> > stack;
-        if (!EvalScript(stack, txin.scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SigVersion::BASE)) {
-            return std::make_pair(CScript(), 0);
-        }
-        if (stack.empty()) {
-            return std::make_pair(CScript(), 0);
-        }
-        prevScript = CScript(stack.back().begin(), stack.back().end());
-        p2sh = true;
-    }
-
-    int witnessversion = 0;
-    std::vector<unsigned char> witnessprogram;
-
-    if (!prevScript.IsWitnessProgram(witnessversion, witnessprogram)) {
-        // For P2SH, scriptSig is always push-only, so the actual script is only the last stack item
-        // For non-P2SH, prevScript is likely the real script, but not part of this transaction, and scriptSig could very well be executable, so return the latter instead
-        return std::make_pair(p2sh ? prevScript : txin.scriptSig, WITNESS_SCALE_FACTOR);
-    }
-
-    Span stack{txin.scriptWitness.stack};
-
-    if (witnessversion == 0 && witnessprogram.size() == WITNESS_V0_SCRIPTHASH_SIZE) {
-        if (stack.empty()) return std::make_pair(CScript(), 0);  // invalid
-        auto& script_data = stack.back();
-        prevScript = CScript(script_data.begin(), script_data.end());
-        return std::make_pair(prevScript, 1);
-    }
-
-    if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !p2sh) {
-        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {
-            SpanPopBack(stack);
-        }
-        if (stack.size() >= 2) {
-            SpanPopBack(stack);  // Ignore control block
-            prevScript = CScript(stack.back().begin(), stack.back().end());
-            return std::make_pair(prevScript, 1);
-        }
-    }
-
-    return std::make_pair(CScript(), 0);
-}
-
-std::pair<size_t, size_t> DatacarrierBytes(const CTransaction& tx, const CCoinsViewCache& view)
-{
-    std::pair<size_t, size_t> ret{0, 0};
-
-    for (const CTxIn& txin : tx.vin) {
-        const CTxOut &utxo = view.AccessCoin(txin.prevout).out;
-        auto[script, consensus_weight_per_byte] = GetScriptForTransactionInput(utxo.scriptPubKey, txin);
-        const auto dcb = script.DatacarrierBytes();
-        ret.first += dcb.first;
-        ret.second += dcb.second;
-    }
-    for (const CTxOut& txout : tx.vout) {
-        const auto dcb = txout.scriptPubKey.DatacarrierBytes();
-        ret.first += dcb.first;
-        ret.second += dcb.second;
-    }
-
-    return ret;
-}
-
-int32_t CalculateExtraTxWeight(const CTransaction& tx, const CCoinsViewCache& view, const unsigned int weight_per_data_byte)
-{
-    int32_t mod_weight{0};
-
-    // Add in any extra weight for data bytes
-    if (weight_per_data_byte > 1) {
-        for (const CTxIn& txin : tx.vin) {
-            const CTxOut &utxo = view.AccessCoin(txin.prevout).out;
-            auto[script, consensus_weight_per_byte] = GetScriptForTransactionInput(utxo.scriptPubKey, txin);
-            if (weight_per_data_byte > consensus_weight_per_byte) {
-                const auto dcb = script.DatacarrierBytes();
-                mod_weight += (dcb.first + dcb.second) * (weight_per_data_byte - consensus_weight_per_byte);
-            }
-        }
-        if (weight_per_data_byte > WITNESS_SCALE_FACTOR) {
-            for (const CTxOut& txout : tx.vout) {
-                const auto dcb = txout.scriptPubKey.DatacarrierBytes();
-                mod_weight += (dcb.first + dcb.second) * (weight_per_data_byte - WITNESS_SCALE_FACTOR);
-            }
-        }
-    }
-
-    return mod_weight;
-}
diff --git a/src/policy/policy.h b/src/policy/policy.h
index 83195a588d..a82488a28c 100644
--- a/src/policy/policy.h
+++ b/src/policy/policy.h
@@ -14,24 +14,13 @@
 
 #include <cstdint>
 #include <string>
-#include <unordered_set>
-#include <utility>
 
 class CCoinsViewCache;
 class CFeeRate;
 class CScript;
-namespace kernel {
-struct MemPoolOptions;
-};
-
-/** Default for -blockmaxsize, which controls the maximum size of block the mining code will create **/
-static const unsigned int DEFAULT_BLOCK_MAX_SIZE = 300000;
-/** Default for -blockprioritysize, maximum space for zero/low-fee transactions **/
-static const unsigned int DEFAULT_BLOCK_PRIORITY_SIZE = 100000;
-/** Minimum priority for transactions to be accepted into the priority area **/
-static const double MINIMUM_TX_PRIORITY = COIN * 144 / 250;
+
 /** Default for -blockmaxweight, which controls the range of block weights the mining code will create **/
-static constexpr unsigned int DEFAULT_BLOCK_MAX_WEIGHT{DEFAULT_BLOCK_MAX_SIZE * WITNESS_SCALE_FACTOR};
+static constexpr unsigned int DEFAULT_BLOCK_MAX_WEIGHT{MAX_BLOCK_WEIGHT - 4000};
 /** Default for -blockmintxfee, which sets the minimum feerate for a transaction in blocks created by mining code **/
 static constexpr unsigned int DEFAULT_BLOCK_MIN_TX_FEE{1000};
 /** The maximum weight for transactions we're willing to relay/mine */
@@ -44,22 +33,10 @@ static constexpr unsigned int MAX_P2SH_SIGOPS{15};
 static constexpr unsigned int MAX_STANDARD_TX_SIGOPS_COST{MAX_BLOCK_SIGOPS_COST/5};
 /** Default for -incrementalrelayfee, which sets the minimum feerate increase for mempool limiting or replacement **/
 static constexpr unsigned int DEFAULT_INCREMENTAL_RELAY_FEE{1000};
-/** Default for -maxscriptsize */
-static constexpr unsigned int DEFAULT_SCRIPT_SIZE_POLICY_LIMIT{1650};
 /** Default for -bytespersigop */
 static constexpr unsigned int DEFAULT_BYTES_PER_SIGOP{20};
-/** Default for -bytespersigopstrict */
-static constexpr unsigned int DEFAULT_BYTES_PER_SIGOP_STRICT{20};
-/** Default for -datacarriercost (multiplied by WITNESS_SCALE_FACTOR) */
-static constexpr unsigned int DEFAULT_WEIGHT_PER_DATA_BYTE{4};
-/** Default for -rejecttokens */
-static constexpr bool DEFAULT_REJECT_TOKENS{false};
-/** Default for -permitbarepubkey */
-static constexpr bool DEFAULT_PERMIT_BAREPUBKEY{false};
 /** Default for -permitbaremultisig */
-static constexpr bool DEFAULT_PERMIT_BAREMULTISIG{false};
-/** Default for -rejectparasites */
-static constexpr bool DEFAULT_REJECT_PARASITES{true};
+static constexpr bool DEFAULT_PERMIT_BAREMULTISIG{true};
 /** The maximum number of witness stack items in a standard P2WSH script */
 static constexpr unsigned int MAX_STANDARD_P2WSH_STACK_ITEMS{100};
 /** The maximum size in bytes of each witness stack item in a standard P2WSH script */
@@ -76,9 +53,6 @@ static constexpr unsigned int MAX_STANDARD_SCRIPTSIG_SIZE{1650};
  * only increase the dust limit after prior releases were already not creating
  * outputs below the new threshold */
 static constexpr unsigned int DUST_RELAY_TX_FEE{3000};
-static const std::string DEFAULT_DUST_DYNAMIC{"off"};
-static const int DEFAULT_DUST_RELAY_MULTIPLIER{3'000};
-static const std::string DEFAULT_SPKREUSE{"allow"};
 /** Default for -minrelaytxfee, minimum relay fee for transactions */
 static constexpr unsigned int DEFAULT_MIN_RELAY_TX_FEE{1000};
 /** Default for -limitancestorcount, max number of in-mempool ancestors */
@@ -92,12 +66,10 @@ static constexpr unsigned int DEFAULT_DESCENDANT_SIZE_LIMIT_KVB{101};
 /** Default for -datacarrier */
 static const bool DEFAULT_ACCEPT_DATACARRIER = true;
 /**
- * Default setting for -datacarriersize. 40 bytes of data, +1 for OP_RETURN,
- * +1 for the pushdata opcode.
+ * Default setting for -datacarriersize. 80 bytes of data, +1 for OP_RETURN,
+ * +2 for the pushdata opcodes.
  */
-static constexpr unsigned int MAX_OP_RETURN_RELAY{42};
-/** Default for -datacarrierfullcount */
-static constexpr bool DEFAULT_DATACARRIER_FULLCOUNT{true};
+static const unsigned int MAX_OP_RETURN_RELAY = 83;
 /**
  * An extra transaction can be added to a package, as long as it only has one
  * ancestor and is no larger than this. Not really any reason to make this
@@ -149,9 +121,6 @@ static constexpr unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS{STANDARD_SCRIP
 /** Used as the flags parameter to sequence and nLocktime checks in non-consensus code. */
 static constexpr unsigned int STANDARD_LOCKTIME_VERIFY_FLAGS{LOCKTIME_VERIFY_SEQUENCE};
 
-typedef std::unordered_set<std::string> ignore_rejects_type;
-static const ignore_rejects_type empty_ignore_rejects{};
-
 CAmount GetDustThreshold(const CTxOut& txout, const CFeeRate& dustRelayFee);
 
 bool IsDust(const CTxOut& txout, const CFeeRate& dustRelayFee);
@@ -168,19 +137,13 @@ static constexpr decltype(CTransaction::version) TX_MAX_STANDARD_VERSION{3};
 * Check for standard transaction types
 * @return True if all outputs (scriptPubKeys) use only standard transaction forms
 */
-bool IsStandardTx(const CTransaction& tx, const kernel::MemPoolOptions& opts, std::string& out_reason, const ignore_rejects_type& ignore_rejects=empty_ignore_rejects);
+bool IsStandardTx(const CTransaction& tx, const std::optional<unsigned>& max_datacarrier_bytes, bool permit_bare_multisig, const CFeeRate& dust_relay_fee, std::string& reason);
 /**
 * Check for standard transaction types
 * @param[in] mapInputs       Map of previous transactions that have outputs we're spending
 * @return True if all inputs (scriptSigs) use only standard transaction forms
 */
-bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs, const std::string& reason_prefix, std::string& out_reason, const ignore_rejects_type& ignore_rejects=empty_ignore_rejects);
-
-inline bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs) {
-    std::string reason;
-    return AreInputsStandard(tx, mapInputs, reason, reason);
-}
-
+bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs);
 /**
 * Check if the transaction is over standard P2WSH resources limit:
 * 3600bytes witnessScript size, 80bytes per witness stack element, 100 witness stack elements
@@ -188,7 +151,7 @@ inline bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& map
 *
 * Also enforce a maximum stack item size limit and no annexes for tapscript spends.
 */
-bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs, const std::string& reason_prefix, std::string& out_reason, const ignore_rejects_type& ignore_rejects=empty_ignore_rejects);
+bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs);
 
 /** Compute the virtual transaction size (weight reinterpreted as bytes). */
 int64_t GetVirtualTransactionSize(int64_t nWeight, int64_t nSigOpCost, unsigned int bytes_per_sigop);
@@ -205,10 +168,4 @@ static inline int64_t GetVirtualTransactionInputSize(const CTxIn& tx)
     return GetVirtualTransactionInputSize(tx, 0, 0);
 }
 
-std::pair<CScript, unsigned int> GetScriptForTransactionInput(CScript prevScript, const CTxIn&);
-
-std::pair<size_t, size_t> DatacarrierBytes(const CTransaction& tx, const CCoinsViewCache& view);
-
-int32_t CalculateExtraTxWeight(const CTransaction& tx, const CCoinsViewCache& view, const unsigned int weight_per_data_byte);
-
 #endif // BITCOIN_POLICY_POLICY_H
diff --git a/src/policy/rbf.cpp b/src/policy/rbf.cpp
index 86b4016e77..2ad79b6f99 100644
--- a/src/policy/rbf.cpp
+++ b/src/policy/rbf.cpp
@@ -7,7 +7,6 @@
 #include <consensus/amount.h>
 #include <kernel/mempool_entry.h>
 #include <policy/feerate.h>
-#include <policy/policy.h>
 #include <primitives/transaction.h>
 #include <sync.h>
 #include <tinyformat.h>
@@ -60,8 +59,7 @@ RBFTransactionState IsRBFOptInEmptyMempool(const CTransaction& tx)
 std::optional<std::string> GetEntriesForConflicts(const CTransaction& tx,
                                                   CTxMemPool& pool,
                                                   const CTxMemPool::setEntries& iters_conflicting,
-                                                  CTxMemPool::setEntries& all_conflicts,
-                                                  const ignore_rejects_type& ignore_rejects)
+                                                  CTxMemPool::setEntries& all_conflicts)
 {
     AssertLockHeld(pool.cs);
     const uint256 txid = tx.GetHash();
@@ -72,7 +70,7 @@ std::optional<std::string> GetEntriesForConflicts(const CTransaction& tx,
         // entries from the mempool. This potentially overestimates the number of actual
         // descendants (i.e. if multiple conflicts share a descendant, it will be counted multiple
         // times), but we just want to be conservative to avoid doing too much work.
-        if (nConflictingCount > MAX_REPLACEMENT_CANDIDATES && !ignore_rejects.count("too-many-replacements") && !ignore_rejects.count("too many potential replacements")) {
+        if (nConflictingCount > MAX_REPLACEMENT_CANDIDATES) {
             return strprintf("rejecting replacement %s; too many potential replacements (%d > %d)\n",
                              txid.ToString(),
                              nConflictingCount,
@@ -119,17 +117,12 @@ std::optional<std::string> HasNoNewUnconfirmed(const CTransaction& tx,
 }
 
 std::optional<std::string> EntriesAndTxidsDisjoint(const CTxMemPool::setEntries& ancestors,
-                                                   const std::map<Txid, bool>& direct_conflicts,
-                                                   const uint256& txid, bool* const out_violates_policy)
+                                                   const std::set<Txid>& direct_conflicts,
+                                                   const uint256& txid)
 {
     for (CTxMemPool::txiter ancestorIt : ancestors) {
         const Txid& hashAncestor = ancestorIt->GetTx().GetHash();
-        const auto& conflictit = direct_conflicts.find(hashAncestor);
-        if (conflictit != direct_conflicts.end()) {
-            if (!conflictit->second /* mere SPK conflict, NOT invalid */) {
-                if (out_violates_policy) *out_violates_policy = true;
-                continue;
-            }
+        if (direct_conflicts.count(hashAncestor)) {
             return strprintf("%s spends conflicting transaction %s",
                              txid.ToString(),
                              hashAncestor.ToString());
diff --git a/src/policy/rbf.h b/src/policy/rbf.h
index d248b4af60..252fbec8e3 100644
--- a/src/policy/rbf.h
+++ b/src/policy/rbf.h
@@ -6,7 +6,6 @@
 #define BITCOIN_POLICY_RBF_H
 
 #include <consensus/amount.h>
-#include <policy/policy.h>
 #include <primitives/transaction.h>
 #include <threadsafety.h>
 #include <txmempool.h>
@@ -69,8 +68,7 @@ RBFTransactionState IsRBFOptInEmptyMempool(const CTransaction& tx);
  */
 std::optional<std::string> GetEntriesForConflicts(const CTransaction& tx, CTxMemPool& pool,
                                                   const CTxMemPool::setEntries& iters_conflicting,
-                                                  CTxMemPool::setEntries& all_conflicts,
-                                                  const ignore_rejects_type& ignore_rejects=empty_ignore_rejects)
+                                                  CTxMemPool::setEntries& all_conflicts)
     EXCLUSIVE_LOCKS_REQUIRED(pool.cs);
 
 /** The replacement transaction may only include an unconfirmed input if that input was included in
@@ -88,12 +86,11 @@ std::optional<std::string> HasNoNewUnconfirmed(const CTransaction& tx, const CTx
  * @param[in]   direct_conflicts    Set of txids corresponding to the mempool conflicts
  *                                  (candidates to be replaced).
  * @param[in]   txid                Transaction ID, included in the error message if violation occurs.
- * @param[out]  out_violates_policy Assigned to true if there are any policy-only conflicts.
- * @returns error message if the sets intersect (consensus-only conflicts), std::nullopt if they are disjoint or only intersect on policy matters.
+ * @returns error message if the sets intersect, std::nullopt if they are disjoint.
  */
 std::optional<std::string> EntriesAndTxidsDisjoint(const CTxMemPool::setEntries& ancestors,
-                                                   const std::map<Txid, bool>& direct_conflicts,
-                                                   const uint256& txid, bool* out_violates_policy);
+                                                   const std::set<Txid>& direct_conflicts,
+                                                   const uint256& txid);
 
 /** Check that the feerate of the replacement transaction(s) is higher than the feerate of each
  * of the transactions in iters_conflicting.
diff --git a/src/policy/settings.cpp b/src/policy/settings.cpp
index a202a9495c..722b12acf5 100644
--- a/src/policy/settings.cpp
+++ b/src/policy/settings.cpp
@@ -8,5 +8,3 @@
 #include <policy/policy.h>
 
 unsigned int nBytesPerSigOp = DEFAULT_BYTES_PER_SIGOP;
-unsigned int nBytesPerSigOpStrict = DEFAULT_BYTES_PER_SIGOP_STRICT;
-unsigned int g_weight_per_data_byte = DEFAULT_WEIGHT_PER_DATA_BYTE;
diff --git a/src/policy/settings.h b/src/policy/settings.h
index 03cfc3775d..145454b0dd 100644
--- a/src/policy/settings.h
+++ b/src/policy/settings.h
@@ -6,9 +6,6 @@
 #ifndef BITCOIN_POLICY_SETTINGS_H
 #define BITCOIN_POLICY_SETTINGS_H
 
-extern unsigned int g_script_size_policy_limit;
 extern unsigned int nBytesPerSigOp;
-extern unsigned int nBytesPerSigOpStrict;
-extern unsigned int g_weight_per_data_byte;
 
 #endif // BITCOIN_POLICY_SETTINGS_H
diff --git a/src/policy/truc_policy.cpp b/src/policy/truc_policy.cpp
index feda0fd83e..69e8d5ed1d 100644
--- a/src/policy/truc_policy.cpp
+++ b/src/policy/truc_policy.cpp
@@ -56,8 +56,6 @@ struct ParentInfo {
 };
 
 std::optional<std::string> PackageTRUCChecks(const CTransactionRef& ptx, int64_t vsize,
-                                           const std::string& reason_prefix, std::string& out_reason,
-                                           const ignore_rejects_type& ignore_rejects,
                                            const Package& package,
                                            const CTxMemPool::setEntries& mempool_ancestors)
 {
@@ -70,14 +68,12 @@ std::optional<std::string> PackageTRUCChecks(const CTransactionRef& ptx, int64_t
     // Now we have all ancestors, so we can start checking TRUC rules.
     if (ptx->version == TRUC_VERSION) {
         // SingleTRUCChecks should have checked this already.
-        if (!Assume(vsize <= TRUC_MAX_VSIZE || ignore_rejects.count(reason_prefix + "vsize-toobig"))) {
-            out_reason = reason_prefix + "vsize-toobig";
+        if (!Assume(vsize <= TRUC_MAX_VSIZE)) {
             return strprintf("version=3 tx %s (wtxid=%s) is too big: %u > %u virtual bytes",
                              ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString(), vsize, TRUC_MAX_VSIZE);
         }
 
-        if (mempool_ancestors.size() + in_package_parents.size() + 1 > TRUC_ANCESTOR_LIMIT && !ignore_rejects.count(reason_prefix + "ancestors-toomany")) {
-            out_reason = reason_prefix + "ancestors-toomany";
+        if (mempool_ancestors.size() + in_package_parents.size() + 1 > TRUC_ANCESTOR_LIMIT) {
             return strprintf("tx %s (wtxid=%s) would have too many ancestors",
                              ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString());
         }
@@ -85,8 +81,7 @@ std::optional<std::string> PackageTRUCChecks(const CTransactionRef& ptx, int64_t
         const bool has_parent{mempool_ancestors.size() + in_package_parents.size() > 0};
         if (has_parent) {
             // A TRUC child cannot be too large.
-            if (vsize > TRUC_CHILD_MAX_VSIZE && !ignore_rejects.count(reason_prefix + "child-toobig")) {
-                out_reason = reason_prefix + "child-toobig";
+            if (vsize > TRUC_CHILD_MAX_VSIZE) {
                 return strprintf("version=3 child tx %s (wtxid=%s) is too big: %u > %u virtual bytes",
                                  ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString(),
                                  vsize, TRUC_CHILD_MAX_VSIZE);
@@ -111,8 +106,7 @@ std::optional<std::string> PackageTRUCChecks(const CTransactionRef& ptx, int64_t
             }();
 
             // If there is a parent, it must have the right version.
-            if (parent_info.m_version != TRUC_VERSION && !ignore_rejects.count(reason_prefix + "spends-nontruc")) {
-                out_reason = reason_prefix + "spends-nontruc";
+            if (parent_info.m_version != TRUC_VERSION) {
                 return strprintf("version=3 tx %s (wtxid=%s) cannot spend from non-version=3 tx %s (wtxid=%s)",
                                  ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString(),
                                  parent_info.m_txid.ToString(), parent_info.m_wtxid.ToString());
@@ -126,24 +120,21 @@ std::optional<std::string> PackageTRUCChecks(const CTransactionRef& ptx, int64_t
                     // Fail if we find another tx with the same parent. We don't check whether the
                     // sibling is to-be-replaced (done in SingleTRUCChecks) because these transactions
                     // are within the same package.
-                    if (input.prevout.hash == parent_info.m_txid && !ignore_rejects.count(reason_prefix + "sibling-known")) {
-                        out_reason = reason_prefix + "sibling-known";
+                    if (input.prevout.hash == parent_info.m_txid) {
                         return strprintf("tx %s (wtxid=%s) would exceed descendant count limit",
                                          parent_info.m_txid.ToString(),
                                          parent_info.m_wtxid.ToString());
                     }
 
                     // This tx can't have both a parent and an in-package child.
-                    if (input.prevout.hash == ptx->GetHash() && !ignore_rejects.count(reason_prefix + "parent-and-child-both")) {
-                        out_reason = reason_prefix + "parent-and-child-both";
+                    if (input.prevout.hash == ptx->GetHash()) {
                         return strprintf("tx %s (wtxid=%s) would have too many ancestors",
                                          package_tx->GetHash().ToString(), package_tx->GetWitnessHash().ToString());
                     }
                 }
             }
 
-            if (parent_info.m_has_mempool_descendant && !ignore_rejects.count(reason_prefix + "descendant-toomany")) {
-                out_reason = reason_prefix + "descendant-toomany";
+            if (parent_info.m_has_mempool_descendant) {
                 return strprintf("tx %s (wtxid=%s) would exceed descendant count limit",
                                 parent_info.m_txid.ToString(), parent_info.m_wtxid.ToString());
             }
@@ -151,16 +142,14 @@ std::optional<std::string> PackageTRUCChecks(const CTransactionRef& ptx, int64_t
     } else {
         // Non-TRUC transactions cannot have TRUC parents.
         for (auto it : mempool_ancestors) {
-            if (it->GetTx().version == TRUC_VERSION && !ignore_rejects.count(reason_prefix + "spent-by-nontruc")) {
-                out_reason = reason_prefix + "spent-by-nontruc";
+            if (it->GetTx().version == TRUC_VERSION) {
                 return strprintf("non-version=3 tx %s (wtxid=%s) cannot spend from version=3 tx %s (wtxid=%s)",
                                  ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString(),
                                  it->GetSharedTx()->GetHash().ToString(), it->GetSharedTx()->GetWitnessHash().ToString());
             }
         }
         for (const auto& index: in_package_parents) {
-            if (package.at(index)->version == TRUC_VERSION && !ignore_rejects.count(reason_prefix + "spent-by-nontruc")) {
-                out_reason = reason_prefix + "spent-by-nontruc";
+            if (package.at(index)->version == TRUC_VERSION) {
                 return strprintf("non-version=3 tx %s (wtxid=%s) cannot spend from version=3 tx %s (wtxid=%s)",
                                  ptx->GetHash().ToString(),
                                  ptx->GetWitnessHash().ToString(),
@@ -173,22 +162,18 @@ std::optional<std::string> PackageTRUCChecks(const CTransactionRef& ptx, int64_t
 }
 
 std::optional<std::pair<std::string, CTransactionRef>> SingleTRUCChecks(const CTransactionRef& ptx,
-                                          const std::string& reason_prefix, std::string& out_reason,
-                                          const ignore_rejects_type& ignore_rejects,
                                           const CTxMemPool::setEntries& mempool_ancestors,
                                           const std::set<Txid>& direct_conflicts,
                                           int64_t vsize)
 {
     // Check TRUC and non-TRUC inheritance.
     for (const auto& entry : mempool_ancestors) {
-        if (ptx->version != TRUC_VERSION && entry->GetTx().version == TRUC_VERSION && !ignore_rejects.count(reason_prefix + "spent-by-nontruc")) {
-            out_reason = reason_prefix + "spent-by-nontruc";
+        if (ptx->version != TRUC_VERSION && entry->GetTx().version == TRUC_VERSION) {
             return std::make_pair(strprintf("non-version=3 tx %s (wtxid=%s) cannot spend from version=3 tx %s (wtxid=%s)",
                              ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString(),
                              entry->GetSharedTx()->GetHash().ToString(), entry->GetSharedTx()->GetWitnessHash().ToString()),
                 nullptr);
-        } else if (ptx->version == TRUC_VERSION && entry->GetTx().version != TRUC_VERSION && !ignore_rejects.count(reason_prefix + "spends-nontruc")) {
-            out_reason = reason_prefix + "spends-nontruc";
+        } else if (ptx->version == TRUC_VERSION && entry->GetTx().version != TRUC_VERSION) {
             return std::make_pair(strprintf("version=3 tx %s (wtxid=%s) cannot spend from non-version=3 tx %s (wtxid=%s)",
                              ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString(),
                              entry->GetSharedTx()->GetHash().ToString(), entry->GetSharedTx()->GetWitnessHash().ToString()),
@@ -203,16 +188,14 @@ std::optional<std::pair<std::string, CTransactionRef>> SingleTRUCChecks(const CT
     // The rest of the rules only apply to transactions with version=3.
     if (ptx->version != TRUC_VERSION) return std::nullopt;
 
-    if (vsize > TRUC_MAX_VSIZE && !ignore_rejects.count(reason_prefix + "vsize-toobig")) {
-        out_reason = reason_prefix + "vsize-toobig";
+    if (vsize > TRUC_MAX_VSIZE) {
         return std::make_pair(strprintf("version=3 tx %s (wtxid=%s) is too big: %u > %u virtual bytes",
                          ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString(), vsize, TRUC_MAX_VSIZE),
             nullptr);
     }
 
     // Check that TRUC_ANCESTOR_LIMIT would not be violated.
-    if (mempool_ancestors.size() + 1 > TRUC_ANCESTOR_LIMIT && !ignore_rejects.count(reason_prefix + "ancestors-toomany")) {
-        out_reason = reason_prefix + "ancestors-toomany";
+    if (mempool_ancestors.size() + 1 > TRUC_ANCESTOR_LIMIT) {
         return std::make_pair(strprintf("tx %s (wtxid=%s) would have too many ancestors",
                          ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString()),
             nullptr);
@@ -221,8 +204,7 @@ std::optional<std::pair<std::string, CTransactionRef>> SingleTRUCChecks(const CT
     // Remaining checks only pertain to transactions with unconfirmed ancestors.
     if (mempool_ancestors.size() > 0) {
         // If this transaction spends TRUC parents, it cannot be too large.
-        if (vsize > TRUC_CHILD_MAX_VSIZE && !ignore_rejects.count(reason_prefix + "child-toobig")) {
-            out_reason = reason_prefix + "child-toobig";
+        if (vsize > TRUC_CHILD_MAX_VSIZE) {
             return std::make_pair(strprintf("version=3 child tx %s (wtxid=%s) is too big: %u > %u virtual bytes",
                              ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString(), vsize, TRUC_CHILD_MAX_VSIZE),
                 nullptr);
@@ -240,7 +222,7 @@ std::optional<std::pair<std::string, CTransactionRef>> SingleTRUCChecks(const CT
         const bool child_will_be_replaced = !children.empty() &&
             std::any_of(children.cbegin(), children.cend(),
                 [&direct_conflicts](const CTxMemPoolEntry& child){return direct_conflicts.count(child.GetTx().GetHash()) > 0;});
-        if (parent_entry->GetCountWithDescendants() + 1 > TRUC_DESCENDANT_LIMIT && (!child_will_be_replaced) && !ignore_rejects.count(reason_prefix + "descendants-toomany")) {
+        if (parent_entry->GetCountWithDescendants() + 1 > TRUC_DESCENDANT_LIMIT && !child_will_be_replaced) {
             // Allow sibling eviction for TRUC transaction: if another child already exists, even if
             // we don't conflict inputs with it, consider evicting it under RBF rules. We rely on TRUC rules
             // only permitting 1 descendant, as otherwise we would need to have logic for deciding
@@ -251,7 +233,6 @@ std::optional<std::pair<std::string, CTransactionRef>> SingleTRUCChecks(const CT
 
             // Return the sibling if its eviction can be considered. Provide the "descendant count
             // limit" string either way, as the caller may decide not to do sibling eviction.
-            out_reason = reason_prefix + "descendants-toomany";
             return std::make_pair(strprintf("tx %u (wtxid=%s) would exceed descendant count limit",
                                             parent_entry->GetSharedTx()->GetHash().ToString(),
                                             parent_entry->GetSharedTx()->GetWitnessHash().ToString()),
diff --git a/src/policy/truc_policy.h b/src/policy/truc_policy.h
index 172e156efd..dbc77696c6 100644
--- a/src/policy/truc_policy.h
+++ b/src/policy/truc_policy.h
@@ -62,8 +62,6 @@ static_assert(TRUC_MAX_VSIZE + TRUC_CHILD_MAX_VSIZE <= DEFAULT_DESCENDANT_SIZE_L
  *   applicable.
  */
 std::optional<std::pair<std::string, CTransactionRef>> SingleTRUCChecks(const CTransactionRef& ptx,
-                                          const std::string& reason_prefix, std::string& out_reason,
-                                          const ignore_rejects_type& ignore_rejects,
                                           const CTxMemPool::setEntries& mempool_ancestors,
                                           const std::set<Txid>& direct_conflicts,
                                           int64_t vsize);
@@ -90,8 +88,6 @@ std::optional<std::pair<std::string, CTransactionRef>> SingleTRUCChecks(const CT
  * @returns debug string if an error occurs, std::nullopt otherwise.
  * */
 std::optional<std::string> PackageTRUCChecks(const CTransactionRef& ptx, int64_t vsize,
-                                           const std::string& reason_prefix, std::string& out_reason,
-                                           const ignore_rejects_type& ignore_rejects,
                                            const Package& package,
                                            const CTxMemPool::setEntries& mempool_ancestors);
 
diff --git a/src/protocol.cpp b/src/protocol.cpp
index 8d98c96789..0439d398c7 100644
--- a/src/protocol.cpp
+++ b/src/protocol.cpp
@@ -99,7 +99,6 @@ static std::string serviceFlagToStr(size_t bit)
     case NODE_COMPACT_FILTERS: return "COMPACT_FILTERS";
     case NODE_NETWORK_LIMITED: return "NETWORK_LIMITED";
     case NODE_P2P_V2:          return "P2P_V2";
-    case NODE_REPLACE_BY_FEE:  return "REPLACE_BY_FEE?";
     // Not using default, so we get warned when a case is missing
     }
 
diff --git a/src/protocol.h b/src/protocol.h
index 0fe0810cfc..fd7cfddf3b 100644
--- a/src/protocol.h
+++ b/src/protocol.h
@@ -336,8 +336,6 @@ enum ServiceFlags : uint64_t {
     // collisions and other cases where nodes may be advertising a service they
     // do not actually support. Other service bits should be allocated via the
     // BIP process.
-
-    NODE_REPLACE_BY_FEE = (1 << 26),
 };
 
 /**
@@ -486,7 +484,9 @@ enum GetDataMsg : uint32_t {
     MSG_CMPCT_BLOCK = 4,                              //!< Defined in BIP152
     MSG_WITNESS_BLOCK = MSG_BLOCK | MSG_WITNESS_FLAG, //!< Defined in BIP144
     MSG_WITNESS_TX = MSG_TX | MSG_WITNESS_FLAG,       //!< Defined in BIP144
-    MSG_FILTERED_WITNESS_BLOCK = MSG_FILTERED_BLOCK | MSG_WITNESS_FLAG,  //!< Defined in BIP144
+    // MSG_FILTERED_WITNESS_BLOCK is defined in BIP144 as reserved for future
+    // use and remains unused.
+    // MSG_FILTERED_WITNESS_BLOCK = MSG_FILTERED_BLOCK | MSG_WITNESS_FLAG,
 };
 
 /** inv message data */
@@ -510,7 +510,6 @@ public:
     bool IsMsgFilteredBlk() const { return type == MSG_FILTERED_BLOCK; }
     bool IsMsgCmpctBlk() const { return type == MSG_CMPCT_BLOCK; }
     bool IsMsgWitnessBlk() const { return type == MSG_WITNESS_BLOCK; }
-    bool IsMsgFilteredWitnessBlk() const { return type == MSG_FILTERED_WITNESS_BLOCK; }
 
     // Combined-message helper methods
     bool IsGenTxMsg() const
@@ -519,7 +518,7 @@ public:
     }
     bool IsGenBlkMsg() const
     {
-        return type == MSG_BLOCK || type == MSG_FILTERED_BLOCK || type == MSG_CMPCT_BLOCK || type == MSG_WITNESS_BLOCK || type == MSG_FILTERED_WITNESS_BLOCK;
+        return type == MSG_BLOCK || type == MSG_FILTERED_BLOCK || type == MSG_CMPCT_BLOCK || type == MSG_WITNESS_BLOCK;
     }
 
     uint32_t type;
diff --git a/src/qt/addressbookpage.cpp b/src/qt/addressbookpage.cpp
index 5e7ebad677..f2f9371c65 100644
--- a/src/qt/addressbookpage.cpp
+++ b/src/qt/addressbookpage.cpp
@@ -97,7 +97,7 @@ AddressBookPage::AddressBookPage(const PlatformStyle *platformStyle, Mode _mode,
         ui->newAddress->setVisible(true);
         break;
     case ReceivingTab:
-        ui->labelExplanation->setText(tr("These are your Bitcoin addresses for receiving payments. Use the 'Request payment' button in the receive tab to create new addresses."));
+        ui->labelExplanation->setText(tr("These are your Bitcoin addresses for receiving payments. Use the 'Create new receiving address' button in the receive tab to create new addresses.\nSigning is only possible with addresses of the type 'legacy'."));
         ui->deleteAddress->setVisible(false);
         ui->newAddress->setVisible(false);
         break;
@@ -181,7 +181,7 @@ void AddressBookPage::onEditAction()
     dlg->setModel(model);
     QModelIndex origIndex = proxyModel->mapToSource(indexes.at(0));
     dlg->loadRow(origIndex.row());
-    GUIUtil::ShowModalDialogAsynchronously(dlg, Qt::WindowModal);
+    GUIUtil::ShowModalDialogAsynchronously(dlg);
 }
 
 void AddressBookPage::on_newAddress_clicked()
diff --git a/src/qt/addresstablemodel.cpp b/src/qt/addresstablemodel.cpp
index 8400e39147..efdc3966d1 100644
--- a/src/qt/addresstablemodel.cpp
+++ b/src/qt/addresstablemodel.cpp
@@ -310,7 +310,9 @@ Qt::ItemFlags AddressTableModel::flags(const QModelIndex &index) const
     Qt::ItemFlags retval = Qt::ItemIsSelectable | Qt::ItemIsEnabled;
     // Can edit address and label for sending addresses,
     // and only label for receiving addresses.
-    if ((rec->type == AddressTableEntry::Sending || rec->type == AddressTableEntry::Receiving) && index.column() == Label) {
+    if(rec->type == AddressTableEntry::Sending ||
+      (rec->type == AddressTableEntry::Receiving && index.column()==Label))
+    {
         retval |= Qt::ItemIsEditable;
     }
     return retval;
diff --git a/src/qt/bitcoin.cpp b/src/qt/bitcoin.cpp
index f835ef62b3..690c2b6f5a 100644
--- a/src/qt/bitcoin.cpp
+++ b/src/qt/bitcoin.cpp
@@ -7,7 +7,6 @@
 #include <qt/bitcoin.h>
 
 #include <chainparams.h>
-#include <clientversion.h>
 #include <common/args.h>
 #include <common/init.h>
 #include <common/system.h>
@@ -31,13 +30,11 @@
 #include <qt/splashscreen.h>
 #include <qt/utilitydialog.h>
 #include <qt/winshutdownmonitor.h>
-#include <stats/stats.h>
 #include <uint256.h>
 #include <util/exception.h>
 #include <util/string.h>
 #include <util/threadnames.h>
 #include <util/translation.h>
-#include <univalue.h>
 #include <validation.h>
 
 #ifdef ENABLE_WALLET
@@ -58,7 +55,6 @@
 #include <QLocale>
 #include <QMessageBox>
 #include <QSettings>
-#include <QString>
 #include <QThread>
 #include <QTimer>
 #include <QTranslator>
@@ -344,7 +340,7 @@ void BitcoinApplication::parameterSetup()
 
 void BitcoinApplication::InitPruneSetting(int64_t prune_MiB)
 {
-    optionsModel->SetPruneTargetMiB(prune_MiB);
+    optionsModel->SetPruneTargetGB(PruneMiBtoGB(prune_MiB));
 }
 
 void BitcoinApplication::requestInitialize()
@@ -414,7 +410,7 @@ void BitcoinApplication::initializeResult(bool success, interfaces::BlockAndHead
 
         // Log this only after AppInitMain finishes, as then logging setup is guaranteed complete
         qInfo() << "Platform customization:" << platformStyle->getName();
-        clientModel = new ClientModel(node(), optionsModel, *platformStyle);
+        clientModel = new ClientModel(node(), optionsModel);
         window->setClientModel(clientModel, &tip_info);
 
         // If '-min' option passed, start window minimized (iconified) or minimized to tray
@@ -497,7 +493,6 @@ bool BitcoinApplication::event(QEvent* e)
 static void SetupUIArgs(ArgsManager& argsman)
 {
     argsman.AddArg("-choosedatadir", strprintf("Choose data directory on startup (default: %u)", DEFAULT_CHOOSE_DATADIR), ArgsManager::ALLOW_ANY, OptionsCategory::GUI);
-    argsman.AddArg("-guisettingsdir=<path>", "Choose a custom data directory especially for the Qt Settings", ArgsManager::ALLOW_ANY, OptionsCategory::GUI);
     argsman.AddArg("-lang=<lang>", "Set language, for example \"de_DE\" (default: system locale)", ArgsManager::ALLOW_ANY, OptionsCategory::GUI);
     argsman.AddArg("-min", "Start minimized", ArgsManager::ALLOW_ANY, OptionsCategory::GUI);
     argsman.AddArg("-resetguisettings", "Reset all settings changed in the GUI", ArgsManager::ALLOW_ANY, OptionsCategory::GUI);
@@ -594,11 +589,6 @@ int GuiMain(int argc, char* argv[])
     QApplication::setOrganizationName(QAPP_ORG_NAME);
     QApplication::setOrganizationDomain(QAPP_ORG_DOMAIN);
     QApplication::setApplicationName(QAPP_APP_NAME_DEFAULT);
-    const std::string qt_settings_path = gArgs.GetArg("-guisettingsdir", "");
-    if (!qt_settings_path.empty()) {
-        QSettings::setDefaultFormat(QSettings::IniFormat);
-        QSettings::setPath(QSettings::IniFormat, QSettings::UserScope, QString::fromStdString(qt_settings_path));
-    }
 
     /// 4. Initialization of translations, so that intro dialog is in user's language
     // Now that QSettings are accessible, initialize translations
@@ -607,8 +597,8 @@ int GuiMain(int argc, char* argv[])
 
     // Show help message immediately after parsing command-line options (for "-lang") and setting locale,
     // but before showing splash screen.
-    if (HelpRequested(gArgs) || gArgs.GetBoolArg("-version", false)) {
-        HelpMessageDialog help(nullptr, gArgs.GetBoolArg("-version", false));
+    if (HelpRequested(gArgs) || gArgs.IsArgSet("-version")) {
+        HelpMessageDialog help(nullptr, gArgs.IsArgSet("-version"));
         help.showOrPrint();
         return EXIT_SUCCESS;
     }
@@ -618,9 +608,10 @@ int GuiMain(int argc, char* argv[])
 
     /// 5. Now that settings and translations are available, ask user for data directory
     // User language is set up: pick a data directory
-    std::unique_ptr<Intro> intro;
+    bool did_show_intro = false;
+    int64_t prune_MiB = 0;  // Intro dialog prune configuration
     // Gracefully exit if the user cancels
-    if (!Intro::showIfNeeded(intro)) return EXIT_SUCCESS;
+    if (!Intro::showIfNeeded(did_show_intro, prune_MiB)) return EXIT_SUCCESS;
 
     /// 6-7. Parse bitcoin.conf, determine network, switch to network specific
     /// options, and create datadir and settings.json.
@@ -653,12 +644,6 @@ int GuiMain(int argc, char* argv[])
     // Re-initialize translations after changing application name (language in network-specific settings can be different)
     initTranslations(qtTranslatorBase, qtTranslator, translatorBase, translator);
 
-    g_software_expiry = gArgs.GetIntArg("-softwareexpiry", DEFAULT_SOFTWARE_EXPIRY);
-    if (IsThisSoftwareExpired(GetTime())) {
-        QMessageBox::critical(nullptr, QObject::tr("Software expired"), QObject::tr("This software is expired, and may be out of consensus. You must choose to upgrade or override this expiration."));
-        return EXIT_FAILURE;
-    }
-
 #ifdef ENABLE_WALLET
     /// 8. URI IPC sending
     // - Do this early as we don't want to bother initializing if we are just calling IPC
@@ -692,9 +677,6 @@ int GuiMain(int argc, char* argv[])
     app.parameterSetup();
     GUIUtil::LogQtInfo();
 
-    // Enable mempool stats by default
-    gArgs.SoftSetBoolArg("-statsenable", true);
-
     if (gArgs.GetBoolArg("-splash", DEFAULT_SPLASHSCREEN) && !gArgs.GetBoolArg("-min", false))
         app.createSplashScreen(networkStyle.data());
 
@@ -705,10 +687,9 @@ int GuiMain(int argc, char* argv[])
         return EXIT_FAILURE;
     }
 
-    if (intro) {
+    if (did_show_intro) {
         // Store intro dialog settings other than datadir (network specific)
-        app.InitPruneSetting(intro->getPruneMiB());
-        gArgs.ForceSetArg("-assumevalid", intro->getAssumeValid().toStdString());
+        app.InitPruneSetting(prune_MiB);
     }
 
     try
@@ -718,13 +699,6 @@ int GuiMain(int argc, char* argv[])
         // This is acceptable because this function only contains steps that are quick to execute,
         // so the GUI thread won't be held up.
         if (app.baseInitialize()) {
-            if (intro) {
-                // Store intro dialog settings other than datadir (network specific)
-                common::SettingsValue intro_assumevalid = intro->getAssumeValid().toStdString();
-                app.node().context()->chain->overwriteRwSetting("assumevalid", intro_assumevalid);
-                // We can release the Intro widget now
-                intro.reset();
-            }
             app.requestInitialize();
 #if defined(Q_OS_WIN)
             WinShutdownMonitor::registerShutdownBlockReason(QObject::tr("%1 didn't yet exit safely…").arg(PACKAGE_NAME), (HWND)app.getMainWinId());
diff --git a/src/qt/bitcoin.h b/src/qt/bitcoin.h
index 189910fb7a..1423a8bbc6 100644
--- a/src/qt/bitcoin.h
+++ b/src/qt/bitcoin.h
@@ -7,7 +7,6 @@
 
 #include <config/bitcoin-config.h> // IWYU pragma: keep
 
-#include <interfaces/chain.h>
 #include <interfaces/node.h>
 #include <qt/initexecutor.h>
 
diff --git a/src/qt/bitcoin.qrc b/src/qt/bitcoin.qrc
index a43864b65f..fed373e551 100644
--- a/src/qt/bitcoin.qrc
+++ b/src/qt/bitcoin.qrc
@@ -1,6 +1,6 @@
 <!DOCTYPE RCC><RCC version="1.0">
     <qresource prefix="/icons">
-        <file alias="bitcoin">res/rendered_icons/bitcoin1024.png</file>
+        <file alias="bitcoin">res/icons/bitcoin.png</file>
         <file alias="address-book">res/icons/address-book.png</file>
         <file alias="send">res/icons/send.png</file>
         <file alias="connect_0">res/icons/connect0.png</file>
@@ -84,6 +84,6 @@
         <file alias="spinner-035">res/animation/spinner-035.png</file>
     </qresource>
     <qresource prefix="/fonts">
-        <file alias="monospace">res/fonts/RobotoTonalMono-Bold.ttf</file>
+        <file alias="monospace">res/fonts/RobotoMono-Bold.ttf</file>
     </qresource>
 </RCC>
diff --git a/src/qt/bitcoinaddressvalidator.cpp b/src/qt/bitcoinaddressvalidator.cpp
index ec6acb1998..a2adca6eac 100644
--- a/src/qt/bitcoinaddressvalidator.cpp
+++ b/src/qt/bitcoinaddressvalidator.cpp
@@ -6,8 +6,6 @@
 
 #include <key_io.h>
 
-#include <vector>
-
 /* Base58 characters are:
      "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
 
@@ -22,8 +20,10 @@ BitcoinAddressEntryValidator::BitcoinAddressEntryValidator(QObject *parent) :
 {
 }
 
-QValidator::State BitcoinAddressEntryValidator::validate(QString &input, std::vector<int>&error_locations) const
+QValidator::State BitcoinAddressEntryValidator::validate(QString &input, int &pos) const
 {
+    Q_UNUSED(pos);
+
     // Empty address is "intermediate" input
     if (input.isEmpty())
         return QValidator::Intermediate;
@@ -73,7 +73,6 @@ QValidator::State BitcoinAddressEntryValidator::validate(QString &input, std::ve
         }
         else
         {
-            error_locations.push_back(idx);
             state = QValidator::Invalid;
         }
     }
@@ -81,25 +80,16 @@ QValidator::State BitcoinAddressEntryValidator::validate(QString &input, std::ve
     return state;
 }
 
-QValidator::State BitcoinAddressEntryValidator::validate(QString &input, int &pos) const
-{
-    std::vector<int> error_locations;
-    const auto ret = validate(input, error_locations);
-    if (!error_locations.empty()) pos = error_locations.at(0);
-    return ret;
-}
-
 BitcoinAddressCheckValidator::BitcoinAddressCheckValidator(QObject *parent) :
-    BitcoinAddressEntryValidator(parent)
+    QValidator(parent)
 {
 }
 
-QValidator::State BitcoinAddressCheckValidator::validate(QString &input, std::vector<int>&error_locations) const
+QValidator::State BitcoinAddressCheckValidator::validate(QString &input, int &pos) const
 {
+    Q_UNUSED(pos);
     // Validate the passed Bitcoin address
-    std::string error_msg;
-    CTxDestination dest = DecodeDestination(input.toStdString(), error_msg, &error_locations);
-    if (IsValidDestination(dest)) {
+    if (IsValidDestinationString(input.toStdString())) {
         return QValidator::Acceptable;
     }
 
diff --git a/src/qt/bitcoinaddressvalidator.h b/src/qt/bitcoinaddressvalidator.h
index b0a4215d22..ae698c72a6 100644
--- a/src/qt/bitcoinaddressvalidator.h
+++ b/src/qt/bitcoinaddressvalidator.h
@@ -7,8 +7,6 @@
 
 #include <QValidator>
 
-#include <vector>
-
 /** Base58 entry widget validator, checks for valid characters and
  * removes some whitespace.
  */
@@ -19,21 +17,19 @@ class BitcoinAddressEntryValidator : public QValidator
 public:
     explicit BitcoinAddressEntryValidator(QObject *parent);
 
-    virtual State validate(QString &input, std::vector<int>&error_locations) const;
-    virtual State validate(QString &input, int &pos) const override;
+    State validate(QString &input, int &pos) const override;
 };
 
 /** Bitcoin address widget validator, checks for a valid bitcoin address.
  */
-class BitcoinAddressCheckValidator : public BitcoinAddressEntryValidator
+class BitcoinAddressCheckValidator : public QValidator
 {
     Q_OBJECT
 
 public:
     explicit BitcoinAddressCheckValidator(QObject *parent);
 
-    using BitcoinAddressEntryValidator::validate;
-    State validate(QString &input, std::vector<int>&error_locations) const override;
+    State validate(QString &input, int &pos) const override;
 };
 
 #endif // BITCOIN_QT_BITCOINADDRESSVALIDATOR_H
diff --git a/src/qt/bitcoinamountfield.cpp b/src/qt/bitcoinamountfield.cpp
index 09133ab7a2..a7e2d22488 100644
--- a/src/qt/bitcoinamountfield.cpp
+++ b/src/qt/bitcoinamountfield.cpp
@@ -94,11 +94,7 @@ public:
     {
         bool valid = false;
         CAmount val = value(&valid);
-        CAmount currentSingleStep = singleStep;
-        if (!currentSingleStep) {
-            currentSingleStep = BitcoinUnits::singlestep(currentUnit);
-        }
-        val = val + steps * currentSingleStep;
+        val = val + steps * singleStep;
         val = qBound(m_min_amount, val, m_max_amount);
         setValue(val);
     }
@@ -155,7 +151,7 @@ public:
 
 private:
     BitcoinUnit currentUnit{BitcoinUnit::BTC};
-    CAmount singleStep{CAmount(0)};
+    CAmount singleStep{CAmount(100000)}; // satoshis
     mutable QSize cachedMinimumSizeHint;
     bool m_allow_empty{true};
     CAmount m_min_amount{CAmount(0)};
diff --git a/src/qt/bitcoingui.cpp b/src/qt/bitcoingui.cpp
index 638cbde936..6d66c7473b 100644
--- a/src/qt/bitcoingui.cpp
+++ b/src/qt/bitcoingui.cpp
@@ -7,14 +7,11 @@
 #include <qt/bitcoingui.h>
 
 #include <qt/bitcoinunits.h>
-#include <qt/blockview.h>
 #include <qt/clientmodel.h>
 #include <qt/createwalletdialog.h>
 #include <qt/guiconstants.h>
 #include <qt/guiutil.h>
-#include <qt/mempoolstats.h>
 #include <qt/modaloverlay.h>
-#include <qt/netwatch.h>
 #include <qt/networkstyle.h>
 #include <qt/notificator.h>
 #include <qt/openuridialog.h>
@@ -34,10 +31,6 @@
 #ifdef Q_OS_MACOS
 #include <qt/macdockiconhandler.h>
 #endif
-#ifdef BITCOIN_QT_WIN_TASKBAR
-#include <QWinTaskbarButton>
-#include <QWinTaskbarProgress>
-#endif
 
 #include <chain.h>
 #include <chainparams.h>
@@ -130,7 +123,6 @@ BitcoinGUI::BitcoinGUI(interfaces::Node& node, const PlatformStyle *_platformSty
         /* When compiled without wallet or -disablewallet is provided,
          * the central widget is the rpc console.
          */
-        rpcConsole->addPairingTab();
         setCentralWidget(rpcConsole);
         Q_EMIT consoleShown(rpcConsole);
     }
@@ -231,9 +223,6 @@ BitcoinGUI::BitcoinGUI(interfaces::Node& node, const PlatformStyle *_platformSty
 #ifdef Q_OS_MACOS
     m_app_nap_inhibitor = new CAppNapInhibitor;
 #endif
-#ifdef BITCOIN_QT_WIN_TASKBAR
-    m_taskbar_button = new QWinTaskbarButton(this);
-#endif
 
     GUIUtil::handleCloseWindowShortcut(this);
 }
@@ -252,7 +241,6 @@ BitcoinGUI::~BitcoinGUI()
     MacDockIconHandler::cleanup();
 #endif
 
-    delete NetWatch;
     delete rpcConsole;
 }
 
@@ -289,13 +277,6 @@ void BitcoinGUI::createActions()
     historyAction->setShortcut(QKeySequence(QStringLiteral("Alt+4")));
     tabGroup->addAction(historyAction);
 
-    m_action_pairing = new QAction(platformStyle->SingleColorIcon(":/icons/connect_1"), tr("&Pairing"), this);
-    m_action_pairing->setStatusTip(tr("Pair other software or devices with your node"));
-    m_action_pairing->setToolTip(m_action_pairing->statusTip());
-    m_action_pairing->setCheckable(true);
-    m_action_pairing->setShortcut(QKeySequence(QStringLiteral("Alt+5")));
-    tabGroup->addAction(m_action_pairing);
-
 #ifdef ENABLE_WALLET
     // These showNormalIfMinimized are needed because Send Coins and Receive Coins
     // can be triggered from the tray menu, and need to show the GUI to be useful.
@@ -307,8 +288,6 @@ void BitcoinGUI::createActions()
     connect(receiveCoinsAction, &QAction::triggered, this, &BitcoinGUI::gotoReceiveCoinsPage);
     connect(historyAction, &QAction::triggered, [this]{ showNormalIfMinimized(); });
     connect(historyAction, &QAction::triggered, this, &BitcoinGUI::gotoHistoryPage);
-    connect(m_action_pairing, &QAction::triggered, this, [this]{ showNormalIfMinimized(); });
-    connect(m_action_pairing, &QAction::triggered, this, &BitcoinGUI::gotoPairingPage);
 #endif // ENABLE_WALLET
 
     quitAction = new QAction(tr("E&xit"), this);
@@ -343,20 +322,12 @@ void BitcoinGUI::createActions()
     m_load_psbt_clipboard_action = new QAction(tr("Load PSBT from &clipboard…"), this);
     m_load_psbt_clipboard_action->setStatusTip(tr("Load Partially Signed Bitcoin Transaction from clipboard"));
 
-    m_show_netwatch_action = new QAction(tr("&Watch network activity"), this);
-    m_show_netwatch_action->setStatusTip(tr("Open p2p network watching window"));
-
     openRPCConsoleAction = new QAction(tr("Node window"), this);
     openRPCConsoleAction->setStatusTip(tr("Open node debugging and diagnostic console"));
     // initially disable the debug window menu item
     openRPCConsoleAction->setEnabled(false);
     openRPCConsoleAction->setObjectName("openRPCConsoleAction");
 
-    showMempoolStatsAction = new QAction(tr("&Mempool Statistics"), this);
-    showMempoolStatsAction->setStatusTip(tr("Mempool Statistics"));
-    // initially disable the mempool stats menu item
-    showMempoolStatsAction->setEnabled(false);
-
     usedSendingAddressesAction = new QAction(tr("&Sending addresses"), this);
     usedSendingAddressesAction->setStatusTip(tr("Show the list of used sending addresses and labels"));
     usedReceivingAddressesAction = new QAction(tr("&Receiving addresses"), this);
@@ -405,10 +376,7 @@ void BitcoinGUI::createActions()
     connect(aboutQtAction, &QAction::triggered, qApp, QApplication::aboutQt);
     connect(optionsAction, &QAction::triggered, this, &BitcoinGUI::optionsClicked);
     connect(showHelpMessageAction, &QAction::triggered, this, &BitcoinGUI::showHelpMessageClicked);
-    connect(m_show_netwatch_action, &QAction::triggered, this, &BitcoinGUI::showNetWatch);
     connect(openRPCConsoleAction, &QAction::triggered, this, &BitcoinGUI::showDebugWindow);
-    connect(showMempoolStatsAction, &QAction::triggered, this, &BitcoinGUI::showMempoolStatsWindow);
-
     // prevents an open debug window from becoming stuck/unusable on client shutdown
     connect(quitAction, &QAction::triggered, rpcConsole, &QWidget::hide);
 
@@ -600,18 +568,6 @@ void BitcoinGUI::createMenuBar()
         window_menu->addAction(usedReceivingAddressesAction);
     }
 
-    window_menu->addSeparator();
-    window_menu->addAction(m_show_netwatch_action);
-    window_menu->addAction(showMempoolStatsAction);
-
-    auto show_blockview_action = new QAction(tr("Block &Visualizer"), this);
-    window_menu->addAction(show_blockview_action);
-    connect(show_blockview_action, &QAction::triggered, [this] {
-        auto blockview = new GuiBlockView(platformStyle, m_network_style);
-        blockview->setClientModel(clientModel);
-        GUIUtil::bringToFront(blockview);
-    });
-
     window_menu->addSeparator();
     for (RPCConsole::TabTypes tab_type : rpcConsole->tabs()) {
         QAction* tab_action = window_menu->addAction(rpcConsole->tabTitle(tab_type));
@@ -641,7 +597,6 @@ void BitcoinGUI::createToolBars()
         toolbar->addAction(sendCoinsAction);
         toolbar->addAction(receiveCoinsAction);
         toolbar->addAction(historyAction);
-        toolbar->addAction(m_action_pairing);
         overviewAction->setChecked(true);
 
 #ifdef ENABLE_WALLET
@@ -695,10 +650,6 @@ void BitcoinGUI::setClientModel(ClientModel *_clientModel, interfaces::BlockAndH
         // Show progress dialog
         connect(_clientModel, &ClientModel::showProgress, this, &BitcoinGUI::showProgress);
 
-        if (NetWatch) {
-            NetWatch->setClientModel(_clientModel);
-        }
-
         rpcConsole->setClientModel(_clientModel, tip_info->block_height, tip_info->block_time, tip_info->verification_progress);
 
         updateProxyIcon();
@@ -729,9 +680,6 @@ void BitcoinGUI::setClientModel(ClientModel *_clientModel, interfaces::BlockAndH
             trayIconMenu->clear();
         }
         // Propagate cleared model to child objects
-        if (NetWatch) {
-            NetWatch->setClientModel(nullptr);
-        }
         rpcConsole->setClientModel(nullptr);
 #ifdef ENABLE_WALLET
         if (walletFrame)
@@ -866,9 +814,10 @@ void BitcoinGUI::removeAllWallets()
 
 void BitcoinGUI::setWalletActionsEnabled(bool enabled)
 {
+    overviewAction->setEnabled(enabled);
     sendCoinsAction->setEnabled(enabled);
     receiveCoinsAction->setEnabled(enabled);
-    historyAction->setEnabled(enabled && !isPrivacyModeActivated());
+    historyAction->setEnabled(enabled);
     encryptWalletAction->setEnabled(enabled);
     backupWalletAction->setEnabled(enabled);
     changePassphraseAction->setEnabled(enabled);
@@ -923,7 +872,6 @@ void BitcoinGUI::createTrayIconMenu()
     QAction* options_action = trayIconMenu->addAction(optionsAction->text(), optionsAction, &QAction::trigger);
     options_action->setMenuRole(QAction::PreferencesRole);
     QAction* node_window_action = trayIconMenu->addAction(openRPCConsoleAction->text(), openRPCConsoleAction, &QAction::trigger);
-    QAction* mempoolstats_action = trayIconMenu->addAction(showMempoolStatsAction->text(), showMempoolStatsAction, &QAction::trigger);
     QAction* quit_action{nullptr};
 #ifndef Q_OS_MACOS
     // Note: On macOS, the Dock icon's menu already has Quit action.
@@ -952,7 +900,7 @@ void BitcoinGUI::createTrayIconMenu()
         // Using QSystemTrayIcon::Context is not reliable.
         // See https://bugreports.qt.io/browse/QTBUG-91697
         trayIconMenu.get(), &QMenu::aboutToShow,
-        [this, show_hide_action, send_action, receive_action, sign_action, verify_action, options_action, node_window_action, mempoolstats_action, quit_action] {
+        [this, show_hide_action, send_action, receive_action, sign_action, verify_action, options_action, node_window_action, quit_action] {
             if (m_node.shutdownRequested()) return; // nothing to do, node is shutting down.
 
             if (show_hide_action) show_hide_action->setText(
@@ -973,7 +921,6 @@ void BitcoinGUI::createTrayIconMenu()
                 }
                 options_action->setEnabled(optionsAction->isEnabled());
                 node_window_action->setEnabled(openRPCConsoleAction->isEnabled());
-                mempoolstats_action->setEnabled(showMempoolStatsAction->isEnabled());
                 if (quit_action) quit_action->setEnabled(true);
             }
         });
@@ -990,16 +937,7 @@ void BitcoinGUI::aboutClicked()
         return;
 
     auto dlg = new HelpMessageDialog(this, /*about=*/true);
-    GUIUtil::ShowModalDialogAsynchronously(dlg, Qt::NonModal);
-}
-
-void BitcoinGUI::showNetWatch()
-{
-    if (!NetWatch) {
-        NetWatch = new GuiNetWatch(platformStyle, m_network_style);
-        NetWatch->setClientModel(clientModel);
-    }
-    GUIUtil::bringToFront(NetWatch);
+    GUIUtil::ShowModalDialogAsynchronously(dlg);
 }
 
 void BitcoinGUI::showDebugWindow()
@@ -1019,19 +957,6 @@ void BitcoinGUI::showHelpMessageClicked()
     GUIUtil::bringToFront(helpMessageDialog);
 }
 
-void BitcoinGUI::showMempoolStatsWindow()
-{
-    // only build the mempool stats window if its requested
-    if (!mempoolStats)
-        mempoolStats = new MempoolStats(this);
-    if (clientModel)
-        mempoolStats->setClientModel(clientModel);
-    mempoolStats->showNormal();
-    mempoolStats->show();
-    mempoolStats->raise();
-    mempoolStats->activateWindow();
-}
-
 #ifdef ENABLE_WALLET
 void BitcoinGUI::openClicked()
 {
@@ -1048,12 +973,6 @@ void BitcoinGUI::gotoOverviewPage()
     if (walletFrame) walletFrame->gotoOverviewPage();
 }
 
-void BitcoinGUI::gotoPairingPage()
-{
-    m_action_pairing->setChecked(true);
-    if (walletFrame) walletFrame->gotoPairingPage();
-}
-
 void BitcoinGUI::gotoHistoryPage()
 {
     historyAction->setChecked(true);
@@ -1172,7 +1091,7 @@ void BitcoinGUI::openOptionsDialogWithTab(OptionsDialog::Tab tab)
     dlg->setCurrentTab(tab);
     dlg->setClientModel(clientModel);
     dlg->setModel(clientModel->getOptionsModel());
-    GUIUtil::ShowModalDialogAsynchronously(dlg, Qt::NonModal);
+    GUIUtil::ShowModalDialogAsynchronously(dlg);
 }
 
 void BitcoinGUI::setNumBlocks(int count, const QDateTime& blockDate, double nVerificationProgress, SyncType synctype, SynchronizationState sync_state)
@@ -1235,11 +1154,6 @@ void BitcoinGUI::setNumBlocks(int count, const QDateTime& blockDate, double nVer
 
     tooltip = tr("Processed %n block(s) of transaction history.", "", count);
 
-#ifdef BITCOIN_QT_WIN_TASKBAR
-    m_taskbar_button->setWindow(windowHandle());
-    QWinTaskbarProgress* taskbar_progress = m_taskbar_button->progress();
-#endif
-
     // Set icon state: spinning if catching up, tick otherwise
     if (secs < MAX_BLOCK_TIME_GAP) {
         tooltip = tr("Up to date") + QString(".<br>") + tooltip;
@@ -1255,9 +1169,6 @@ void BitcoinGUI::setNumBlocks(int count, const QDateTime& blockDate, double nVer
 
         progressBarLabel->setVisible(false);
         progressBar->setVisible(false);
-#ifdef BITCOIN_QT_WIN_TASKBAR
-        taskbar_progress->setVisible(false);
-#endif
     }
     else
     {
@@ -1268,10 +1179,6 @@ void BitcoinGUI::setNumBlocks(int count, const QDateTime& blockDate, double nVer
         progressBar->setMaximum(1000000000);
         progressBar->setValue(nVerificationProgress * 1000000000.0 + 0.5);
         progressBar->setVisible(true);
-#ifdef BITCOIN_QT_WIN_TASKBAR
-        taskbar_progress->setValue(qRound(nVerificationProgress * 100.0));
-        taskbar_progress->setVisible(true);
-#endif
 
         tooltip = tr("Catching up…") + QString("<br>") + tooltip;
         if(count != prevBlocks)
@@ -1308,6 +1215,11 @@ void BitcoinGUI::setNumBlocks(int count, const QDateTime& blockDate, double nVer
 void BitcoinGUI::createWallet()
 {
 #ifdef ENABLE_WALLET
+#ifndef USE_SQLITE
+    // Compiled without sqlite support (required for descriptor wallets)
+    message(tr("Error creating wallet"), tr("Cannot create new wallet, the software was compiled without sqlite support (required for descriptor wallets)"), CClientUIInterface::MSG_ERROR);
+    return;
+#endif // USE_SQLITE
     auto activity = new CreateWalletActivity(getWalletController(), this);
     connect(activity, &CreateWalletActivity::created, this, &BitcoinGUI::setCurrentWallet);
     connect(activity, &CreateWalletActivity::created, rpcConsole, &RPCConsole::setCurrentWallet);
@@ -1414,9 +1326,6 @@ void BitcoinGUI::closeEvent(QCloseEvent *event)
     {
         if(!clientModel->getOptionsModel()->getMinimizeOnClose())
         {
-            if (NetWatch) {
-                NetWatch->close();
-            }
             // close rpcConsole in case it was open to make some space for the shutdown window
             rpcConsole->close();
 
@@ -1437,7 +1346,6 @@ void BitcoinGUI::showEvent(QShowEvent *event)
 {
     // enable the debug window when the main window shows up
     openRPCConsoleAction->setEnabled(true);
-    showMempoolStatsAction->setEnabled(true);
     aboutAction->setEnabled(true);
     optionsAction->setEnabled(true);
 }
@@ -1617,9 +1525,6 @@ void BitcoinGUI::detectShutdown()
 {
     if (m_node.shutdownRequested())
     {
-        if (NetWatch) {
-            NetWatch->hide();
-        }
         if(rpcConsole)
             rpcConsole->hide();
         Q_EMIT quitRequested();
diff --git a/src/qt/bitcoingui.h b/src/qt/bitcoingui.h
index 6a1550029a..73adbda5a5 100644
--- a/src/qt/bitcoingui.h
+++ b/src/qt/bitcoingui.h
@@ -27,7 +27,6 @@
 
 #include <memory>
 
-class GuiNetWatch;
 class NetworkStyle;
 class Notificator;
 class OptionsModel;
@@ -40,7 +39,6 @@ class WalletFrame;
 class WalletModel;
 class HelpMessageDialog;
 class ModalOverlay;
-class MempoolStats;
 enum class SynchronizationState;
 
 namespace interfaces {
@@ -55,7 +53,6 @@ class QComboBox;
 class QDateTime;
 class QProgressBar;
 class QProgressDialog;
-class QWinTaskbarButton;
 QT_END_NAMESPACE
 
 namespace GUIUtil {
@@ -136,7 +133,6 @@ private:
     QMenuBar* appMenuBar = nullptr;
     QToolBar* appToolBar = nullptr;
     QAction* overviewAction = nullptr;
-    QAction* m_action_pairing = nullptr;
     QAction* historyAction = nullptr;
     QAction* quitAction = nullptr;
     QAction* sendCoinsAction = nullptr;
@@ -153,11 +149,9 @@ private:
     QAction* backupWalletAction = nullptr;
     QAction* changePassphraseAction = nullptr;
     QAction* aboutQtAction = nullptr;
-    QAction* m_show_netwatch_action = nullptr;
     QAction* openRPCConsoleAction = nullptr;
     QAction* openAction = nullptr;
     QAction* showHelpMessageAction = nullptr;
-    QAction* showMempoolStatsAction = nullptr;
     QAction* m_create_wallet_action{nullptr};
     QAction* m_open_wallet_action{nullptr};
     QMenu* m_open_wallet_menu{nullptr};
@@ -176,14 +170,9 @@ private:
     QSystemTrayIcon* trayIcon = nullptr;
     const std::unique_ptr<QMenu> trayIconMenu;
     Notificator* notificator = nullptr;
-    GuiNetWatch* NetWatch = nullptr;
     RPCConsole* rpcConsole = nullptr;
     HelpMessageDialog* helpMessageDialog = nullptr;
-#ifdef BITCOIN_QT_WIN_TASKBAR
-    QWinTaskbarButton* m_taskbar_button = nullptr;
-#endif
     ModalOverlay* modalOverlay = nullptr;
-    MempoolStats* mempoolStats = nullptr;
 
     QMenu* m_network_context_menu = new QMenu(this);
 
@@ -288,8 +277,6 @@ public Q_SLOTS:
 #ifdef ENABLE_WALLET
     /** Switch to overview (home) page */
     void gotoOverviewPage();
-    /** Switch to pairing page */
-    void gotoPairingPage();
     /** Switch to history (transactions) page */
     void gotoHistoryPage();
     /** Switch to receive coins page */
@@ -313,15 +300,12 @@ public Q_SLOTS:
     void optionsClicked();
     /** Show about dialog */
     void aboutClicked();
-    void showNetWatch();
     /** Show debug window */
     void showDebugWindow();
     /** Show debug window and set focus to the console */
     void showDebugWindowActivateConsole();
     /** Show help message dialog */
     void showHelpMessageClicked();
-    /** Show mempool stats window */
-    void showMempoolStatsWindow();
 
     /** Show window if hidden, unminimize when minimized, rise when obscured or show if hidden and fToggleHidden is true */
     void showNormalIfMinimized() { showNormalIfMinimized(false); }
diff --git a/src/qt/bitcoinunits.cpp b/src/qt/bitcoinunits.cpp
index 2e3324cd64..fe3eb3240b 100644
--- a/src/qt/bitcoinunits.cpp
+++ b/src/qt/bitcoinunits.cpp
@@ -3,7 +3,6 @@
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
 #include <qt/bitcoinunits.h>
-#include <qt/tonalutils.h>
 
 #include <consensus/amount.h>
 
@@ -12,7 +11,6 @@
 #include <cassert>
 
 static constexpr auto MAX_DIGITS_BTC = 16;
-static constexpr auto MAX_DIGITS_TBC = 13;
 
 BitcoinUnits::BitcoinUnits(QObject *parent):
         QAbstractListModel(parent),
@@ -27,12 +25,6 @@ QList<BitcoinUnit> BitcoinUnits::availableUnits()
     unitlist.append(Unit::mBTC);
     unitlist.append(Unit::uBTC);
     unitlist.append(Unit::SAT);
-    if (TonalUtils::Supported())
-    {
-        unitlist.append(Unit::bTBC);
-        unitlist.append(Unit::sTBC);
-        unitlist.append(Unit::TBC);
-    }
     return unitlist;
 }
 
@@ -43,9 +35,6 @@ QString BitcoinUnits::longName(Unit unit)
     case Unit::mBTC: return QString("mBTC");
     case Unit::uBTC: return QString::fromUtf8("µBTC (bits)");
     case Unit::SAT: return QString("Satoshi (sat)");
-    case Unit::bTBC: return QString::fromUtf8("ᵇTBC");
-    case Unit::sTBC: return QString::fromUtf8("ˢTBC");
-    case Unit::TBC: return QString("TBC");
     } // no default case, so the compiler can warn about missing cases
     assert(false);
 }
@@ -57,9 +46,6 @@ QString BitcoinUnits::shortName(Unit unit)
     case Unit::mBTC: return longName(unit);
     case Unit::uBTC: return QString("bits");
     case Unit::SAT: return QString("sat");
-    case Unit::bTBC: return QString::fromUtf8("ᵇTBC");
-    case Unit::sTBC: return QString::fromUtf8("ˢTBC");
-    case Unit::TBC: return QString("TBC");
     } // no default case, so the compiler can warn about missing cases
     assert(false);
 }
@@ -67,13 +53,10 @@ QString BitcoinUnits::shortName(Unit unit)
 QString BitcoinUnits::description(Unit unit)
 {
     switch (unit) {
-    case Unit::BTC: return QString("Bitcoins (decimal)");
+    case Unit::BTC: return QString("Bitcoins");
     case Unit::mBTC: return QString("Milli-Bitcoins (1 / 1" THIN_SP_UTF8 "000)");
     case Unit::uBTC: return QString("Micro-Bitcoins (bits) (1 / 1" THIN_SP_UTF8 "000" THIN_SP_UTF8 "000)");
     case Unit::SAT: return QString("Satoshi (sat) (1 / 100" THIN_SP_UTF8 "000" THIN_SP_UTF8 "000)");
-    case Unit::bTBC: return QString("Bong-Bitcoins (1,0000 tonal)");
-    case Unit::sTBC: return QString("San-Bitcoins (100 tonal)");
-    case Unit::TBC: return QString("Bitcoins (tonal)");
     } // no default case, so the compiler can warn about missing cases
     assert(false);
 }
@@ -85,9 +68,6 @@ qint64 BitcoinUnits::factor(Unit unit)
     case Unit::mBTC: return 100'000;
     case Unit::uBTC: return 100;
     case Unit::SAT: return 1;
-    case Unit::bTBC: return 0x100000000LL;
-    case Unit::sTBC: return 0x1000000;
-    case Unit::TBC:  return 0x10000;
     } // no default case, so the compiler can warn about missing cases
     assert(false);
 }
@@ -99,57 +79,10 @@ int BitcoinUnits::decimals(Unit unit)
     case Unit::mBTC: return 5;
     case Unit::uBTC: return 2;
     case Unit::SAT: return 0;
-    case Unit::bTBC: return 8;
-    case Unit::sTBC: return 6;
-    case Unit::TBC: return 4;
     } // no default case, so the compiler can warn about missing cases
     assert(false);
 }
 
-int BitcoinUnits::radix(Unit unit)
-{
-    switch (unit) {
-    case Unit::bTBC:
-    case Unit::sTBC:
-    case Unit::TBC:
-        return 0x10;
-    default:
-        return 10;
-    }
-}
-
-BitcoinUnit BitcoinUnits::numsys(Unit unit)
-{
-    switch (unit) {
-    case Unit::bTBC:
-    case Unit::sTBC:
-    case Unit::TBC:
-        return Unit::TBC;
-    default:
-        return Unit::BTC;
-    }
-}
-
-qint64 BitcoinUnits::max_digits(Unit unit)
-{
-    switch (numsys(unit)) {
-    case Unit::TBC:
-        return MAX_DIGITS_TBC;
-    default:
-        return MAX_DIGITS_BTC;
-    }
-}
-
-qint64 BitcoinUnits::singlestep(Unit unit)
-{
-    switch (numsys(unit)) {
-    case Unit::TBC:
-        return 0x10000;
-    default:
-        return 100000;
-    }
-}
-
 QString BitcoinUnits::format(Unit unit, const CAmount& nIn, bool fPlus, SeparatorStyle separators, bool justify)
 {
     // Note: not using straight sprintf here because we do NOT want
@@ -159,22 +92,11 @@ QString BitcoinUnits::format(Unit unit, const CAmount& nIn, bool fPlus, Separato
     int num_decimals = decimals(unit);
     qint64 n_abs = (n > 0 ? n : -n);
     qint64 quotient = n_abs / coin;
-    int uradix = radix(unit);
-    QString quotient_str = QString::number(quotient, uradix);
+    QString quotient_str = QString::number(quotient);
     if (justify) {
-        quotient_str = quotient_str.rightJustified(max_digits(unit) - num_decimals, ' ');
+        quotient_str = quotient_str.rightJustified(MAX_DIGITS_BTC - num_decimals, ' ');
     }
 
-    QString remainder_str;
-    if (num_decimals > 0) {
-        const qint64 remainder = n_abs % coin;
-        remainder_str = QString::number(remainder, uradix).rightJustified(num_decimals, '0');
-    }
-
-    switch (numsys(unit)) {
-    case Unit::BTC:
-    {
-
     // Use SI-style thin space separators as these are locale independent and can't be
     // confused with the decimal marker.
     QChar thin_sp(THIN_SP_CP);
@@ -183,28 +105,18 @@ QString BitcoinUnits::format(Unit unit, const CAmount& nIn, bool fPlus, Separato
         for (int i = 3; i < q_size; i += 3)
             quotient_str.insert(q_size - i, thin_sp);
 
-    break;
-    }
-    case Unit::TBC:
-    {
-        // Right-trim excess zeros after the decimal point
-        static const QRegExp tail_zeros("0+$");
-        remainder_str.remove(tail_zeros);
-        TonalUtils::ConvertFromHex(quotient_str);
-        TonalUtils::ConvertFromHex(remainder_str);
-        break;
-    }
-    default: assert(false);
-    }
-
     if (n < 0)
         quotient_str.insert(0, '-');
     else if (fPlus && n > 0)
         quotient_str.insert(0, '+');
 
-    if (!remainder_str.isEmpty())
-        quotient_str += QString(".") + remainder_str;
-    return quotient_str;
+    if (num_decimals > 0) {
+        qint64 remainder = n_abs % coin;
+        QString remainder_str = QString::number(remainder).rightJustified(num_decimals, '0');
+        return quotient_str + QString(".") + remainder_str;
+    } else {
+        return quotient_str;
+    }
 }
 
 
@@ -254,7 +166,7 @@ bool BitcoinUnits::parse(Unit unit, const QString& value, CAmount* val_out)
     {
         return false; // More than one dot
     }
-    const QString& whole = parts[0];
+    QString whole = parts[0];
     QString decimals;
 
     if(parts.size() > 1)
@@ -268,18 +180,11 @@ bool BitcoinUnits::parse(Unit unit, const QString& value, CAmount* val_out)
     bool ok = false;
     QString str = whole + decimals.leftJustified(num_decimals, '0');
 
-    Unit unumsys = numsys(unit);
-    if (unumsys == Unit::TBC) {
-        if (str.size() > 15)
-            return false; // Longer numbers may exceed 63 bits
-        TonalUtils::ConvertToHex(str);
-    } else
     if(str.size() > 18)
     {
         return false; // Longer numbers will exceed 63 bits
     }
-
-    CAmount retvalue(str.toLongLong(&ok, radix(unit)));
+    CAmount retvalue(str.toLongLong(&ok));
     if(val_out)
     {
         *val_out = retvalue;
@@ -323,21 +228,18 @@ CAmount BitcoinUnits::maxMoney()
     return MAX_MONEY;
 }
 
-std::variant<qint8, QString> BitcoinUnits::ToSetting(BitcoinUnit unit)
+namespace {
+qint8 ToQint8(BitcoinUnit unit)
 {
     switch (unit) {
-    case BitcoinUnit::BTC:  return qint8{0};
-    case BitcoinUnit::mBTC: return qint8{1};
-    case BitcoinUnit::uBTC: return qint8{2};
-    case BitcoinUnit::SAT:  return qint8{3};
-    case BitcoinUnit::bTBC: return QString("bTBC");
-    case BitcoinUnit::sTBC: return QString("sTBC");
-    case BitcoinUnit::TBC:  return QString("TBC");
+    case BitcoinUnit::BTC: return 0;
+    case BitcoinUnit::mBTC: return 1;
+    case BitcoinUnit::uBTC: return 2;
+    case BitcoinUnit::SAT: return 3;
     } // no default case, so the compiler can warn about missing cases
     assert(false);
 }
 
-namespace {
 BitcoinUnit FromQint8(qint8 num)
 {
     switch (num) {
@@ -346,32 +248,13 @@ BitcoinUnit FromQint8(qint8 num)
     case 2: return BitcoinUnit::uBTC;
     case 3: return BitcoinUnit::SAT;
     }
-    return BitcoinUnit::BTC;
+    assert(false);
 }
 } // namespace
 
-BitcoinUnit BitcoinUnits::FromSetting(const QString& s, BitcoinUnit def)
-{
-    if (s == "0") return BitcoinUnit::BTC;
-    if (s == "1") return BitcoinUnit::mBTC;
-    if (s == "2") return BitcoinUnit::uBTC;
-    if (s == "3") return BitcoinUnit::SAT;
-    if (s == "4") return BitcoinUnit::sTBC;
-    if (s == "5") return BitcoinUnit::TBC;
-    if (s == "bTBC") return BitcoinUnit::bTBC;
-    if (s == "sTBC") return BitcoinUnit::sTBC;
-    if (s == "TBC")  return BitcoinUnit::TBC;
-    return def;
-}
-
 QDataStream& operator<<(QDataStream& out, const BitcoinUnit& unit)
 {
-    auto setting_val = BitcoinUnits::ToSetting(unit);
-    if (const QString* setting_str = std::get_if<QString>(&setting_val)) {
-        return out << qint8{0} << *setting_str;
-    } else {
-        return out << std::get<qint8>(setting_val);
-    }
+    return out << ToQint8(unit);
 }
 
 QDataStream& operator>>(QDataStream& in, BitcoinUnit& unit)
@@ -379,10 +262,5 @@ QDataStream& operator>>(QDataStream& in, BitcoinUnit& unit)
     qint8 input;
     in >> input;
     unit = FromQint8(input);
-    if (!in.atEnd()) {
-        QString setting_str;
-        in >> setting_str;
-        unit = BitcoinUnits::FromSetting(setting_str, unit);
-    }
     return in;
 }
diff --git a/src/qt/bitcoinunits.h b/src/qt/bitcoinunits.h
index 4e9e77cee0..b3b5a8fc18 100644
--- a/src/qt/bitcoinunits.h
+++ b/src/qt/bitcoinunits.h
@@ -43,10 +43,7 @@ public:
         BTC,
         mBTC,
         uBTC,
-        SAT,
-        bTBC,
-        sTBC,
-        TBC,
+        SAT
     };
     Q_ENUM(Unit)
 
@@ -63,10 +60,6 @@ public:
 
     //! Get list of units, for drop-down box
     static QList<Unit> availableUnits();
-    //! String for setting(s)
-    static std::variant<qint8, QString> ToSetting(Unit unit);
-    //! Convert setting(s) string to unit
-    static Unit FromSetting(const QString&, Unit def);
     //! Long name
     static QString longName(Unit unit);
     //! Short name
@@ -75,16 +68,8 @@ public:
     static QString description(Unit unit);
     //! Number of Satoshis (1e-8) per unit
     static qint64 factor(Unit unit);
-    //! Number of fractional places
+    //! Number of decimals left
     static int decimals(Unit unit);
-    //! Radix
-    static int radix(Unit unit);
-    //! Number system
-    static Unit numsys(Unit unit);
-    //! Number of digits total in maximum value
-    static qint64 max_digits(Unit unit);
-    //! "Single step" amount, in satoshis
-    static qint64 singlestep(Unit unit);
     //! Format as string
     static QString format(Unit unit, const CAmount& amount, bool plussign = false, SeparatorStyle separators = SeparatorStyle::STANDARD, bool justify = false);
     //! Format as string (with unit)
diff --git a/src/qt/blockview.cpp b/src/qt/blockview.cpp
deleted file mode 100644
index 309e30fbf5..0000000000
--- a/src/qt/blockview.cpp
+++ /dev/null
@@ -1,513 +0,0 @@
-// Copyright (c) 2024 Luke Dashjr
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#if defined(HAVE_CONFIG_H)
-#include <config/bitcoin-config.h>
-#endif
-
-#include <qt/blockview.h>
-
-#include <interfaces/node.h>
-#include <logging.h>
-#include <node/context.h>
-#include <node/miner.h>
-#include <primitives/block.h>
-#include <util/strencodings.h>
-#include <validation.h>
-#include <validationinterface.h>
-
-#include <qt/bitcoinunits.h>
-#include <qt/clientmodel.h>
-#include <qt/guiutil.h>
-#include <qt/networkstyle.h>
-#include <qt/optionsmodel.h>
-
-#include <cmath>
-#include <numbers>
-
-#include <QComboBox>
-#include <QLabel>
-#include <QGraphicsEllipseItem>
-#include <QGraphicsScene>
-#include <QGraphicsView>
-#include <QHBoxLayout>
-#include <QVBoxLayout>
-
-static constexpr qreal TX_PADDING_NEXT{4};
-static constexpr qreal TX_PADDING_NEARBY{2};
-static constexpr qreal EXPECTED_WHITESPACE_PERCENT{1.5};
-static constexpr auto RADIAN_DIVISOR{8};
-
-void ScalingGraphicsView::resizeEvent(QResizeEvent * const event)
-{
-    fitInView(scene()->sceneRect(), Qt::KeepAspectRatio);
-    QGraphicsView::resizeEvent(event);
-}
-
-class BlockViewValidationInterface final : public CValidationInterface
-{
-private:
-    GuiBlockView& m_bv;
-
-public:
-    explicit BlockViewValidationInterface(GuiBlockView& bv) : m_bv(bv) {}
-
-    void BlockConnected(ChainstateRole role, const std::shared_ptr<const CBlock>& block_cached, const CBlockIndex* pblockindex) override {
-        m_bv.updateBestBlock(pblockindex->nHeight);
-
-        if (!m_bv.m_follow_tip) return;
-
-        std::shared_ptr<const CBlock> block = block_cached;
-        auto chainman = m_bv.getChainstateManager();
-        Assert(chainman);
-        if (!block) {
-            std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();
-            if (!chainman->m_blockman.ReadBlockFromDisk(*pblock, *pblockindex)) {
-                // Indicate error somehow?
-                return;
-            }
-            block = pblock;
-        }
-
-        const auto block_subsidy = GetBlockSubsidy(pblockindex->nHeight, chainman->GetParams().GetConsensus());
-
-        m_bv.setBlock(block, block_subsidy);
-    }
-
-    void NewBlockTemplate(const std::shared_ptr<node::CBlockTemplate>& blocktemplate) override {
-        {
-            LOCK(m_bv.m_mutex);
-            if (m_bv.m_block) {
-                // Update cached template, but don't render it
-                m_bv.m_block_template = blocktemplate;
-                return;
-            }
-        }
-
-        m_bv.setBlock(blocktemplate);
-    }
-};
-
-void GuiBlockView::updateBestBlock(const int height)
-{
-    m_block_chooser->setItemText(1, tr("Newest block (%1)").arg(height));
-}
-
-GuiBlockView::GuiBlockView(const PlatformStyle *platformStyle, const NetworkStyle *networkStyle, QWidget *parent) :
-    QDialog(parent, GUIUtil::dialog_flags | Qt::WindowMaximizeButtonHint)
-{
-    setWindowTitle(tr(PACKAGE_NAME) + " - " + tr("Block View") + " " + networkStyle->getTitleAddText());
-    setWindowIcon(networkStyle->getTrayAndWindowIcon());
-    resize(640, 640);
-
-    QVBoxLayout * const layout = new QVBoxLayout(this);
-    setLayout(layout);
-
-    auto hlayout = new QHBoxLayout;
-    layout->addLayout(hlayout);
-    hlayout->addWidget(new QLabel(tr("Displayed block: ")));
-    m_block_chooser = new QComboBox(this);
-    hlayout->addWidget(m_block_chooser, 1);
-    connect(m_block_chooser, QOverload<int>::of(&QComboBox::currentIndexChanged), [=, this](const int index){
-        m_follow_tip = false;
-        auto ud = m_block_chooser->itemData(index).toInt();
-        if (ud == -3) {
-            m_block_chooser->setEditable(false);
-            auto block_template = WITH_LOCK(m_mutex, return m_block_template);
-            if (block_template) {
-                setBlock(block_template);
-            } else {
-                clear();
-            }
-            return;
-        }
-
-        auto chainman = getChainstateManager();
-        if (!chainman) {
-            clear();
-            return;
-        }
-        auto& blockman = chainman->m_blockman;
-
-        CBlockIndex *pblockindex;
-        if (ud == -2) {
-            m_follow_tip = true;
-            pblockindex = WITH_LOCK(::cs_main, return chainman->ActiveChain().Tip());
-            if (!pblockindex) {
-                clear();
-                return;
-            }
-        } else if (ud == -1) {
-            m_block_chooser->setEditable(true);
-            m_block_chooser->clearEditText();
-            return;
-        } else {
-            auto qtxt = m_block_chooser->itemText(index);
-            auto txt = qtxt.toStdString();
-            auto blockhash{uint256::FromHex(txt)};
-            if (blockhash) {
-                LOCK(cs_main);
-                pblockindex = blockman.LookupBlockIndex(*blockhash);
-            } else if (auto height = ToIntegral<int>(txt)) {
-                LOCK(cs_main);
-                pblockindex = chainman->ActiveChain()[*height];
-            } else {
-                pblockindex = nullptr;
-            }
-            if (!pblockindex) {
-                clear();
-                QMessageBox::critical(this, tr("Invalid block"), tr("\"%1\" is not a valid block height or hash!").arg(qtxt));
-                m_block_chooser->removeItem(index);
-                return;
-            }
-        }
-
-        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();
-        if ((!blockman.ReadBlockFromDisk(*block, *pblockindex)) || block->vtx.empty()) {
-            clear();
-            const bool is_pruned = WITH_LOCK(::cs_main, return blockman.IsBlockPruned(*pblockindex));
-            if (is_pruned) {
-                QMessageBox::critical(this, tr("Pruned block"), tr("Block %1 (%2) is pruned.").arg(pblockindex->nHeight).arg(QString::fromStdString(pblockindex->GetBlockHash().ToString())));
-            } else {
-                QMessageBox::critical(this, tr("Error reading block"), tr("Block %1 (%2) could not be loaded.").arg(pblockindex->nHeight).arg(QString::fromStdString(pblockindex->GetBlockHash().ToString())));
-            }
-            m_block_chooser->removeItem(index);
-            return;
-        }
-
-        m_block_chooser->setEditable(false);
-
-        const auto block_subsidy = GetBlockSubsidy(pblockindex->nHeight, chainman->GetParams().GetConsensus());
-
-        setBlock(block, block_subsidy);
-    });
-    // Items initialized later, after ClientModel is available
-
-    m_scene = new QGraphicsScene(this);
-    m_scene->setSceneRect(0, 0, 1, 1);
-    auto view = new ScalingGraphicsView(m_scene, this);
-    layout->addWidget(view);
-    view->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
-    view->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
-    view->setStyleSheet("QGraphicsView { background: transparent; }");
-    view->setAlignment(Qt::AlignHCenter | Qt::AlignBottom);
-    connect(m_scene, &QGraphicsScene::sceneRectChanged, [view](const QRectF& rect){
-        view->fitInView(rect, Qt::KeepAspectRatio);
-    });
-
-    hlayout = new QHBoxLayout;
-    layout->addLayout(hlayout);
-    hlayout->addWidget(new QLabel(tr("Transactions"), this));
-    m_lbl_tx_count = new QLabel(this);
-    m_lbl_tx_count->setAlignment(Qt::AlignRight);
-    hlayout->addWidget(m_lbl_tx_count);
-
-    hlayout = new QHBoxLayout;
-    layout->addLayout(hlayout);
-    hlayout->addWidget(new QLabel(tr("Txn Fees"), this));
-    m_lbl_tx_fees = new QLabel(this);
-    m_lbl_tx_fees->setAlignment(Qt::AlignRight);
-    hlayout->addWidget(m_lbl_tx_fees);
-
-    connect(&m_timer, &QTimer::timeout, this, &GuiBlockView::updateScene);
-
-    m_validation_interface = new BlockViewValidationInterface(*this);
-}
-
-GuiBlockView::~GuiBlockView()
-{
-    if (m_validation_interface) {
-        setClientModel(nullptr);
-        delete m_validation_interface;
-        m_validation_interface = nullptr;
-    }
-}
-
-void GuiBlockView::setClientModel(ClientModel *model)
-{
-    if (m_client_model) {
-        auto& validation_signals = m_client_model->node().context()->validation_signals;
-        if (validation_signals) {
-            validation_signals->UnregisterValidationInterface(m_validation_interface);
-        }
-        disconnect(m_client_model->getOptionsModel(), &OptionsModel::displayUnitChanged, this, &GuiBlockView::updateDisplayUnit);
-    }
-    m_client_model = model;
-    if (model) {
-        connect(model->getOptionsModel(), &OptionsModel::displayUnitChanged, this, &GuiBlockView::updateDisplayUnit);
-        updateDisplayUnit();
-
-        if (m_block_chooser->count() == 0) {
-            m_block_chooser->addItem(tr("This node's preferred block template"), -3);
-            m_block_chooser->addItem("", -2);
-            m_block_chooser->addItem(tr("Specific block"), -1);
-            m_block_chooser->setCurrentIndex(1);
-        }
-
-        auto chainman = getChainstateManager();
-        if (chainman) {
-            const auto pblockindex = WITH_LOCK(::cs_main, return chainman->ActiveChain().Tip());
-            updateBestBlock(pblockindex->nHeight);
-        }
-        auto& validation_signals = model->node().context()->validation_signals;
-        if (validation_signals) {
-            validation_signals->RegisterValidationInterface(m_validation_interface);
-        }
-    }
-}
-
-ChainstateManager* GuiBlockView::getChainstateManager() const
-{
-    if (!m_client_model) return nullptr;
-    auto node_ctx = m_client_model->node().context();
-    if (!node_ctx) return nullptr;
-    auto& chainman = node_ctx->chainman;
-    if (!chainman) return nullptr;
-    return &(*chainman);
-}
-
-void GuiBlockView::clear()
-{
-    LOCK(m_mutex);
-    m_block_fees = -1;
-    m_lbl_tx_count->setText("");
-    m_block.reset();
-    m_block_template.reset();
-    for (auto& [wtxid, elem] : m_elements) {
-        const auto gi = elem.gi;
-        m_scene->removeItem(gi);
-        delete gi;
-    }
-    m_elements.clear();
-}
-
-bool GuiBlockView::any_overlap(const Bubble& proposed, const std::vector<Bubble>& others)
-{
-    for (const auto& other : others) {
-        const auto x_dist = std::abs(other.pos.x() - proposed.pos.x());
-        const auto y_dist = std::abs(other.pos.y() - proposed.pos.y());
-        const auto dist = std::sqrt((x_dist * x_dist) + (y_dist * y_dist));
-        if (dist < proposed.radius + other.radius + TX_PADDING_NEARBY) {
-            return true;
-        }
-    }
-    return false;
-}
-
-void GuiBlockView::setBlock(std::shared_ptr<const CBlock> block, const CAmount block_subsidy)
-{
-    LOCK(m_mutex);
-    m_block_fees = [&] {
-        CAmount total{0};
-        Assert(!block->vtx.empty());
-        for (const auto& outp : block->vtx[0]->vout) {
-            total += outp.nValue;
-        }
-        return total - block_subsidy;
-    }();
-    m_block = block;
-    m_block_template.reset();
-    m_block_changed = true;
-    updateElements(/*instant=*/ true);
-}
-
-void GuiBlockView::setBlock(std::shared_ptr<const node::CBlockTemplate> blocktemplate)
-{
-    LOCK(m_mutex);
-    const bool instant = (bool)m_block;  // force instant if changing from real block to template
-    m_block_fees = -blocktemplate->vTxFees.front();
-    m_block.reset();
-    m_block_template = blocktemplate;
-    m_block_changed = true;
-    updateElements(/*instant=*/ instant);
-}
-
-void GuiBlockView::updateBlockFees(CAmount block_fees)
-{
-    if (block_fees < 0) {
-        m_lbl_tx_fees->setText("");
-        return;
-    }
-    const auto unit = m_client_model ? m_client_model->getOptionsModel()->getDisplayUnit() : BitcoinUnit::BTC;
-    m_lbl_tx_fees->setText(BitcoinUnits::formatWithUnit(unit, block_fees));
-}
-
-void GuiBlockView::updateDisplayUnit()
-{
-    const auto block_fees = WITH_LOCK(m_mutex, return m_block_fees);
-    updateBlockFees(block_fees);
-}
-
-constexpr qreal offscreen{99};
-
-void GuiBlockView::updateElements(bool instant)
-{
-    if (!m_block_changed) return;
-
-    m_timer.stop();
-    m_block_changed = false;
-    auto pblocktemplate = m_block_template;
-    auto pblock = m_block;
-    auto& block = pblock ? *pblock : pblocktemplate->block;
-
-    instant |= m_elements.empty();
-    for (auto& el : m_elements) {
-        el.second.target_loc.setY(offscreen);
-    }
-    m_bubblegraph = std::make_unique<BubbleGraph>();
-    auto& bubbles = m_bubblegraph->bubbles;
-    size_t total_txs_size{0};
-    qreal limit_halfwidth{std::sqrt(::GetSerializeSize(TX_WITH_WITNESS(block))) * EXPECTED_WHITESPACE_PERCENT / 2};
-    for (size_t i = 1; i < block.vtx.size(); ++i) {
-        auto& tx = *block.vtx[i];
-        auto& el = m_elements[tx.GetWitnessHash()];
-        QPointF preferred_loc;
-        double diameter;
-        const auto tx_size = tx.GetTotalSize();
-        total_txs_size += tx_size;
-        const bool fresh_bubble = !el.gi;
-        if (fresh_bubble) {
-            diameter = 2 * std::sqrt(tx_size / std::numbers::pi);
-        } else {
-            // preferred_loc = el.gi->pos();
-            diameter = el.gi->boundingRect().height();
-        }
-        Bubble proposed{ .pos = {}, .radius = diameter / 2, .el = &el, };
-        qreal x_extremity{proposed.radius};
-        if (bubbles.empty()) {
-            proposed.pos.setY(-proposed.radius);
-        }
-        for (auto bubble_it = bubbles.rbegin(); bubble_it != bubbles.rend(); ++bubble_it) {
-            const auto& centre = bubble_it->pos;
-            QPointF preferred_loc_rel(preferred_loc.x() - centre.x(), preferred_loc.y() - centre.y());
-            double preferred_angle;
-            if (preferred_loc_rel.isNull()) {
-                preferred_angle = std::numbers::pi / 2;
-            } else {
-                preferred_angle = std::atan2(preferred_loc.y() - centre.y(), preferred_loc.x() - centre.x());
-            }
-            const auto distance = bubble_it->radius + proposed.radius + TX_PADDING_NEXT;
-            double angle = preferred_angle;
-            bool found{false};
-            while (true) {
-                proposed.pos = QPointF(centre.x() + (distance * std::cos(angle)), centre.y() + (distance * std::sin(angle)));
-
-                x_extremity = std::abs(proposed.pos.x()) + proposed.radius;
-                if (proposed.pos.y() < -proposed.radius && x_extremity <= limit_halfwidth && !any_overlap(proposed, bubbles)) {
-                    found = true;
-                    break;
-                }
-
-                if (angle < preferred_angle) {
-                    angle = preferred_angle + (preferred_angle - angle);
-                } else {
-                    angle = preferred_angle - (angle - preferred_angle) - (std::numbers::pi / RADIAN_DIVISOR);
-                }
-                if (angle > preferred_angle + std::numbers::pi) {
-                    break;
-                }
-            }
-            if (found) break;
-        }
-        m_bubblegraph->min_x = std::min(m_bubblegraph->min_x, proposed.pos.x() - proposed.radius);
-        m_bubblegraph->max_x = std::max(m_bubblegraph->max_x, proposed.pos.x() + proposed.radius);
-        m_bubblegraph->min_y = std::min(m_bubblegraph->min_y, proposed.pos.y() - proposed.radius);
-        bubbles.push_back(proposed);
-        el.target_loc = proposed.pos;
-    }
-    m_lbl_tx_count->setText(tr("%1 (%2)").arg(block.vtx.size() - 1).arg(tr("%1 kB").arg(total_txs_size / 1000.0, 0, 'f', 1)));
-    updateBlockFees(m_block_fees);
-    m_bubblegraph->instant = instant;
-    QMetaObject::invokeMethod(this, "updateSceneInit", Qt::QueuedConnection);
-}
-
-void GuiBlockView::updateSceneInit()
-{
-    LOCK(m_mutex);
-    if (!m_bubblegraph) return;
-    for (auto& bubble : m_bubblegraph->bubbles) {
-        auto& el = *bubble.el;
-        if (!el.gi) {
-            const auto diameter = bubble.radius * 2;
-            auto gi = m_scene->addEllipse(0, 0, diameter, diameter, QPen(palette().window(), TX_PADDING_NEARBY));
-            el.gi = gi;
-            gi->setBrush(QColor(Qt::blue));
-            gi->setPos(bubble.pos.x() - bubble.radius, m_bubblegraph->instant ? (bubble.pos.y() - bubble.radius) : offscreen);
-        }
-    }
-    for (auto it = m_elements.begin(); it != m_elements.end(); ) {
-        const auto& target_loc = it->second.target_loc;
-        const auto gi = it->second.gi;
-        bool delete_el{false};
-        if (target_loc.y() == offscreen || !gi /* never got a chance to exist */) {
-            delete_el = true;
-            // TODO: if confirmed, slide it off the bottom
-            // TODO: if conflicted, pop the bubble?
-            // TODO: if delayed, move off the top
-        } else {
-            if (gi->y() == offscreen) {
-                gi->setY(m_bubblegraph->min_y - gi->boundingRect().height());
-            }
-        }
-        if (delete_el) {
-            if (gi) {
-                m_scene->removeItem(gi);
-                delete gi;
-            }
-            it = m_elements.erase(it);
-        } else {
-            ++it;
-        }
-    }
-    m_scene->setSceneRect(m_bubblegraph->min_x, m_bubblegraph->min_y, m_bubblegraph->max_x - m_bubblegraph->min_x, -m_bubblegraph->min_y);
-    if (!m_bubblegraph->instant) {
-        m_frame_div = 4;
-        updateScene();
-        m_timer.start(100);
-    }
-    m_bubblegraph.reset();
-}
-
-void GuiBlockView::updateScene()
-{
-    LOCK(m_mutex);
-    bool all_completed{true};
-    for (auto it = m_elements.begin(); it != m_elements.end(); ) {
-        const auto& target_loc = it->second.target_loc;
-        QGraphicsItem* gi = it->second.gi;
-        const auto radius = gi->boundingRect().width() / 2;
-        const QPointF current_loc(gi->pos().x() + radius, gi->pos().y() + radius);
-        bool delete_el{false};
-        if (target_loc != current_loc) {
-            // Get 25% closer each tick
-            QPointF new_loc(current_loc.x() + ((target_loc.x() - current_loc.x()) / m_frame_div),
-                            current_loc.y() + ((target_loc.y() - current_loc.y()) / m_frame_div));
-            if (std::abs(new_loc.x() - target_loc.x()) < TX_PADDING_NEXT) {
-                new_loc.setX(target_loc.x());
-            }
-            if (std::abs(new_loc.y() - target_loc.y()) < TX_PADDING_NEXT) {
-                new_loc.setY(target_loc.y());
-            }
-            gi->setPos(new_loc.x() - radius, new_loc.y() - radius);
-            if (new_loc == target_loc) {
-                if (target_loc.y() + radius < m_scene->sceneRect().y() || target_loc.y() - radius > 0) {
-                    delete_el = true;
-                }
-            } else {
-                all_completed = false;
-            }
-        }
-        if (delete_el) {
-            m_scene->removeItem(gi);
-            delete gi;
-            it = m_elements.erase(it);
-        } else {
-            ++it;
-        }
-    }
-    --m_frame_div;
-    if (all_completed) {
-        m_timer.stop();
-    }
-}
diff --git a/src/qt/blockview.h b/src/qt/blockview.h
deleted file mode 100644
index fe1159a144..0000000000
--- a/src/qt/blockview.h
+++ /dev/null
@@ -1,120 +0,0 @@
-// Copyright (c) 2024 Luke Dashjr
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#ifndef BITCOIN_QT_BLOCKVIEW_H
-#define BITCOIN_QT_BLOCKVIEW_H
-
-#include <consensus/amount.h>
-#include <sync.h>
-#include <threadsafety.h>
-#include <util/transaction_identifier.h>
-
-#include <atomic>
-#include <map>
-#include <memory>
-#include <vector>
-
-#include <QDialog>
-#include <QGraphicsView>
-#include <QPointF>
-#include <QTimer>
-
-QT_BEGIN_NAMESPACE
-class QComboBox;
-class QGraphicsItem;
-class QGraphicsScene;
-class QLabel;
-class QWidget;
-QT_END_NAMESPACE
-
-class CBlock;
-namespace node { struct CBlockTemplate; }
-class ChainstateManager;
-class ClientModel;
-class CValidationInterface;
-class NetworkStyle;
-class PlatformStyle;
-
-class ScalingGraphicsView : public QGraphicsView
-{
-    Q_OBJECT
-
-public:
-    using QGraphicsView::QGraphicsView;
-
-    void resizeEvent(QResizeEvent *event) override;
-};
-
-class BlockViewValidationInterface;
-
-class GuiBlockView : public QDialog
-{
-    Q_OBJECT
-
-public:
-    RecursiveMutex m_mutex;
-
-private:
-    struct SceneElement {
-        QGraphicsItem* gi;
-        QPointF target_loc;
-    };
-    struct Bubble {
-        QPointF pos;
-        double radius;
-        SceneElement *el;
-    };
-    struct BubbleGraph {
-        std::vector<Bubble> bubbles;
-        qreal min_x{0};
-        qreal max_x{0};
-        qreal min_y{0};
-        bool instant;
-    };
-    std::map<Wtxid, SceneElement> m_elements GUARDED_BY(m_mutex);
-    std::unique_ptr<BubbleGraph> m_bubblegraph GUARDED_BY(m_mutex);
-    QGraphicsScene *m_scene;
-    QTimer m_timer;
-    unsigned int m_frame_div;
-
-    QComboBox *m_block_chooser;
-    QLabel *m_lbl_tx_count;
-    QLabel *m_lbl_tx_fees;
-
-    BlockViewValidationInterface *m_validation_interface;
-
-    static bool any_overlap(const Bubble& proposed, const std::vector<Bubble>& others);
-
-protected:
-    void updateElements(bool instant) EXCLUSIVE_LOCKS_REQUIRED(m_mutex);
-    void updateBlockFees(CAmount block_fees);
-
-protected Q_SLOTS:
-    void updateDisplayUnit();
-    void updateSceneInit();
-    void updateScene();
-
-public:
-    ClientModel *m_client_model{nullptr};
-
-    bool m_block_changed GUARDED_BY(m_mutex);
-    CAmount m_block_fees GUARDED_BY(m_mutex) {-1};
-    std::shared_ptr<const node::CBlockTemplate> m_block_template GUARDED_BY(m_mutex);
-    std::shared_ptr<const CBlock> m_block GUARDED_BY(m_mutex);
-    std::atomic<bool> m_follow_tip;
-
-    GuiBlockView(const PlatformStyle *, const NetworkStyle *, QWidget * parent = nullptr);
-    ~GuiBlockView();
-
-    void setClientModel(ClientModel *model);
-    ChainstateManager* getChainstateManager() const;
-
-    void updateBestBlock(int height);
-
-    void clear();
-    void setBlock(std::shared_ptr<const CBlock> block, CAmount block_subsidy);
-    void setBlock(std::shared_ptr<const node::CBlockTemplate> blocktemplate);
-};
-
-#endif // BITCOIN_QT_BLOCKVIEW_H
diff --git a/src/qt/clientmodel.cpp b/src/qt/clientmodel.cpp
index 2ed2fe2c95..5c70c2695c 100644
--- a/src/qt/clientmodel.cpp
+++ b/src/qt/clientmodel.cpp
@@ -33,7 +33,7 @@
 static SteadyClock::time_point g_last_header_tip_update_notification{};
 static SteadyClock::time_point g_last_block_tip_update_notification{};
 
-ClientModel::ClientModel(interfaces::Node& node, OptionsModel *_optionsModel, const PlatformStyle& platform_style, QObject *parent) :
+ClientModel::ClientModel(interfaces::Node& node, OptionsModel *_optionsModel, QObject *parent) :
     QObject(parent),
     m_node(node),
     optionsModel(_optionsModel),
@@ -42,7 +42,7 @@ ClientModel::ClientModel(interfaces::Node& node, OptionsModel *_optionsModel, co
     cachedBestHeaderHeight = -1;
     cachedBestHeaderTime = -1;
 
-    peerTableModel = new PeerTableModel(m_node, platform_style, this);
+    peerTableModel = new PeerTableModel(m_node, this);
     m_peer_table_sort_proxy = new PeerTableSortProxy(this);
     m_peer_table_sort_proxy->setSourceModel(peerTableModel);
 
@@ -246,11 +246,6 @@ void ClientModel::TipChanged(SynchronizationState sync_state, interfaces::BlockT
     nLastUpdateNotification = now;
 }
 
-static void MempoolStatsDidChange(ClientModel *clientmodel)
-{
-    QMetaObject::invokeMethod(clientmodel, "updateMempoolStats", Qt::QueuedConnection);
-}
-
 void ClientModel::subscribeToCoreSignals()
 {
     m_event_handlers.emplace_back(m_node.handleShowProgress(
@@ -265,10 +260,6 @@ void ClientModel::subscribeToCoreSignals()
         [this](bool network_active) {
             Q_EMIT networkActiveChanged(network_active);
         }));
-    m_event_handlers.emplace_back(m_node.handleNotifyNetworkLocalChanged(
-        [this]() {
-            Q_EMIT networkLocalChanged();
-        }));
     m_event_handlers.emplace_back(m_node.handleNotifyAlertChanged(
         [this]() {
             qDebug() << "ClientModel: NotifyAlertChanged";
@@ -287,15 +278,11 @@ void ClientModel::subscribeToCoreSignals()
         [this](SynchronizationState sync_state, interfaces::BlockTip tip, bool presync) {
             TipChanged(sync_state, tip, /*verification_progress=*/0.0, presync ? SyncType::HEADER_PRESYNC : SyncType::HEADER_SYNC);
         }));
-
-    m_connection_mempool_stats_did_change = CStats::DefaultStats()->MempoolStatsDidChange.connect(std::bind(MempoolStatsDidChange, this));
 }
 
 void ClientModel::unsubscribeFromCoreSignals()
 {
     m_event_handlers.clear();
-
-    m_connection_mempool_stats_did_change.disconnect();
 }
 
 bool ClientModel::getProxyInfo(std::string& ip_port) const
@@ -307,31 +294,3 @@ bool ClientModel::getProxyInfo(std::string& ip_port) const
     }
     return false;
 }
-
-bool ClientModel::getTorInfo(QString& out_onion) const
-{
-    for (const auto& [addr, info] : m_node.getNetLocalAddresses()) {
-        if (addr.IsTor()) {
-            out_onion = QString::fromStdString(addr.ToStringAddr());
-            return true;
-        }
-    }
-    return false;
-}
-
-mempoolSamples_t ClientModel::getMempoolStatsInRange(QDateTime &from, QDateTime &to)
-{
-    // get stats from the core stats model
-    uint64_t timeFrom = from.toTime_t();
-    uint64_t timeTo = to.toTime_t();
-
-    mempoolSamples_t samples = CStats::DefaultStats()->mempoolGetValuesInRange(timeFrom,timeTo);
-    from.setTime_t(timeFrom);
-    to.setTime_t(timeTo);
-    return samples;
-}
-
-void ClientModel::updateMempoolStats()
-{
-    Q_EMIT mempoolStatsDidUpdate();
-}
diff --git a/src/qt/clientmodel.h b/src/qt/clientmodel.h
index 9c26718439..7d0e35e7f9 100644
--- a/src/qt/clientmodel.h
+++ b/src/qt/clientmodel.h
@@ -10,7 +10,6 @@
 
 #include <atomic>
 #include <memory>
-#include <stats/stats.h>
 #include <sync.h>
 #include <uint256.h>
 
@@ -21,7 +20,6 @@ class CBlockIndex;
 class OptionsModel;
 class PeerTableModel;
 class PeerTableSortProxy;
-class PlatformStyle;
 enum class SynchronizationState;
 struct LocalServiceInfo;
 
@@ -60,7 +58,7 @@ class ClientModel : public QObject
     Q_OBJECT
 
 public:
-    explicit ClientModel(interfaces::Node& node, OptionsModel *optionsModel, const PlatformStyle&, QObject *parent = nullptr);
+    explicit ClientModel(interfaces::Node& node, OptionsModel *optionsModel, QObject *parent = nullptr);
     ~ClientModel();
 
     void stop();
@@ -92,7 +90,6 @@ public:
     QString blocksDir() const;
 
     bool getProxyInfo(std::string& ip_port) const;
-    bool getTorInfo(QString& out_onion) const;
 
     // caches for the best header: hash, number of blocks and block time
     mutable std::atomic<int> cachedBestHeaderHeight;
@@ -102,12 +99,9 @@ public:
     Mutex m_cached_tip_mutex;
     uint256 m_cached_tip_blocks GUARDED_BY(m_cached_tip_mutex){};
 
-    mempoolSamples_t getMempoolStatsInRange(QDateTime &from, QDateTime &to);
-
 private:
     interfaces::Node& m_node;
     std::vector<std::unique_ptr<interfaces::Handler>> m_event_handlers;
-    boost::signals2::scoped_connection m_connection_mempool_stats_did_change;
     OptionsModel *optionsModel;
     PeerTableModel* peerTableModel{nullptr};
     PeerTableSortProxy* m_peer_table_sort_proxy{nullptr};
@@ -125,7 +119,6 @@ Q_SIGNALS:
     void numBlocksChanged(int count, const QDateTime& blockDate, double nVerificationProgress, SyncType header, SynchronizationState sync_state);
     void mempoolSizeChanged(long count, size_t mempoolSizeInBytes, size_t mempoolMaxSizeInBytes);
     void networkActiveChanged(bool networkActive);
-    void networkLocalChanged();
     void alertsChanged(const QString &warnings);
     void bytesChanged(quint64 totalBytesIn, quint64 totalBytesOut);
 
@@ -134,12 +127,6 @@ Q_SIGNALS:
 
     // Show progress dialog e.g. for verifychain
     void showProgress(const QString &title, int nProgress);
-
-    void mempoolStatsDidUpdate();
-
-public Q_SLOTS:
-    /* stats stack */
-    void updateMempoolStats();
 };
 
 #endif // BITCOIN_QT_CLIENTMODEL_H
diff --git a/src/qt/coincontroltreewidget.cpp b/src/qt/coincontroltreewidget.cpp
index d232b5bce4..4ffbd832e9 100644
--- a/src/qt/coincontroltreewidget.cpp
+++ b/src/qt/coincontroltreewidget.cpp
@@ -9,7 +9,6 @@ CoinControlTreeWidget::CoinControlTreeWidget(QWidget *parent) :
     QTreeWidget(parent)
 {
 
-    setSelectionMode(QAbstractItemView::ExtendedSelection);
 }
 
 void CoinControlTreeWidget::keyPressEvent(QKeyEvent *event)
@@ -17,9 +16,9 @@ void CoinControlTreeWidget::keyPressEvent(QKeyEvent *event)
     if (event->key() == Qt::Key_Space) // press spacebar -> select checkbox
     {
         event->ignore();
-        for (QTreeWidgetItem* item : selectedItems()) {
+        if (this->currentItem()) {
             int COLUMN_CHECKBOX = 0;
-            item->setCheckState(COLUMN_CHECKBOX, ((item->checkState(COLUMN_CHECKBOX) == Qt::Checked) ? Qt::Unchecked : Qt::Checked));
+            this->currentItem()->setCheckState(COLUMN_CHECKBOX, ((this->currentItem()->checkState(COLUMN_CHECKBOX) == Qt::Checked) ? Qt::Unchecked : Qt::Checked));
         }
     }
     else if (event->key() == Qt::Key_Escape) // press esc -> close dialog
diff --git a/src/qt/createwalletdialog.cpp b/src/qt/createwalletdialog.cpp
index f1ad7ea446..3e8d1461e5 100644
--- a/src/qt/createwalletdialog.cpp
+++ b/src/qt/createwalletdialog.cpp
@@ -48,12 +48,10 @@ CreateWalletDialog::CreateWalletDialog(QWidget* parent) :
         ui->encrypt_wallet_checkbox->setEnabled(!checked);
         ui->blank_wallet_checkbox->setEnabled(!checked);
         ui->disable_privkeys_checkbox->setEnabled(!checked);
-        ui->descriptor_checkbox->setEnabled(!checked);
 
         // The external signer checkbox is only enabled when a device is detected.
         // In that case it is checked by default. Toggling it restores the other
         // options to their default.
-        ui->descriptor_checkbox->setChecked(checked);
         ui->encrypt_wallet_checkbox->setChecked(false);
         ui->disable_privkeys_checkbox->setChecked(checked);
         ui->blank_wallet_checkbox->setChecked(false);
@@ -85,19 +83,6 @@ CreateWalletDialog::CreateWalletDialog(QWidget* parent) :
         }
     });
 
-#ifndef USE_SQLITE
-        ui->descriptor_checkbox->setToolTip(tr("Compiled without sqlite support (required for descriptor wallets)"));
-        ui->descriptor_checkbox->setEnabled(false);
-        ui->descriptor_checkbox->setChecked(false);
-        ui->external_signer_checkbox->setEnabled(false);
-        ui->external_signer_checkbox->setChecked(false);
-#endif
-
-#ifndef USE_BDB
-        ui->descriptor_checkbox->setEnabled(false);
-        ui->descriptor_checkbox->setChecked(true);
-#endif
-
 #ifndef ENABLE_EXTERNAL_SIGNER
         //: "External signing" means using devices such as hardware wallets.
         ui->external_signer_checkbox->setToolTip(tr("Compiled without external signing support (required for external signing)"));
@@ -153,11 +138,6 @@ bool CreateWalletDialog::isMakeBlankWalletChecked() const
     return ui->blank_wallet_checkbox->isChecked();
 }
 
-bool CreateWalletDialog::isDescriptorWalletChecked() const
-{
-    return ui->descriptor_checkbox->isChecked();
-}
-
 bool CreateWalletDialog::isExternalSignerChecked() const
 {
     return ui->external_signer_checkbox->isChecked();
diff --git a/src/qt/createwalletdialog.h b/src/qt/createwalletdialog.h
index 939b82ff78..24ee97385b 100644
--- a/src/qt/createwalletdialog.h
+++ b/src/qt/createwalletdialog.h
@@ -35,7 +35,6 @@ public:
     bool isEncryptWalletChecked() const;
     bool isDisablePrivateKeysChecked() const;
     bool isMakeBlankWalletChecked() const;
-    bool isDescriptorWalletChecked() const;
     bool isExternalSignerChecked() const;
 
 private:
diff --git a/src/qt/editaddressdialog.cpp b/src/qt/editaddressdialog.cpp
index 9079752bd9..092a89fa11 100644
--- a/src/qt/editaddressdialog.cpp
+++ b/src/qt/editaddressdialog.cpp
@@ -34,7 +34,6 @@ EditAddressDialog::EditAddressDialog(Mode _mode, QWidget* parent)
         break;
     case EditSendingAddress:
         setWindowTitle(tr("Edit sending address"));
-        ui->addressEdit->setEnabled(false);
         break;
     }
 
diff --git a/src/qt/forms/addressbookpage.ui b/src/qt/forms/addressbookpage.ui
index c22156c067..7ac216286c 100644
--- a/src/qt/forms/addressbookpage.ui
+++ b/src/qt/forms/addressbookpage.ui
@@ -34,7 +34,7 @@
       <enum>Qt::CustomContextMenu</enum>
      </property>
      <property name="toolTip">
-      <string>Right-click to edit label</string>
+      <string>Right-click to edit address or label</string>
      </property>
      <property name="tabKeyNavigation">
       <bool>false</bool>
diff --git a/src/qt/forms/createwalletdialog.ui b/src/qt/forms/createwalletdialog.ui
index 3bf6c7c4fd..1d6f0ed530 100644
--- a/src/qt/forms/createwalletdialog.ui
+++ b/src/qt/forms/createwalletdialog.ui
@@ -153,19 +153,6 @@
         </property>
        </widget>
       </item>
-      <item>
-       <widget class="QCheckBox" name="descriptor_checkbox">
-        <property name="toolTip">
-         <string>Use descriptors for scriptPubKey management</string>
-        </property>
-        <property name="text">
-         <string>Descriptor Wallet</string>
-        </property>
-        <property name="checked">
-         <bool>true</bool>
-        </property>
-       </widget>
-      </item>
       <item>
        <widget class="QCheckBox" name="external_signer_checkbox">
         <property name="toolTip">
@@ -209,7 +196,6 @@
   <tabstop>encrypt_wallet_checkbox</tabstop>
   <tabstop>disable_privkeys_checkbox</tabstop>
   <tabstop>blank_wallet_checkbox</tabstop>
-  <tabstop>descriptor_checkbox</tabstop>
   <tabstop>external_signer_checkbox</tabstop>
  </tabstops>
  <resources/>
diff --git a/src/qt/forms/debugwindow.ui b/src/qt/forms/debugwindow.ui
index 6450680c7c..eccea14318 100644
--- a/src/qt/forms/debugwindow.ui
+++ b/src/qt/forms/debugwindow.ui
@@ -647,32 +647,79 @@
       <attribute name="title">
        <string>&amp;Network Traffic</string>
       </attribute>
-      <layout class="QVBoxLayout" name="verticalLayout_4">
+      <layout class="QHBoxLayout" name="horizontalLayout_3">
        <item>
-        <widget class="TrafficGraphWidget" name="trafficGraph" native="true">
-         <property name="sizePolicy">
-          <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
-           <horstretch>0</horstretch>
-           <verstretch>0</verstretch>
-          </sizepolicy>
-         </property>
-        </widget>
+        <layout class="QVBoxLayout" name="verticalLayout_4">
+         <item>
+          <widget class="TrafficGraphWidget" name="trafficGraph" native="true">
+           <property name="sizePolicy">
+            <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
+             <horstretch>0</horstretch>
+             <verstretch>0</verstretch>
+            </sizepolicy>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <layout class="QHBoxLayout" name="horizontalLayout_2">
+           <item>
+            <widget class="QSlider" name="sldGraphRange">
+             <property name="minimum">
+              <number>1</number>
+             </property>
+             <property name="maximum">
+              <number>288</number>
+             </property>
+             <property name="pageStep">
+              <number>12</number>
+             </property>
+             <property name="value">
+              <number>6</number>
+             </property>
+             <property name="orientation">
+              <enum>Qt::Horizontal</enum>
+             </property>
+            </widget>
+           </item>
+           <item>
+            <widget class="QLabel" name="lblGraphRange">
+             <property name="minimumSize">
+              <size>
+               <width>100</width>
+               <height>0</height>
+              </size>
+             </property>
+             <property name="alignment">
+              <set>Qt::AlignCenter</set>
+             </property>
+            </widget>
+           </item>
+           <item>
+            <widget class="QPushButton" name="btnClearTrafficGraph">
+             <property name="text">
+              <string>&amp;Reset</string>
+             </property>
+             <property name="autoDefault">
+              <bool>false</bool>
+             </property>
+            </widget>
+           </item>
+          </layout>
+         </item>
+        </layout>
        </item>
        <item>
-        <layout class="QHBoxLayout" name="bottomFrame">
+        <layout class="QVBoxLayout" name="verticalLayout">
          <item>
           <widget class="QGroupBox" name="groupBox">
            <property name="title">
-            <string/>
+            <string>Totals</string>
            </property>
-           <property name="flat">
-            <bool>true</bool>
-           </property>
-           <layout class="QVBoxLayout" name="verticalLayout_9">
+           <layout class="QVBoxLayout" name="verticalLayout_5">
             <item>
-             <layout class="QHBoxLayout" name="RecievedBox">
+             <layout class="QHBoxLayout" name="horizontalLayout_4">
               <item>
-               <widget class="Line" name="RecievedLine">
+               <widget class="Line" name="line">
                 <property name="sizePolicy">
                  <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                   <horstretch>0</horstretch>
@@ -728,7 +775,7 @@
                </widget>
               </item>
               <item>
-               <widget class="QLabel" name="Recieved">
+               <widget class="QLabel" name="label_16">
                 <property name="text">
                  <string>Received</string>
                 </property>
@@ -750,9 +797,9 @@
              </layout>
             </item>
             <item>
-             <layout class="QHBoxLayout" name="SentBox">
+             <layout class="QHBoxLayout" name="horizontalLayout_5">
               <item>
-               <widget class="Line" name="SentLine">
+               <widget class="Line" name="line_2">
                 <property name="sizePolicy">
                  <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                   <horstretch>0</horstretch>
@@ -808,7 +855,7 @@
                </widget>
               </item>
               <item>
-               <widget class="QLabel" name="Sent">
+               <widget class="QLabel" name="label_17">
                 <property name="text">
                  <string>Sent</string>
                 </property>
@@ -829,57 +876,22 @@
               </item>
              </layout>
             </item>
+            <item>
+             <spacer name="verticalSpacer_4">
+              <property name="orientation">
+               <enum>Qt::Vertical</enum>
+              </property>
+              <property name="sizeHint" stdset="0">
+               <size>
+                <width>20</width>
+                <height>407</height>
+               </size>
+              </property>
+             </spacer>
+            </item>
            </layout>
           </widget>
          </item>
-         <item>
-          <widget class="QSlider" name="sldGraphRange">
-           <property name="minimumSize">
-            <size>
-             <width>105</width>
-             <height>0</height>
-            </size>
-           </property>
-           <property name="minimum">
-            <number>1</number>
-           </property>
-           <property name="maximum">
-            <number>288</number>
-           </property>
-           <property name="pageStep">
-            <number>12</number>
-           </property>
-           <property name="value">
-            <number>6</number>
-           </property>
-           <property name="orientation">
-            <enum>Qt::Horizontal</enum>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <widget class="QLabel" name="lblGraphRange">
-           <property name="minimumSize">
-            <size>
-             <width>60</width>
-             <height>0</height>
-            </size>
-           </property>
-           <property name="alignment">
-            <set>Qt::AlignCenter</set>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <widget class="QPushButton" name="btnClearTrafficGraph">
-           <property name="text">
-            <string>&amp;Reset</string>
-           </property>
-           <property name="autoDefault">
-            <bool>false</bool>
-           </property>
-          </widget>
-         </item>
         </layout>
        </item>
       </layout>
@@ -1132,7 +1144,7 @@
                 <height>426</height>
                </rect>
               </property>
-              <layout class="QGridLayout" name="peerDetailsGrid" columnstretch="0,1">
+              <layout class="QGridLayout" name="gridLayout_2" columnstretch="0,1">
                <item row="0" column="0">
                 <widget class="QLabel" name="label_30">
                  <property name="text">
diff --git a/src/qt/forms/intro.ui b/src/qt/forms/intro.ui
index 57efb0fa3a..9ab91f6aa9 100644
--- a/src/qt/forms/intro.ui
+++ b/src/qt/forms/intro.ui
@@ -223,7 +223,7 @@
    <item>
     <widget class="QLabel" name="lblExplanation3">
      <property name="text">
-      <string>If you choose to limit block chain storage (pruning), the historical data must still be downloaded and processed, but will be deleted afterward to keep your disk usage low.</string>
+      <string>If you have chosen to limit block chain storage (pruning), the historical data must still be downloaded and processed, but will be deleted afterward to keep your disk usage low.</string>
      </property>
      <property name="wordWrap">
       <bool>true</bool>
@@ -243,16 +243,16 @@
       </widget>
      </item>
      <item>
-      <widget class="QSpinBox" name="pruneMiB">
+      <widget class="QSpinBox" name="pruneGB">
        <property name="suffix">
-        <string> MiB</string>
+        <string> GB</string>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QLabel" name="lblPruneSuffix">
        <property name="buddy">
-        <cstring>pruneMiB</cstring>
+        <cstring>pruneGB</cstring>
        </property>
       </widget>
      </item>
@@ -271,64 +271,6 @@
      </item>
     </layout>
    </item>
-   <item>
-    <widget class="QWidget" name="groupAssumeValid">
-     <layout class="QVBoxLayout">
-      <item>
-       <widget class="QLabel" name="lblExplanationAssumeValid">
-        <property name="text">
-         <string>The initial synchronisation process can go faster if you skip verification of older transactions. This does, however, require trusting that the &quot;assumed valid&quot; blockchain below is in fact valid. Uncheck this if you want to fully validate the entire blockchain history.</string>
-        </property>
-        <property name="wordWrap">
-         <bool>true</bool>
-        </property>
-       </widget>
-      </item>
-      <item>
-       <layout class="QHBoxLayout" name="layoutAssumeValid">
-        <item>
-         <widget class="QCheckBox" name="assumevalid">
-          <property name="toolTip">
-           <string>Reverting this setting will slow down initial synchronisation due to validating old transactions</string>
-          </property>
-          <property name="text">
-           <string>Skip validation of the transactions until after block:</string>
-          </property>
-          <property name="checked">
-           <bool>true</bool>
-          </property>
-         </widget>
-        </item>
-        <item>
-         <spacer>
-          <property name="orientation">
-           <enum>Qt::Horizontal</enum>
-          </property>
-         </spacer>
-        </item>
-       </layout>
-      </item>
-      <item>
-       <layout class="QHBoxLayout" name="layoutAssumeValidBlock">
-        <item>
-         <spacer>
-          <property name="orientation">
-           <enum>Qt::Horizontal</enum>
-          </property>
-         </spacer>
-        </item>
-        <item>
-         <widget class="QLineEdit" name="assumevalidBlock">
-          <property name="maxLength">
-           <number>64</number>
-          </property>
-         </widget>
-        </item>
-       </layout>
-      </item>
-     </layout>
-    </widget>
-   </item>
    <item>
     <spacer name="verticalSpacer">
      <property name="orientation">
diff --git a/src/qt/forms/mempoolstats.ui b/src/qt/forms/mempoolstats.ui
deleted file mode 100644
index 42ea87caf3..0000000000
--- a/src/qt/forms/mempoolstats.ui
+++ /dev/null
@@ -1,44 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>MempoolStats</class>
- <widget class="QWidget" name="MempoolStats">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>480</width>
-    <height>380</height>
-   </rect>
-  </property>
-  <property name="minimumSize">
-   <size>
-    <width>480</width>
-    <height>380</height>
-   </size>
-  </property>
-  <property name="windowTitle">
-   <string>Mempool Stats</string>
-  </property>
-  <widget class="QGraphicsView" name="graphicsView">
-   <property name="geometry">
-    <rect>
-     <x>0</x>
-     <y>0</y>
-     <width>256</width>
-     <height>200</height>
-    </rect>
-   </property>
-   <property name="styleSheet">
-    <string notr="true"/>
-   </property>
-   <property name="verticalScrollBarPolicy">
-    <enum>Qt::ScrollBarAlwaysOff</enum>
-   </property>
-   <property name="horizontalScrollBarPolicy">
-    <enum>Qt::ScrollBarAlwaysOff</enum>
-   </property>
-  </widget>
- </widget>
- <resources/>
- <connections/>
-</ui>
diff --git a/src/qt/forms/openuridialog.ui b/src/qt/forms/openuridialog.ui
index 8b7be7ec2d..97399e59a2 100644
--- a/src/qt/forms/openuridialog.ui
+++ b/src/qt/forms/openuridialog.ui
@@ -49,9 +49,6 @@
          <height>22</height>
         </size>
        </property>
-       <property name="shortcut">
-        <string>Alt+P</string>
-       </property>
       </widget>
      </item>
     </layout>
diff --git a/src/qt/forms/optionsdialog.ui b/src/qt/forms/optionsdialog.ui
index dc98151b9d..99fb238772 100644
--- a/src/qt/forms/optionsdialog.ui
+++ b/src/qt/forms/optionsdialog.ui
@@ -63,12 +63,12 @@
           </widget>
          </item>
          <item>
-          <widget class="QSpinBox" name="pruneSizeMiB"/>
+          <widget class="QSpinBox" name="pruneSize"/>
          </item>
          <item>
           <widget class="QLabel" name="pruneSizeUnitLabel">
            <property name="text">
-            <string>MiB</string>
+            <string>GB</string>
            </property>
            <property name="textFormat">
             <enum>Qt::PlainText</enum>
@@ -108,7 +108,7 @@
             <string extracomment="Tooltip text for Options window setting that sets the size of the database cache. Explains the corresponding effects of increasing/decreasing this value.">Maximum database cache size. A larger cache can contribute to faster sync, after which the benefit is less pronounced for most use cases. Lowering the cache size will reduce memory usage. Unused mempool memory is shared for this cache.</string>
            </property>
            <property name="text">
-            <string>S&amp;ize of database cache</string>
+            <string>Size of &amp;database cache</string>
            </property>
            <property name="textFormat">
             <enum>Qt::PlainText</enum>
@@ -226,27 +226,6 @@
          </property>
         </widget>
        </item>
-       <item>
-        <layout class="QHBoxLayout">
-         <item>
-          <widget class="QLabel">
-           <property name="text">
-            <string>Address type:</string>
-           </property>
-           <property name="buddy">
-            <cstring>addressType</cstring>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <widget class="QValueComboBox" name="addressType">
-           <property name="toolTip">
-            <string>Choose the default address type to select when receiving coins.</string>
-           </property>
-          </widget>
-         </item>
-        </layout>
-       </item>
        <item>
         <widget class="QGroupBox" name="groupBox">
          <property name="title">
@@ -259,7 +238,7 @@
              <string>Whether to show coin control features or not.</string>
             </property>
             <property name="text">
-             <string>Enable co&amp;in control features</string>
+             <string>Enable coin &amp;control features</string>
             </property>
            </widget>
           </item>
@@ -336,55 +315,6 @@
        <string>&amp;Network</string>
       </attribute>
       <layout class="QVBoxLayout" name="verticalLayout_Network">
-       <item>
-        <layout class="QHBoxLayout" name="horizontalLayout_Network_Port">
-         <item>
-          <widget class="QLabel" name="networkPortLabel">
-           <property name="text">
-            <string>Network &amp;port</string>
-           </property>
-           <property name="textFormat">
-            <enum>Qt::PlainText</enum>
-           </property>
-           <property name="buddy">
-            <cstring>networkPort</cstring>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <widget class="QLineEdit" name="networkPort">
-           <property name="minimumSize">
-            <size>
-             <width>55</width>
-             <height>0</height>
-            </size>
-           </property>
-           <property name="maximumSize">
-            <size>
-             <width>55</width>
-             <height>16777215</height>
-            </size>
-           </property>
-           <property name="toolTip">
-            <string>Network port (e.g. 8333)</string>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <spacer name="horizontalSpacer_Network_Port">
-           <property name="orientation">
-            <enum>Qt::Horizontal</enum>
-           </property>
-           <property name="sizeHint" stdset="0">
-            <size>
-             <width>40</width>
-             <height>20</height>
-            </size>
-           </property>
-          </spacer>
-         </item>
-        </layout>
-       </item>
        <item>
         <widget class="QCheckBox" name="mapPortUpnp">
          <property name="toolTip">
@@ -421,7 +351,7 @@
           <string>Connect to the Bitcoin network through a SOCKS5 proxy.</string>
          </property>
          <property name="text">
-          <string>Connect through &amp;SOCKS5 proxy (default proxy):</string>
+          <string>&amp;Connect through SOCKS5 proxy (default proxy):</string>
          </property>
         </widget>
        </item>
@@ -693,66 +623,6 @@
          </item>
         </layout>
        </item>
-       <item>
-        <layout class="QHBoxLayout" name="horizontalLayout_maxuploadtarget">
-         <item>
-          <widget class="QCheckBox" name="maxuploadtargetCheckbox">
-           <property name="text">
-            <string>Try to keep upload traffic under</string>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <widget class="QSpinBox" name="maxuploadtarget"/>
-         </item>
-         <item>
-          <widget class="QLabel" name="maxuploadtargetUnitLabel">
-           <property name="text">
-            <string>MiB per day</string>
-           </property>
-           <property name="textFormat">
-            <enum>Qt::PlainText</enum>
-           </property>
-           <property name="buddy">
-            <cstring>maxuploadtargetCheckbox</cstring>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <spacer name="horizontalSpacer_maxuploadtarget">
-           <property name="orientation">
-            <enum>Qt::Horizontal</enum>
-           </property>
-           <property name="sizeHint" stdset="0">
-            <size>
-             <width>40</width>
-             <height>20</height>
-            </size>
-           </property>
-          </spacer>
-         </item>
-        </layout>
-       </item>
-       <item>
-        <widget class="QCheckBox" name="peerbloomfilters">
-         <property name="toolTip">
-          <string>Support filtering of blocks and transaction with bloom filters</string>
-         </property>
-         <property name="text">
-          <string>Provide search services for light clients</string>
-         </property>
-        </widget>
-       </item>
-       <item>
-        <widget class="QCheckBox" name="peerblockfilters">
-         <property name="toolTip">
-          <string>Generate compact block filters and allow peers to download them</string>
-         </property>
-         <property name="text">
-          <string>Provide compact block filters for light clients</string>
-         </property>
-        </widget>
-       </item>
        <item>
         <spacer name="verticalSpacer_Network">
          <property name="orientation">
@@ -792,7 +662,7 @@
           <string>Show only a tray icon after minimizing the window.</string>
          </property>
          <property name="text">
-          <string>Minimize to the &amp;tray instead of the taskbar</string>
+          <string>&amp;Minimize to the tray instead of the taskbar</string>
          </property>
         </widget>
        </item>
@@ -874,16 +744,6 @@
          </item>
         </layout>
        </item>
-       <item>
-        <widget class="QCheckBox" name="displayAddresses">
-         <property name="toolTip">
-          <string>Whether to show Bitcoin addresses in the transaction list or not.</string>
-         </property>
-         <property name="text">
-          <string>&amp;Display addresses in transaction list</string>
-         </property>
-        </widget>
-       </item>
        <item>
         <layout class="QHBoxLayout" name="horizontalLayout_3_Display">
          <item>
@@ -892,7 +752,7 @@
             <string>Third-party URLs (e.g. a block explorer) that appear in the transactions tab as context menu items. %s in the URL is replaced by transaction hash. Multiple URLs are separated by vertical bar |.</string>
            </property>
            <property name="text">
-            <string>&amp;Third-party transaction URLs:</string>
+            <string>&amp;Third-party transaction URLs</string>
            </property>
            <property name="buddy">
             <cstring>thirdPartyTxUrls</cstring>
@@ -936,41 +796,6 @@
          </item>
         </layout>
        </item>
-       <item>
-        <layout class="QHBoxLayout" name="horizontalLayout_qrFont">
-         <item>
-          <widget class="QLabel" name="qrFontLabel">
-           <property name="text">
-            <string>Font in QR Codes: </string>
-           </property>
-           <property name="buddy">
-            <cstring>qrFont</cstring>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <widget class="QComboBox" name="qrFont"/>
-         </item>
-         <item>
-          <widget class="QLabel" name="qrFont_preview">
-           <property name="text">
-            <string notr="true">1NS17iag9jJgT…
-bc1p2q3rvn3gp…</string>
-           </property>
-          </widget>
-         </item>
-        </layout>
-       </item>
-       <item>
-        <widget class="QCheckBox" name="peersTabAlternatingRowColors">
-         <property name="toolTip">
-          <string>Alternate the row colors for the &quot;Peers&quot; and &quot;Banned peers&quot; tables in the Peers tab.</string>
-         </property>
-         <property name="text">
-          <string>Alternate row colors in the Peers tab</string>
-         </property>
-        </widget>
-       </item>
        <item>
         <spacer name="verticalSpacer_Display">
          <property name="orientation">
diff --git a/src/qt/forms/receivecoinsdialog.ui b/src/qt/forms/receivecoinsdialog.ui
index c9948fe39b..7590dd524d 100644
--- a/src/qt/forms/receivecoinsdialog.ui
+++ b/src/qt/forms/receivecoinsdialog.ui
@@ -108,7 +108,7 @@
              </size>
             </property>
             <property name="text">
-             <string>&amp;Request payment</string>
+             <string>&amp;Create new receiving address</string>
             </property>
             <property name="icon">
              <iconset resource="../bitcoin.qrc">
diff --git a/src/qt/forms/receiverequestdialog.ui b/src/qt/forms/receiverequestdialog.ui
index 56107761d4..70a7cf71de 100644
--- a/src/qt/forms/receiverequestdialog.ui
+++ b/src/qt/forms/receiverequestdialog.ui
@@ -6,14 +6,17 @@
    <rect>
     <x>0</x>
     <y>0</y>
-    <width>487</width>
-    <height>597</height>
+    <width>413</width>
+    <height>229</height>
    </rect>
   </property>
   <property name="windowTitle">
    <string>Request payment to …</string>
   </property>
   <layout class="QGridLayout" name="gridLayout" columnstretch="0,1">
+   <property name="sizeConstraint">
+    <enum>QLayout::SetFixedSize</enum>
+   </property>
    <item row="0" column="0" colspan="2" alignment="Qt::AlignHCenter">
     <widget class="QRImageWidget" name="qr_code">
      <property name="text">
diff --git a/src/qt/forms/signverifymessagedialog.ui b/src/qt/forms/signverifymessagedialog.ui
index f42d19093b..b72360b586 100644
--- a/src/qt/forms/signverifymessagedialog.ui
+++ b/src/qt/forms/signverifymessagedialog.ui
@@ -30,7 +30,7 @@
        <item>
         <widget class="QLabel" name="infoLabel_SM">
          <property name="text">
-          <string>You can sign messages/agreements with your addresses to prove you can receive bitcoins sent to them. Be careful not to sign anything vague or random, as phishing attacks may try to trick you into signing your identity over to them. Only sign fully-detailed statements you agree to.</string>
+          <string>You can sign messages/agreements with your legacy (P2PKH) addresses to prove you can receive bitcoins sent to them. Be careful not to sign anything vague or random, as phishing attacks may try to trick you into signing your identity over to them. Only sign fully-detailed statements you agree to.</string>
          </property>
          <property name="textFormat">
           <enum>Qt::PlainText</enum>
diff --git a/src/qt/guiconstants.h b/src/qt/guiconstants.h
index 6f368dabc8..30ffa302a4 100644
--- a/src/qt/guiconstants.h
+++ b/src/qt/guiconstants.h
@@ -26,10 +26,6 @@ static const bool DEFAULT_SPLASHSCREEN = true;
 
 /* Invalid field background style */
 #define STYLE_INVALID "border: 3px solid #FF8080"
-/* "Warning" field background style */
-#define STYLE_INCORRECT "border: 3px solid #FFFF80"
-/* Background style for active search in NetWatch */
-#define STYLE_ACTIVE "border: 3px solid #80FF80"
 
 /* Transaction list -- unconfirmed transaction */
 #define COLOR_UNCONFIRMED QColor(128, 128, 128)
@@ -58,13 +54,10 @@ static const int TOOLTIP_WRAP_THRESHOLD = 80;
 #define QAPP_APP_NAME_SIGNET "Bitcoin-Qt-signet"
 #define QAPP_APP_NAME_REGTEST "Bitcoin-Qt-regtest"
 
-/* One mebibyte (MiB) in bytes */
-static constexpr uint64_t MiB_BYTES{1024 * 1024};
-
 /* One gigabyte (GB) in bytes */
 static constexpr uint64_t GB_BYTES{1000000000};
 
 // Default prune target displayed in GUI.
-static constexpr int DEFAULT_PRUNE_TARGET_MiB{1907};
+static constexpr int DEFAULT_PRUNE_TARGET_GB{2};
 
 #endif // BITCOIN_QT_GUICONSTANTS_H
diff --git a/src/qt/guiutil.cpp b/src/qt/guiutil.cpp
index ebaeffb35b..2369f6b631 100644
--- a/src/qt/guiutil.cpp
+++ b/src/qt/guiutil.cpp
@@ -87,19 +87,9 @@ using namespace std::chrono_literals;
 
 namespace GUIUtil {
 
-QString dateStr(const QDate &date)
-{
-    return QLocale::system().toString(date, QLocale::ShortFormat);
-}
-
-QString dateStr(qint64 nTime)
-{
-    return dateStr(QDateTime::fromSecsSinceEpoch(nTime).date());
-}
-
 QString dateTimeStr(const QDateTime &date)
 {
-    return dateStr(date.date()) + QString(" ") + date.toString("hh:mm");
+    return QLocale::system().toString(date.date(), QLocale::ShortFormat) + QString(" ") + date.toString("hh:mm");
 }
 
 QString dateTimeStr(qint64 nTime)
@@ -156,39 +146,6 @@ void AddButtonShortcut(QAbstractButton* button, const QKeySequence& shortcut)
     QObject::connect(new QShortcut(shortcut, button), &QShortcut::activated, [button]() { button->animateClick(); });
 }
 
-qint64 URIParseAmount(std::string amount_str, bool * const ok)
-{
-    bool is_hex = false;
-    if (amount_str[0] == 'x' || amount_str[0] == 'X') {
-        is_hex = true;
-        amount_str = amount_str.substr(1);
-    }
-    size_t exponent_sep_pos = amount_str.find_first_of("Xx", 1);
-    int exponent;
-    if (exponent_sep_pos != std::string::npos) {
-        exponent = QString::fromStdString(amount_str.substr(exponent_sep_pos + 1)).toInt(ok, is_hex ? 0x10 : 10);
-        if (!*ok) return -1;
-    } else {
-        exponent = is_hex ? 4 : 8;
-        exponent_sep_pos = amount_str.size();
-    }
-    size_t fractional_sep_pos = amount_str.find('.');
-    size_t fractional_digits = 0;
-    if (fractional_sep_pos == std::string::npos)
-        fractional_sep_pos = exponent_sep_pos;
-    else
-        fractional_digits = (exponent_sep_pos - fractional_sep_pos) - 1;
-    exponent -= fractional_digits;
-    amount_str = amount_str.substr(0, fractional_sep_pos) + (fractional_digits ? amount_str.substr(fractional_sep_pos + 1, fractional_digits) : "");
-    if (exponent > 0) {
-        amount_str.append(exponent, '0');
-    } else if (exponent < 0) {
-        // Sub-satoshi amount? Truncate
-        amount_str = amount_str.substr(0, amount_str.size() + exponent);
-    }
-    return QString::fromStdString(amount_str).toLongLong(ok, is_hex ? 0x10 : 10);
-}
-
 bool parseBitcoinURI(const QUrl &uri, SendCoinsRecipient *out)
 {
     // return if URI is not valid or is no bitcoin: URI
@@ -228,9 +185,9 @@ bool parseBitcoinURI(const QUrl &uri, SendCoinsRecipient *out)
         {
             if(!i->second.isEmpty())
             {
-                bool ok;
-                rv.amount = URIParseAmount((i->second).toStdString(), &ok);
-                if (!ok) return false;
+                if (!BitcoinUnits::parse(BitcoinUnit::BTC, i->second, &rv.amount)) {
+                    return false;
+                }
             }
             fShouldReturnFalse = false;
         }
@@ -556,120 +513,6 @@ bool LabelOutOfFocusEventFilter::eventFilter(QObject* watched, QEvent* event)
     return QObject::eventFilter(watched, event);
 }
 
-void TableViewLastColumnResizingFixer::connectViewHeadersSignals()
-{
-    connect(tableView->horizontalHeader(), &QHeaderView::sectionResized, this, &TableViewLastColumnResizingFixer::on_sectionResized);
-    connect(tableView->horizontalHeader(), &QHeaderView::geometriesChanged, this, &TableViewLastColumnResizingFixer::on_geometriesChanged);
-}
-
-// We need to disconnect these while handling the resize events, otherwise we can enter infinite loops.
-void TableViewLastColumnResizingFixer::disconnectViewHeadersSignals()
-{
-    disconnect(tableView->horizontalHeader(), &QHeaderView::sectionResized, this, &TableViewLastColumnResizingFixer::on_sectionResized);
-    disconnect(tableView->horizontalHeader(), &QHeaderView::geometriesChanged, this, &TableViewLastColumnResizingFixer::on_geometriesChanged);
-}
-
-// Setup the resize mode, handles compatibility for Qt5 and below as the method signatures changed.
-// Refactored here for readability.
-void TableViewLastColumnResizingFixer::setViewHeaderResizeMode(int logicalIndex, QHeaderView::ResizeMode resizeMode)
-{
-    tableView->horizontalHeader()->setSectionResizeMode(logicalIndex, resizeMode);
-}
-
-void TableViewLastColumnResizingFixer::resizeColumn(int nColumnIndex, int width)
-{
-    tableView->setColumnWidth(nColumnIndex, width);
-    tableView->horizontalHeader()->resizeSection(nColumnIndex, width);
-}
-
-int TableViewLastColumnResizingFixer::getColumnsWidth()
-{
-    int nColumnsWidthSum = 0;
-    for (int i = 0; i < columnCount; i++)
-    {
-        nColumnsWidthSum += tableView->horizontalHeader()->sectionSize(i);
-    }
-    return nColumnsWidthSum;
-}
-
-int TableViewLastColumnResizingFixer::getAvailableWidthForColumn(int column)
-{
-    int nResult = lastColumnMinimumWidth;
-    int nTableWidth = tableView->horizontalHeader()->width();
-
-    if (nTableWidth > 0)
-    {
-        int nOtherColsWidth = getColumnsWidth() - tableView->horizontalHeader()->sectionSize(column);
-        nResult = std::max(nResult, nTableWidth - nOtherColsWidth);
-    }
-
-    return nResult;
-}
-
-// Make sure we don't make the columns wider than the table's viewport width.
-void TableViewLastColumnResizingFixer::adjustTableColumnsWidth()
-{
-    disconnectViewHeadersSignals();
-    resizeColumn(lastColumnIndex, getAvailableWidthForColumn(lastColumnIndex));
-    connectViewHeadersSignals();
-
-    int nTableWidth = tableView->horizontalHeader()->width();
-    int nColsWidth = getColumnsWidth();
-    if (nColsWidth > nTableWidth)
-    {
-        resizeColumn(secondToLastColumnIndex,getAvailableWidthForColumn(secondToLastColumnIndex));
-    }
-}
-
-// Make column use all the space available, useful during window resizing.
-void TableViewLastColumnResizingFixer::stretchColumnWidth(int column)
-{
-    disconnectViewHeadersSignals();
-    resizeColumn(column, getAvailableWidthForColumn(column));
-    connectViewHeadersSignals();
-}
-
-// When a section is resized this is a slot-proxy for ajustAmountColumnWidth().
-void TableViewLastColumnResizingFixer::on_sectionResized(int logicalIndex, int oldSize, int newSize)
-{
-    adjustTableColumnsWidth();
-    int remainingWidth = getAvailableWidthForColumn(logicalIndex);
-    if (newSize > remainingWidth)
-    {
-       resizeColumn(logicalIndex, remainingWidth);
-    }
-}
-
-// When the table's geometry is ready, we manually perform the stretch of the "Message" column,
-// as the "Stretch" resize mode does not allow for interactive resizing.
-void TableViewLastColumnResizingFixer::on_geometriesChanged()
-{
-    if ((getColumnsWidth() - this->tableView->horizontalHeader()->width()) != 0)
-    {
-        disconnectViewHeadersSignals();
-        resizeColumn(secondToLastColumnIndex, getAvailableWidthForColumn(secondToLastColumnIndex));
-        connectViewHeadersSignals();
-    }
-}
-
-/**
- * Initializes all internal variables and prepares the
- * the resize modes of the last 2 columns of the table and
- */
-TableViewLastColumnResizingFixer::TableViewLastColumnResizingFixer(QTableView* table, int lastColMinimumWidth, int allColsMinimumWidth, QObject *parent) :
-    QObject(parent),
-    tableView(table),
-    lastColumnMinimumWidth(lastColMinimumWidth),
-    allColumnsMinimumWidth(allColsMinimumWidth)
-{
-    columnCount = tableView->horizontalHeader()->count();
-    lastColumnIndex = columnCount - 1;
-    secondToLastColumnIndex = columnCount - 2;
-    tableView->horizontalHeader()->setMinimumSectionSize(allColumnsMinimumWidth);
-    setViewHeaderResizeMode(secondToLastColumnIndex, QHeaderView::Interactive);
-    setViewHeaderResizeMode(lastColumnIndex, QHeaderView::Interactive);
-}
-
 #ifdef WIN32
 fs::path static StartupShortcutPath()
 {
@@ -783,14 +626,8 @@ bool GetStartOnSystemStartup()
 
 bool SetStartOnSystemStartup(bool fAutoStart)
 {
-    if (!fAutoStart) {
-        try {
-            fs::remove(GetAutostartFilePath());
-        } catch(const fs::filesystem_error& e) {
-            LogPrintf("Failed to remove autostart file: %s\n", e.what());
-            return false;
-        }
-    }
+    if (!fAutoStart)
+        fs::remove(GetAutostartFilePath());
     else
     {
         char pszExePath[MAX_PATH+1];
@@ -800,12 +637,7 @@ bool SetStartOnSystemStartup(bool fAutoStart)
         }
         pszExePath[r] = '\0';
 
-        try {
-            fs::create_directories(GetAutostartDir());
-        } catch(const fs::filesystem_error& e) {
-            LogPrintf("Failed to create autostart directory: %s\n", e.what());
-            return false;
-        }
+        fs::create_directories(GetAutostartDir());
 
         std::ofstream optionFile{GetAutostartFilePath(), std::ios_base::out | std::ios_base::trunc};
         if (!optionFile.good())
@@ -1001,40 +833,6 @@ QString formatBytes(uint64_t bytes)
     return QObject::tr("%1 GB").arg(bytes / 1'000'000'000);
 }
 
-QString formatBytesps(float val)
-{
-    if (val < 10)
-        //: "Bytes per second"
-        return QObject::tr("%1 B/s").arg(0.01 * int(val * 100));
-    if (val < 100)
-        //: "Bytes per second"
-        return QObject::tr("%1 B/s").arg(0.1 * int(val * 10));
-    if (val < 1'000)
-        //: "Bytes per second"
-        return QObject::tr("%1 B/s").arg((int)val);
-    if (val < 10'000)
-        //: "Kilobytes per second"
-        return QObject::tr("%1 kB/s").arg(0.01 * ((int)val / 10));
-    if (val < 100'000)
-        //: "Kilobytes per second"
-        return QObject::tr("%1 kB/s").arg(0.1 * ((int)val / 100));
-    if (val < 1'000'000)
-        //: "Kilobytes per second"
-        return QObject::tr("%1 kB/s").arg((int)val / 1'000);
-    if (val < 10'000'000)
-        //: "Megabytes per second"
-        return QObject::tr("%1 MB/s").arg(0.01 * ((int)val / 10'000));
-    if (val < 100'000'000)
-        //: "Megabytes per second"
-        return QObject::tr("%1 MB/s").arg(0.1 * ((int)val / 100'000));
-    if (val < 10'000'000'000)
-        //: "Megabytes per second"
-        return QObject::tr("%1 MB/s").arg((long)val / 1'000'000);
-
-    //: "Gigabytes per second"
-    return QObject::tr("%1 GB/s").arg((long)val / 1'000'000'000);
-}
-
 qreal calculateIdealFontSize(int width, const QString& text, QFont font, qreal minPointSize, qreal font_size) {
     while(font_size >= minPointSize) {
         font.setPointSizeF(font_size);
@@ -1203,18 +1001,15 @@ void PrintSlotException(
     PrintExceptionContinue(exception, description);
 }
 
-void ShowModalDialogAsynchronously(QDialog* dialog, const Qt::WindowModality modality)
+void ShowModalDialogAsynchronously(QDialog* dialog)
 {
     dialog->setAttribute(Qt::WA_DeleteOnClose);
-    dialog->setWindowModality(modality);
+    dialog->setWindowModality(Qt::ApplicationModal);
     dialog->show();
 }
 
 QString WalletDisplayName(const QString& name)
 {
-    if (name.endsWith(".dat")) {
-        return name.chopped(4);
-    }
     return name.isEmpty() ? "[" + QObject::tr("default wallet") + "]" : name;
 }
 
diff --git a/src/qt/guiutil.h b/src/qt/guiutil.h
index bcf7dc29a0..4525198794 100644
--- a/src/qt/guiutil.h
+++ b/src/qt/guiutil.h
@@ -22,7 +22,6 @@
 #include <QProgressBar>
 #include <QString>
 #include <QTableView>
-#include <Qt>
 
 #include <cassert>
 #include <chrono>
@@ -61,8 +60,6 @@ namespace GUIUtil
     constexpr auto dialog_flags = Qt::WindowTitleHint | Qt::WindowSystemMenuHint | Qt::WindowCloseButtonHint;
 
     // Create human-readable string from date
-    QString dateStr(const QDate &datetime);
-    QString dateStr(qint64 nTime);
     QString dateTimeStr(const QDateTime &datetime);
     QString dateTimeStr(qint64 nTime);
 
@@ -216,45 +213,6 @@ namespace GUIUtil
         bool eventFilter(QObject* watched, QEvent* event) override;
     };
 
-    /**
-     * Makes a QTableView last column feel as if it was being resized from its left border.
-     * Also makes sure the column widths are never larger than the table's viewport.
-     * In Qt, all columns are resizable from the right, but it's not intuitive resizing the last column from the right.
-     * Usually our second to last columns behave as if stretched, and when on stretch mode, columns aren't resizable
-     * interactively or programmatically.
-     *
-     * This helper object takes care of this issue.
-     *
-     */
-    class TableViewLastColumnResizingFixer: public QObject
-    {
-        Q_OBJECT
-
-        public:
-            TableViewLastColumnResizingFixer(QTableView* table, int lastColMinimumWidth, int allColsMinimumWidth, QObject *parent);
-            void stretchColumnWidth(int column);
-
-        private:
-            QTableView* tableView;
-            int lastColumnMinimumWidth;
-            int allColumnsMinimumWidth;
-            int lastColumnIndex;
-            int columnCount;
-            int secondToLastColumnIndex;
-
-            void adjustTableColumnsWidth();
-            int getAvailableWidthForColumn(int column);
-            int getColumnsWidth();
-            void connectViewHeadersSignals();
-            void disconnectViewHeadersSignals();
-            void setViewHeaderResizeMode(int logicalIndex, QHeaderView::ResizeMode resizeMode);
-            void resizeColumn(int nColumnIndex, int width);
-
-        private Q_SLOTS:
-            void on_sectionResized(int logicalIndex, int oldSize, int newSize);
-            void on_geometriesChanged();
-    };
-
     bool GetStartOnSystemStartup();
     bool SetStartOnSystemStartup(bool fAutoStart);
 
@@ -288,7 +246,6 @@ namespace GUIUtil
     QString formatNiceTimeOffset(qint64 secs);
 
     QString formatBytes(uint64_t bytes);
-    QString formatBytesps(float bytes);
 
     qreal calculateIdealFontSize(int width, const QString& text, QFont font, qreal minPointSize = 4, qreal startPointSize = 14);
 
@@ -468,7 +425,7 @@ namespace GUIUtil
     /**
      * Shows a QDialog instance asynchronously, and deletes it on close.
      */
-    void ShowModalDialogAsynchronously(QDialog* dialog, Qt::WindowModality modality=Qt::ApplicationModal);
+    void ShowModalDialogAsynchronously(QDialog* dialog);
 
     inline bool IsEscapeOrBack(int key)
     {
diff --git a/src/qt/intro.cpp b/src/qt/intro.cpp
index 4ba510a95d..26b42deb64 100644
--- a/src/qt/intro.cpp
+++ b/src/qt/intro.cpp
@@ -45,7 +45,6 @@ public:
     enum Status {
         ST_OK,
         ST_ERROR
-        ,ST_WARNING
     };
 
 public Q_SLOTS:
@@ -101,13 +100,6 @@ void FreespaceChecker::check()
                 replyMessage = tr("Path already exists, and is not a directory.");
             }
         }
-#ifdef __APPLE__
-        const FSType fs_type = GetFilesystemType(parentDir);
-        if (fs_type == FSType::EXFAT) {
-            replyStatus = ST_WARNING;
-            replyMessage = tr("Path is on ExFAT filesystem, known to cause corruption on macOS.");
-        }
-#endif
     } catch (const fs::filesystem_error&)
     {
         /* Parent directory does not exist or is not accessible */
@@ -119,11 +111,11 @@ void FreespaceChecker::check()
 
 namespace {
 //! Return pruning size that will be used if automatic pruning is enabled.
-int GetPruneTargetMiB()
+int GetPruneTargetGB()
 {
     int64_t prune_target_mib = gArgs.GetIntArg("-prune", 0);
     // >1 means automatic pruning is enabled by config, 1 means manual pruning, 0 means no pruning.
-    return prune_target_mib > 1 ? prune_target_mib : DEFAULT_PRUNE_TARGET_MiB;
+    return prune_target_mib > 1 ? PruneMiBtoGB(prune_target_mib) : DEFAULT_PRUNE_TARGET_GB;
 }
 } // namespace
 
@@ -132,7 +124,7 @@ Intro::Intro(QWidget *parent, int64_t blockchain_size_gb, int64_t chain_state_si
     ui(new Ui::Intro),
     m_blockchain_size_gb(blockchain_size_gb),
     m_chain_state_size_gb(chain_state_size_gb),
-    m_prune_target_mib{GetPruneTargetMiB()}
+    m_prune_target_gb{GetPruneTargetGB()}
 {
     ui->setupUi(this);
     ui->welcomeLabel->setText(ui->welcomeLabel->text().arg(PACKAGE_NAME));
@@ -146,69 +138,29 @@ Intro::Intro(QWidget *parent, int64_t blockchain_size_gb, int64_t chain_state_si
     );
     ui->lblExplanation2->setText(ui->lblExplanation2->text().arg(PACKAGE_NAME));
 
-    const int min_prune_target_MiB = (MIN_DISK_SPACE_FOR_BLOCK_FILES + MiB_BYTES - 1) / MiB_BYTES;
-    ui->pruneMiB->setRange(min_prune_target_MiB, std::numeric_limits<int>::max());
+    const int min_prune_target_GB = std::ceil(MIN_DISK_SPACE_FOR_BLOCK_FILES / 1e9);
+    ui->pruneGB->setRange(min_prune_target_GB, std::numeric_limits<int>::max());
     if (gArgs.IsArgSet("-prune")) {
         m_prune_checkbox_is_default = false;
-        switch (gArgs.GetIntArg("-prune", 0)) {
-        case 0:
-            ui->prune->setChecked(false);
-            break;
-        case 1:
-            ui->prune->setTristate();
-            ui->prune->setCheckState(Qt::PartiallyChecked);
-            break;
-        default:
-            ui->prune->setChecked(true);
-        }
+        ui->prune->setChecked(gArgs.GetIntArg("-prune", 0) >= 1);
+        ui->prune->setEnabled(false);
     }
-    ui->pruneMiB->setValue(m_prune_target_mib);
-    ui->pruneMiB->setToolTip(ui->prune->toolTip());
+    ui->pruneGB->setValue(m_prune_target_gb);
+    ui->pruneGB->setToolTip(ui->prune->toolTip());
     ui->lblPruneSuffix->setToolTip(ui->prune->toolTip());
-    UpdatePruneLabels(ui->prune->checkState() == Qt::Checked);
+    UpdatePruneLabels(ui->prune->isChecked());
 
-    connect(ui->prune, &QCheckBox::stateChanged, [this](int prune_state) {
+    connect(ui->prune, &QCheckBox::toggled, [this](bool prune_checked) {
         m_prune_checkbox_is_default = false;
-        UpdatePruneLabels(prune_state == Qt::Checked);
+        UpdatePruneLabels(prune_checked);
         UpdateFreeSpaceLabel();
     });
-    connect(ui->pruneMiB, qOverload<int>(&QSpinBox::valueChanged), [this](int prune_MiB) {
-        m_prune_target_mib = prune_MiB;
-        UpdatePruneLabels(ui->prune->checkState() == Qt::Checked);
+    connect(ui->pruneGB, qOverload<int>(&QSpinBox::valueChanged), [this](int prune_GB) {
+        m_prune_target_gb = prune_GB;
+        UpdatePruneLabels(ui->prune->isChecked());
         UpdateFreeSpaceLabel();
     });
 
-    bool have_user_assumevalid = false;
-    if (gArgs.IsArgSet("-assumevalid")) {
-        const auto user_assumevalid = gArgs.GetArg("-assumevalid", /* ignored default; determines return type */ "");
-        if (uint256S(user_assumevalid).IsNull()) {
-            // -assumevalid=0: default checkbox to off, and initialise with chainparams later
-            ui->assumevalid->setChecked(false);
-        } else {
-            // -assumevalid=blockhash: initialise with the user-specified value, enabled
-            ui->assumevalid->setChecked(true);
-            ui->assumevalidBlock->setText(QString::fromStdString(user_assumevalid));
-            have_user_assumevalid = true;
-        }
-    }
-    if (!have_user_assumevalid) {
-        const auto chainparams = CreateChainParams(gArgs, gArgs.GetChainType());
-        const uint256 default_assumevalid = chainparams ? chainparams->GetConsensus().defaultAssumeValid : uint256();
-        if (default_assumevalid.IsNull()) {
-            // no chainparams assumevalid (nor user-provided), so hide the options entirely
-            ui->groupAssumeValid->setVisible(false);
-        } else {
-            // assumevalid from chainparams only (normal case): disable editing of blockhash
-            ui->assumevalidBlock->setText(QString::fromStdString(default_assumevalid.GetHex()));
-            ui->assumevalidBlock->setReadOnly(true);
-        }
-    }
-    {
-        // TODO: Ideally, we would include actual margins here (instead of extra digits), but this seems non-trivial
-        const int text_width = ui->assumevalidBlock->fontMetrics().horizontalAdvance(QStringLiteral("4")) * (64 + 4);
-        ui->assumevalidBlock->setFixedWidth(text_width);
-    }
-
     startThread();
 }
 
@@ -244,25 +196,15 @@ int64_t Intro::getPruneMiB() const
 {
     switch (ui->prune->checkState()) {
     case Qt::Checked:
-        return m_prune_target_mib;
-    case Qt::PartiallyChecked:
-        return 1;
+        return PruneGBtoMiB(m_prune_target_gb);
     case Qt::Unchecked: default:
         return 0;
     }
 }
 
-QString Intro::getAssumeValid() const
+bool Intro::showIfNeeded(bool& did_show_intro, int64_t& prune_MiB)
 {
-    if (!ui->assumevalid->isChecked()) {
-        return QStringLiteral("0");
-    }
-    return ui->assumevalidBlock->text();
-}
-
-bool Intro::showIfNeeded(std::unique_ptr<Intro>& intro)
-{
-    intro.reset();
+    did_show_intro = false;
 
     QSettings settings;
     /* If data directory provided on command line, no need to look at settings
@@ -284,18 +226,19 @@ bool Intro::showIfNeeded(std::unique_ptr<Intro>& intro)
         }
 
         /* If current default data directory does not exist, let the user choose one */
-        intro = std::make_unique<Intro>(nullptr, Params().AssumedBlockchainSize(), Params().AssumedChainStateSize());
-        intro->setDataDirectory(dataDir);
-        intro->setWindowIcon(QIcon(QStringLiteral(":icons/bitcoin")));
+        Intro intro(nullptr, Params().AssumedBlockchainSize(), Params().AssumedChainStateSize());
+        intro.setDataDirectory(dataDir);
+        intro.setWindowIcon(QIcon(":icons/bitcoin"));
+        did_show_intro = true;
 
         while(true)
         {
-            if(!intro->exec())
+            if(!intro.exec())
             {
                 /* Cancel clicked */
                 return false;
             }
-            dataDir = intro->getDataDirectory();
+            dataDir = intro.getDataDirectory();
             try {
                 if (TryCreateDirectories(GUIUtil::QStringToPath(dataDir))) {
                     // If a new data directory has been created, make wallets subdirectory too
@@ -309,6 +252,9 @@ bool Intro::showIfNeeded(std::unique_ptr<Intro>& intro)
             }
         }
 
+        // Additional preferences:
+        prune_MiB = intro.getPruneMiB();
+
         settings.setValue("strDataDir", dataDir);
         settings.setValue("fReset", false);
     }
@@ -324,7 +270,6 @@ bool Intro::showIfNeeded(std::unique_ptr<Intro>& intro)
 
 void Intro::setStatus(int status, const QString &message, quint64 bytesAvailable)
 {
-    m_warning_msg = "";
     switch(status)
     {
     case FreespaceChecker::ST_OK:
@@ -335,11 +280,6 @@ void Intro::setStatus(int status, const QString &message, quint64 bytesAvailable
         ui->errorMessage->setText(tr("Error") + ": " + message);
         ui->errorMessage->setStyleSheet("QLabel { color: #800000 }");
         break;
-    case FreespaceChecker::ST_WARNING:
-        m_warning_msg = tr("Warning") + ": " + message;
-        ui->errorMessage->setText(m_warning_msg);
-        ui->errorMessage->setStyleSheet("QLabel { color: #800000 }");
-        break;
     }
     /* Indicate number of bytes available */
     if(status == FreespaceChecker::ST_ERROR)
@@ -356,14 +296,6 @@ void Intro::setStatus(int status, const QString &message, quint64 bytesAvailable
     ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(status != FreespaceChecker::ST_ERROR);
 }
 
-void Intro::accept()
-{
-    if ((!m_warning_msg.isEmpty()) && QMessageBox::warning(this, PACKAGE_NAME, m_warning_msg + "<br><br>" + tr("Ignore warning?"), QMessageBox::Ignore | QMessageBox::Cancel) == QMessageBox::Cancel) {
-        return;
-    }
-    QDialog::accept();
-}
-
 void Intro::UpdateFreeSpaceLabel()
 {
     QString freeString = tr("%n GB of space available", "", m_bytes_available / GB_BYTES);
@@ -371,7 +303,7 @@ void Intro::UpdateFreeSpaceLabel()
         freeString += " " + tr("(of %n GB needed)", "", m_required_space_gb);
         ui->freeSpace->setStyleSheet("QLabel { color: #800000 }");
     } else if (m_bytes_available / GB_BYTES - m_required_space_gb < 10) {
-        freeString += " " + tr("(%n GB needed)", "", m_required_space_gb);
+        freeString += " " + tr("(%n GB needed for full chain)", "", m_required_space_gb);
         ui->freeSpace->setStyleSheet("QLabel { color: #999900 }");
     } else {
         ui->freeSpace->setStyleSheet("");
@@ -444,15 +376,15 @@ void Intro::UpdatePruneLabels(bool prune_checked)
 {
     m_required_space_gb = m_blockchain_size_gb + m_chain_state_size_gb;
     QString storageRequiresMsg = tr("At least %1 GB of data will be stored in this directory, and it will grow over time.");
-    const int64_t prune_target_gb = (m_prune_target_mib * MiB_BYTES + GB_BYTES - 1) / GB_BYTES;
-    if (prune_checked && prune_target_gb <= m_blockchain_size_gb) {
-        m_required_space_gb = prune_target_gb + m_chain_state_size_gb;
+    if (prune_checked && m_prune_target_gb <= m_blockchain_size_gb) {
+        m_required_space_gb = m_prune_target_gb + m_chain_state_size_gb;
         storageRequiresMsg = tr("Approximately %1 GB of data will be stored in this directory.");
     }
-    ui->pruneMiB->setEnabled(prune_checked);
+    ui->lblExplanation3->setVisible(prune_checked);
+    ui->pruneGB->setEnabled(prune_checked);
     static constexpr uint64_t nPowTargetSpacing = 10 * 60;  // from chainparams, which we don't have at this stage
     static constexpr uint32_t expected_block_data_size = 2250000;  // includes undo data
-    const uint64_t expected_backup_days = m_prune_target_mib * MiB_BYTES / (uint64_t(expected_block_data_size) * 86400 / nPowTargetSpacing);
+    const uint64_t expected_backup_days = m_prune_target_gb * 1e9 / (uint64_t(expected_block_data_size) * 86400 / nPowTargetSpacing);
     ui->lblPruneSuffix->setText(
         //: Explanatory text on the capability of the current prune target.
         tr("(sufficient to restore backups %n day(s) old)", "", expected_backup_days));
diff --git a/src/qt/intro.h b/src/qt/intro.h
index 11c3e0150b..7b34c73b02 100644
--- a/src/qt/intro.h
+++ b/src/qt/intro.h
@@ -9,8 +9,6 @@
 #include <QMutex>
 #include <QThread>
 
-#include <memory>
-
 static const bool DEFAULT_CHOOSE_DATADIR = false;
 
 class FreespaceChecker;
@@ -39,7 +37,6 @@ public:
     QString getDataDirectory();
     void setDataDirectory(const QString &dataDir);
     int64_t getPruneMiB() const;
-    QString getAssumeValid() const;
 
     /**
      * Determine data directory. Let the user choose if the current one doesn't exist.
@@ -51,14 +48,13 @@ public:
      * @note do NOT call global gArgs.GetDataDirNet() before calling this function, this
      * will cause the wrong path to be cached.
      */
-    static bool showIfNeeded(std::unique_ptr<Intro>& intro);
+    static bool showIfNeeded(bool& did_show_intro, int64_t& prune_MiB);
 
 Q_SIGNALS:
     void requestCheck();
 
 public Q_SLOTS:
     void setStatus(int status, const QString &message, quint64 bytesAvailable);
-    void accept() override;
 
 private Q_SLOTS:
     void on_dataDirectory_textChanged(const QString &arg1);
@@ -73,13 +69,12 @@ private:
     QMutex mutex;
     bool signalled{false};
     QString pathToCheck;
-    QString m_warning_msg;
     const int64_t m_blockchain_size_gb;
     const int64_t m_chain_state_size_gb;
     //! Total required space (in GB) depending on user choice (prune or not prune).
     int64_t m_required_space_gb{0};
     uint64_t m_bytes_available{0};
-    int64_t m_prune_target_mib;
+    int64_t m_prune_target_gb;
 
     void startThread();
     void checkPath(const QString &dataDir);
diff --git a/src/qt/mempoolstats.cpp b/src/qt/mempoolstats.cpp
deleted file mode 100644
index a86e1d7f85..0000000000
--- a/src/qt/mempoolstats.cpp
+++ /dev/null
@@ -1,418 +0,0 @@
-// Copyright (c) 2016 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#include <qt/mempoolstats.h>
-#include <qt/forms/ui_mempoolstats.h>
-
-#include <qt/clientmodel.h>
-#include <qt/guiutil.h>
-#include <stats/stats.h>
-
-#include <math.h>
-
-static const char *LABEL_FONT = "Arial";
-static int LABEL_TITLE_SIZE = 22;
-static int LABEL_KV_SIZE = 12;
-
-static const int TEN_MINS = 600;
-static const int ONE_HOUR = 3600;
-static const int ONE_DAY = ONE_HOUR*24;
-
-static const int LABEL_LEFT_SIZE = 30;
-static const int LABEL_RIGHT_SIZE = 30;
-static const int GRAPH_PADDING_LEFT = 30+LABEL_LEFT_SIZE;
-static const int GRAPH_PADDING_RIGHT = 30+LABEL_RIGHT_SIZE;
-static const int GRAPH_PADDING_TOP = 10;
-static const int GRAPH_PADDING_TOP_LABEL = 150;
-static const int GRAPH_PADDING_BOTTOM = 50;
-static const int LABEL_HEIGHT = 15;
-
-void ClickableTextItem::mousePressEvent(QGraphicsSceneMouseEvent *event)
-{
-    Q_EMIT objectClicked(this);
-}
-
-void ClickableTextItem::setEnabled(bool state)
-{
-    if (state)
-        setDefaultTextColor(QColor(15,68,113, 250));
-    else
-        setDefaultTextColor(QColor(100,100,100, 200));
-}
-
-MempoolStats::MempoolStats(QWidget *parent) :
-QWidget(parent, Qt::Window),
-timeFilter(TEN_MINS),
-ui(new Ui::MempoolStats)
-{
-    ui->setupUi(this);
-    if (parent) {
-        parent->installEventFilter(this);
-        raise();
-    }
-
-    // autoadjust font size
-    QGraphicsTextItem testText("jY"); //screendesign expected 27.5 pixel in width for this string
-    testText.setFont(QFont(LABEL_FONT, LABEL_TITLE_SIZE, QFont::Light));
-    LABEL_TITLE_SIZE *= 27.5/testText.boundingRect().width();
-    LABEL_KV_SIZE *= 27.5/testText.boundingRect().width();
-
-    scene = new QGraphicsScene();
-    ui->graphicsView->setScene(scene);
-    ui->graphicsView->setRenderHints(QPainter::Antialiasing | QPainter::SmoothPixmapTransform);
-
-    if (clientModel)
-        drawChart();
-}
-
-void MempoolStats::setClientModel(ClientModel *model)
-{
-    clientModel = model;
-
-    if (model)
-        connect(model, SIGNAL(mempoolStatsDidUpdate()), this, SLOT(drawChart()));
-}
-
-void MempoolStats::drawChart()
-{
-    if (!(isVisible() && clientModel))
-        return;
-
-    if (!titleItem)
-    {
-        // create labels (only once)
-        titleItem = scene->addText(tr("Mempool Statistics"));
-        titleItem->setFont(QFont(LABEL_FONT, LABEL_TITLE_SIZE, QFont::Light));
-        titleLine = scene->addLine(0,0,100,100);
-        titleLine->setPen(QPen(QColor(100,100,100, 200), 2, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));
-
-        cbShowMemUsage = new QCheckBox("Dynamic Memory Usage");
-        cbShowMemUsage->setChecked(true);
-        dynMemUsageSwitch = scene->addWidget(cbShowMemUsage);
-        connect(cbShowMemUsage, SIGNAL(stateChanged(int)), this, SLOT(drawChart()));
-        cbShowMemUsage->setFont(QFont(LABEL_FONT, LABEL_KV_SIZE, QFont::Light));
-        dynMemUsageValueItem = scene->addText("N/A");
-        dynMemUsageValueItem->setFont(QFont(LABEL_FONT, LABEL_KV_SIZE, QFont::Bold));
-
-        cbShowNumTxns = new QCheckBox("Amount of Transactions");
-        cbShowNumTxns->setChecked(true);
-        txCountSwitch = scene->addWidget(cbShowNumTxns);
-        scene->addItem(txCountSwitch);
-        connect(cbShowNumTxns, SIGNAL(stateChanged(int)), this, SLOT(drawChart()));
-        cbShowNumTxns->setFont(QFont(LABEL_FONT, LABEL_KV_SIZE, QFont::Light));
-        txCountValueItem = scene->addText("N/A");
-        txCountValueItem->setFont(QFont(LABEL_FONT, LABEL_KV_SIZE, QFont::Bold));
-
-        cbShowMinFeerate = new QCheckBox("MinRelayFee per KB");
-        cbShowMinFeerate->setChecked(false);
-        minFeeSwitch = scene->addWidget(cbShowMinFeerate);
-        scene->addItem(minFeeSwitch);
-        connect(cbShowMinFeerate, SIGNAL(stateChanged(int)), this, SLOT(drawChart()));
-        cbShowMinFeerate->setFont(QFont(LABEL_FONT, LABEL_KV_SIZE, QFont::Light));
-        minFeeValueItem = scene->addText(tr("N/A"));
-        minFeeValueItem->setFont(QFont(LABEL_FONT, LABEL_KV_SIZE, QFont::Bold));
-
-        noDataItem = scene->addText(tr("No Data available"));
-        noDataItem->setFont(QFont(LABEL_FONT, LABEL_TITLE_SIZE, QFont::Light));
-        noDataItem->setDefaultTextColor(QColor(100,100,100, 200));
-
-        last10MinLabel = new ClickableTextItem(); last10MinLabel->setPlainText(tr("Last 10 min"));
-        scene->addItem(last10MinLabel);
-        connect(last10MinLabel, SIGNAL(objectClicked(QGraphicsItem*)), this, SLOT(objectClicked(QGraphicsItem*)));
-        last10MinLabel->setFont(QFont(LABEL_FONT, LABEL_KV_SIZE, QFont::Light));
-        lastHourLabel = new ClickableTextItem(); lastHourLabel->setPlainText(tr("Last Hour"));
-        scene->addItem(lastHourLabel);
-        connect(lastHourLabel, SIGNAL(objectClicked(QGraphicsItem*)), this, SLOT(objectClicked(QGraphicsItem*)));
-        lastHourLabel->setFont(QFont(LABEL_FONT, LABEL_KV_SIZE, QFont::Light));
-        lastDayLabel = new ClickableTextItem(); lastDayLabel->setPlainText(tr("Last Day"));
-        scene->addItem(lastDayLabel);
-        connect(lastDayLabel, SIGNAL(objectClicked(QGraphicsItem*)), this, SLOT(objectClicked(QGraphicsItem*)));
-        lastDayLabel->setFont(QFont(LABEL_FONT, LABEL_KV_SIZE, QFont::Light));
-        allDataLabel = new ClickableTextItem(); allDataLabel->setPlainText(tr("All Data"));
-        scene->addItem(allDataLabel);
-        connect(allDataLabel, SIGNAL(objectClicked(QGraphicsItem*)), this, SLOT(objectClicked(QGraphicsItem*)));
-        allDataLabel->setFont(QFont(LABEL_FONT, LABEL_KV_SIZE, QFont::Light));
-    }
-
-    static const QString checkbox_style_base = QStringLiteral("background-color:rgb(255,255,255);");
-    cbShowNumTxns->setStyleSheet(cbShowNumTxns->isChecked() ? (checkbox_style_base + "color:rgb(188,49,62);") : checkbox_style_base);
-    cbShowMinFeerate->setStyleSheet(cbShowMinFeerate->isChecked() ? (checkbox_style_base + "color:rgb(49,113,62);") : checkbox_style_base);
-    cbShowMemUsage->setStyleSheet(cbShowMemUsage->isChecked() ? (checkbox_style_base + "color:rgb(15,68,113);") : checkbox_style_base);
-
-    last10MinLabel->setEnabled((timeFilter == TEN_MINS));
-    lastHourLabel->setEnabled((timeFilter == ONE_HOUR));
-    lastDayLabel->setEnabled((timeFilter == ONE_DAY));
-    allDataLabel->setEnabled((timeFilter == 0));
-
-    // remove the items which needs to be redrawn
-    for (QGraphicsItem * item : redrawItems)
-    {
-        scene->removeItem(item);
-        delete item;
-    }
-    redrawItems.clear();
-
-    // get the samples
-    QDateTime toDateTime = QDateTime::currentDateTime();
-    QDateTime fromDateTime = toDateTime.addSecs(-timeFilter); //-1h
-    if (timeFilter == 0)
-    {
-        // disable filter if timeFilter == 0
-        toDateTime.setTime_t(0);
-        fromDateTime.setTime_t(0);
-    }
-
-    mempoolSamples_t vSamples = clientModel->getMempoolStatsInRange(fromDateTime, toDateTime);
-
-    // set the values into the overview labels
-    if (vSamples.size())
-    {
-        dynMemUsageValueItem->setPlainText(GUIUtil::formatBytes((uint64_t)vSamples.back().m_dyn_mem_usage));
-        txCountValueItem->setPlainText(QString::number(vSamples.back().m_tx_count));
-        minFeeValueItem->setPlainText(QString::number(vSamples.back().m_min_fee_per_k));
-    }
-
-    // set dynamic label positions
-    int maxValueSize = std::max(std::max(txCountValueItem->boundingRect().width(), dynMemUsageValueItem->boundingRect().width()), minFeeValueItem->boundingRect().width());
-    maxValueSize = ceil(maxValueSize*0.11)*10; //use size steps of 10dip
-
-    int rightPaddingLabels = std::max(std::max(dynMemUsageSwitch->boundingRect().width(), txCountSwitch->boundingRect().width()), minFeeSwitch->boundingRect().width())+maxValueSize;
-    int rightPadding = 10;
-    dynMemUsageSwitch->setPos(width()-rightPaddingLabels-rightPadding, 5);
-
-    txCountSwitch->setPos(width()-rightPaddingLabels-rightPadding, dynMemUsageSwitch->pos().y()+dynMemUsageSwitch->boundingRect().height());
-
-    minFeeSwitch->setPos(width()-rightPaddingLabels-rightPadding, txCountSwitch->pos().y()+txCountSwitch->boundingRect().height());
-
-    dynMemUsageValueItem->setPos(width()-dynMemUsageValueItem->boundingRect().width()-rightPadding, dynMemUsageSwitch->pos().y());
-    txCountValueItem->setPos(width()-txCountValueItem->boundingRect().width()-rightPadding, txCountSwitch->pos().y());
-    minFeeValueItem->setPos(width()-minFeeValueItem->boundingRect().width()-rightPadding, minFeeSwitch->pos().y());
-
-    titleItem->setPos(5,minFeeSwitch->pos().y()+minFeeSwitch->boundingRect().height()-titleItem->boundingRect().height()+10);
-    titleLine->setLine(10, titleItem->pos().y()+titleItem->boundingRect().height(), width()-10, titleItem->pos().y()+titleItem->boundingRect().height());
-
-    // center the optional "no data" label
-    noDataItem->setPos(width()/2.0-noDataItem->boundingRect().width()/2.0, height()/2.0);
-
-    // set the position of the filter icons
-    static const int filterBottomPadding = 30;
-    int totalWidth = last10MinLabel->boundingRect().width()+lastHourLabel->boundingRect().width()+lastDayLabel->boundingRect().width()+allDataLabel->boundingRect().width()+30;
-    last10MinLabel->setPos((width()-totalWidth)/2.0,height()-filterBottomPadding);
-    lastHourLabel->setPos((width()-totalWidth)/2.0+last10MinLabel->boundingRect().width()+10,height()-filterBottomPadding);
-    lastDayLabel->setPos((width()-totalWidth)/2.0+last10MinLabel->boundingRect().width()+lastHourLabel->boundingRect().width()+20,height()-filterBottomPadding);
-    allDataLabel->setPos((width()-totalWidth)/2.0+last10MinLabel->boundingRect().width()+lastHourLabel->boundingRect().width()+lastDayLabel->boundingRect().width()+30,height()-filterBottomPadding);
-
-    // don't paint the grind/graph if there are no or only a single sample
-    if (vSamples.size() < 2)
-    {
-        noDataItem->setVisible(true);
-        return;
-    }
-    noDataItem->setVisible(false);
-
-    int bottom = ui->graphicsView->size().height()-GRAPH_PADDING_BOTTOM;
-    qreal maxwidth = ui->graphicsView->size().width()-GRAPH_PADDING_LEFT-GRAPH_PADDING_RIGHT;
-    qreal maxheightG = ui->graphicsView->size().height()-GRAPH_PADDING_TOP-GRAPH_PADDING_TOP_LABEL-LABEL_HEIGHT;
-    float paddingTopSizeFactor = 1.2;
-    qreal step = maxwidth/(double)vSamples.size();
-
-    // make sure we skip samples that would be drawn narrower then 1px
-    // larger window can result in drawing more samples
-    int samplesStep = 1;
-    if (step < 1)
-        samplesStep = ceil(1/samplesStep);
-
-    // find maximum values
-    int64_t maxDynMemUsage = 0;
-    int64_t minDynMemUsage = std::numeric_limits<int64_t>::max();
-    int64_t maxTxCount = 0;
-    int64_t minTxCount = std::numeric_limits<int64_t>::max();
-    int64_t maxMinFee = 0;
-    uint32_t maxTimeDetla = vSamples.back().m_time_delta-vSamples.front().m_time_delta;
-    for(const struct CStatsMempoolSample &sample : vSamples)
-    {
-        if (sample.m_dyn_mem_usage > maxDynMemUsage)
-            maxDynMemUsage = sample.m_dyn_mem_usage;
-
-        if (sample.m_dyn_mem_usage < minDynMemUsage)
-            minDynMemUsage = sample.m_dyn_mem_usage;
-
-        if (sample.m_tx_count > maxTxCount)
-            maxTxCount = sample.m_tx_count;
-
-        if (sample.m_tx_count < minTxCount)
-            minTxCount = sample.m_tx_count;
-
-        if (sample.m_min_fee_per_k > maxMinFee)
-            maxMinFee = sample.m_min_fee_per_k;
-    }
-
-    int64_t dynMemUsagelog10Val = pow(10.0, floor(log10(maxDynMemUsage*paddingTopSizeFactor-minDynMemUsage)));
-    int64_t topDynMemUsage = ceil((double)maxDynMemUsage*paddingTopSizeFactor/dynMemUsagelog10Val)*dynMemUsagelog10Val;
-    int64_t bottomDynMemUsage = floor((double)minDynMemUsage/dynMemUsagelog10Val)*dynMemUsagelog10Val;
-
-    int64_t txCountLog10Val = pow(10.0, floor(log10(maxTxCount*paddingTopSizeFactor-minTxCount)));
-    int64_t topTxCount = ceil((double)maxTxCount*paddingTopSizeFactor/txCountLog10Val)*txCountLog10Val;
-    int64_t bottomTxCount = floor((double)minTxCount/txCountLog10Val)*txCountLog10Val;
-
-    qreal currentX = GRAPH_PADDING_LEFT;
-    QPainterPath dynMemUsagePath(QPointF(currentX, bottom));
-    QPainterPath txCountPath(QPointF(currentX, bottom));
-    QPainterPath minFeePath(QPointF(currentX, bottom));
-
-    // draw the three possible paths
-    for (mempoolSamples_t::iterator it = vSamples.begin(); it != vSamples.end(); it+=samplesStep)
-    {
-        const struct CStatsMempoolSample &sample = (*it);
-        qreal xPos = maxTimeDetla > 0 ? maxwidth/maxTimeDetla*(sample.m_time_delta-vSamples.front().m_time_delta) : maxwidth/(double)vSamples.size();
-        if (sample.m_time_delta == vSamples.front().m_time_delta)
-        {
-            dynMemUsagePath.moveTo(GRAPH_PADDING_LEFT+xPos, bottom-maxheightG/(topDynMemUsage-bottomDynMemUsage)*(sample.m_dyn_mem_usage-bottomDynMemUsage));
-            txCountPath.moveTo(GRAPH_PADDING_LEFT+xPos, bottom-maxheightG/(topTxCount-bottomTxCount)*(sample.m_tx_count-bottomTxCount));
-            minFeePath.moveTo(GRAPH_PADDING_LEFT+xPos, bottom-maxheightG/maxMinFee*sample.m_min_fee_per_k);
-        }
-        else
-        {
-            dynMemUsagePath.lineTo(GRAPH_PADDING_LEFT+xPos, bottom-maxheightG/(topDynMemUsage-bottomDynMemUsage)*(sample.m_dyn_mem_usage-bottomDynMemUsage));
-            txCountPath.lineTo(GRAPH_PADDING_LEFT+xPos, bottom-maxheightG/(topTxCount-bottomTxCount)*(sample.m_tx_count-bottomTxCount));
-            minFeePath.lineTo(GRAPH_PADDING_LEFT+xPos, bottom-maxheightG/maxMinFee*sample.m_min_fee_per_k);
-        }
-    }
-
-    // copy the path for the fill
-    QPainterPath dynMemUsagePathFill(dynMemUsagePath);
-
-    // close the path for the fill
-    dynMemUsagePathFill.lineTo(GRAPH_PADDING_LEFT+maxwidth, bottom);
-    dynMemUsagePathFill.lineTo(GRAPH_PADDING_LEFT, bottom);
-
-    QPainterPath dynMemUsageGridPath(QPointF(currentX, bottom));
-
-    // draw horizontal grid
-    int amountOfLinesH = 5;
-    QFont gridFont;
-    gridFont.setPointSize(8);
-    for (int i=0; i < amountOfLinesH; i++)
-    {
-        qreal lY = bottom-i*(maxheightG/(amountOfLinesH-1));
-        dynMemUsageGridPath.moveTo(GRAPH_PADDING_LEFT, lY);
-        dynMemUsageGridPath.lineTo(GRAPH_PADDING_LEFT+maxwidth, lY);
-
-        size_t gridDynSize = (float)i*(topDynMemUsage-bottomDynMemUsage)/(amountOfLinesH-1) + bottomDynMemUsage;
-        size_t gridTxCount = (float)i*(topTxCount-bottomTxCount)/(amountOfLinesH-1) + bottomTxCount;
-
-        QGraphicsTextItem *itemDynSize = scene->addText(GUIUtil::formatBytes(gridDynSize), gridFont);
-        QGraphicsTextItem *itemTxCount = scene->addText(QString::number(gridTxCount), gridFont);
-
-        itemDynSize->setPos(GRAPH_PADDING_LEFT-itemDynSize->boundingRect().width(), lY-(itemDynSize->boundingRect().height()/2));
-        itemTxCount->setPos(GRAPH_PADDING_LEFT+maxwidth, lY-(itemDynSize->boundingRect().height()/2));
-        redrawItems.append(itemDynSize);
-        redrawItems.append(itemTxCount);
-    }
-
-    // draw vertical grid
-    int amountOfLinesV = 4;
-    QDateTime drawTime(fromDateTime);
-    std::string fromS = fromDateTime.toString().toStdString();
-    std::string toS = toDateTime.toString().toStdString();
-    qint64 secsTotal = fromDateTime.secsTo(toDateTime);
-    for (int i=0; i <= amountOfLinesV; i++)
-    {
-        qreal lX = i*(maxwidth/(amountOfLinesV));
-        dynMemUsageGridPath.moveTo(GRAPH_PADDING_LEFT+lX, bottom);
-        dynMemUsageGridPath.lineTo(GRAPH_PADDING_LEFT+lX, bottom-maxheightG);
-
-        QGraphicsTextItem *item = scene->addText(drawTime.toString("HH:mm"), gridFont);
-        item->setPos(GRAPH_PADDING_LEFT+lX-(item->boundingRect().width()/2), bottom);
-        redrawItems.append(item);
-        qint64 step = secsTotal/amountOfLinesV;
-        drawTime = drawTime.addSecs(step);
-    }
-
-    // materialize path
-    QPen gridPen(QColor(100,100,100, 200), 1, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin);
-    redrawItems.append(scene->addPath(dynMemUsageGridPath, gridPen));
-
-    // draw semi-transparent gradient for the dynamic memory size fill
-    QLinearGradient gradient(currentX, bottom, currentX, 0);
-    gradient.setColorAt(1.0, QColor(15,68,113, 250));
-    gradient.setColorAt(0, QColor(255,255,255,0));
-    QBrush graBru(gradient);
-
-    QPen linePenBlue(QColor(15,68,113, 250), 2, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin);
-    QPen linePenRed(QColor(188,49,62, 250), 2, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin);
-    QPen linePenGreen(QColor(49,188,62, 250), 2, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin);
-
-    if (cbShowNumTxns->isChecked())
-        redrawItems.append(scene->addPath(txCountPath, linePenRed));
-    if (cbShowMinFeerate->isChecked())
-        redrawItems.append(scene->addPath(minFeePath, linePenGreen));
-    if (cbShowMemUsage->isChecked())
-    {
-        redrawItems.append(scene->addPath(dynMemUsagePath, linePenBlue));
-        redrawItems.append(scene->addPath(dynMemUsagePathFill, QPen(Qt::NoPen), graBru));
-    }
-}
-
-// We override the virtual resizeEvent of the QWidget to adjust tables column
-// sizes as the tables width is proportional to the dialogs width.
-void MempoolStats::resizeEvent(QResizeEvent *event)
-{
-    QWidget::resizeEvent(event);
-    ui->graphicsView->resize(size());
-    ui->graphicsView->scene()->setSceneRect(rect());
-    drawChart();
-}
-
-void MempoolStats::showEvent(QShowEvent *event)
-{
-    QWidget::showEvent(event);
-    if (clientModel)
-        drawChart();
-}
-
-void MempoolStats::objectClicked(QGraphicsItem *item)
-{
-    if (item == last10MinLabel)
-        timeFilter = 600;
-
-    if (item == lastHourLabel)
-        timeFilter = 3600;
-
-    if (item == lastDayLabel)
-        timeFilter = 24*3600;
-
-    if (item == allDataLabel)
-        timeFilter = 0;
-
-    drawChart();
-}
-
-MempoolStats::~MempoolStats()
-{
-    if (titleItem)
-    {
-        for (QGraphicsItem * item : redrawItems)
-        {
-            scene->removeItem(item);
-            delete item;
-        }
-        redrawItems.clear();
-
-        delete titleItem;
-        delete titleLine;
-        delete noDataItem;
-        delete dynMemUsageValueItem;
-        delete txCountValueItem;
-        delete minFeeValueItem;
-        delete last10MinLabel;
-        delete lastHourLabel;
-        delete lastDayLabel;
-        delete allDataLabel;
-        delete txCountSwitch;
-        delete minFeeSwitch;
-        delete dynMemUsageSwitch;
-        delete scene;
-    }
-}
diff --git a/src/qt/mempoolstats.h b/src/qt/mempoolstats.h
deleted file mode 100644
index c3c804259b..0000000000
--- a/src/qt/mempoolstats.h
+++ /dev/null
@@ -1,84 +0,0 @@
-// Copyright (c) 2016 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#ifndef BITCOIN_QT_MEMPOOLSTATS_H
-#define BITCOIN_QT_MEMPOOLSTATS_H
-
-#include <QWidget>
-#include <QGraphicsLineItem>
-#include <QGraphicsPixmapItem>
-
-#include <QCheckBox>
-#include <QGraphicsProxyWidget>
-
-#include <QEvent>
-
-class ClientModel;
-
-class ClickableTextItem : public QGraphicsTextItem
-{
-    Q_OBJECT
-public:
-    void setEnabled(bool state);
-protected:
-    void mousePressEvent(QGraphicsSceneMouseEvent *event) override;
-Q_SIGNALS:
-    void objectClicked(QGraphicsItem*);
-};
-
-
-namespace Ui {
-    class MempoolStats;
-}
-
-class MempoolStats : public QWidget
-{
-    Q_OBJECT
-
-public:
-    MempoolStats(QWidget *parent = nullptr);
-    ~MempoolStats();
-
-    void setClientModel(ClientModel *model);
-
-public Q_SLOTS:
-    void drawChart();
-    void objectClicked(QGraphicsItem *);
-
-private:
-    ClientModel *clientModel{nullptr};
-
-    virtual void resizeEvent(QResizeEvent *event) override;
-    virtual void showEvent(QShowEvent *event) override;
-
-    QGraphicsTextItem *titleItem{nullptr};
-    QGraphicsLineItem *titleLine;
-    QGraphicsTextItem *noDataItem;
-
-    QGraphicsTextItem *dynMemUsageValueItem;
-    QGraphicsTextItem *txCountValueItem;
-    QGraphicsTextItem *minFeeValueItem;
-
-    ClickableTextItem *last10MinLabel;
-    ClickableTextItem *lastHourLabel;
-    ClickableTextItem *lastDayLabel;
-    ClickableTextItem *allDataLabel;
-
-    QGraphicsProxyWidget *txCountSwitch;
-    QGraphicsProxyWidget *minFeeSwitch;
-    QGraphicsProxyWidget *dynMemUsageSwitch;
-
-    QGraphicsScene *scene{nullptr};
-    QVector<QGraphicsItem*> redrawItems;
-
-    QCheckBox *cbShowMemUsage;
-    QCheckBox *cbShowNumTxns;
-    QCheckBox *cbShowMinFeerate;
-
-    int64_t timeFilter;
-
-    Ui::MempoolStats *ui;
-};
-
-#endif // BITCOIN_QT_MEMPOOLSTATS_H
diff --git a/src/qt/netwatch.cpp b/src/qt/netwatch.cpp
deleted file mode 100644
index 7bc57f37bb..0000000000
--- a/src/qt/netwatch.cpp
+++ /dev/null
@@ -1,849 +0,0 @@
-// Copyright (c) 2017-2021 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#if defined(HAVE_CONFIG_H)
-#include <config/bitcoin-config.h>
-#endif
-
-#include <qt/netwatch.h>
-
-#include <qt/bitcoinunits.h>
-#include <qt/clientmodel.h>
-#include <qt/guiconstants.h>
-#include <qt/guiutil.h>
-#include <qt/networkstyle.h>
-#include <qt/optionsmodel.h>
-#include <qt/platformstyle.h>
-
-#include <chain.h>
-#include <interfaces/node.h>
-#include <key_io.h>
-#include <node/blockstorage.h>
-#include <node/context.h>
-#include <primitives/transaction.h>
-#include <pubkey.h>
-#include <sync.h>
-#include <util/time.h>
-#include <validation.h>
-#include <validationinterface.h>
-
-#include <algorithm>
-#include <memory>
-#include <type_traits>
-
-#include <QAbstractTableModel>
-#include <QHBoxLayout>
-#include <QLineEdit>
-#include <QPushButton>
-#include <QScrollBar>
-#include <QVBoxLayout>
-#include <QWidget>
-
-namespace {
-
-bool IsDatacarrier(const CTxOut& txout)
-{
-    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);
-}
-
-size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)
-{
-    size_t count = 0;
-    for (const auto& txout : tx->vout) {
-        if (IsDatacarrier(txout)) continue;
-        ++count;
-    }
-    return count;
-}
-
-const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)
-{
-    size_t count = 0;
-    for (auto& txout : tx->vout) {
-        if (IsDatacarrier(txout)) continue;
-        if (count == txout_index) {
-            return &txout;
-        }
-        ++count;
-    }
-    return nullptr;
-}
-
-} // namespace
-
-QString LogEntry::LogEntryTypeAbbreviation(const Type log_entry_type)
-{
-    switch (log_entry_type) {
-        case Type::Block:       return QObject::tr("Blk", "Tx Watch: Block type abbreviation");
-        case Type::Transaction: return QObject::tr("Txn", "Tx Watch: Transaction type abbreviation");
-    } // no default case, so the compiler can warn about missing cases
-
-    assert(false);
-}
-
-void LogEntry::init(const LogEntry& other)
-{
-    if (!other.m_data) {
-        m_data = nullptr;
-        return;
-    }
-    const meta_t n = *(meta_t*)other.m_data;
-    const int32_t relTimestamp = n & rel_ts_mask;
-    switch (n >> 30) {
-        case 1:  // CBlockIndex*
-            init(relTimestamp, other.getBlockIndex());
-            break;
-        case 2:  // CTransactionRef
-        {
-            CTransactionWeakref ptx(*other.get<CTransactionRef>());
-            init(relTimestamp, ptx, false);
-            break;
-        }
-        case 3:  // CTransactionWeakref
-            init(relTimestamp, *other.get<CTransactionWeakref>(), true);
-            break;
-        default: assert(false);
-    }
-}
-
-LogEntry::LogEntry(const LogEntry& other)
-{
-    init(other);
-}
-
-void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)
-{
-    relTimestamp &= rel_ts_mask;
-    size_t alignment;
-    const size_t sz = data_sizeof<CBlockIndex*>(alignment);
-    m_data = (uint8_t*)::operator new(sz);
-    *((meta_t*)m_data) = relTimestamp | (1 << 30);
-    *((const CBlockIndex**)&m_data[alignment]) = &blockindex;
-}
-
-LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)
-{
-    init(relTimestamp, blockindex);
-}
-
-void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)
-{
-    relTimestamp &= rel_ts_mask;
-
-    // Allocate enough space for either, so we can convert between them
-    size_t alignment_shared, alignment_weak;
-    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));
-    m_data = (uint8_t*)::operator new(sz);
-
-    uint32_t type;
-    if (weak) {
-        //std::allocator<std::weak_ptr<CTransaction>>::construct(m_data + alignment_weak, tx);
-        new (m_data + alignment_weak) CTransactionWeakref(tx);
-        type = 3;
-    } else {
-        new (m_data + alignment_shared) CTransactionRef(tx.lock());
-        type = 2;
-    }
-    *((meta_t*)m_data) = relTimestamp | (type << 30);
-}
-
-LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)
-{
-    init(relTimestamp, tx, weak);
-}
-
-LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)
-{
-    CTransactionWeakref ptx(tx);
-    init(relTimestamp, ptx, weak);
-}
-
-void LogEntry::clear()
-{
-    if (!m_data) {
-        return;
-    }
-    const meta_t n = *(meta_t*)m_data;
-    switch (n >> 30) {
-        case 1:  // CBlockIndex*
-            break;
-        case 2:  // CTransactionRef
-            get<CTransactionRef>()->~CTransactionRef();
-            break;
-        case 3:  // CTransactionWeakref
-            get<CTransactionWeakref>()->~CTransactionWeakref();
-            break;
-        default: assert(false);
-    }
-    delete m_data;
-}
-
-LogEntry::~LogEntry()
-{
-    clear();
-}
-
-LogEntry& LogEntry::operator=(const LogEntry& other)
-{
-    if (this != &other) {
-        clear();
-        init(other);
-    }
-    return *this;
-}
-
-LogEntry::operator bool() const
-{
-    return m_data;
-}
-
-int32_t LogEntry::getRelTimestamp() const
-{
-    const meta_t n = *(meta_t*)m_data;
-    return n & rel_ts_mask;
-}
-
-uint64_t LogEntry::getTimestamp(uint64_t now) const
-{
-    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();
-    if (ts > now) {
-        ts -= (rel_ts_mask64 + 1);
-    }
-    return ts;
-}
-
-LogEntry::Type LogEntry::getType() const
-{
-    const meta_t n = *(meta_t*)m_data;
-    return (n >> 31) ? Type::Transaction : Type::Block;
-}
-
-const CBlockIndex& LogEntry::getBlockIndex() const
-{
-    return **(get<const CBlockIndex*>());
-}
-
-CTransactionRef LogEntry::getTransactionRef() const
-{
-    const meta_t n = *(meta_t*)m_data;
-    if ((n >> 30) & 1) {
-        return get<CTransactionWeakref>()->lock();
-    } else {
-        return *get<CTransactionRef>();
-    }
-}
-
-bool LogEntry::isWeak() const
-{
-    const meta_t n = *(meta_t*)m_data;
-    return ((n >> 30) == 3);
-}
-
-bool LogEntry::expired() const
-{
-    if (isWeak()) {
-        return get<CTransactionWeakref>()->expired();
-    }
-    return false;
-}
-
-void LogEntry::makeWeak()
-{
-    const meta_t n = *(meta_t*)m_data;
-    if ((n >> 30) != 2) {
-        return;
-    }
-    CTransactionRef * const ptx_old = get<CTransactionRef>();
-    CTransactionRef tx = *ptx_old;  // save a copy
-    ptx_old->~CTransactionRef();
-    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();
-    new (ptx_new) CTransactionWeakref(tx);
-    *((meta_t*)m_data) |= (3 << 30);
-}
-
-class NetWatchValidationInterface final : public CValidationInterface {
-private:
-    NetWatchLogModel& model;
-
-public:
-    explicit NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}
-    void ValidationInterfaceUnregistering() override;
-
-    void BlockConnected(ChainstateRole role, const std::shared_ptr<const CBlock>& block, const CBlockIndex* pindex) override;
-    void TransactionAddedToMempool(const NewMempoolTransactionInfo&, uint64_t mempool_sequence) override;
-};
-
-void NetWatchValidationInterface::ValidationInterfaceUnregistering()
-{
-    model.OrphanedValidationInterface();
-}
-
-void NetWatchValidationInterface::BlockConnected(ChainstateRole role, const std::shared_ptr<const CBlock>& block, const CBlockIndex* pindex)
-{
-    model.LogBlock(pindex, block);
-}
-
-void NetWatchValidationInterface::TransactionAddedToMempool(const NewMempoolTransactionInfo& txinfo, uint64_t mempool_sequence)
-{
-    model.LogTransaction(txinfo.info.m_tx);
-}
-
-NetWatchLogModel::NetWatchLogModel(QWidget *parent) :
-    QAbstractTableModel(parent),
-    m_widget(parent)
-{
-}
-
-NetWatchLogModel::~NetWatchLogModel()
-{
-    LOCK(cs);
-    if (m_validation_interface) {
-        Assert(m_client_model && m_client_model->node().context()->validation_signals);
-        m_client_model->node().context()->validation_signals->UnregisterValidationInterface(m_validation_interface);
-        delete m_validation_interface;
-        m_validation_interface = nullptr;
-    }
-}
-
-void NetWatchLogModel::OrphanedValidationInterface()
-{
-    LOCK(cs);
-    delete m_validation_interface;
-    m_validation_interface = nullptr;
-}
-
-int NetWatchLogModel::rowCount(const QModelIndex& parent) const
-{
-    LOCK(cs);
-    return m_log.size() - m_logskip;
-}
-
-int NetWatchLogModel::columnCount(const QModelIndex& parent) const
-{
-    return HeaderCount;
-}
-
-QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const
-{
-    switch (header) {
-        case Header::Type:
-            return LogEntry::LogEntryTypeAbbreviation(LogEntry::Type::Block);
-        case Header::Id:
-            return QString::fromStdString(blockindex.GetBlockHash().GetHex());
-        case Header::Address:
-        case Header::Value: {
-            if (blockindex.nTx == 0 || !(WITH_LOCK(::cs_main, return blockindex.nStatus) & BLOCK_HAVE_DATA)) {
-                return QVariant();
-            }
-            CBlock block;
-            Assert(m_client_model && m_client_model->node().context());
-            if (!m_client_model->node().context()->chainman->m_blockman.ReadBlockFromDisk(block, blockindex)) {
-                // Indicate error somehow?
-                return QVariant();
-            }
-            assert(block.vtx.size());
-            return data(block.vtx[0], txout_index, header);
-        }
-        case Header::Time:  // Not valid here
-            assert(false);
-    }
-    return QVariant();
-}
-
-QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const
-{
-    switch (header) {
-        case Header::Type:
-            return LogEntry::LogEntryTypeAbbreviation(LogEntry::Type::Transaction);
-        case Header::Id:
-            return QString::fromStdString(tx->GetHash().GetHex());
-        case Header::Address: {
-            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);
-            if (!ptxout) {
-                // Only datacarriers
-                ptxout = &tx->vout[0];
-            }
-            CTxDestination txdest;
-            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {
-                return tr("(Burn)", "Tx Watch: Provably burned value in transaction");
-            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {
-                return tr("(Unknown)", "Tx Watch: Unknown transaction output type");
-            }
-            return QString::fromStdString(EncodeDestination(txdest));
-        }
-        case Header::Value: {
-            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);
-            if (!ptxout) {
-                ptxout = &tx->vout[0];
-            }
-            if (m_client_model) {
-                return BitcoinUnits::format(m_client_model->getOptionsModel()->getDisplayUnit(), ptxout->nValue);
-            } else {
-                return qlonglong(ptxout->nValue);
-            }
-        }
-        case Header::Time:  // Not valid here
-            assert(false);
-    }
-    return QVariant();
-}
-
-const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const
-{
-    AssertLockHeld(cs);
-    size_t pos = (m_logpos + row) % m_log.size();
-    return m_log[pos];
-}
-
-LogEntry& NetWatchLogModel::getLogEntryRow(int row)
-{
-    AssertLockHeld(cs);
-    size_t pos = (m_logpos + row) % m_log.size();
-    return m_log[pos];
-}
-
-bool NetWatchLogModel::isLogRowContinuation(int row) const
-{
-    AssertLockHeld(cs);
-    return !getLogEntryRow(row);
-}
-
-const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const
-{
-    AssertLockHeld(cs);
-    out_entry_row = 0;
-    while (row && isLogRowContinuation(row)) {
-        --row;
-        ++out_entry_row;
-    }
-    return getLogEntryRow(row);
-}
-
-// NOLINTNEXTLINE(misc-no-recursion)
-QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const
-{
-    const Header header = Header(index.column());
-    switch (role) {
-        case Qt::DisplayRole:
-            break;
-        case Qt::BackgroundRole: {
-            if (!data(index, Qt::DisplayRole).isValid()) {
-                return m_widget->palette().brush(QPalette::WindowText);
-            }
-            LogEntry::Type type;
-            {
-                int entry_row;
-                LOCK(cs);
-                const LogEntry& le = findLogEntry(index.row(), entry_row);
-                type = le.getType();
-            }
-            if (type == LogEntry::Type::Block) {
-                return m_widget->palette().brush(QPalette::AlternateBase);
-            }
-            return QVariant();
-        }
-        case Qt::ForegroundRole: {
-            if (index.column() < 3) {
-                bool iscont;
-                {
-                    LOCK(cs);
-                    iscont = isLogRowContinuation(index.row());
-                }
-                if (iscont) {
-                    QBrush brush = m_widget->palette().brush(QPalette::WindowText);
-                    QColor color = brush.color();
-                    color.setAlpha(color.alpha() / 2);
-                    brush.setColor(color);
-                    return brush;
-                }
-            }
-            return QVariant();
-        }
-        case Qt::TextAlignmentRole:
-            if (header == Header::Value) {
-                return QVariant(Qt::AlignRight | Qt::AlignVCenter);
-            }
-            return QVariant();
-        case Qt::FontRole:
-            if (header == Header::Id) {
-                return GUIUtil::fixedPitchFont();
-            }
-            return QVariant();
-        default:
-            return QVariant();
-    }
-    int entry_row;
-    LOCK(cs);
-    const LogEntry& le = findLogEntry(index.row(), entry_row);
-    if (header == Header::Time) {
-        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));
-    }
-    const LogEntry::Type type = le.getType();
-    if (type == LogEntry::Type::Block) {
-        return data(le.getBlockIndex(), entry_row, header);
-    }
-    if (header == Header::Type) {
-        return LogEntry::LogEntryTypeAbbreviation(LogEntry::Type::Transaction);
-    }
-
-    if (le.expired()) {
-        return QVariant();
-    }
-    return data(le.getTransactionRef(), entry_row, header);
-}
-
-QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const
-{
-    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {
-        return QVariant();
-    }
-    switch (Header(section)) {
-        case Header::Time:     return tr("Time"   , "NetWatch: Time header");
-        case Header::Type:     return tr("Type"   , "NetWatch: Type header");
-        case Header::Id:       return tr("Id"     , "NetWatch: Block hash / Txid header");
-        case Header::Address:  return tr("Address", "NetWatch: Address header");
-        case Header::Value:
-            if (m_client_model) {
-                return BitcoinUnits::getAmountColumnTitle(m_client_model->getOptionsModel()->getDisplayUnit());
-            } else {
-                // Used only for sizing of the column
-                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::Unit::mBTC);
-            }
-    }
-    return QVariant();
-}
-
-NetWatchLogSearch::NetWatchLogSearch(const QString& query, BitcoinUnit display_unit) :
-    m_query(query)
-{
-    const QRegExp reHex("^[\\da-f]+$", Qt::CaseInsensitive, QRegExp::RegExp2);
-    const QRegExp reType("^(T(xn?)?|B(lk?)?)$", Qt::CaseInsensitive, QRegExp::RegExp2);
-
-    m_check_type = m_query.length() < 4 && reType.exactMatch(m_query);
-    m_check_id = m_query.length() <= 64 && reHex.exactMatch(m_query);
-    m_check_addr = m_query.length() <= LONGEST_BECH32_ADDRESS;
-    CAmount val;
-    m_check_value = BitcoinUnits::parse(display_unit, m_query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();
-}
-
-bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const
-{
-    if (model.data(model.index(row, int(NetWatchLogModel::Header::Time))).toString().contains(m_query)) {
-        return true;
-    } else if (m_check_type && model.data(model.index(row, int(NetWatchLogModel::Header::Type))).toString().contains(m_query, Qt::CaseInsensitive)) {
-        return true;
-    } else if (m_check_id && model.data(model.index(row, int(NetWatchLogModel::Header::Id))).toString().contains(m_query, Qt::CaseInsensitive)) {
-        return true;
-    } else if (m_check_addr && model.data(model.index(row, int(NetWatchLogModel::Header::Address))).toString().contains(m_query, Qt::CaseInsensitive)) {
-        return true;
-    } else if (m_check_value && model.data(model.index(row, int(NetWatchLogModel::Header::Value))).toString().contains(m_query)) {
-        return true;
-    }
-    return false;
-}
-
-void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)
-{
-    const auto currentUnit = m_client_model->getOptionsModel()->getDisplayUnit();
-    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);
-    LOCK(cs);
-    delete m_current_search;
-    m_current_search = newsearch;
-
-    bool fAdding = false;
-    const size_t rows_used = rowCount();
-    for (size_t row = 0; row < rows_used; ++row) {
-        if (isLogRowContinuation(row) || newsearch->m_check_addr || newsearch->m_check_value) {
-            // Check for a match
-            fAdding = newsearch->match(*this, row);
-        }
-        if (fAdding) {
-            results.append(row);
-        }
-    }
-}
-
-void NetWatchLogModel::searchDisable() {
-    LOCK(cs);
-    delete m_current_search;
-    m_current_search = nullptr;
-}
-
-void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)
-{
-    AssertLockHeld(cs);
-    if (m_log.size() < logsizelimit) {
-        // Haven't filled up yet, so just push_back
-        // Ensure push_back will append the current circular buffer, not go in the middle somewhere
-        // NOTE: m_logpos and m_logskip can be non-zero here, when further outputs will be overwriting
-        assert(m_logpos == m_logskip);
-        m_log.push_back(le);
-    } else {
-        // Replace a deleted row
-        assert(m_logskip);
-        getLogEntryRow(rows_used) = le;
-        --m_logskip;
-    }
-    ++rows_used;
-    if (rows_used > max_nonweak_txouts) {
-        LogEntry& old_le = getLogEntryRow(rows_used - max_nonweak_txouts - 1);
-        if (old_le) {
-            old_le.makeWeak();
-        }
-    }
-}
-
-void NetWatchLogModel::LogAddEntry(const LogEntry& le, size_t vout_count)
-{
-    if (vout_count < 1) {
-        vout_count = 1;
-    }
-    const QModelIndex dummy;
-    LOCK(cs);
-    size_t rows_to_remove = 0;
-    if (vout_count >= max_vout_per_tx) {
-        vout_count = max_vout_per_tx;
-    }
-    size_t rows_used = rowCount();
-    if (rows_used > logsizelimit - vout_count) {
-        rows_to_remove = (rows_used + vout_count) - logsizelimit;
-    }
-    if (rows_to_remove) {
-        // Don't orphan continuation entries
-        while (isLogRowContinuation(rows_to_remove)) {
-            ++rows_to_remove;
-        }
-
-        beginRemoveRows(dummy, 0, rows_to_remove - 1);
-        m_logpos = (m_logpos + rows_to_remove) % m_log.size();
-        m_logskip += rows_to_remove;
-        endRemoveRows();
-
-        rows_used = rowCount();
-    }
-
-    const LogEntry cont_le;
-    const int first_new_row = rows_used, last_new_row = rows_used + vout_count - 1;
-    beginInsertRows(dummy, first_new_row, last_new_row);
-    log_append(le, rows_used);
-    for (size_t i = 1; i < vout_count; ++i) {
-        log_append(cont_le, rows_used);
-    }
-    endInsertRows();
-
-    if (m_current_search) {
-        QList<int> new_matches;
-        if (m_current_search->m_check_addr || m_current_search->m_check_value) {
-            for (int row = first_new_row; row <= last_new_row; ++row) {
-                if (m_current_search->match(*this, row)) {
-                    new_matches.append(row);
-                }
-            }
-        } else if (m_current_search->match(*this, first_new_row)) {
-            for (int row = first_new_row; row <= last_new_row; ++row) {
-                new_matches.append(row);
-            }
-        }
-        if (!new_matches.isEmpty()) {
-            Q_EMIT moreSearchResults(new_matches);
-        }
-    }
-}
-
-void NetWatchLogModel::LogBlock(const CBlockIndex* pblockindex, const std::shared_ptr<const CBlock>& block_cached)
-{
-    std::shared_ptr<const CBlock> block = block_cached;
-    if (!block) {
-        std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();
-        Assert(m_client_model && m_client_model->node().context());
-        if (!m_client_model->node().context()->chainman->m_blockman.ReadBlockFromDisk(*pblock, *pblockindex)) {
-            // Indicate error somehow?
-            return;
-        }
-        block = pblock;
-    }
-    assert(block->vtx.size());
-    const size_t vout_count = CountNonDatacarrierOutputs(block->vtx[0]);
-    LogAddEntry(LogEntry(GetTime(), *pblockindex), vout_count);
-}
-
-void NetWatchLogModel::LogTransaction(const CTransactionRef& tx)
-{
-    const size_t vout_count = CountNonDatacarrierOutputs(tx);
-    LogAddEntry(LogEntry(GetTime(), tx), vout_count);
-}
-
-void NetWatchLogModel::setClientModel(ClientModel *model)
-{
-    if (m_client_model) {
-        delete m_validation_interface;
-        m_validation_interface = nullptr;
-
-        disconnect(m_client_model->getOptionsModel(), &OptionsModel::displayUnitChanged, this, &NetWatchLogModel::updateDisplayUnit);
-    }
-    m_client_model = model;
-    if (model) {
-        connect(model->getOptionsModel(), &OptionsModel::displayUnitChanged, this, &NetWatchLogModel::updateDisplayUnit);
-
-        Assert(model->node().context()->validation_signals);
-        m_validation_interface = new NetWatchValidationInterface(*this);
-        model->node().context()->validation_signals->RegisterValidationInterface(m_validation_interface);
-    }
-    updateDisplayUnit();
-}
-
-void NetWatchLogModel::updateDisplayUnit()
-{
-    Q_EMIT headerDataChanged(Qt::Horizontal, int(Header::Value), int(Header::Value));
-    Q_EMIT dataChanged(index(0, int(Header::Value)), index(rowCount() - 1, int(Header::Value)));
-}
-
-int NetWatchLogTestModel::rowCount(const QModelIndex& parent) const
-{
-    return 2;
-}
-
-QVariant NetWatchLogTestModel::data(const QModelIndex& index, int role) const
-{
-    const NetWatchLogModel::Header header = NetWatchLogModel::Header(index.column());
-    if (role == Qt::FontRole && header == Header::Id) {
-        return GUIUtil::fixedPitchFont();
-    } else if (role != Qt::DisplayRole) {
-        return QVariant();
-    }
-    switch (header) {
-        case Header::Time:
-            return QString{GUIUtil::dateTimeStr(GetTime()) + "4"};
-        case Header::Type:
-            return LogEntry::LogEntryTypeAbbreviation(LogEntry::Type(index.row()));
-        case Header::Id:
-            return QString(64, '0');
-        case Header::Address:
-            if (index.row()) {
-                return QString{"bc1" + QString(LONGEST_BECH32_ADDRESS-3, 'x')};
-            } else {
-                return QString(LONGEST_BASE58_ADDRESS, 'W');
-            }
-        case Header::Value:
-            return "20000000.00000000";
-    }
-    return QVariant();
-}
-
-GuiNetWatch::GuiNetWatch(const PlatformStyle *platformStyle, const NetworkStyle *networkStyle, QWidget *parent) :
-    QWidget(parent)
-{
-    QVBoxLayout * const layout = new QVBoxLayout(this);
-
-    m_search_editor = new QLineEdit(this);
-    m_search_editor->setPlaceholderText("Search");
-    layout->addWidget(m_search_editor);
-
-    m_log_view = new QTableView(this);
-    m_log_view->verticalHeader()->hide();
-    m_log_view->setSizePolicy(QSizePolicy(QSizePolicy::Ignored, QSizePolicy::Ignored));
-    m_log_view->setSelectionBehavior(QAbstractItemView::SelectRows);
-    m_log_view->setTabKeyNavigation(false);
-    m_log_view->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
-
-    {
-        NetWatchLogTestModel testmodel;
-        m_log_view->setModel(&testmodel);
-        m_log_view->resizeColumnsToContents();
-
-        log_model = new NetWatchLogModel(this);
-        m_log_view->setModel(log_model);
-    }
-    layout->addWidget(m_log_view);
-
-    setWindowTitle(tr(PACKAGE_NAME) + " - " + tr("Network Watch") + " " + networkStyle->getTitleAddText());
-    setMinimumSize(640, 480);
-    resize(layout->contentsMargins().left() + (m_log_view->frameWidth() * 2) + m_log_view->columnViewportPosition(NetWatchLogModel::HeaderCount-1) + m_log_view->columnWidth(NetWatchLogModel::HeaderCount-1) + m_log_view->verticalScrollBar()->size().width() + layout->contentsMargins().right(), 480);
-    setWindowIcon(networkStyle->getTrayAndWindowIcon());
-
-    connect(m_search_editor, &QLineEdit::textChanged, this, &GuiNetWatch::doSearch);
-
-    connect(log_model, &NetWatchLogModel::rowsRemoved, this, &GuiNetWatch::rowsRemoved);
-    connect(log_model, &NetWatchLogModel::rowsAboutToBeInserted, this, &GuiNetWatch::aboutToInsert);
-    connect(log_model, &NetWatchLogModel::rowsInserted, this, &GuiNetWatch::maybeScrollToBottom);
-    connect(log_model, &NetWatchLogModel::moreSearchResults, this, &GuiNetWatch::moreSearchResults);
-
-    connect(m_log_view->selectionModel(), &QItemSelectionModel::selectionChanged, this, &GuiNetWatch::maybeCancelSearch);
-
-    setLayout(layout);
-}
-
-void GuiNetWatch::setClientModel(ClientModel *model)
-{
-    log_model->setClientModel(model);
-}
-
-void GuiNetWatch::rowsRemoved(const QModelIndex& parent, int start, int end)
-{
-    if (m_log_view->verticalScrollBar()->value() >= m_log_view->verticalScrollBar()->maximum()) {
-        return;
-    }
-    // Maintain the current viewed entries in place
-    int scrollpos = m_log_view->verticalScrollBar()->value();
-    if (start < scrollpos) {
-        scrollpos -= std::max(0, 1 + end - start);
-        m_log_view->verticalScrollBar()->setValue(scrollpos);
-    }
-}
-
-void GuiNetWatch::aboutToInsert()
-{
-    m_adjust_scroll = (m_log_view->verticalScrollBar()->value() >= m_log_view->verticalScrollBar()->maximum());
-}
-
-void GuiNetWatch::maybeScrollToBottom()
-{
-    if (m_adjust_scroll) {
-        m_log_view->scrollToBottom();
-    }
-}
-
-void GuiNetWatch::doSearch(const QString& query)
-{
-    if (query.isEmpty()) {
-        log_model->searchDisable();
-        m_search_editor->setStyleSheet("");
-        return;
-    }
-    QList<int> results;
-    log_model->searchRows(query, results);
-    if (results.isEmpty()) {
-        m_search_editor->setStyleSheet(STYLE_INVALID);
-        return;
-    }
-    m_search_editor->setStyleSheet(STYLE_ACTIVE);
-    QItemSelectionModel& sel = *m_log_view->selectionModel();
-    m_dont_cancel_search = true;
-    sel.clear();
-    Q_FOREACH (int row, results) {
-        sel.select(log_model->index(row, 0), QItemSelectionModel::Rows | QItemSelectionModel::Select);
-    }
-    m_dont_cancel_search = false;
-    m_log_view->scrollTo(log_model->index(results.back(), int(NetWatchLogModel::Header::Id)));
-}
-
-void GuiNetWatch::moreSearchResults(const QList<int>& rows)
-{
-    m_search_editor->setStyleSheet(STYLE_ACTIVE);
-    QItemSelectionModel& sel = *m_log_view->selectionModel();
-    m_dont_cancel_search = true;
-    Q_FOREACH (int row, rows) {
-        sel.select(log_model->index(row, 0), QItemSelectionModel::Rows | QItemSelectionModel::Select);
-    }
-    m_dont_cancel_search = false;
-}
-
-void GuiNetWatch::maybeCancelSearch()
-{
-    if (m_dont_cancel_search) {
-        return;
-    }
-    m_search_editor->setStyleSheet("");
-    log_model->searchDisable();
-}
diff --git a/src/qt/netwatch.h b/src/qt/netwatch.h
deleted file mode 100644
index 872e02bc01..0000000000
--- a/src/qt/netwatch.h
+++ /dev/null
@@ -1,232 +0,0 @@
-// Copyright (c) 2017-2021 The Bitcoin Core developers
-// Copyright (c) 2011-2013 David Krauss (std::align substitute from c-plus)
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#ifndef BITCOIN_QT_NETWATCH_H
-#define BITCOIN_QT_NETWATCH_H
-
-#include <qt/bitcoinunits.h>
-
-#include <primitives/transaction.h>
-#include <sync.h>
-#include <validationinterface.h>
-
-#include <QAbstractTableModel>
-#include <QWidget>
-
-QT_BEGIN_NAMESPACE
-class QLineEdit;
-class QTableView;
-QT_END_NAMESPACE
-
-class CBlock;
-class CBlockIndex;
-class ClientModel;
-class LogEntry;
-class NetworkStyle;
-class PlatformStyle;
-
-static constexpr int LONGEST_BASE58_ADDRESS{35};
-static constexpr int LONGEST_BECH32_ADDRESS{62};  // NOTE: Up to 74 in theory, but 62 in practice
-
-class LogEntry {
-private:
-    /**
-     * m_data is a uint32_t (meta_t) with the top two bits used for:
-     *   1: CBlockIndex*
-     *   2: CTransactionRef
-     *   3: weak_ptr<const CTransaction>
-     * The subsequent 30 bits are the timestamp, assumed to be most recent to the current time.
-     * Following this, and any padding necessary for alignment, the object itself is stored
-     */
-    uint8_t *m_data{nullptr};
-
-    typedef uint32_t meta_t;
-    typedef std::weak_ptr<const CTransaction> CTransactionWeakref;
-    static constexpr uint32_t rel_ts_mask{0x3fffffff};
-    static constexpr uint64_t rel_ts_mask64{rel_ts_mask};
-
-    template<typename T> static size_t data_sizeof(size_t& offset) {
-        void *p = (void *)intptr_t(sizeof(meta_t));
-        size_t dummy_bufsize = sizeof(T) * 2;
-        p = align(std::alignment_of<T>::value, sizeof(T), p, dummy_bufsize);
-        assert(p);
-        offset = size_t(p);
-        return offset + sizeof(T);
-    }
-
-    // std::align (missing in at least GCC 4.9) substitute from c-plus
-    static inline void *align(std::size_t alignment, std::size_t size, void *&ptr, std::size_t &space) {
-        auto pn = reinterpret_cast<std::uintptr_t>(ptr);
-        auto aligned = (pn + alignment - 1) & -alignment;
-        auto new_space = space - (aligned - pn);
-        if (new_space < size) {
-            return nullptr;
-        }
-        space = new_space;
-        return ptr = reinterpret_cast<void *>(aligned);
-    }
-
-    void init(const LogEntry&);
-    void init(int32_t relTimestamp, const CBlockIndex&);
-    void init(int32_t relTimestamp, const CTransactionWeakref&, bool weak);
-    void clear();
-
-public:
-    enum class Type {
-        Block,
-        Transaction,
-    };
-    static QString LogEntryTypeAbbreviation(Type);
-
-    LogEntry(const LogEntry&);
-    LogEntry() = default;
-    explicit LogEntry(int32_t relTimestamp, const CBlockIndex&);
-    explicit LogEntry(int32_t relTimestamp, const CTransactionWeakref&, bool weak = true);
-    explicit LogEntry(int32_t relTimestamp, const CTransactionRef&, bool weak = false);
-    ~LogEntry();
-
-    LogEntry& operator=(const LogEntry& other);
-
-    explicit operator bool() const;
-    int32_t getRelTimestamp() const;
-    uint64_t getTimestamp(uint64_t now) const;
-    Type getType() const;
-
-    template <typename T> T* get() const {
-        void *p = m_data + sizeof(meta_t);
-        size_t dummy_bufsize = sizeof(T) * 2;
-        p = align(std::alignment_of<T>::value, sizeof(T), p, dummy_bufsize);
-        assert(p);
-        return (T*)p;
-    }
-
-    const CBlockIndex& getBlockIndex() const;
-    CTransactionRef getTransactionRef() const;
-    bool isWeak() const;
-    bool expired() const;
-    void makeWeak();
-};
-
-class NetWatchLogModel;
-
-class NetWatchLogSearch {
-public:
-    QString m_query;
-
-    bool m_check_type;
-    bool m_check_id;
-    bool m_check_addr;
-    bool m_check_value;
-
-    NetWatchLogSearch(const QString& query, BitcoinUnit display_unit);
-    bool match(const NetWatchLogModel& model, int row) const;
-};
-
-class NetWatchValidationInterface;
-
-class NetWatchLogModel : public QAbstractTableModel
-{
-    Q_OBJECT
-
-private:
-    QWidget * const m_widget;
-    ClientModel *m_client_model{nullptr};
-
-    NetWatchValidationInterface *m_validation_interface{nullptr};
-
-    mutable RecursiveMutex cs;
-    std::vector<LogEntry> m_log GUARDED_BY(cs);
-    static constexpr size_t logsizelimit{0x400};
-    size_t m_logpos GUARDED_BY(cs) {0};
-    size_t m_logskip GUARDED_BY(cs) {0};
-
-    static constexpr size_t max_nonweak_txouts{0x200};
-    static constexpr size_t max_vout_per_tx{0x100};
-
-    NetWatchLogSearch *m_current_search GUARDED_BY(cs) {nullptr};
-
-    const LogEntry& getLogEntryRow(int row) const EXCLUSIVE_LOCKS_REQUIRED(cs);
-    LogEntry& getLogEntryRow(int row) EXCLUSIVE_LOCKS_REQUIRED(cs);
-    void log_append(const LogEntry&, size_t& rows_used) EXCLUSIVE_LOCKS_REQUIRED(cs);
-
-public:
-    static constexpr int HeaderCount{5};
-    enum class Header {
-        Time,
-        Type,
-        Id,
-        Address,
-        Value,
-    };
-
-    explicit NetWatchLogModel(QWidget *parent);
-    ~NetWatchLogModel();
-
-    void setClientModel(ClientModel *model);
-    void OrphanedValidationInterface();
-
-    bool isLogRowContinuation(int row) const EXCLUSIVE_LOCKS_REQUIRED(cs);
-    const LogEntry& findLogEntry(int row, int& out_entry_row) const EXCLUSIVE_LOCKS_REQUIRED(cs);
-
-    int rowCount(const QModelIndex& parent = QModelIndex()) const override;
-    int columnCount(const QModelIndex& parent) const override;
-    QVariant data(const CBlockIndex&, int txout_index, const Header) const;
-    QVariant data(const CTransactionRef&, int txout_index, const Header) const;
-    QVariant data(const QModelIndex&, int role = Qt::DisplayRole) const override;
-    QVariant headerData(int section, Qt::Orientation, int role = Qt::DisplayRole) const override;
-
-    void searchRows(const QString& query, QList<int>& results);
-    void searchDisable();
-
-    void LogAddEntry(const LogEntry& le, size_t vout_count);
-    void LogBlock(const CBlockIndex*, const std::shared_ptr<const CBlock>&);
-    void LogTransaction(const CTransactionRef&);
-
-Q_SIGNALS:
-    void moreSearchResults(const QList<int>& rows);
-
-public Q_SLOTS:
-    void updateDisplayUnit();
-};
-
-class NetWatchLogTestModel : public NetWatchLogModel
-{
-    Q_OBJECT
-
-public:
-    NetWatchLogTestModel() : NetWatchLogModel(nullptr) { }
-
-    int rowCount(const QModelIndex& parent) const override;
-    QVariant data(const QModelIndex&, int role = Qt::DisplayRole) const override;
-};
-
-class GuiNetWatch: public QWidget
-{
-    Q_OBJECT
-
-private:
-    bool m_adjust_scroll;
-
-public:
-    GuiNetWatch(const PlatformStyle *, const NetworkStyle *, QWidget * parent = nullptr);
-
-    void setClientModel(ClientModel *model);
-
-    NetWatchLogModel *log_model;
-    bool m_dont_cancel_search{false};
-
-    QLineEdit *m_search_editor;
-    QTableView *m_log_view;
-
-public Q_SLOTS:
-    void rowsRemoved(const QModelIndex& parent, int start, int end);
-    void aboutToInsert();
-    void maybeScrollToBottom();
-    void doSearch(const QString& query);
-    void moreSearchResults(const QList<int>& rows);
-    void maybeCancelSearch();
-};
-
-#endif // BITCOIN_QT_NETWATCH_H
diff --git a/src/qt/notificator.cpp b/src/qt/notificator.cpp
index ec6ff4c653..85bdeee49a 100644
--- a/src/qt/notificator.cpp
+++ b/src/qt/notificator.cpp
@@ -28,18 +28,6 @@
 #ifdef USE_DBUS
 // https://wiki.ubuntu.com/NotificationDevelopmentGuidelines recommends at least 128
 const int FREEDESKTOP_NOTIFICATION_ICON_SIZE = 128;
-
-void DBusInitThread::run() {
-    auto interface = new QDBusInterface("org.freedesktop.Notifications", "/org/freedesktop/Notifications", "org.freedesktop.Notifications");
-    if (!interface->isValid()) {
-        delete interface;
-        return;
-    }
-    interface->moveToThread(m_notificator.thread());
-    m_notificator.interface = interface;
-    m_notificator.mode = Notificator::Freedesktop;
-}
-
 #endif
 
 Notificator::Notificator(const QString &_programName, QSystemTrayIcon *_trayIcon, QWidget *_parent) :
@@ -53,8 +41,12 @@ Notificator::Notificator(const QString &_programName, QSystemTrayIcon *_trayIcon
         mode = QSystemTray;
     }
 #ifdef USE_DBUS
-    m_dbus_init_thread = new DBusInitThread(*this);
-    m_dbus_init_thread->start();
+    interface = new QDBusInterface("org.freedesktop.Notifications",
+        "/org/freedesktop/Notifications", "org.freedesktop.Notifications");
+    if(interface->isValid())
+    {
+        mode = Freedesktop;
+    }
 #endif
 #ifdef Q_OS_MACOS
     // check if users OS has support for NSUserNotification
@@ -67,8 +59,6 @@ Notificator::Notificator(const QString &_programName, QSystemTrayIcon *_trayIcon
 Notificator::~Notificator()
 {
 #ifdef USE_DBUS
-    m_dbus_init_thread->wait();
-    delete m_dbus_init_thread;
     delete interface;
 #endif
 }
@@ -228,7 +218,8 @@ void Notificator::notifyMacUserNotificationCenter(const QString &title, const QS
 
 void Notificator::notify(Class cls, const QString &title, const QString &text, const QIcon &icon, int millisTimeout)
 {
-    switch (Mode(mode)) {
+    switch(mode)
+    {
 #ifdef USE_DBUS
     case Freedesktop:
         notifyDBus(cls, title, text, icon, millisTimeout);
diff --git a/src/qt/notificator.h b/src/qt/notificator.h
index 960b785202..8808716aa4 100644
--- a/src/qt/notificator.h
+++ b/src/qt/notificator.h
@@ -9,9 +9,6 @@
 
 #include <QIcon>
 #include <QObject>
-#include <QThread>
-
-#include <atomic>
 
 QT_BEGIN_NAMESPACE
 class QSystemTrayIcon;
@@ -21,23 +18,6 @@ class QDBusInterface;
 #endif
 QT_END_NAMESPACE
 
-class Notificator;
-
-#ifdef USE_DBUS
-class DBusInitThread : public QThread
-{
-    Q_OBJECT
-
-    Notificator& m_notificator;
-
-public:
-    DBusInitThread(Notificator& notificator) : m_notificator(notificator) {};
-
-protected:
-    void run() override;
-};
-#endif
-
 /** Cross-platform desktop notification client. */
 class Notificator: public QObject
 {
@@ -79,15 +59,11 @@ private:
         UserNotificationCenter      /**< Use the 10.8+ User Notification Center (Mac only) */
     };
     QString programName;
-    std::atomic<Mode> mode{None};
+    Mode mode{None};
     QSystemTrayIcon *trayIcon;
 #ifdef USE_DBUS
-    QThread *m_dbus_init_thread{nullptr};
-protected:
     QDBusInterface* interface{nullptr};
-    friend class DBusInitThread;
 
-private:
     void notifyDBus(Class cls, const QString &title, const QString &text, const QIcon &icon, int millisTimeout);
 #endif
     void notifySystray(Class cls, const QString &title, const QString &text, int millisTimeout);
diff --git a/src/qt/optionsdialog.cpp b/src/qt/optionsdialog.cpp
index eecdd8f52e..4db2d6016c 100644
--- a/src/qt/optionsdialog.cpp
+++ b/src/qt/optionsdialog.cpp
@@ -7,181 +7,30 @@
 #include <qt/optionsdialog.h>
 #include <qt/forms/ui_optionsdialog.h>
 
-#include <qt/bitcoinamountfield.h>
 #include <qt/bitcoinunits.h>
 #include <qt/clientmodel.h>
 #include <qt/guiconstants.h>
 #include <qt/guiutil.h>
 #include <qt/optionsmodel.h>
 
-#include <common/args.h>
 #include <common/system.h>
-#include <consensus/consensus.h> // for MAX_BLOCK_SERIALIZED_SIZE
-#include <index/blockfilterindex.h>
 #include <interfaces/node.h>
 #include <node/chainstatemanager_args.h>
 #include <netbase.h>
-#include <node/mempool_args.h> // for ParseDustDynamicOpt
-#include <outputtype.h>
-#include <primitives/transaction.h> // for WITNESS_SCALE_FACTOR
 #include <txdb.h>
-#include <txmempool.h> // for maxmempoolMinimum
-#include <util/check.h>
 #include <util/strencodings.h>
+
 #include <chrono>
-#include <utility>
 
 #include <QApplication>
-#include <QBoxLayout>
 #include <QDataWidgetMapper>
 #include <QDir>
-#include <QDoubleSpinBox>
 #include <QFontDialog>
-#include <QGroupBox>
-#include <QHBoxLayout>
-#include <QInputDialog>
 #include <QIntValidator>
-#include <QLabel>
 #include <QLocale>
 #include <QMessageBox>
-#include <QRadioButton>
-#include <QScrollArea>
-#include <QScrollBar>
-#include <QSpacerItem>
-#include <QString>
-#include <QStringList>
 #include <QSystemTrayIcon>
 #include <QTimer>
-#include <QVBoxLayout>
-#include <QWidget>
-
-ModScrollArea::ModScrollArea()
-{
-    setWidgetResizable(true);
-    setFrameShape(QFrame::NoFrame);
-    setObjectName(QStringLiteral("scroll"));
-    setStyleSheet("QScrollArea#scroll, QScrollArea#scroll > QWidget > QWidget { background: transparent; } QScrollArea#scroll > QWidget > QScrollBar { background: palette(base); }");
-}
-
-ModScrollArea *ModScrollArea::fromWidget(QWidget * const parent, QWidget * const o)
-{
-    auto * const scroll = new ModScrollArea;
-    scroll->setWidget(o);
-    return scroll;
-}
-
-QSize ModScrollArea::minimumSizeHint() const
-{
-    auto w = widget()->minimumSizeHint().width();
-    w += verticalScrollBar()->sizeHint().width();
-    const auto h = fontMetrics().height() * 2;
-    return QSize(w, h);
-}
-
-QSize ModScrollArea::sizeHint() const
-{
-    QSize sz = widget()->sizeHint();
-    sz.rwidth() += verticalScrollBar()->sizeHint().width();
-    return sz;
-}
-
-void OptionsDialog::FixTabOrder(QWidget * const o)
-{
-    BitcoinAmountField * const af = qobject_cast<BitcoinAmountField *>(o);
-    if (af) {
-        prevwidget = af->setupTabChain(prevwidget);
-    } else {
-        setTabOrder(prevwidget, o);
-        prevwidget = o;
-    }
-}
-
-struct CreateOptionUIOpts {
-    QBoxLayout *horizontal_layout{nullptr};
-    int stretch{1};
-    int indent{0};
-};
-
-void OptionsDialog::CreateOptionUI(QBoxLayout * const layout, const QString& text, const std::vector<QWidget *>& objs, const CreateOptionUIOpts& opts)
-{
-    Assert(!objs.empty());
-
-    auto& first_o = objs[0];
-    QWidget * const parent = first_o->parentWidget();
-
-    QBoxLayout * const horizontalLayout = opts.horizontal_layout ? opts.horizontal_layout : (new QHBoxLayout);
-
-    if (opts.indent) horizontalLayout->addSpacing(opts.indent);
-
-    int processed{0}, index_start{0};
-    QWidget *last_widget{nullptr};
-    while (true) {
-        int pos = text.indexOf('%', index_start);
-        int idx;
-        if (pos == -1) {
-            pos = text.size();
-            idx = -1;
-        } else {
-            const int pos_next{pos + 1};
-            const auto char_next = text[pos_next];
-            idx = (char_next == 's') ? 0 : (char_next.digitValue() - 1);
-            if (pos_next == text.size() || idx < 0 || idx > 8 || (unsigned)idx >= objs.size()) {
-                index_start = pos_next;
-                continue;
-            }
-        }
-        if (processed != pos) {
-            auto label_text = text.mid(processed, pos - processed);
-            if (auto last_widget_as_qcheckbox = qobject_cast<QCheckBox*>(last_widget)) {
-                if (label_text[0].isSpace()) label_text = label_text.mid(1);
-                last_widget_as_qcheckbox->setText(label_text);
-            } else {
-                const auto label = new QLabel(parent);
-                label->setText(label_text);
-                label->setTextFormat(Qt::PlainText);
-                label->setBuddy(first_o);
-                label->setToolTip(first_o->toolTip());
-                horizontalLayout->addWidget(label);
-            }
-        }
-        if (idx == -1) break;
-        last_widget = objs[idx];
-        horizontalLayout->addWidget(last_widget);
-        index_start = processed = pos + 2;
-    }
-
-    if (opts.stretch) horizontalLayout->addStretch(opts.stretch);
-
-    layout->addLayout(horizontalLayout);
-
-    for (auto& o : objs) {
-        o->setProperty("L", QVariant::fromValue((QLayout*)horizontalLayout));
-        FixTabOrder(o);
-    }
-}
-
-void OptionsDialog::CreateOptionUI(QBoxLayout * const layout, const QString& text, const std::vector<QWidget *>& objs)
-{
-    CreateOptionUI(layout, text, objs, {});
-}
-
-void OptionsDialog::CreateOptionUI(QBoxLayout * const layout, QWidget * const o, const QString& text, QBoxLayout *horizontalLayout)
-{
-    CreateOptionUI(layout, text, {o}, { .horizontal_layout = horizontalLayout, });
-}
-
-static void setSiblingsEnabled(QWidget * const o, const bool state)
-{
-    auto layout = o->property("L").value<QLayout*>();
-    Assert(layout);
-    // NOTE: QLayout::children does not do what we need here
-    for (int i = layout->count(); i-- > 0; ) {
-        QLayoutItem * const layoutitem = layout->itemAt(i);
-        QWidget * const childwidget = layoutitem->widget();
-        if (!childwidget) continue;
-        childwidget->setEnabled(state);
-    }
-}
 
 int setFontChoice(QComboBox* cb, const OptionsModel::FontChoice& fc)
 {
@@ -253,13 +102,8 @@ OptionsDialog::OptionsDialog(QWidget* parent, bool enableWallet)
     ui->pruneWarning->setVisible(false);
     ui->pruneWarning->setStyleSheet("QLabel { color: red; }");
 
-    ui->pruneSizeMiB->setEnabled(false);
-    connect(ui->prune, &QCheckBox::stateChanged, [this](int state){
-        ui->pruneSizeMiB->setEnabled(state == Qt::Checked);
-    });
-
-    ui->networkPort->setValidator(new QIntValidator(1024, 65535, this));
-    connect(ui->networkPort, SIGNAL(textChanged(const QString&)), this, SLOT(checkLineEdit()));
+    ui->pruneSize->setEnabled(false);
+    connect(ui->prune, &QPushButton::toggled, ui->pruneSize, &QWidget::setEnabled);
 
     /* Network elements init */
 #ifndef USE_UPNP
@@ -285,277 +129,6 @@ OptionsDialog::OptionsDialog(QWidget* parent, bool enableWallet)
     connect(ui->connectSocksTor, &QPushButton::toggled, ui->proxyPortTor, &QWidget::setEnabled);
     connect(ui->connectSocksTor, &QPushButton::toggled, this, &OptionsDialog::updateProxyValidationState);
 
-    ui->maxuploadtarget->setMinimum(144 /* MiB/day */);
-    ui->maxuploadtarget->setMaximum(std::numeric_limits<int>::max());
-    connect(ui->maxuploadtargetCheckbox, SIGNAL(toggled(bool)), ui->maxuploadtarget, SLOT(setEnabled(bool)));
-
-    prevwidget = ui->tabWidget;
-
-    walletrbf = new QCheckBox(ui->tabWallet);
-    walletrbf->setText(tr("Request Replace-By-Fee"));
-    walletrbf->setToolTip(tr("Indicates that the sender may wish to replace this transaction with a new one paying higher fees (prior to being confirmed). Can be overridden per send."));
-    ui->verticalLayout_Wallet->insertWidget(0, walletrbf);
-    FixTabOrder(walletrbf);
-
-    /* Network tab */
-    QLayoutItem *spacer = ui->verticalLayout_Network->takeAt(ui->verticalLayout_Network->count() - 1);
-    prevwidget = dynamic_cast<QWidgetItem*>(ui->verticalLayout_Network->itemAt(ui->verticalLayout_Network->count() - 1))->widget();
-
-    blockreconstructionextratxn = new QSpinBox(ui->tabNetwork);
-    blockreconstructionextratxn->setMinimum(0);
-    blockreconstructionextratxn->setMaximum(std::numeric_limits<int>::max());
-    CreateOptionUI(ui->verticalLayout_Network, blockreconstructionextratxn, tr("Keep at most %s extra transactions in memory for compact block reconstruction"));
-
-    ui->verticalLayout_Network->addItem(spacer);
-
-    prevwidget = ui->peerbloomfilters;
-
-    /* Mempool tab */
-
-    QWidget * const tabMempool = new QWidget();
-    QVBoxLayout * const verticalLayout_Mempool = new QVBoxLayout(tabMempool);
-    ui->tabWidget->insertTab(ui->tabWidget->indexOf(ui->tabWindow), tabMempool, tr("Mem&pool"));
-
-    mempoolreplacement = new QValueComboBox(tabMempool);
-    mempoolreplacement->addItem(QString("never"), QVariant("never"));
-    mempoolreplacement->addItem(QString("with a higher mining fee, and opt-in"), QVariant("fee,optin"));
-    mempoolreplacement->addItem(QString("with a higher mining fee (no opt-out)"), QVariant("fee,-optin"));
-    CreateOptionUI(verticalLayout_Mempool, mempoolreplacement, tr("Transaction &replacement: %s"));
-
-    incrementalrelayfee = new BitcoinAmountField(tabMempool);
-    connect(incrementalrelayfee, SIGNAL(valueChanged()), this, SLOT(incrementalrelayfee_changed()));
-    CreateOptionUI(verticalLayout_Mempool, incrementalrelayfee, tr("Require transaction fees to be at least %s per kvB higher than transactions they are replacing."));
-
-    rejectspkreuse = new QCheckBox(tabMempool);
-    rejectspkreuse->setText(tr("Disallow most address reuse"));
-    rejectspkreuse->setToolTip(tr("With this option enabled, your memory pool will only allow each unique payment destination to be used once, effectively deprioritising address reuse. Address reuse is not technically supported, and harms the privacy of all Bitcoin users. It also has limited real-world utility, and has been known to be common with spam."));
-    verticalLayout_Mempool->addWidget(rejectspkreuse);
-    FixTabOrder(rejectspkreuse);
-
-    mempooltruc = new QValueComboBox(tabMempool);
-    mempooltruc->addItem(QString("do not relay or mine at all"), QVariant("reject"));
-    mempooltruc->addItem(QString("handle the same as other transactions"), QVariant("accept"));
-    mempooltruc->addItem(QString("impose stricter limits requested (DRAFT)"), QVariant("enforce"));
-    mempooltruc->setToolTip(tr("Some transactions signal a request to limit both themselves and other related transactions to more restrictive expectations. Specifically, this would disallow more than 1 unconfirmed predecessor or spending transaction, as well as smaller size limits (see BIP 431 for details), regardless of what policy you have configured."));
-    CreateOptionUI(verticalLayout_Mempool, mempooltruc, tr("Transactions requesting more restrictive policy limits (TRUC): %s"));
-
-    maxorphantx = new QSpinBox(tabMempool);
-    maxorphantx->setMinimum(0);
-    maxorphantx->setMaximum(std::numeric_limits<int>::max());
-    CreateOptionUI(verticalLayout_Mempool, maxorphantx, tr("Keep at most %s unconnected transactions in memory"));
-
-    maxmempool = new QSpinBox(tabMempool);
-    const int64_t nMempoolSizeMinMB = maxmempoolMinimumBytes(gArgs.GetIntArg("-limitdescendantsize", DEFAULT_DESCENDANT_SIZE_LIMIT_KVB) * 1'000) / 1'000'000;
-    maxmempool->setMinimum(nMempoolSizeMinMB);
-    maxmempool->setMaximum(std::numeric_limits<int>::max());
-    CreateOptionUI(verticalLayout_Mempool, maxmempool, tr("Keep the transaction memory pool below %s MB"));
-
-    mempoolexpiry = new QSpinBox(tabMempool);
-    mempoolexpiry->setMinimum(1);
-    mempoolexpiry->setMaximum(std::numeric_limits<int>::max());
-    CreateOptionUI(verticalLayout_Mempool, mempoolexpiry, tr("Do not keep transactions in memory more than %s hours"));
-
-    verticalLayout_Mempool->addItem(new QSpacerItem(20, 40, QSizePolicy::Minimum, QSizePolicy::Expanding));
-
-    /* Filters tab */
-
-    QWidget * const tabFilters = new QWidget();
-    auto& groupBox_Spamfiltering = tabFilters;
-    ui->tabWidget->insertTab(ui->tabWidget->indexOf(ui->tabWindow), ModScrollArea::fromWidget(this, groupBox_Spamfiltering), tr("Spam &filtering"));
-    QVBoxLayout * const verticalLayout_Spamfiltering = new QVBoxLayout(groupBox_Spamfiltering);
-
-    rejectunknownscripts = new QCheckBox(groupBox_Spamfiltering);
-    rejectunknownscripts->setText(tr("Ignore unrecognised receiver scripts"));
-    rejectunknownscripts->setToolTip(tr("With this option enabled, unrecognised receiver (\"pubkey\") scripts will be ignored. Unrecognisable scripts could be used to bypass further spam filters. If your software is outdated, they may also be used to trick you into thinking you were sent bitcoins that will never confirm."));
-    verticalLayout_Spamfiltering->addWidget(rejectunknownscripts);
-    FixTabOrder(rejectunknownscripts);
-
-    rejectparasites = new QCheckBox(groupBox_Spamfiltering);
-    rejectparasites->setText(tr("Reject parasite transactions"));
-    rejectparasites->setToolTip(tr("With this option enabled, transactions related to parasitic overlay protocols will be ignored. Parasites are transactions using Bitcoin as a technical infrastructure to animate other protocols, unrelated to ordinary money transfers."));
-    verticalLayout_Spamfiltering->addWidget(rejectparasites);
-    FixTabOrder(rejectparasites);
-
-    rejecttokens = new QCheckBox(groupBox_Spamfiltering);
-    rejecttokens->setText(tr("Ignore transactions involving non-bitcoin token/asset overlay protocols"));
-    rejecttokens->setToolTip(tr("With this option enabled, transactions involving non-bitcoin tokens/assets will not be relayed or mined by your node. Due to not having value, and some technical design flaws, token mints and transfers are often spammy and can bog down the network."));
-    verticalLayout_Spamfiltering->addWidget(rejecttokens);
-    FixTabOrder(rejecttokens);
-
-    minrelaytxfee = new BitcoinAmountField(groupBox_Spamfiltering);
-    CreateOptionUI(verticalLayout_Spamfiltering, minrelaytxfee, tr("Ignore transactions offering miners less than %s per kvB in transaction fees."));
-
-    bytespersigop = new QSpinBox(groupBox_Spamfiltering);
-    bytespersigop->setMinimum(1);
-    bytespersigop->setMaximum(std::numeric_limits<int>::max());
-    CreateOptionUI(verticalLayout_Spamfiltering, bytespersigop, tr("Treat each consensus-counted sigop as at least %s bytes."));
-
-    bytespersigopstrict = new QSpinBox(groupBox_Spamfiltering);
-    bytespersigopstrict->setMinimum(1);
-    bytespersigopstrict->setMaximum(std::numeric_limits<int>::max());
-    CreateOptionUI(verticalLayout_Spamfiltering, bytespersigopstrict, tr("Ignore transactions with fewer than %s bytes per potentially-executed sigop."));
-
-    limitancestorcount = new QSpinBox(groupBox_Spamfiltering);
-    limitancestorcount->setMinimum(1);
-    limitancestorcount->setMaximum(std::numeric_limits<int>::max());
-    CreateOptionUI(verticalLayout_Spamfiltering, limitancestorcount, tr("Ignore transactions with %s or more unconfirmed ancestors."));
-
-    limitancestorsize = new QSpinBox(groupBox_Spamfiltering);
-    limitancestorsize->setMinimum(1);
-    limitancestorsize->setMaximum(std::numeric_limits<int>::max());
-    CreateOptionUI(verticalLayout_Spamfiltering, limitancestorsize, tr("Ignore transactions whose size with all unconfirmed ancestors exceeds %s kilobytes."));
-
-    limitdescendantcount = new QSpinBox(groupBox_Spamfiltering);
-    limitdescendantcount->setMinimum(1);
-    limitdescendantcount->setMaximum(std::numeric_limits<int>::max());
-    CreateOptionUI(verticalLayout_Spamfiltering, limitdescendantcount, tr("Ignore transactions if any ancestor would have %s or more unconfirmed descendants."));
-
-    limitdescendantsize = new QSpinBox(groupBox_Spamfiltering);
-    limitdescendantsize->setMinimum(1);
-    limitdescendantsize->setMaximum(std::numeric_limits<int>::max());
-    CreateOptionUI(verticalLayout_Spamfiltering, limitdescendantsize, tr("Ignore transactions if any ancestor would have more than %s kilobytes of unconfirmed descendants."));
-
-    rejectbarepubkey = new QCheckBox(groupBox_Spamfiltering);
-    rejectbarepubkey->setText(tr("Ignore bare/exposed public keys (pay-to-IP)"));
-    rejectbarepubkey->setToolTip(tr("Spam is sometimes disguised to appear as if it is a deprecated pay-to-IP (bare pubkey) transaction, where the \"key\" is actually arbitrary data (not a real key) instead. Support for pay-to-IP was only ever supported by Satoshi's early Bitcoin wallet, which has been abandoned since 2011."));
-    verticalLayout_Spamfiltering->addWidget(rejectbarepubkey);
-    FixTabOrder(rejectbarepubkey);
-
-    rejectbaremultisig = new QCheckBox(groupBox_Spamfiltering);
-    rejectbaremultisig->setText(tr("Ignore bare/exposed \"multisig\" scripts"));
-    rejectbaremultisig->setToolTip(tr("Spam is sometimes disguised to appear as if it is an old-style N-of-M multi-party transaction, where most of the keys are really bogus. At the same time, legitimate multi-party transactions typically have always used P2SH format (which is not filtered by this option), which is more secure."));
-    verticalLayout_Spamfiltering->addWidget(rejectbaremultisig);
-    FixTabOrder(rejectbaremultisig);
-
-    maxscriptsize = new QSpinBox(groupBox_Spamfiltering);
-    maxscriptsize->setMinimum(0);
-    maxscriptsize->setMaximum(std::numeric_limits<int>::max());
-    maxscriptsize->setToolTip(tr("There may be rare smart contracts that require a large amount of code, but more often a larger code segment is actually just spam finding new ways to try to evade filtering. 1650 bytes is sometimes considered the high end of what might be normal, usually for N-of-20 multisig."));
-    CreateOptionUI(verticalLayout_Spamfiltering, maxscriptsize, tr("Ignore transactions with smart contract code larger than %s bytes."));
-
-    datacarriersize = new QSpinBox(groupBox_Spamfiltering);
-    datacarriersize->setMinimum(0);
-    datacarriersize->setMaximum(std::numeric_limits<int>::max());
-    datacarriersize->setToolTip(tr("While Bitcoin itself does not support attaching arbitrary data to transactions, despite that various methods for disguising it have been devised over the years. Since it is sometimes impractical to detect small spam disguised as ordinary transactions, it is sometimes considered beneficial to tolerate certain kinds of less harmful data attachments."));
-    CreateOptionUI(verticalLayout_Spamfiltering, datacarriersize, tr("Ignore transactions with additional data larger than %s bytes."));
-
-    datacarriercost = new QDoubleSpinBox(groupBox_Spamfiltering);
-    datacarriercost->setDecimals(2);
-    datacarriercost->setStepType(QAbstractSpinBox::DefaultStepType);
-    datacarriercost->setSingleStep(0.25);
-    datacarriercost->setMinimum(0.25);
-    datacarriercost->setMaximum(MAX_BLOCK_SERIALIZED_SIZE);
-    datacarriercost->setToolTip(tr("As an alternative to, or in addition to, limiting the size of disguised data, you can also configure how it is accounted for in comparison to legitimate transaction data. For example, 1 vbyte per actual byte would count it as equivalent to ordinary transaction data; 0.25 vB/B would allow it to benefit from the so-called \"segwit discount\"; or 2 vB/B would establish a bias toward legitimate transactions."));
-    CreateOptionUI(verticalLayout_Spamfiltering, datacarriercost, tr("Weigh embedded data as %s virtual bytes per actual byte."));
-    connect(datacarriercost, QOverload<double>::of(&QDoubleSpinBox::valueChanged), [&](double d){
-        const double w = d * 4;
-        const double wf = floor(w);
-        if (w != wf) datacarriercost->setValue(wf / 4);
-    });
-
-    rejectnonstddatacarrier = new QCheckBox(groupBox_Spamfiltering);
-    rejectnonstddatacarrier->setText(tr("Ignore data embedded with non-standard formats"));
-    rejectnonstddatacarrier->setToolTip(tr("Some attempts to spam Bitcoin intentionally use non-standard formats in an attempt to bypass the datacarrier limits. Without this option, %1 will attempt to detect these and enforce the intended limits. By enabling this option, your node will ignore these transactions entirely (when detected) even if they fall within the configured limits otherwise."));
-    verticalLayout_Spamfiltering->addWidget(rejectnonstddatacarrier);
-    FixTabOrder(rejectnonstddatacarrier);
-
-    dustrelayfee = new BitcoinAmountField(groupBox_Spamfiltering);
-    CreateOptionUI(verticalLayout_Spamfiltering, dustrelayfee, tr("Ignore transactions with values that would cost more to spend at a fee rate of %s per kvB (\"dust\")."));
-
-
-    dustdynamic_enable = new QCheckBox(groupBox_Spamfiltering);
-    dustdynamic_multiplier = new QDoubleSpinBox(groupBox_Spamfiltering);
-    dustdynamic_multiplier->setDecimals(3);
-    dustdynamic_multiplier->setStepType(QAbstractSpinBox::DefaultStepType);
-    dustdynamic_multiplier->setSingleStep(1);
-    dustdynamic_multiplier->setMinimum(0.001);
-    dustdynamic_multiplier->setMaximum(65);
-    dustdynamic_multiplier->setValue(DEFAULT_DUST_RELAY_MULTIPLIER / 1000.0);
-    CreateOptionUI(verticalLayout_Spamfiltering, tr("%1 Automatically adjust the dust limit upward to %2 times:"), {dustdynamic_enable, dustdynamic_multiplier});
-
-    QStyleOptionButton styleoptbtn;
-    const auto checkbox_indent = dustdynamic_enable->style()->subElementRect(QStyle::SE_CheckBoxIndicator, &styleoptbtn, dustdynamic_enable).width();
-
-    dustdynamic_target = new QRadioButton(groupBox_Spamfiltering);
-    dustdynamic_target_blocks = new QSpinBox(groupBox_Spamfiltering);
-    dustdynamic_target_blocks->setMinimum(2);
-    dustdynamic_target_blocks->setMaximum(1008);  // FIXME: Get this from the fee estimator
-    dustdynamic_target_blocks->setValue(1008);
-    CreateOptionUI(verticalLayout_Spamfiltering, tr("%1 fee estimate for %2 blocks."), {dustdynamic_target, dustdynamic_target_blocks}, { .indent = checkbox_indent, });
-    // FIXME: Make it possible to click labels to select + focus spinbox
-
-    dustdynamic_mempool = new QRadioButton(groupBox_Spamfiltering);
-    dustdynamic_mempool_kvB = new QSpinBox(groupBox_Spamfiltering);
-    dustdynamic_mempool_kvB->setMinimum(1);
-    dustdynamic_mempool_kvB->setMaximum(std::numeric_limits<int32_t>::max());
-    dustdynamic_mempool_kvB->setValue(3024000);
-    CreateOptionUI(verticalLayout_Spamfiltering, tr("%1 the lowest fee of the best known %2 kvB of unconfirmed transactions."), {dustdynamic_mempool, dustdynamic_mempool_kvB}, { .indent = checkbox_indent, });
-
-    const auto dustdynamic_enable_toggled = [this](const bool state){
-        dustdynamic_multiplier->setEnabled(state);
-        setSiblingsEnabled(dustdynamic_target_blocks, state);
-        setSiblingsEnabled(dustdynamic_mempool_kvB, state);
-        if (state) {
-            if (!dustdynamic_mempool->isChecked()) dustdynamic_target->setChecked(true);
-            dustdynamic_target_blocks->setEnabled(dustdynamic_target->isChecked());
-            dustdynamic_mempool_kvB->setEnabled(dustdynamic_mempool->isChecked());
-        }
-    };
-    connect(dustdynamic_enable, &QAbstractButton::toggled, dustdynamic_enable_toggled);
-    dustdynamic_enable_toggled(dustdynamic_enable->isChecked());
-    connect(dustdynamic_target, &QAbstractButton::toggled, [this](const bool state){
-        dustdynamic_target_blocks->setEnabled(state);
-    });
-    connect(dustdynamic_mempool, &QAbstractButton::toggled, [this](const bool state){
-        dustdynamic_mempool_kvB->setEnabled(state);
-    });
-
-
-    connect(rejectunknownscripts, &QAbstractButton::toggled, [this, dustdynamic_enable_toggled](const bool state){
-        rejectbarepubkey->setEnabled(state);
-        rejectbaremultisig->setEnabled(state);
-        rejectparasites->setEnabled(state);
-        rejecttokens->setEnabled(state);
-        setSiblingsEnabled(dustrelayfee, state);
-        setSiblingsEnabled(maxscriptsize, state);
-        setSiblingsEnabled(dustdynamic_multiplier, state);
-        dustdynamic_enable_toggled(state && dustdynamic_enable->isChecked());
-    });
-
-
-    verticalLayout_Spamfiltering->addStretch(1);
-
-    /* Mining tab */
-
-    QWidget * const tabMining = new QWidget();
-    QVBoxLayout * const verticalLayout_Mining = new QVBoxLayout(tabMining);
-    ui->tabWidget->insertTab(ui->tabWidget->indexOf(ui->tabWindow), tabMining, tr("M&ining"));
-
-    verticalLayout_Mining->addWidget(new QLabel(tr("<strong>Note that mining is heavily influenced by the settings on the Mempool and Spam filtering tabs.</strong>")));
-
-    blockmintxfee = new BitcoinAmountField(tabMining);
-    CreateOptionUI(verticalLayout_Mining, blockmintxfee, tr("Only mine transactions paying a fee of at least %s per kvB."));
-
-    blockmaxsize = new QSpinBox(tabMining);
-    blockmaxsize->setMinimum(1);
-    blockmaxsize->setMaximum((MAX_BLOCK_SERIALIZED_SIZE - 1000) / 1000);
-    connect(blockmaxsize, SIGNAL(valueChanged(int)), this, SLOT(blockmaxsize_changed(int)));
-    CreateOptionUI(verticalLayout_Mining, blockmaxsize, tr("Never mine a block larger than %s kB."));
-
-    blockprioritysize = new QSpinBox(tabMining);
-    blockprioritysize->setMinimum(0);
-    blockprioritysize->setMaximum(blockmaxsize->maximum());
-    connect(blockprioritysize, SIGNAL(valueChanged(int)), this, SLOT(blockmaxsize_increase(int)));
-    CreateOptionUI(verticalLayout_Mining, blockprioritysize, tr("Mine first %s kB of transactions sorted by coin-age priority."));
-
-    blockmaxweight = new QSpinBox(tabMining);
-    blockmaxweight->setMinimum(1);
-    blockmaxweight->setMaximum((MAX_BLOCK_WEIGHT-4000) / 1000);
-    connect(blockmaxweight, SIGNAL(valueChanged(int)), this, SLOT(blockmaxweight_changed(int)));
-    CreateOptionUI(verticalLayout_Mining, blockmaxweight, tr("Never mine a block weighing more than %s kWU."));
-
-    verticalLayout_Mining->addItem(new QSpacerItem(20, 40, QSizePolicy::Minimum, QSizePolicy::Expanding));
-
     /* Window elements init */
 #ifdef Q_OS_MACOS
     /* remove Window tab on Mac */
@@ -571,15 +144,6 @@ OptionsDialog::OptionsDialog(QWidget* parent, bool enableWallet)
         ui->tabWidget->removeTab(ui->tabWidget->indexOf(ui->tabWallet));
         ui->thirdPartyTxUrlsLabel->setVisible(false);
         ui->thirdPartyTxUrls->setVisible(false);
-    } else {
-        for (OutputType type : OUTPUT_TYPES) {
-            const QString& val = QString::fromStdString(FormatOutputType(type));
-            const auto [text, tooltip] = GetOutputTypeDescription(type);
-
-            const auto index = ui->addressType->count();
-            ui->addressType->addItem(text, val);
-            ui->addressType->setItemData(index, tooltip, Qt::ToolTipRole);
-        }
     }
 
 #ifdef ENABLE_EXTERNAL_SIGNER
@@ -642,14 +206,6 @@ OptionsDialog::OptionsDialog(QWidget* parent, bool enableWallet)
     }
 
     setupFontOptions(ui->moneyFont, ui->moneyFont_preview);
-    setupFontOptions(ui->qrFont, ui->qrFont_preview);
-#ifndef USE_QRCODE
-    ui->qrFontLabel->setVisible(false);
-    ui->qrFont->setVisible(false);
-    ui->qrFont_preview->setVisible(false);
-#endif
-
-    adjustSize();
 
     GUIUtil::handleCloseWindowShortcut(this);
 }
@@ -674,8 +230,9 @@ void OptionsDialog::setModel(OptionsModel *_model)
         if (_model->isRestartRequired())
             showRestartWarning(true);
 
-        static constexpr uint64_t nMinDiskSpace = (MIN_DISK_SPACE_FOR_BLOCK_FILES + MiB_BYTES - 1) / MiB_BYTES;
-        ui->pruneSizeMiB->setRange(nMinDiskSpace, std::numeric_limits<int>::max());
+        // Prune values are in GB to be consistent with intro.cpp
+        static constexpr uint64_t nMinDiskSpace = (MIN_DISK_SPACE_FOR_BLOCK_FILES / GB_BYTES) + (MIN_DISK_SPACE_FOR_BLOCK_FILES % GB_BYTES) ? 1 : 0;
+        ui->pruneSize->setRange(nMinDiskSpace, std::numeric_limits<int>::max());
 
         QString strLabel = _model->getOverriddenByCommandLine();
         if (strLabel.isEmpty())
@@ -689,9 +246,6 @@ void OptionsDialog::setModel(OptionsModel *_model)
         const auto& font_for_money = _model->data(_model->index(OptionsModel::FontForMoney, 0), Qt::EditRole).value<OptionsModel::FontChoice>();
         setFontChoice(ui->moneyFont, font_for_money);
 
-        const auto& font_for_qrcodes = _model->data(_model->index(OptionsModel::FontForQRCodes, 0), Qt::EditRole).value<OptionsModel::FontChoice>();
-        setFontChoice(ui->qrFont, font_for_qrcodes);
-
         updateDefaultProxyNets();
     }
 
@@ -700,22 +254,17 @@ void OptionsDialog::setModel(OptionsModel *_model)
     /* Main */
     connect(ui->prune, &QCheckBox::clicked, this, &OptionsDialog::showRestartWarning);
     connect(ui->prune, &QCheckBox::clicked, this, &OptionsDialog::togglePruneWarning);
-    connect(ui->pruneSizeMiB, qOverload<int>(&QSpinBox::valueChanged), this, &OptionsDialog::showRestartWarning);
+    connect(ui->pruneSize, qOverload<int>(&QSpinBox::valueChanged), this, &OptionsDialog::showRestartWarning);
     connect(ui->databaseCache, qOverload<int>(&QSpinBox::valueChanged), this, &OptionsDialog::showRestartWarning);
     connect(ui->externalSignerPath, &QLineEdit::textChanged, [this]{ showRestartWarning(); });
     connect(ui->threadsScriptVerif, qOverload<int>(&QSpinBox::valueChanged), this, &OptionsDialog::showRestartWarning);
     /* Wallet */
     connect(ui->spendZeroConfChange, &QCheckBox::clicked, this, &OptionsDialog::showRestartWarning);
     /* Network */
-    connect(ui->networkPort, SIGNAL(textChanged(const QString &)), this, SLOT(showRestartWarning()));
     connect(ui->allowIncoming, &QCheckBox::clicked, this, &OptionsDialog::showRestartWarning);
     connect(ui->enableServer, &QCheckBox::clicked, this, &OptionsDialog::showRestartWarning);
     connect(ui->connectSocks, &QCheckBox::clicked, this, &OptionsDialog::showRestartWarning);
     connect(ui->connectSocksTor, &QCheckBox::clicked, this, &OptionsDialog::showRestartWarning);
-    connect(ui->peerbloomfilters, &QCheckBox::clicked, this, &OptionsDialog::showRestartWarning);
-    connect(ui->peerblockfilters, &QCheckBox::clicked, this, &OptionsDialog::showRestartWarning);
-    /* Mempool */
-    connect(rejectspkreuse, &QCheckBox::clicked, this, &OptionsDialog::showRestartWarning);
     /* Display */
     connect(ui->lang, qOverload<>(&QValueComboBox::valueChanged), [this]{ showRestartWarning(); });
     connect(ui->thirdPartyTxUrls, &QLineEdit::textChanged, [this]{ showRestartWarning(); });
@@ -737,17 +286,10 @@ void OptionsDialog::setMapper()
     mapper->addMapping(ui->bitcoinAtStartup, OptionsModel::StartAtStartup);
     mapper->addMapping(ui->threadsScriptVerif, OptionsModel::ThreadsScriptVerif);
     mapper->addMapping(ui->databaseCache, OptionsModel::DatabaseCache);
-
-    const auto prune_checkstate = model->data(model->index(OptionsModel::PruneTristate, 0), Qt::EditRole).value<Qt::CheckState>();
-    if (prune_checkstate == Qt::PartiallyChecked) {
-        ui->prune->setTristate();
-    }
-    ui->prune->setCheckState(prune_checkstate);
-    mapper->addMapping(ui->pruneSizeMiB, OptionsModel::PruneSizeMiB);
+    mapper->addMapping(ui->prune, OptionsModel::Prune);
+    mapper->addMapping(ui->pruneSize, OptionsModel::PruneSize);
 
     /* Wallet */
-    mapper->addMapping(walletrbf, OptionsModel::walletrbf);
-    mapper->addMapping(ui->addressType, OptionsModel::addresstype);
     mapper->addMapping(ui->spendZeroConfChange, OptionsModel::SpendZeroConfChange);
     mapper->addMapping(ui->coinControlFeatures, OptionsModel::CoinControlFeatures);
     mapper->addMapping(ui->subFeeFromAmount, OptionsModel::SubFeeFromAmount);
@@ -755,7 +297,6 @@ void OptionsDialog::setMapper()
     mapper->addMapping(ui->m_enable_psbt_controls, OptionsModel::EnablePSBTControls);
 
     /* Network */
-    mapper->addMapping(ui->networkPort, OptionsModel::NetworkPort);
     mapper->addMapping(ui->mapPortUpnp, OptionsModel::MapPortUPnP);
     mapper->addMapping(ui->mapPortNatpmp, OptionsModel::MapPortNatpmp);
     mapper->addMapping(ui->allowIncoming, OptionsModel::Listen);
@@ -769,99 +310,6 @@ void OptionsDialog::setMapper()
     mapper->addMapping(ui->proxyIpTor, OptionsModel::ProxyIPTor);
     mapper->addMapping(ui->proxyPortTor, OptionsModel::ProxyPortTor);
 
-    int current_maxuploadtarget = model->data(model->index(OptionsModel::maxuploadtarget, 0), Qt::EditRole).toInt();
-    if (current_maxuploadtarget == 0) {
-        ui->maxuploadtargetCheckbox->setChecked(false);
-        ui->maxuploadtarget->setEnabled(false);
-        ui->maxuploadtarget->setValue(ui->maxuploadtarget->minimum());
-    } else {
-        if (current_maxuploadtarget < ui->maxuploadtarget->minimum()) {
-            ui->maxuploadtarget->setMinimum(current_maxuploadtarget);
-        }
-        ui->maxuploadtargetCheckbox->setChecked(true);
-        ui->maxuploadtarget->setEnabled(true);
-        ui->maxuploadtarget->setValue(current_maxuploadtarget);
-    }
-
-    mapper->addMapping(ui->peerbloomfilters, OptionsModel::peerbloomfilters);
-    mapper->addMapping(ui->peerblockfilters, OptionsModel::peerblockfilters);
-    if (prune_checkstate != Qt::Unchecked && !GetBlockFilterIndex(BlockFilterType::BASIC)) {
-        // Once pruning begins, it's too late to enable block filters, and doing so will prevent starting the client
-        // Rather than try to monitor sync state, just disable the option once pruning is enabled
-        // Advanced users can override this manually anyway
-        ui->peerblockfilters->setEnabled(false);
-        ui->peerblockfilters->setToolTip(ui->peerblockfilters->toolTip() + " " + tr("(only available if enabled at least once before turning on pruning)"));
-    }
-
-    mapper->addMapping(blockreconstructionextratxn, OptionsModel::blockreconstructionextratxn);
-
-    /* Mempool tab */
-
-    QVariant current_mempoolreplacement = model->data(model->index(OptionsModel::mempoolreplacement, 0), Qt::EditRole);
-    int current_mempoolreplacement_index = mempoolreplacement->findData(current_mempoolreplacement);
-    if (current_mempoolreplacement_index == -1) {
-        mempoolreplacement->addItem(current_mempoolreplacement.toString(), current_mempoolreplacement);
-        current_mempoolreplacement_index = mempoolreplacement->count() - 1;
-    }
-    mempoolreplacement->setCurrentIndex(current_mempoolreplacement_index);
-
-    QVariant current_mempooltruc = model->data(model->index(OptionsModel::mempooltruc, 0), Qt::EditRole);
-    int current_mempooltruc_index = mempooltruc->findData(current_mempooltruc);
-    if (current_mempooltruc_index == -1) {
-        mempooltruc->addItem(current_mempooltruc.toString(), current_mempooltruc);
-        current_mempooltruc_index = mempooltruc->count() - 1;
-    }
-    mempooltruc->setCurrentIndex(current_mempooltruc_index);
-
-    mapper->addMapping(maxorphantx, OptionsModel::maxorphantx);
-    mapper->addMapping(maxmempool, OptionsModel::maxmempool);
-    mapper->addMapping(incrementalrelayfee, OptionsModel::incrementalrelayfee);
-    mapper->addMapping(mempoolexpiry, OptionsModel::mempoolexpiry);
-
-    mapper->addMapping(rejectunknownscripts, OptionsModel::rejectunknownscripts);
-    mapper->addMapping(rejectparasites, OptionsModel::rejectparasites);
-    mapper->addMapping(rejecttokens, OptionsModel::rejecttokens);
-    mapper->addMapping(rejectspkreuse, OptionsModel::rejectspkreuse);
-    mapper->addMapping(minrelaytxfee, OptionsModel::minrelaytxfee);
-    mapper->addMapping(bytespersigop, OptionsModel::bytespersigop);
-    mapper->addMapping(bytespersigopstrict, OptionsModel::bytespersigopstrict);
-    mapper->addMapping(limitancestorcount, OptionsModel::limitancestorcount);
-    mapper->addMapping(limitancestorsize, OptionsModel::limitancestorsize);
-    mapper->addMapping(limitdescendantcount, OptionsModel::limitdescendantcount);
-    mapper->addMapping(limitdescendantsize, OptionsModel::limitdescendantsize);
-    mapper->addMapping(rejectbarepubkey, OptionsModel::rejectbarepubkey);
-    mapper->addMapping(rejectbaremultisig, OptionsModel::rejectbaremultisig);
-    mapper->addMapping(maxscriptsize, OptionsModel::maxscriptsize);
-    mapper->addMapping(datacarriercost, OptionsModel::datacarriercost);
-    mapper->addMapping(datacarriersize, OptionsModel::datacarriersize);
-    mapper->addMapping(rejectnonstddatacarrier, OptionsModel::rejectnonstddatacarrier);
-    mapper->addMapping(dustrelayfee, OptionsModel::dustrelayfee);
-
-    QVariant current_dustdynamic = model->data(model->index(OptionsModel::dustdynamic, 0), Qt::EditRole);
-    const util::Result<std::pair<int32_t, int>> parsed_dustdynamic = ParseDustDynamicOpt(current_dustdynamic.toString().toStdString(), std::numeric_limits<unsigned int>::max());
-    if (parsed_dustdynamic) {
-        if (parsed_dustdynamic->first == 0) {
-            dustdynamic_enable->setChecked(false);
-        } else {
-            dustdynamic_multiplier->setValue(parsed_dustdynamic->second / 1000.0);
-            if (parsed_dustdynamic->first < 0) {
-                dustdynamic_target->setChecked(true);
-                dustdynamic_target_blocks->setValue(-parsed_dustdynamic->first);
-            } else {
-                dustdynamic_mempool->setChecked(true);
-                dustdynamic_mempool_kvB->setValue(parsed_dustdynamic->first);
-            }
-            dustdynamic_enable->setChecked(true);
-        }
-    }
-
-    /* Mining tab */
-
-    mapper->addMapping(blockmintxfee, OptionsModel::blockmintxfee);
-    mapper->addMapping(blockmaxsize, OptionsModel::blockmaxsize);
-    mapper->addMapping(blockprioritysize, OptionsModel::blockprioritysize);
-    mapper->addMapping(blockmaxweight, OptionsModel::blockmaxweight);
-
     /* Window */
 #ifndef Q_OS_MACOS
     if (QSystemTrayIcon::isSystemTrayAvailable()) {
@@ -872,64 +320,16 @@ void OptionsDialog::setMapper()
 #endif
 
     /* Display */
-    mapper->addMapping(ui->peersTabAlternatingRowColors, OptionsModel::PeersTabAlternatingRowColors);
     mapper->addMapping(ui->lang, OptionsModel::Language);
     mapper->addMapping(ui->unit, OptionsModel::DisplayUnit);
-    mapper->addMapping(ui->displayAddresses, OptionsModel::DisplayAddresses);
     mapper->addMapping(ui->thirdPartyTxUrls, OptionsModel::ThirdPartyTxUrls);
 }
 
-void OptionsDialog::checkLineEdit()
-{
-    QLineEdit * const lineedit = qobject_cast<QLineEdit*>(QObject::sender());
-    if (lineedit->hasAcceptableInput()) {
-        lineedit->setStyleSheet("");
-    } else {
-        lineedit->setStyleSheet("color: red;");
-    }
-}
-
 void OptionsDialog::setOkButtonState(bool fState)
 {
     ui->okButton->setEnabled(fState);
 }
 
-void OptionsDialog::incrementalrelayfee_changed()
-{
-    if (incrementalrelayfee->value() > minrelaytxfee->value()) {
-        minrelaytxfee->setValue(incrementalrelayfee->value());
-    }
-}
-
-void OptionsDialog::blockmaxsize_changed(int i)
-{
-    if (blockprioritysize->value() > i) {
-        blockprioritysize->setValue(i);
-    }
-
-    if (blockmaxweight->value() < i) {
-        blockmaxweight->setValue(i);
-    } else if (blockmaxweight->value() > i * WITNESS_SCALE_FACTOR) {
-        blockmaxweight->setValue(i * WITNESS_SCALE_FACTOR);
-    }
-}
-
-void OptionsDialog::blockmaxsize_increase(int i)
-{
-    if (blockmaxsize->value() < i) {
-        blockmaxsize->setValue(i);
-    }
-}
-
-void OptionsDialog::blockmaxweight_changed(int i)
-{
-    if (blockmaxsize->value() < i / WITNESS_SCALE_FACTOR) {
-        blockmaxsize->setValue(i / WITNESS_SCALE_FACTOR);
-    } else if (blockmaxsize->value() > i) {
-        blockmaxsize->setValue(i);
-    }
-}
-
 void OptionsDialog::on_resetButton_clicked()
 {
     if (model) {
@@ -945,25 +345,14 @@ void OptionsDialog::on_resetButton_clicked()
             with a client shutdown. */
         reset_dialog_text.append(tr("Client will be shut down. Do you want to proceed?"));
         //: Window title text of pop-up window shown when the user has chosen to reset options.
-        QStringList items;
-        QString strPrefix = tr("Use policy defaults for %1");
-        items << strPrefix.arg(tr(PACKAGE_NAME));
-        items << strPrefix.arg(tr("Bitcoin Core")+" ");
-
-        QInputDialog dialog(this);
-        dialog.setWindowTitle(tr("Confirm options reset"));
-        dialog.setLabelText(reset_dialog_text);
-        dialog.setComboBoxItems(items);
-        dialog.setTextValue(items[0]);
-        dialog.setComboBoxEditable(false);
-
-        if (!dialog.exec()) {
+        QMessageBox::StandardButton btnRetVal = QMessageBox::question(this, tr("Confirm options reset"),
+            reset_dialog_text, QMessageBox::Yes | QMessageBox::Cancel, QMessageBox::Cancel);
+
+        if (btnRetVal == QMessageBox::Cancel)
             return;
-        }
 
         /* reset all options and close GUI */
         model->Reset();
-        model->setData(model->index(OptionsModel::corepolicy, 0), items.indexOf(dialog.textValue()));
         close();
         Q_EMIT quitOnReset();
     }
@@ -995,48 +384,7 @@ void OptionsDialog::on_openBitcoinConfButton_clicked()
 
 void OptionsDialog::on_okButton_clicked()
 {
-    for (int i = 0; i < ui->tabWidget->count(); ++i) {
-        QWidget * const tab = ui->tabWidget->widget(i);
-        Q_FOREACH(QObject* o, tab->children()) {
-            QLineEdit * const lineedit = qobject_cast<QLineEdit*>(o);
-            if (lineedit && !lineedit->hasAcceptableInput()) {
-                int row = mapper->mappedSection(lineedit);
-                if (model->data(model->index(row, 0), Qt::EditRole) == lineedit->text()) {
-                    // Allow unchanged fields through
-                    continue;
-                }
-                ui->tabWidget->setCurrentWidget(tab);
-                lineedit->setFocus(Qt::OtherFocusReason);
-                lineedit->selectAll();
-                QMessageBox::critical(this, tr("Invalid setting"), tr("The value entered is invalid."));
-                return;
-            }
-        }
-    }
-
-    model->setData(model->index(OptionsModel::PruneTristate, 0), ui->prune->checkState());
-
     model->setData(model->index(OptionsModel::FontForMoney, 0), ui->moneyFont->itemData(ui->moneyFont->currentIndex()));
-    model->setData(model->index(OptionsModel::FontForQRCodes, 0), ui->qrFont->itemData(ui->qrFont->currentIndex()));
-
-    if (ui->maxuploadtargetCheckbox->isChecked()) {
-        model->setData(model->index(OptionsModel::maxuploadtarget, 0), ui->maxuploadtarget->value());
-    } else {
-        model->setData(model->index(OptionsModel::maxuploadtarget, 0), 0);
-    }
-
-    model->setData(model->index(OptionsModel::mempoolreplacement, 0), mempoolreplacement->itemData(mempoolreplacement->currentIndex()));
-    model->setData(model->index(OptionsModel::mempooltruc, 0), mempooltruc->itemData(mempooltruc->currentIndex()));
-
-    if (dustdynamic_enable->isChecked()) {
-        if (dustdynamic_target->isChecked()) {
-            model->setData(model->index(OptionsModel::dustdynamic, 0), QStringLiteral("%2*target:%1").arg(dustdynamic_target_blocks->value()).arg(dustdynamic_multiplier->value()));
-        } else if (dustdynamic_mempool->isChecked()) {
-            model->setData(model->index(OptionsModel::dustdynamic, 0), QStringLiteral("%2*mempool:%1").arg(dustdynamic_mempool_kvB->value()).arg(dustdynamic_multiplier->value()));
-        }
-    } else {
-        model->setData(model->index(OptionsModel::dustdynamic, 0), "off");
-    }
 
     mapper->submit();
     accept();
diff --git a/src/qt/optionsdialog.h b/src/qt/optionsdialog.h
index 6640a0704a..031e4d3163 100644
--- a/src/qt/optionsdialog.h
+++ b/src/qt/optionsdialog.h
@@ -6,42 +6,16 @@
 #define BITCOIN_QT_OPTIONSDIALOG_H
 
 #include <QDialog>
-#include <QScrollArea>
 #include <QValidator>
 
-class BitcoinAmountField;
 class ClientModel;
 class OptionsModel;
 class QValidatedLineEdit;
 
 QT_BEGIN_NAMESPACE
-class QBoxLayout;
-class QCheckBox;
 class QDataWidgetMapper;
-class QDoubleSpinBox;
-class QBoxLayout;
-class QRadioButton;
-class QSpinBox;
-class QString;
-class QValueComboBox;
-class QWidget;
 QT_END_NAMESPACE
 
-struct CreateOptionUIOpts;
-
-/** QScrollArea, but returning reasonable size hints.
- */
-class ModScrollArea : public QScrollArea {
-    Q_OBJECT
-
-public:
-    ModScrollArea();
-    static ModScrollArea *fromWidget(QWidget *parent, QWidget *o);
-
-    QSize minimumSizeHint() const override;
-    QSize sizeHint() const override;
-};
-
 namespace Ui {
 class OptionsDialog;
 }
@@ -93,12 +67,6 @@ private Q_SLOTS:
     void updateProxyValidationState();
     /* query the networks, for which the default proxy is used */
     void updateDefaultProxyNets();
-    void checkLineEdit();
-
-    void incrementalrelayfee_changed();
-    void blockmaxsize_changed(int);
-    void blockmaxsize_increase(int);
-    void blockmaxweight_changed(int);
 
 Q_SIGNALS:
     void proxyIpChecks(QValidatedLineEdit *pUiProxyIp, uint16_t nProxyPort);
@@ -109,50 +77,6 @@ private:
     ClientModel* m_client_model{nullptr};
     OptionsModel* model{nullptr};
     QDataWidgetMapper* mapper{nullptr};
-
-    QWidget *prevwidget{nullptr};
-    void FixTabOrder(QWidget *);
-    void CreateOptionUI(QBoxLayout *, const QString& text, const std::vector<QWidget *>&, const CreateOptionUIOpts&);
-    void CreateOptionUI(QBoxLayout *, const QString& text, const std::vector<QWidget *>&);
-    void CreateOptionUI(QBoxLayout *, QWidget *, const QString& text, QBoxLayout *horizontalLayout = nullptr);
-
-    QCheckBox *walletrbf;
-
-    QSpinBox *blockreconstructionextratxn;
-
-    QValueComboBox *mempoolreplacement;
-    QValueComboBox *mempooltruc;
-    QSpinBox *maxorphantx;
-    BitcoinAmountField *incrementalrelayfee;
-    QSpinBox *maxmempool;
-    QSpinBox *mempoolexpiry;
-
-    QCheckBox *rejectunknownscripts;
-    QCheckBox *rejectparasites;
-    QCheckBox *rejecttokens;
-    QCheckBox *rejectspkreuse;
-    BitcoinAmountField *minrelaytxfee;
-    QSpinBox *bytespersigop, *bytespersigopstrict;
-    QSpinBox *limitancestorcount;
-    QSpinBox *limitancestorsize;
-    QSpinBox *limitdescendantcount;
-    QSpinBox *limitdescendantsize;
-    QCheckBox *rejectbarepubkey;
-    QCheckBox *rejectbaremultisig;
-    QSpinBox *maxscriptsize;
-    QSpinBox *datacarriersize;
-    QDoubleSpinBox *datacarriercost;
-    QCheckBox *rejectnonstddatacarrier;
-    BitcoinAmountField *dustrelayfee;
-    QCheckBox *dustdynamic_enable;
-    QDoubleSpinBox *dustdynamic_multiplier;
-    QRadioButton *dustdynamic_target;
-    QSpinBox *dustdynamic_target_blocks;
-    QRadioButton *dustdynamic_mempool;
-    QSpinBox *dustdynamic_mempool_kvB;
-
-    BitcoinAmountField *blockmintxfee;
-    QSpinBox *blockmaxsize, *blockprioritysize, *blockmaxweight;
 };
 
 #endif // BITCOIN_QT_OPTIONSDIALOG_H
diff --git a/src/qt/optionsmodel.cpp b/src/qt/optionsmodel.cpp
index ee6c1b11c3..0c21c6748d 100644
--- a/src/qt/optionsmodel.cpp
+++ b/src/qt/optionsmodel.cpp
@@ -10,37 +10,17 @@
 #include <qt/guiconstants.h>
 #include <qt/guiutil.h>
 
-#include <chainparams.h>
 #include <common/args.h>
-#include <consensus/consensus.h>
-#include <index/blockfilterindex.h>
 #include <interfaces/node.h>
-#include <kernel/mempool_options.h> // for DEFAULT_MAX_MEMPOOL_SIZE_MB, DEFAULT_MEMPOOL_EXPIRY_HOURS
 #include <mapport.h>
-#include <policy/settings.h>
 #include <net.h>
-#include <net_processing.h>
 #include <netbase.h>
 #include <node/chainstatemanager_args.h>
-#include <node/context.h>
-#include <node/mempool_args.h> // for ParseDustDynamicOpt
-#include <outputtype.h>
-#include <policy/settings.h>
 #include <txdb.h> // for -dbcache defaults
-#include <util/moneystr.h> // for FormatMoney
 #include <util/string.h>
 #include <validation.h>    // For DEFAULT_SCRIPTCHECK_THREADS
 #include <wallet/wallet.h> // For DEFAULT_SPEND_ZEROCONF_CHANGE
 
-#ifdef ENABLE_WALLET
-#include <interfaces/wallet.h>
-#endif
-
-#include <chrono>
-#include <string>
-#include <unordered_set>
-#include <utility>
-
 #include <QDebug>
 #include <QLatin1Char>
 #include <QSettings>
@@ -65,10 +45,8 @@ static const char* SettingName(OptionsModel::OptionID option)
     case OptionsModel::MapPortNatpmp: return "natpmp";
     case OptionsModel::Listen: return "listen";
     case OptionsModel::Server: return "server";
-    case OptionsModel::walletrbf: return "walletrbf";
-    case OptionsModel::addresstype: return "addresstype";
-    case OptionsModel::PruneSizeMiB: return "prune";
-    case OptionsModel::PruneTristate: return "prune";
+    case OptionsModel::PruneSize: return "prune";
+    case OptionsModel::Prune: return "prune";
     case OptionsModel::ProxyIP: return "proxy";
     case OptionsModel::ProxyPort: return "proxy";
     case OptionsModel::ProxyUse: return "proxy";
@@ -76,39 +54,6 @@ static const char* SettingName(OptionsModel::OptionID option)
     case OptionsModel::ProxyPortTor: return "onion";
     case OptionsModel::ProxyUseTor: return "onion";
     case OptionsModel::Language: return "lang";
-    case OptionsModel::maxuploadtarget: return "maxuploadtarget";
-    case OptionsModel::peerbloomfilters: return "peerbloomfilters";
-    case OptionsModel::peerblockfilters: return "peerblockfilters";
-    case OptionsModel::mempoolreplacement: return "mempoolreplacement";
-    case OptionsModel::mempooltruc: return "mempooltruc";
-    case OptionsModel::maxorphantx: return "maxorphantx";
-    case OptionsModel::maxmempool: return "maxmempool";
-    case OptionsModel::incrementalrelayfee: return "incrementalrelayfee";
-    case OptionsModel::mempoolexpiry: return "mempoolexpiry";
-    case OptionsModel::rejectunknownscripts: return "rejectunknownscripts";
-    case OptionsModel::rejectparasites: return "rejectparasites";
-    case OptionsModel::rejecttokens: return "rejecttokens";
-    case OptionsModel::rejectspkreuse: return "rejectspkreuse";
-    case OptionsModel::minrelaytxfee: return "minrelaytxfee";
-    case OptionsModel::bytespersigop: return "bytespersigop";
-    case OptionsModel::bytespersigopstrict: return "bytespersigopstrict";
-    case OptionsModel::limitancestorcount: return "limitancestorcount";
-    case OptionsModel::limitancestorsize: return "limitancestorsize";
-    case OptionsModel::limitdescendantcount: return "limitdescendantcount";
-    case OptionsModel::limitdescendantsize: return "limitdescendantsize";
-    case OptionsModel::rejectbarepubkey: return "rejectbarepubkey";
-    case OptionsModel::rejectbaremultisig: return "rejectbaremultisig";
-    case OptionsModel::maxscriptsize: return "maxscriptsize";
-    case OptionsModel::datacarriercost: return "datacarriercost";
-    case OptionsModel::datacarriersize: return "datacarriersize";
-    case OptionsModel::rejectnonstddatacarrier: return "rejectnonstddatacarrier";
-    case OptionsModel::dustrelayfee: return "dustrelayfee";
-    case OptionsModel::dustdynamic: return "dustdynamic";
-    case OptionsModel::blockmintxfee: return "blockmintxfee";
-    case OptionsModel::blockmaxsize: return "blockmaxsize";
-    case OptionsModel::blockprioritysize: return "blockprioritysize";
-    case OptionsModel::blockmaxweight: return "blockmaxweight";
-    case OptionsModel::blockreconstructionextratxn: return "blockreconstructionextratxn";
     default: throw std::logic_error(strprintf("GUI option %i has no corresponding node setting.", option));
     }
 }
@@ -119,8 +64,8 @@ static void UpdateRwSetting(interfaces::Node& node, OptionsModel::OptionID optio
     if (value.isNum() &&
         (option == OptionsModel::DatabaseCache ||
          option == OptionsModel::ThreadsScriptVerif ||
-         option == OptionsModel::PruneTristate ||
-         option == OptionsModel::PruneSizeMiB)) {
+         option == OptionsModel::Prune ||
+         option == OptionsModel::PruneSize)) {
         // Write certain old settings as strings, even though they are numbers,
         // because Bitcoin 22.x releases try to read these specific settings as
         // strings in addOverriddenOption() calls at startup, triggering
@@ -135,17 +80,10 @@ static void UpdateRwSetting(interfaces::Node& node, OptionsModel::OptionID optio
 }
 
 //! Convert enabled/size values to bitcoin -prune setting.
-static common::SettingsValue PruneSettingFromMiB(Qt::CheckState prune_enabled, int prune_size_mib)
+static common::SettingsValue PruneSetting(bool prune_enabled, int prune_size_gb)
 {
-    assert(prune_enabled != Qt::Checked || prune_size_mib >= 1); // PruneSizeMiB and ParsePruneSizeMiB never return less
-    switch (prune_enabled) {
-    case Qt::Unchecked:
-        return 0;
-    case Qt::PartiallyChecked:
-        return 1;
-    default:
-        return prune_size_mib;
-    }
+    assert(!prune_enabled || prune_size_gb >= 1); // PruneSizeGB and ParsePruneSizeGB never return less
+    return prune_enabled ? PruneGBtoMiB(prune_size_gb) : 0;
 }
 
 //! Get pruning enabled value to show in GUI from bitcoin -prune setting.
@@ -155,25 +93,20 @@ static bool PruneEnabled(const common::SettingsValue& prune_setting)
     return SettingToInt(prune_setting, 0) > 1;
 }
 
-//! Get pruning enabled value to show in GUI from bitcoin -prune setting.
-static Qt::CheckState PruneSettingAsTristate(const common::SettingsValue& prune_setting)
-{
-    switch (SettingToInt(prune_setting, 0)) {
-    case 0:
-        return Qt::Unchecked;
-    case 1:
-        return Qt::PartiallyChecked;
-    default:
-        return Qt::Checked;
-    }
-}
-
 //! Get pruning size value to show in GUI from bitcoin -prune setting. If
 //! pruning is not enabled, just show default recommended pruning size (2GB).
-static int PruneSizeAsMiB(const common::SettingsValue& prune_setting)
+static int PruneSizeGB(const common::SettingsValue& prune_setting)
 {
     int value = SettingToInt(prune_setting, 0);
-    return value > 1 ? value : DEFAULT_PRUNE_TARGET_MiB;
+    return value > 1 ? PruneMiBtoGB(value) : DEFAULT_PRUNE_TARGET_GB;
+}
+
+//! Parse pruning size value provided by user in GUI or loaded from QSettings
+//! (windows registry key or qt .conf file). Smallest value that the GUI can
+//! display is 1 GB, so round up if anything less is parsed.
+static int ParsePruneSizeGB(const QVariant& prune_size)
+{
+    return std::max(1, prune_size.toInt());
 }
 
 struct ProxySetting {
@@ -188,33 +121,6 @@ static const QLatin1String fontchoice_str_embedded{"embedded"};
 static const QLatin1String fontchoice_str_best_system{"best_system"};
 static const QString fontchoice_str_custom_prefix{QStringLiteral("custom, ")};
 
-static const std::map<OutputType, std::pair<const char*, const char*>> UntranslatedOutputTypeDescriptions{
-    {OutputType::LEGACY, {
-        QT_TRANSLATE_NOOP("Output type name", "Base58 (Legacy)"),
-        QT_TRANSLATE_NOOP("Output type description", "Widest compatibility and best for health of the Bitcoin network, but may result in higher fees later. Recommended."),
-    }},
-    {OutputType::P2SH_SEGWIT, {
-        QT_TRANSLATE_NOOP("Output type name", "Base58 (P2SH Segwit)"),
-        QT_TRANSLATE_NOOP("Output type description", "Compatible with most older wallets, and may result in lower fees than Legacy."),
-    }},
-    {OutputType::BECH32, {
-        QT_TRANSLATE_NOOP("Output type name", "Native Segwit (Bech32)"),
-        QT_TRANSLATE_NOOP("Output type description", "Lower fees than Base58, but some old wallets don't support it."),
-    }},
-    {OutputType::BECH32M, {
-        QT_TRANSLATE_NOOP("Output type name", "Taproot (Bech32m)"),
-        QT_TRANSLATE_NOOP("Output type description", "Lowest fees, but wallet support is still limited."),
-    }},
-};
-
-std::pair<QString, QString> GetOutputTypeDescription(const OutputType type)
-{
-    auto& untr = UntranslatedOutputTypeDescriptions.at(type);
-    QString text = QCoreApplication::translate("Output type name", untr.first);
-    QString tooltip = QCoreApplication::translate("Output type description", untr.second);
-    return std::make_pair(text, tooltip);
-}
-
 QString OptionsModel::FontChoiceToString(const OptionsModel::FontChoice& f)
 {
     if (std::holds_alternative<FontChoiceAbstract>(f)) {
@@ -242,26 +148,6 @@ OptionsModel::FontChoice OptionsModel::FontChoiceFromString(const QString& s)
     }
 }
 
-static QString CanonicalMempoolReplacement(const OptionsModel& model)
-{
-    switch (model.node().mempool().m_opts.rbf_policy) {
-    case RBFPolicy::Never:  return "never";
-    case RBFPolicy::OptIn:  return "fee,optin";
-    case RBFPolicy::Always: return "fee,-optin";
-    }
-    assert(0);
-}
-
-static QString CanonicalMempoolTRUC(const OptionsModel& model)
-{
-    switch (model.node().mempool().m_opts.truc_policy) {
-    case TRUCPolicy::Reject:  return "reject";
-    case TRUCPolicy::Accept:  return "accept";
-    case TRUCPolicy::Enforce: return "enforce";
-    }
-    assert(0);
-}
-
 OptionsModel::OptionsModel(interfaces::Node& node, QObject *parent) :
     QAbstractListModel(parent), m_node{node}
 {
@@ -304,17 +190,9 @@ bool OptionsModel::Init(bilingual_str& error)
 
     // Display
     if (!settings.contains("DisplayBitcoinUnit")) {
-        auto init_unit = BitcoinUnit::BTC;
-        if (settings.contains("nDisplayUnit")) {
-            // Migrate to new setting
-            init_unit = BitcoinUnits::FromSetting(settings.value("nDisplayUnit").toString(), init_unit);
-        }
-        settings.setValue("DisplayBitcoinUnit", QVariant::fromValue(init_unit));
+        settings.setValue("DisplayBitcoinUnit", QVariant::fromValue(BitcoinUnit::BTC));
     }
     QVariant unit = settings.value("DisplayBitcoinUnit");
-    if (settings.contains("DisplayBitcoinUnitKnots")) {
-        unit = settings.value("DisplayBitcoinUnitKnots");
-    }
     if (unit.canConvert<BitcoinUnit>()) {
         m_display_bitcoin_unit = unit.value<BitcoinUnit>();
     } else {
@@ -322,10 +200,6 @@ bool OptionsModel::Init(bilingual_str& error)
         settings.setValue("DisplayBitcoinUnit", QVariant::fromValue(m_display_bitcoin_unit));
     }
 
-    if (!settings.contains("bDisplayAddresses"))
-        settings.setValue("bDisplayAddresses", false);
-    bDisplayAddresses = settings.value("bDisplayAddresses", false).toBool();
-
     if (!settings.contains("strThirdPartyTxUrls"))
         settings.setValue("strThirdPartyTxUrls", "");
     strThirdPartyTxUrls = settings.value("strThirdPartyTxUrls", "").toString();
@@ -341,14 +215,9 @@ bool OptionsModel::Init(bilingual_str& error)
 
     // These are shared with the core or have a command-line parameter
     // and we want command-line parameters to overwrite the GUI settings.
-    std::unordered_set<std::string> checked_settings;
     for (OptionID option : {DatabaseCache, ThreadsScriptVerif, SpendZeroConfChange, ExternalSignerPath, MapPortUPnP,
-                            MapPortNatpmp, Listen, Server, PruneTristate, ProxyUse, ProxyUseTor, Language}) {
-        // isSettingIgnored will have a false positive here during first-run prune changes
-        if (option == PruneTristate && m_prune_forced_by_gui) continue;
-
+                            MapPortNatpmp, Listen, Server, Prune, ProxyUse, ProxyUseTor, Language}) {
         std::string setting = SettingName(option);
-        checked_settings.insert(setting);
         if (node().isSettingIgnored(setting)) addOverriddenOption("-" + setting);
         try {
             getOption(option);
@@ -361,18 +230,6 @@ bool OptionsModel::Init(bilingual_str& error)
         }
     }
 
-    if (m_prune_forced_by_gui) checked_settings.insert("prune");
-    for (OptionID option = OptionID(0); option < OptionIDRowCount; option = OptionID(option + 1)) {
-        std::string setting;
-        try {
-            setting = SettingName(option);
-        } catch (const std::logic_error&) {
-            continue;  // Ignore GUI-only settings
-        }
-        if (!checked_settings.insert(setting).second) continue;
-        if (node().isSettingIgnored(setting)) addOverriddenOption("-" + setting);
-    }
-
     // If setting doesn't exist create it with defaults.
 
     // Main
@@ -387,17 +244,6 @@ bool OptionsModel::Init(bilingual_str& error)
     m_sub_fee_from_amount = settings.value("SubFeeFromAmount", false).toBool();
 #endif
 
-    // Network
-    if (!settings.contains("nNetworkPort"))
-        settings.setValue("nNetworkPort", (quint16)Params().GetDefaultPort());
-    if (!gArgs.SoftSetArg("-port", settings.value("nNetworkPort").toString().toStdString()))
-        addOverriddenOption("-port");
-
-    // rwconf settings that require a restart
-    // Caution: This is before general initialisation occurs!
-    f_peerbloomfilters = gArgs.GetBoolArg("-peerbloomfilters", DEFAULT_PEERBLOOMFILTERS);
-    f_rejectspkreuse = !(gArgs.GetArg("-spkreuse", DEFAULT_SPKREUSE) == "allow" || gArgs.GetBoolArg("-spkreuse", false));
-
     // Display
     if (settings.contains("FontForMoney")) {
         m_font_money = FontChoiceFromString(settings.value("FontForMoney").toString());
@@ -410,17 +256,6 @@ bool OptionsModel::Init(bilingual_str& error)
     }
     Q_EMIT fontForMoneyChanged(getFontForMoney());
 
-    if (settings.contains("FontForQRCodes")) {
-        m_font_qrcodes = FontChoiceFromString(settings.value("FontForQRCodes").toString());
-    }
-    Q_EMIT fontForQRCodesChanged(getFontChoiceForQRCodes());
-
-    if (!settings.contains("PeersTabAlternatingRowColors")) {
-        settings.setValue("PeersTabAlternatingRowColors", "false");
-    }
-    m_peers_tab_alternating_row_colors = settings.value("PeersTabAlternatingRowColors").toBool();
-    Q_EMIT peersTabAlternatingRowColorsChanged(m_peers_tab_alternating_row_colors);
-
     m_mask_values = settings.value("mask_values", false).toBool();
 
     return true;
@@ -459,20 +294,12 @@ void OptionsModel::Reset()
     QString dataDir = GUIUtil::getDefaultDataDirectory();
     dataDir = settings.value("strDataDir", dataDir).toString();
 
-    // Remove rw config file
-    gArgs.EraseRWConfigFile();
-
     // Remove all entries from our QSettings object
     settings.clear();
 
     // Set strDataDir
     settings.setValue("strDataDir", dataDir);
 
-    // Set prune option iff it was configured in rwconf
-    if (gArgs.RWConfigHasPruneOption()) {
-        SetPruneTargetMiB(gArgs.GetIntArg("-prune", 0));
-    }
-
     // Set that this was reset
     settings.setValue("fReset", true);
 
@@ -493,15 +320,10 @@ static ProxySetting ParseProxyString(const QString& proxy)
     if (proxy.isEmpty()) {
         return default_val;
     }
-    uint16_t port{0};
-    std::string hostname;
-    if (SplitHostPort(proxy.toStdString(), port, hostname) && port != 0) {
-        // Valid and port within the valid range
-        // Check if the hostname contains a colon, indicating an IPv6 address
-        if (hostname.find(':') != std::string::npos) {
-            hostname = "[" + hostname + "]"; // Wrap IPv6 address in brackets
-        }
-        return {true, QString::fromStdString(hostname), QString::number(port)};
+    // contains IP at index 0 and port at index 1
+    QStringList ip_port = GUIUtil::SplitSkipEmptyParts(proxy, ":");
+    if (ip_port.size() == 2) {
+        return {true, ip_port.at(0), ip_port.at(1)};
     } else { // Invalid: return default
         return default_val;
     }
@@ -522,30 +344,29 @@ static QString GetDefaultProxyAddress()
     return QString("%1:%2").arg(DEFAULT_GUI_PROXY_HOST).arg(DEFAULT_GUI_PROXY_PORT);
 }
 
-void OptionsModel::SetPruneTargetMiB(int prune_target_mib)
+void OptionsModel::SetPruneTargetGB(int prune_target_gb)
 {
     const common::SettingsValue cur_value = node().getPersistentSetting("prune");
-    const common::SettingsValue new_value = prune_target_mib;
+    const common::SettingsValue new_value = PruneSetting(prune_target_gb > 0, prune_target_gb);
 
     // Force setting to take effect. It is still safe to change the value at
     // this point because this function is only called after the intro screen is
     // shown, before the node starts.
     node().forceSetting("prune", new_value);
-    m_prune_forced_by_gui = true;
 
     // Update settings.json if value configured in intro screen is different
     // from saved value. Avoid writing settings.json if bitcoin.conf value
     // doesn't need to be overridden.
-    if (cur_value.write() != new_value.write()) {
+    if (PruneEnabled(cur_value) != PruneEnabled(new_value) ||
+        PruneSizeGB(cur_value) != PruneSizeGB(new_value)) {
         // Call UpdateRwSetting() instead of setOption() to avoid setting
         // RestartRequired flag
-        UpdateRwSetting(node(), PruneTristate, "", new_value);
-        gArgs.ModifyRWConfigFile("prune", new_value.getValStr());
+        UpdateRwSetting(node(), Prune, "", new_value);
     }
 
     // Keep previous pruning size, if pruning was disabled.
     if (PruneEnabled(cur_value)) {
-        UpdateRwSetting(node(), PruneTristate, "-prev", PruneEnabled(new_value) ? common::SettingsValue{} : cur_value);
+        UpdateRwSetting(node(), Prune, "-prev", PruneEnabled(new_value) ? common::SettingsValue{} : cur_value);
     }
 }
 
@@ -586,8 +407,6 @@ QVariant OptionsModel::getOption(OptionID option, const std::string& suffix) con
         return m_show_tray_icon;
     case MinimizeToTray:
         return fMinimizeToTray;
-    case NetworkPort:
-        return settings.value("nNetworkPort");
     case MapPortUPnP:
 #ifdef USE_UPNP
         return SettingToBool(setting(), DEFAULT_UPNP);
@@ -637,40 +456,25 @@ QVariant OptionsModel::getOption(OptionID option, const std::string& suffix) con
         return QString::fromStdString(SettingToString(setting(), ""));
     case SubFeeFromAmount:
         return m_sub_fee_from_amount;
-    case addresstype:
-    {
-        const OutputType default_address_type = ParseOutputType(gArgs.GetArg("-addresstype", "")).value_or(wallet::DEFAULT_ADDRESS_TYPE);
-        return QString::fromStdString(FormatOutputType(default_address_type));
-    }
 #endif
     case DisplayUnit:
         return QVariant::fromValue(m_display_bitcoin_unit);
-    case DisplayAddresses:
-        return bDisplayAddresses;
     case ThirdPartyTxUrls:
         return strThirdPartyTxUrls;
     case Language:
         return QString::fromStdString(SettingToString(setting(), ""));
     case FontForMoney:
         return QVariant::fromValue(m_font_money);
-    case FontForQRCodes:
-        return QVariant::fromValue(m_font_qrcodes);
-    case PeersTabAlternatingRowColors:
-        return m_peers_tab_alternating_row_colors;
-#ifdef ENABLE_WALLET
-    case walletrbf:
-        return gArgs.GetBoolArg("-walletrbf", wallet::DEFAULT_WALLET_RBF);
-#endif
     case CoinControlFeatures:
         return fCoinControlFeatures;
     case EnablePSBTControls:
         return settings.value("enable_psbt_controls");
-    case PruneTristate:
-        return PruneSettingAsTristate(setting());
-    case PruneSizeMiB:
-        return PruneEnabled(setting()) ? PruneSizeAsMiB(setting()) :
+    case Prune:
+        return PruneEnabled(setting());
+    case PruneSize:
+        return PruneEnabled(setting()) ? PruneSizeGB(setting()) :
                suffix.empty()          ? getOption(option, "-prev") :
-                                         DEFAULT_PRUNE_TARGET_MiB;
+                                         DEFAULT_PRUNE_TARGET_GB;
     case DatabaseCache:
         return qlonglong(SettingToInt(setting(), nDefaultDbCache));
     case ThreadsScriptVerif:
@@ -681,76 +485,6 @@ QVariant OptionsModel::getOption(OptionID option, const std::string& suffix) con
         return SettingToBool(setting(), false);
     case MaskValues:
         return m_mask_values;
-    case maxuploadtarget:
-        return qlonglong(node().context()->connman->GetMaxOutboundTarget() / 1024 / 1024);
-    case peerbloomfilters:
-        return f_peerbloomfilters;
-    case peerblockfilters:
-        return gArgs.GetBoolArg("-peerblockfilters", DEFAULT_PEERBLOCKFILTERS);
-    case mempoolreplacement:
-        return CanonicalMempoolReplacement(*this);
-    case mempooltruc:
-        return CanonicalMempoolTRUC(*this);
-    case maxorphantx:
-        return qlonglong(gArgs.GetIntArg("-maxorphantx", DEFAULT_MAX_ORPHAN_TRANSACTIONS));
-    case maxmempool:
-        return qlonglong(node().mempool().m_opts.max_size_bytes / 1'000'000);
-    case incrementalrelayfee:
-        return qlonglong(node().mempool().m_opts.incremental_relay_feerate.GetFeePerK());
-    case mempoolexpiry:
-        return qlonglong(std::chrono::duration_cast<std::chrono::hours>(node().mempool().m_opts.expiry).count());
-    case rejectunknownscripts:
-        return node().mempool().m_opts.require_standard;
-    case rejectparasites:
-        return node().mempool().m_opts.reject_parasites;
-    case rejecttokens:
-        return node().mempool().m_opts.reject_tokens;
-    case rejectspkreuse:
-        return f_rejectspkreuse;
-    case minrelaytxfee:
-        return qlonglong(node().mempool().m_opts.min_relay_feerate.GetFeePerK());
-    case bytespersigop:
-        return nBytesPerSigOp;
-    case bytespersigopstrict:
-        return nBytesPerSigOpStrict;
-    case limitancestorcount:
-        return qlonglong(node().mempool().m_opts.limits.ancestor_count);
-    case limitancestorsize:
-        return qlonglong(node().mempool().m_opts.limits.ancestor_size_vbytes / 1'000);
-    case limitdescendantcount:
-        return qlonglong(node().mempool().m_opts.limits.descendant_count);
-    case limitdescendantsize:
-        return qlonglong(node().mempool().m_opts.limits.descendant_size_vbytes / 1'000);
-    case rejectbarepubkey:
-        return !node().mempool().m_opts.permit_bare_pubkey;
-    case rejectbaremultisig:
-        return !node().mempool().m_opts.permit_bare_multisig;
-    case maxscriptsize:
-        return ::g_script_size_policy_limit;
-    case datacarriercost:
-        return double(::g_weight_per_data_byte) / WITNESS_SCALE_FACTOR;
-    case datacarriersize:
-        return qlonglong(node().mempool().m_opts.max_datacarrier_bytes.value_or(0));
-    case rejectnonstddatacarrier:
-        return !node().mempool().m_opts.accept_non_std_datacarrier;
-    case dustrelayfee:
-        return qlonglong(node().mempool().m_opts.dust_relay_feerate_floor.GetFeePerK());
-    case dustdynamic:
-        return QString::fromStdString(SettingToString(setting(), DEFAULT_DUST_DYNAMIC));
-    case blockmintxfee:
-        if (gArgs.IsArgSet("-blockmintxfee")) {
-            return qlonglong(ParseMoney(gArgs.GetArg("-blockmintxfee", "")).value_or(0));
-        } else {
-            return qlonglong(DEFAULT_BLOCK_MIN_TX_FEE);
-        }
-    case blockmaxsize:
-        return qlonglong(gArgs.GetIntArg("-blockmaxsize", DEFAULT_BLOCK_MAX_SIZE) / 1000);
-    case blockprioritysize:
-        return qlonglong(gArgs.GetIntArg("-blockprioritysize", DEFAULT_BLOCK_PRIORITY_SIZE) / 1000);
-    case blockmaxweight:
-        return qlonglong(gArgs.GetIntArg("-blockmaxweight", DEFAULT_BLOCK_MAX_WEIGHT) / 1000);
-    case blockreconstructionextratxn:
-        return qlonglong(gArgs.GetIntArg("-blockreconstructionextratxn", DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN));
     default:
         return QVariant();
     }
@@ -795,18 +529,6 @@ bool OptionsModel::setOption(OptionID option, const QVariant& value, const std::
         fMinimizeToTray = value.toBool();
         settings.setValue("fMinimizeToTray", fMinimizeToTray);
         break;
-    case NetworkPort:
-        if (settings.value("nNetworkPort") != value) {
-            // If the port input box is empty, set to default port
-            if (value.toString().isEmpty()) {
-                settings.setValue("nNetworkPort", (quint16)Params().GetDefaultPort());
-            }
-            else {
-                settings.setValue("nNetworkPort", (quint16)value.toInt());
-            }
-            setRestartRequired(true);
-        }
-        break;
     case MapPortUPnP: // core option - can be changed on-the-fly
         if (changed()) {
             update(value.toBool());
@@ -901,35 +623,10 @@ bool OptionsModel::setOption(OptionID option, const QVariant& value, const std::
         m_sub_fee_from_amount = value.toBool();
         settings.setValue("SubFeeFromAmount", m_sub_fee_from_amount);
         break;
-    case addresstype:
-    {
-        const std::string newvalue_str = value.toString().toStdString();
-        const OutputType oldvalue = ParseOutputType(gArgs.GetArg("-addresstype", "")).value_or(wallet::DEFAULT_ADDRESS_TYPE);
-        const OutputType newvalue = ParseOutputType(newvalue_str).value_or(oldvalue);
-        if (newvalue != oldvalue) {
-            gArgs.ModifyRWConfigFile("addresstype", newvalue_str);
-            gArgs.ForceSetArg("-addresstype", newvalue_str);
-            for (auto& wallet_interface : m_node.walletLoader().getWallets()) {
-                wallet::CWallet *wallet;
-                if (wallet_interface && (wallet = wallet_interface->wallet())) {
-                    wallet->m_default_address_type = newvalue;
-                } else {
-                    setRestartRequired(true);
-                    continue;
-                }
-            }
-            Q_EMIT addresstypeChanged(newvalue);
-        }
-        break;
-    }
 #endif
     case DisplayUnit:
         setDisplayUnit(value);
         break;
-    case DisplayAddresses:
-        bDisplayAddresses = value.toBool();
-        settings.setValue("bDisplayAddresses", bDisplayAddresses);
-        break;
     case ThirdPartyTxUrls:
         if (strThirdPartyTxUrls != value.toString()) {
             strThirdPartyTxUrls = value.toString();
@@ -952,38 +649,6 @@ bool OptionsModel::setOption(OptionID option, const QVariant& value, const std::
         Q_EMIT fontForMoneyChanged(getFontForMoney());
         break;
     }
-    case FontForQRCodes:
-    {
-        const auto& new_font = value.value<FontChoice>();
-        if (m_font_qrcodes == new_font) break;
-        settings.setValue("FontForQRCodes", FontChoiceToString(new_font));
-        m_font_qrcodes = new_font;
-        Q_EMIT fontForQRCodesChanged(new_font);
-        break;
-    }
-    case PeersTabAlternatingRowColors:
-        m_peers_tab_alternating_row_colors = value.toBool();
-        settings.setValue("PeersTabAlternatingRowColors", m_peers_tab_alternating_row_colors);
-        Q_EMIT peersTabAlternatingRowColorsChanged(m_peers_tab_alternating_row_colors);
-        break;
-#ifdef ENABLE_WALLET
-    case walletrbf:
-        if (changed()) {
-            const bool fNewValue = value.toBool();
-            const std::string newvalue_str = strprintf("%d", fNewValue);
-            gArgs.ModifyRWConfigFile("walletrbf", newvalue_str);
-            gArgs.ForceSetArg("-walletrbf", newvalue_str);
-            for (auto& wallet_interface : m_node.walletLoader().getWallets()) {
-                wallet::CWallet *wallet;
-                if (wallet_interface && (wallet = wallet_interface->wallet())) {
-                    wallet->m_signal_rbf = fNewValue;
-                } else {
-                    setRestartRequired(true);
-                }
-            }
-        }
-        break;
-#endif
     case CoinControlFeatures:
         fCoinControlFeatures = value.toBool();
         settings.setValue("fCoinControlFeatures", fCoinControlFeatures);
@@ -993,28 +658,22 @@ bool OptionsModel::setOption(OptionID option, const QVariant& value, const std::
         m_enable_psbt_controls = value.toBool();
         settings.setValue("enable_psbt_controls", m_enable_psbt_controls);
         break;
-    case PruneTristate:
+    case Prune:
         if (changed()) {
-            const bool is_autoprune = (value.value<Qt::CheckState>() == Qt::Checked);
-            const auto prune_setting = PruneSettingFromMiB(value.value<Qt::CheckState>(), getOption(PruneSizeMiB).toInt());
-            if (suffix.empty() && !is_autoprune) setOption(option, Qt::Checked, "-prev");
-            update(prune_setting);
-            if (suffix.empty()) gArgs.ModifyRWConfigFile("prune", prune_setting.getValStr());
-            if (suffix.empty() && is_autoprune) UpdateRwSetting(node(), option, "-prev", {});
+            if (suffix.empty() && !value.toBool()) setOption(option, true, "-prev");
+            update(PruneSetting(value.toBool(), getOption(PruneSize).toInt()));
+            if (suffix.empty() && value.toBool()) UpdateRwSetting(node(), option, "-prev", {});
             if (suffix.empty()) setRestartRequired(true);
         }
         break;
-    case PruneSizeMiB:
+    case PruneSize:
         if (changed()) {
-            const bool is_autoprune = (Qt::Checked == getOption(PruneTristate).value<Qt::CheckState>());
-            if (suffix.empty() && !is_autoprune) {
+            if (suffix.empty() && !getOption(Prune).toBool()) {
                 setOption(option, value, "-prev");
             } else {
-                const auto prune_setting = PruneSettingFromMiB(Qt::Checked, value.toInt());
-                update(prune_setting);
-                if (suffix.empty()) gArgs.ModifyRWConfigFile("prune", prune_setting.getValStr());
+                update(PruneSetting(true, ParsePruneSizeGB(value)));
             }
-            if (suffix.empty() && is_autoprune) setRestartRequired(true);
+            if (suffix.empty() && getOption(Prune).toBool()) setRestartRequired(true);
         }
         break;
     case DatabaseCache:
@@ -1040,340 +699,6 @@ bool OptionsModel::setOption(OptionID option, const QVariant& value, const std::
         m_mask_values = value.toBool();
         settings.setValue("mask_values", m_mask_values);
         break;
-    case maxuploadtarget:
-    {
-        if (changed()) {
-            gArgs.ModifyRWConfigFile("maxuploadtarget", value.toString().toStdString());
-            node().context()->connman->SetMaxOutboundTarget(value.toLongLong() * 1024 * 1024);
-        }
-        break;
-    }
-    case peerbloomfilters:
-        if (changed()) {
-            gArgs.ModifyRWConfigFile("peerbloomfilters", strprintf("%d", value.toBool()));
-            f_peerbloomfilters = value.toBool();
-            setRestartRequired(true);
-        }
-        break;
-    case peerblockfilters:
-    {
-        bool nv = value.toBool();
-        if (gArgs.GetBoolArg("-peerblockfilters", DEFAULT_PEERBLOCKFILTERS) != nv) {
-            gArgs.ModifyRWConfigFile("peerblockfilters", strprintf("%d", nv));
-            gArgs.ModifyRWConfigFile("peercfilters", strprintf("%d", nv), /*also_settings_json=*/ false);  // for downgrade compatibility with Knots 0.19
-            gArgs.ForceSetArg("peerblockfilters", nv);
-            if (nv && !GetBlockFilterIndex(BlockFilterType::BASIC)) {
-                // TODO: When other options are possible, we need to append a list!
-                // TODO: Some way to unset/delete this...
-                gArgs.ModifyRWConfigFile("blockfilterindex", "basic");
-                gArgs.ForceSetArg("blockfilterindex", "basic");
-            }
-            setRestartRequired(true);
-        }
-        break;
-    }
-    case mempoolreplacement:
-    {
-        if (changed()) {
-            QString nv = value.toString();
-            if (nv == "never") {
-                node().mempool().m_opts.rbf_policy = RBFPolicy::Never;
-                node().updateRwSetting("mempoolfullrbf", "0");
-            } else if (nv == "fee,optin") {
-                node().mempool().m_opts.rbf_policy = RBFPolicy::OptIn;
-                node().updateRwSetting("mempoolfullrbf", "0");
-            } else {  // "fee,-optin"
-                node().mempool().m_opts.rbf_policy = RBFPolicy::Always;
-                node().updateRwSetting("mempoolfullrbf", "1");
-            }
-            gArgs.ModifyRWConfigFile("mempoolreplacement", nv.toStdString());
-        }
-        break;
-    }
-    case mempooltruc:
-    {
-        if (changed()) {
-            QString nv = value.toString();
-            if (nv == "reject") {
-                node().mempool().m_opts.truc_policy = TRUCPolicy::Reject;
-            } else if (nv == "accept") {
-                node().mempool().m_opts.truc_policy = TRUCPolicy::Accept;
-            } else if (nv == "enforce") {
-                node().mempool().m_opts.truc_policy = TRUCPolicy::Enforce;
-            }
-            node().updateRwSetting("mempooltruc", nv.toStdString());
-        }
-        break;
-    }
-    case maxorphantx:
-    {
-        if (changed()) {
-            unsigned int nMaxOrphanTx = gArgs.GetIntArg("-maxorphantx", DEFAULT_MAX_ORPHAN_TRANSACTIONS);
-            unsigned int nNv = value.toLongLong();
-            std::string strNv = value.toString().toStdString();
-            gArgs.ForceSetArg("-maxorphantx", strNv);
-            gArgs.ModifyRWConfigFile("maxorphantx", strNv);
-            if (nNv < nMaxOrphanTx) {
-                assert(node().context() && node().context()->peerman);
-                node().context()->peerman->LimitOrphanTxSize(nNv);
-            }
-        }
-        break;
-    }
-    case maxmempool:
-    {
-        if (changed()) {
-            long long nOldValue = node().mempool().m_opts.max_size_bytes;
-            long long nNv = value.toLongLong();
-            std::string strNv = value.toString().toStdString();
-            node().mempool().m_opts.max_size_bytes = nNv * 1'000'000;
-            gArgs.ForceSetArg("-maxmempool", strNv);
-            gArgs.ModifyRWConfigFile("maxmempool", strNv);
-            if (nNv < nOldValue) {
-                LOCK(cs_main);
-                auto node_ctx = node().context();
-                assert(node_ctx && node_ctx->mempool && node_ctx->chainman);
-                auto& active_chainstate = node_ctx->chainman->ActiveChainstate();
-                LimitMempoolSize(*node_ctx->mempool, active_chainstate.CoinsTip());
-            }
-        }
-        break;
-    }
-    case incrementalrelayfee:
-        if (changed()) {
-            CAmount nNv = value.toLongLong();
-            gArgs.ModifyRWConfigFile("incrementalrelayfee", FormatMoney(nNv));
-            node().mempool().m_opts.incremental_relay_feerate = CFeeRate(nNv);
-        }
-        break;
-    case mempoolexpiry:
-    {
-        if (changed()) {
-            const auto old_value = node().mempool().m_opts.expiry;
-            const std::chrono::hours new_value{value.toLongLong()};
-            std::string strNv = value.toString().toStdString();
-            node().mempool().m_opts.expiry = new_value;
-            gArgs.ForceSetArg("-mempoolexpiry", strNv);
-            gArgs.ModifyRWConfigFile("mempoolexpiry", strNv);
-            if (new_value < old_value) {
-                LOCK(cs_main);
-                auto node_ctx = node().context();
-                assert(node_ctx && node_ctx->mempool && node_ctx->chainman);
-                auto& active_chainstate = node_ctx->chainman->ActiveChainstate();
-                LimitMempoolSize(*node_ctx->mempool, active_chainstate.CoinsTip());
-            }
-        }
-        break;
-    }
-    case rejectunknownscripts:
-    {
-        if (changed()) {
-            const bool fNewValue = value.toBool();
-            node().mempool().m_opts.require_standard = fNewValue;
-            // This option is inverted in the config:
-            gArgs.ModifyRWConfigFile("acceptnonstdtxn", strprintf("%d", ! fNewValue));
-        }
-        break;
-    }
-    case rejectparasites:
-    {
-        if (changed()) {
-            const bool nv = value.toBool();
-            node().mempool().m_opts.reject_parasites = nv;
-            node().updateRwSetting("rejectparasites", nv);
-        }
-        break;
-    }
-    case rejecttokens:
-    {
-        if (changed()) {
-            const bool nv = value.toBool();
-            node().mempool().m_opts.reject_tokens = nv;
-            node().updateRwSetting("rejecttokens", nv);
-        }
-        break;
-    }
-    case rejectspkreuse:
-        if (changed()) {
-            const bool fNewValue = value.toBool();
-            gArgs.ModifyRWConfigFile("spkreuse", fNewValue ? "conflict" : "allow");
-            f_rejectspkreuse = fNewValue;
-            setRestartRequired(true);
-        }
-        break;
-    case minrelaytxfee:
-        if (changed()) {
-            CAmount nNv = value.toLongLong();
-            gArgs.ModifyRWConfigFile("minrelaytxfee", FormatMoney(nNv));
-            node().mempool().m_opts.min_relay_feerate = CFeeRate(nNv);
-        }
-        break;
-    case bytespersigop:
-        if (changed()) {
-            gArgs.ModifyRWConfigFile("bytespersigop", value.toString().toStdString());
-            nBytesPerSigOp = value.toLongLong();
-        }
-        break;
-    case bytespersigopstrict:
-        if (changed()) {
-            gArgs.ModifyRWConfigFile("bytespersigopstrict", value.toString().toStdString());
-            nBytesPerSigOpStrict = value.toLongLong();
-        }
-        break;
-    case limitancestorcount:
-        if (changed()) {
-            long long nNv = value.toLongLong();
-            std::string strNv = value.toString().toStdString();
-            node().mempool().m_opts.limits.ancestor_count = nNv;
-            gArgs.ForceSetArg("-limitancestorcount", strNv);
-            gArgs.ModifyRWConfigFile("limitancestorcount", strNv);
-        }
-        break;
-    case limitancestorsize:
-        if (changed()) {
-            long long nNv = value.toLongLong();
-            std::string strNv = value.toString().toStdString();
-            node().mempool().m_opts.limits.ancestor_size_vbytes = nNv * 1'000;
-            gArgs.ForceSetArg("-limitancestorsize", strNv);
-            gArgs.ModifyRWConfigFile("limitancestorsize", strNv);
-        }
-        break;
-    case limitdescendantcount:
-        if (changed()) {
-            long long nNv = value.toLongLong();
-            std::string strNv = value.toString().toStdString();
-            node().mempool().m_opts.limits.descendant_count = nNv;
-            gArgs.ForceSetArg("-limitdescendantcount", strNv);
-            gArgs.ModifyRWConfigFile("limitdescendantcount", strNv);
-        }
-        break;
-    case limitdescendantsize:
-        if (changed()) {
-            long long nNv = value.toLongLong();
-            std::string strNv = value.toString().toStdString();
-            node().mempool().m_opts.limits.descendant_size_vbytes = nNv * 1'000;
-            gArgs.ForceSetArg("-limitdescendantsize", strNv);
-            gArgs.ModifyRWConfigFile("limitdescendantsize", strNv);
-        }
-        break;
-    case rejectbarepubkey:
-        if (changed()) {
-            // The config and internal option is inverted
-            const bool nv = ! value.toBool();
-            node().mempool().m_opts.permit_bare_pubkey = nv;
-            node().updateRwSetting("permitbaremultisig", nv);
-        }
-        break;
-    case rejectbaremultisig:
-        if (changed()) {
-            // The config and internal option is inverted
-            const bool fNewValue = ! value.toBool();
-            node().mempool().m_opts.permit_bare_multisig = fNewValue;
-            gArgs.ModifyRWConfigFile("permitbaremultisig", strprintf("%d", fNewValue));
-        }
-        break;
-    case maxscriptsize:
-        if (changed()) {
-            const auto nv = value.toLongLong();
-            update(nv);
-            ::g_script_size_policy_limit = nv;
-        }
-        break;
-    case datacarriercost:
-        if (changed()) {
-            const double nNewSize = value.toDouble();
-            update(nNewSize);
-            ::g_weight_per_data_byte = nNewSize * WITNESS_SCALE_FACTOR;
-        }
-        break;
-    case datacarriersize:
-        if (changed()) {
-            const int nNewSize = value.toInt();
-            const bool fNewEn = (nNewSize > 0);
-            if (fNewEn) {
-                if (!node().mempool().m_opts.max_datacarrier_bytes.has_value()) {
-                    gArgs.ModifyRWConfigFile("datacarrier", strprintf("%d", fNewEn));
-                }
-                gArgs.ModifyRWConfigFile("datacarriersize", value.toString().toStdString());
-                node().mempool().m_opts.max_datacarrier_bytes = nNewSize;
-            } else {
-                gArgs.ModifyRWConfigFile("datacarrier", "0");
-                node().mempool().m_opts.max_datacarrier_bytes = std::nullopt;
-            }
-        }
-        break;
-    case rejectnonstddatacarrier:
-        if (changed()) {
-            // This option is inverted
-            const bool new_value = ! value.toBool();
-            node().updateRwSetting("acceptnonstddatacarrier" + suffix, new_value);
-            node().mempool().m_opts.accept_non_std_datacarrier = new_value;
-        }
-        break;
-    case dustrelayfee:
-        if (changed()) {
-            CAmount nNv = value.toLongLong();
-            gArgs.ModifyRWConfigFile("dustrelayfee", FormatMoney(nNv));
-            CFeeRate feerate{nNv};
-            node().mempool().m_opts.dust_relay_feerate_floor = feerate;
-            if (node().mempool().m_opts.dust_relay_feerate < feerate || !node().mempool().m_opts.dust_relay_target) {
-                node().mempool().m_opts.dust_relay_feerate = feerate;
-            } else {
-                node().mempool().UpdateDynamicDustFeerate();
-            }
-        }
-        break;
-    case dustdynamic:
-        if (changed()) {
-            const std::string newvalue_str = value.toString().toStdString();
-            const util::Result<std::pair<int32_t, int>> parsed = ParseDustDynamicOpt(newvalue_str, 1008 /* FIXME: get from estimator */);
-            assert(parsed);  // FIXME: what to do if it fails to parse?
-            // FIXME: save -prev-<type> for each type
-            update(newvalue_str);
-            node().mempool().m_opts.dust_relay_target = parsed->first;
-            node().mempool().m_opts.dust_relay_multiplier = parsed->second;
-        }
-        break;
-    case blockmintxfee:
-        if (changed()) {
-            std::string strNv = FormatMoney(value.toLongLong());
-            gArgs.ForceSetArg("-blockmintxfee", strNv);
-            gArgs.ModifyRWConfigFile("blockmintxfee", strNv);
-        }
-        break;
-    case blockmaxsize:
-    case blockprioritysize:
-    case blockmaxweight:
-        if (changed()) {
-            const int nNewValue_kB = value.toInt();
-            std::string strNv = strprintf("%d000", nNewValue_kB);
-            std::string strKey;
-            switch (option) {
-                case blockmaxsize:
-                    strKey = "blockmaxsize";
-                    break;
-                case blockprioritysize:
-                    strKey = "blockprioritysize";
-                    break;
-                case blockmaxweight:
-                    strKey = "blockmaxweight";
-                    break;
-                default: assert(0);
-            }
-            gArgs.ForceSetArg("-" + strKey, strNv);
-            gArgs.ModifyRWConfigFile(strKey, strNv);
-        }
-        break;
-    case blockreconstructionextratxn:
-        if (changed()) {
-            std::string strNv = value.toString().toStdString();
-            gArgs.ForceSetArg("-blockreconstructionextratxn", strNv);
-            gArgs.ModifyRWConfigFile("blockreconstructionextratxn", strNv);
-        }
-        break;
-    case corepolicy:
-        gArgs.ModifyRWConfigFile("corepolicy", value.toString().toStdString());
-        break;
     default:
         break;
     }
@@ -1386,21 +711,7 @@ void OptionsModel::setDisplayUnit(const QVariant& new_unit)
     if (new_unit.isNull() || new_unit.value<BitcoinUnit>() == m_display_bitcoin_unit) return;
     m_display_bitcoin_unit = new_unit.value<BitcoinUnit>();
     QSettings settings;
-    if (BitcoinUnits::numsys(m_display_bitcoin_unit) == BitcoinUnit::BTC) {
-        settings.setValue("DisplayBitcoinUnit", QVariant::fromValue(m_display_bitcoin_unit));
-        settings.remove("DisplayBitcoinUnitKnots");
-    } else {
-        settings.setValue("DisplayBitcoinUnitKnots", QVariant::fromValue(m_display_bitcoin_unit));
-    }
-    {
-        // For older versions:
-        auto setting_val = BitcoinUnits::ToSetting(m_display_bitcoin_unit);
-        if (const QString* setting_str = std::get_if<QString>(&setting_val)) {
-            settings.setValue("nDisplayUnit", *setting_str);
-        } else {
-            settings.setValue("nDisplayUnit", std::get<qint8>(setting_val));
-        }
-    }
+    settings.setValue("DisplayBitcoinUnit", QVariant::fromValue(m_display_bitcoin_unit));
     Q_EMIT displayUnitChanged(m_display_bitcoin_unit);
 }
 
@@ -1464,14 +775,6 @@ void OptionsModel::checkAndMigrate()
                 ProxySetting parsed = ParseProxyString(value.toString());
                 setOption(ProxyIPTor, parsed.ip);
                 setOption(ProxyPortTor, parsed.port);
-            } else if (option == PruneSizeMiB) {
-                // Stored as GB
-                const int64_t prune_size_gb = value.toInt();
-                const int prune_size_mib = std::max(prune_size_gb * GB_BYTES / MiB_BYTES, MIN_DISK_SPACE_FOR_BLOCK_FILES / MiB_BYTES);
-                setOption(option, prune_size_mib);
-            } else if (option == PruneTristate) {
-                // Stored as bool
-                setOption(option, value.toBool() ? Qt::Checked : Qt::Unchecked);
             } else {
                 setOption(option, value);
             }
@@ -1489,8 +792,8 @@ void OptionsModel::checkAndMigrate()
     migrate_setting(MapPortNatpmp, "fUseNatpmp");
     migrate_setting(Listen, "fListen");
     migrate_setting(Server, "server");
-    migrate_setting(PruneSizeMiB, "nPruneSize");
-    migrate_setting(PruneTristate, "bPrune");
+    migrate_setting(PruneSize, "nPruneSize");
+    migrate_setting(Prune, "bPrune");
     migrate_setting(ProxyIP, "addrProxy");
     migrate_setting(ProxyUse, "fUseProxy");
     migrate_setting(ProxyIPTor, "addrSeparateProxyTor");
diff --git a/src/qt/optionsmodel.h b/src/qt/optionsmodel.h
index 46f812f808..b5ea6c783e 100644
--- a/src/qt/optionsmodel.h
+++ b/src/qt/optionsmodel.h
@@ -11,16 +11,11 @@
 
 #include <QAbstractListModel>
 #include <QFont>
-#include <QString>
 
 #include <assert.h>
-#include <map>
-#include <utility>
 #include <variant>
 
 struct bilingual_str;
-enum class OutputType;
-
 namespace interfaces {
 class Node;
 }
@@ -28,7 +23,15 @@ class Node;
 extern const char *DEFAULT_GUI_PROXY_HOST;
 static constexpr uint16_t DEFAULT_GUI_PROXY_PORT = 9050;
 
-std::pair<QString, QString> GetOutputTypeDescription(const OutputType type);
+/**
+ * Convert configured prune target MiB to displayed GB. Round up to avoid underestimating max disk usage.
+ */
+static inline int PruneMiBtoGB(int64_t mib) { return (mib * 1024 * 1024 + GB_BYTES - 1) / GB_BYTES; }
+
+/**
+ * Convert displayed prune target GB to configured MiB. Round down so roundtrip GB -> MiB -> GB conversion is stable.
+ */
+static inline int64_t PruneGBtoMiB(int gb) { return gb * GB_BYTES / 1024 / 1024; }
 
 /** Interface from Qt to configuration data structure for Bitcoin client.
    To Qt, the options are presented as a list with the different options
@@ -47,7 +50,6 @@ public:
         StartAtStartup,         // bool
         ShowTrayIcon,           // bool
         MinimizeToTray,         // bool
-        NetworkPort,            // int
         MapPortUPnP,            // bool
         MapPortNatpmp,          // bool
         MinimizeOnClose,        // bool
@@ -58,60 +60,21 @@ public:
         ProxyIPTor,             // QString
         ProxyPortTor,           // int
         DisplayUnit,            // BitcoinUnit
-        DisplayAddresses,       // bool
         ThirdPartyTxUrls,       // QString
         Language,               // QString
         FontForMoney,           // FontChoice
-        FontForQRCodes,         // FontChoice
-        PeersTabAlternatingRowColors, // bool
-        walletrbf,              // bool
         CoinControlFeatures,    // bool
         SubFeeFromAmount,       // bool
         ThreadsScriptVerif,     // int
-        PruneTristate,          // Qt::CheckState
-        PruneSizeMiB,           // int
+        Prune,                  // bool
+        PruneSize,              // int
         DatabaseCache,          // int
         ExternalSignerPath,     // QString
         SpendZeroConfChange,    // bool
-        addresstype,            // QString
         Listen,                 // bool
         Server,                 // bool
         EnablePSBTControls,     // bool
         MaskValues,             // bool
-        maxuploadtarget,
-        peerbloomfilters,       // bool
-        peerblockfilters,       // bool
-        mempoolreplacement,
-        mempooltruc,
-        maxorphantx,
-        maxmempool,
-        incrementalrelayfee,
-        mempoolexpiry,
-        rejectunknownscripts,   // bool
-        rejectparasites,        // bool
-        rejecttokens,           // bool
-        rejectspkreuse,         // bool
-        minrelaytxfee,
-        bytespersigop,
-        bytespersigopstrict,
-        limitancestorcount,
-        limitancestorsize,
-        limitdescendantcount,
-        limitdescendantsize,
-        rejectbarepubkey,       // bool
-        rejectbaremultisig,     // bool
-        maxscriptsize,
-        datacarriercost,        // double
-        datacarriersize,
-        rejectnonstddatacarrier,  // bool
-        dustrelayfee,
-        dustdynamic,            // QString
-        blockmintxfee,
-        blockmaxsize,
-        blockprioritysize,
-        blockmaxweight,
-        blockreconstructionextratxn,
-        corepolicy,
         OptionIDRowCount,
     };
 
@@ -139,11 +102,8 @@ public:
     bool getMinimizeToTray() const { return fMinimizeToTray; }
     bool getMinimizeOnClose() const { return fMinimizeOnClose; }
     BitcoinUnit getDisplayUnit() const { return m_display_bitcoin_unit; }
-    bool getDisplayAddresses() const { return bDisplayAddresses; }
     QString getThirdPartyTxUrls() const { return strThirdPartyTxUrls; }
     QFont getFontForMoney() const;
-    FontChoice getFontChoiceForQRCodes() const { return m_font_qrcodes; }
-    bool getPeersTabAlternatingRowColors() const { return m_peers_tab_alternating_row_colors; }
     bool getCoinControlFeatures() const { return fCoinControlFeatures; }
     bool getSubFeeFromAmount() const { return m_sub_fee_from_amount; }
     bool getEnablePSBTControls() const { return m_enable_psbt_controls; }
@@ -153,7 +113,7 @@ public:
     bool hasSigner();
 
     /* Explicit setters */
-    void SetPruneTargetMiB(int prune_target_mib);
+    void SetPruneTargetGB(int prune_target_gb);
 
     /* Restart flag helper */
     void setRestartRequired(bool fRequired);
@@ -169,11 +129,8 @@ private:
     bool fMinimizeOnClose;
     QString language;
     BitcoinUnit m_display_bitcoin_unit;
-    bool bDisplayAddresses;
     QString strThirdPartyTxUrls;
     FontChoice m_font_money{FontChoiceAbstract::EmbeddedFont};
-    FontChoice m_font_qrcodes{FontChoiceAbstract::EmbeddedFont};
-    bool m_peers_tab_alternating_row_colors;
     bool fCoinControlFeatures;
     bool m_sub_fee_from_amount;
     bool m_enable_psbt_controls;
@@ -181,15 +138,10 @@ private:
 
     /* settings that were overridden by command-line */
     QString strOverriddenByCommandLine;
-    bool m_prune_forced_by_gui{false};
 
     static QString FontChoiceToString(const OptionsModel::FontChoice&);
     static FontChoice FontChoiceFromString(const QString&);
 
-    /* rwconf settings that require a restart */
-    bool f_peerbloomfilters;
-    bool f_rejectspkreuse;
-
     // Add option to list of GUI options overridden through command line/config file
     void addOverriddenOption(const std::string &option);
 
@@ -199,11 +151,8 @@ private:
 Q_SIGNALS:
     void displayUnitChanged(BitcoinUnit unit);
     void coinControlFeaturesChanged(bool);
-    void addresstypeChanged(OutputType);
     void showTrayIconChanged(bool);
     void fontForMoneyChanged(const QFont&);
-    void fontForQRCodesChanged(const FontChoice&);
-    void peersTabAlternatingRowColorsChanged(bool);
 };
 
 Q_DECLARE_METATYPE(OptionsModel::FontChoice)
diff --git a/src/qt/pairingpage.cpp b/src/qt/pairingpage.cpp
deleted file mode 100644
index 593a49bf2c..0000000000
--- a/src/qt/pairingpage.cpp
+++ /dev/null
@@ -1,78 +0,0 @@
-// Copyright (c) 2018 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#if defined(HAVE_CONFIG_H)
-#include <config/bitcoin-config.h>
-#endif
-
-#include <qt/clientmodel.h>
-#include <qt/pairingpage.h>
-#include <qt/qrimagewidget.h>
-
-#include <QFormLayout>
-#include <QLabel>
-#include <QLayout>
-#include <QLineEdit>
-
-PairingPage::PairingPage(QWidget *parent) :
-    QWidget(parent)
-{
-    QVBoxLayout *layout = new QVBoxLayout(this);
-
-    QLabel *label_experimental = new QLabel(this);
-    label_experimental->setStyleSheet("QLabel { background-color: qlineargradient(x1: 0, y1: 0, x2: 1, y2: 0, stop:0 #F0D0A0, stop:1 #F8D488); color:#000000; }");
-    label_experimental->setMargin(3);
-    label_experimental->setTextInteractionFlags(Qt::TextSelectableByMouse);
-    label_experimental->setWordWrap(true);
-    label_experimental->setText(tr("Pairing is an experimental feature that currently only works when Tor is enabled. It is expected that the pairing address below will change with future updates, and you may need to re-pair after upgrading."));
-    layout->addWidget(label_experimental);
-
-    QLabel *label_summary = new QLabel(this);
-    label_summary->setText(tr("Below you will find information to pair other software or devices with this node:"));
-    layout->addWidget(label_summary);
-
-    QFormLayout *form_layout = new QFormLayout();
-    m_onion_address = new QLineEdit(this);
-    m_onion_address->setReadOnly(true);
-    form_layout->addRow(tr("Onion address: "), m_onion_address);
-
-    layout->addLayout(form_layout);
-
-    m_qrcode = new QRImageWidget(this);
-#ifdef USE_QRCODE
-    layout->addWidget(m_qrcode);
-#endif
-
-    layout->addStretch();
-
-    refresh();
-}
-
-void PairingPage::setClientModel(ClientModel *client_model)
-{
-    if (m_client_model) {
-        disconnect(m_client_model, &ClientModel::networkLocalChanged, this, &PairingPage::refresh);
-    }
-    m_client_model = client_model;
-    if (client_model) {
-        connect(client_model, &ClientModel::networkLocalChanged, this, &PairingPage::refresh);
-    }
-    refresh();
-}
-
-void PairingPage::refresh()
-{
-    QString onion;
-    if (m_client_model && m_client_model->getTorInfo(onion)) {
-        m_onion_address->setText(onion);
-        m_onion_address->setEnabled(true);
-        QString uri = QString("bitcoin-p2p://") + onion;
-        m_qrcode->setQR(uri);
-        m_qrcode->setVisible(true);
-    } else {
-        m_onion_address->setText(tr("(not connected)"));
-        m_onion_address->setEnabled(false);
-        m_qrcode->setVisible(false);
-    }
-}
diff --git a/src/qt/pairingpage.h b/src/qt/pairingpage.h
deleted file mode 100644
index 59c35abc65..0000000000
--- a/src/qt/pairingpage.h
+++ /dev/null
@@ -1,35 +0,0 @@
-// Copyright (c) 2018 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#ifndef BITCOIN_QT_PAIRINGPAGE_H
-#define BITCOIN_QT_PAIRINGPAGE_H
-
-#include <QWidget>
-
-class ClientModel;
-class QRImageWidget;
-
-QT_BEGIN_NAMESPACE
-class QLineEdit;
-QT_END_NAMESPACE
-
-class PairingPage : public QWidget
-{
-    Q_OBJECT
-
-public:
-    explicit PairingPage(QWidget *parent = nullptr);
-
-    void setClientModel(ClientModel *);
-
-public Q_SLOTS:
-    void refresh();
-
-private:
-    ClientModel *m_client_model{nullptr};
-    QLineEdit *m_onion_address{nullptr};
-    QRImageWidget *m_qrcode{nullptr};
-};
-
-#endif // BITCOIN_QT_PAIRINGPAGE_H
diff --git a/src/qt/peertablemodel.cpp b/src/qt/peertablemodel.cpp
index 29f17e7274..9f47213ed9 100644
--- a/src/qt/peertablemodel.cpp
+++ b/src/qt/peertablemodel.cpp
@@ -6,144 +6,29 @@
 
 #include <qt/guiconstants.h>
 #include <qt/guiutil.h>
-#include <qt/platformstyle.h>
 
 #include <interfaces/node.h>
 
 #include <utility>
 
-#include <QBrush>
-#include <QFont>
-#include <QFontInfo>
-#include <QImage>
-#include <QPainter>
-#include <QPixmap>
 #include <QList>
 #include <QTimer>
 
-PeerTableModel::PeerTableModel(interfaces::Node& node, const PlatformStyle& platform_style, QObject* parent)
+PeerTableModel::PeerTableModel(interfaces::Node& node, QObject* parent)
     : QAbstractTableModel(parent),
-      m_node(node),
-      m_platform_style(platform_style)
+      m_node(node)
 {
     // set up timer for auto refresh
     timer = new QTimer(this);
     connect(timer, &QTimer::timeout, this, &PeerTableModel::refresh);
     timer->setInterval(MODEL_UPDATE_DELAY);
 
-    DrawIcons();
-
     // load initial data
     refresh();
 }
 
 PeerTableModel::~PeerTableModel() = default;
 
-void PeerTableModel::DrawIcons()
-{
-    static constexpr auto SIZE = 32;
-    static constexpr auto ARROW_HEIGHT = SIZE * 2 / 3;
-    QImage icon_in(SIZE, SIZE, QImage::Format_Alpha8);
-    icon_in.fill(Qt::transparent);
-    QImage icon_out(icon_in);
-    QPainter icon_in_painter(&icon_in);
-    QPainter icon_out_painter(&icon_out);
-
-    // Arrow
-    auto DrawArrow = [](const int x, QPainter& icon_painter) {
-        icon_painter.setBrush(Qt::SolidPattern);
-        QPoint shape[] = {
-            {x, ARROW_HEIGHT / 2},
-            {(SIZE-1) - x,  0},
-            {(SIZE-1) - x, ARROW_HEIGHT-1},
-        };
-        icon_painter.drawConvexPolygon(shape, 3);
-    };
-    DrawArrow(0, icon_in_painter);
-    DrawArrow(SIZE-1, icon_out_painter);
-
-    {
-        //: Label on inbound connection icon
-        const QString label_in  = tr("IN");
-        //: Label on outbound connection icon
-        const QString label_out = tr("OUT");
-        QImage scratch(SIZE, SIZE, QImage::Format_Alpha8);
-        QPainter scratch_painter(&scratch);
-        QFont font;  // NOTE: Application default font
-        font.setBold(true);
-        auto CheckSize = [&](const QImage& icon, const QString& text, const bool align_right) {
-            // Make sure it's at least able to fit (width only)
-            if (scratch_painter.boundingRect(0, 0, SIZE, SIZE, 0, text).width() > SIZE) {
-                return false;
-            }
-
-            // Draw text on the scratch image
-            // NOTE: QImage::fill doesn't like QPainter being active
-            scratch_painter.setCompositionMode(QPainter::CompositionMode_Source);
-            scratch_painter.fillRect(0, 0, SIZE, SIZE, Qt::transparent);
-            scratch_painter.setCompositionMode(QPainter::CompositionMode_SourceOver);
-            scratch_painter.drawText(0, SIZE, text);
-
-            int text_offset_x = 0;
-            if (align_right) {
-                // Figure out how far right we can shift it
-                for (int col = SIZE-1; col >= 0; --col) {
-                    bool any_pixels = false;
-                    for (int row = SIZE-1; row >= 0; --row) {
-                        int opacity = qAlpha(scratch.pixel(col, row));
-                        if (opacity > 0) {
-                            any_pixels = true;
-                            break;
-                        }
-                    }
-                    if (any_pixels) {
-                        text_offset_x = (SIZE-1) - col;
-                        break;
-                    }
-                }
-            }
-
-            // Check if there's any overlap
-            for (int row = 0; row < SIZE; ++row) {
-                for (int col = text_offset_x; col < SIZE; ++col) {
-                    int opacity = qAlpha(icon.pixel(col, row));
-                    if (col >= text_offset_x) {
-                        opacity += qAlpha(scratch.pixel(col - text_offset_x, row));
-                    }
-                    if (opacity > 0xff) {
-                        // Overlap found, we're done
-                        return false;
-                    }
-                }
-            }
-            return true;
-        };
-        int font_size = SIZE;
-        while (font_size > 1) {
-            font.setPixelSize(--font_size);
-            scratch_painter.setFont(font);
-            if (CheckSize(icon_in , label_in , /* align_right= */ false) &&
-                CheckSize(icon_out, label_out, /* align_right= */ true)) break;
-        }
-        icon_in_painter .drawText(0, 0, SIZE, SIZE, Qt::AlignLeft  | Qt::AlignBottom, label_in);
-        icon_out_painter.drawText(0, 0, SIZE, SIZE, Qt::AlignRight | Qt::AlignBottom, label_out);
-    }
-    m_icon_conn_in  = m_platform_style.TextColorIcon(QIcon(QPixmap::fromImage(icon_in)));
-    m_icon_conn_out = m_platform_style.TextColorIcon(QIcon(QPixmap::fromImage(icon_out)));
-}
-
-void PeerTableModel::updatePalette()
-{
-    m_icon_conn_in  = m_platform_style.TextColorIcon(m_icon_conn_in);
-    m_icon_conn_out = m_platform_style.TextColorIcon(m_icon_conn_out);
-    if (m_peers_data.empty()) return;
-    Q_EMIT dataChanged(
-        createIndex(0, Direction),
-        createIndex(m_peers_data.size() - 1, Direction),
-        QVector<int>{Qt::DecorationRole}
-    );
-}
-
 void PeerTableModel::startAutoRefresh()
 {
     timer->start();
@@ -187,7 +72,11 @@ QVariant PeerTableModel::data(const QModelIndex& index, int role) const
         case Address:
             return QString::fromStdString(rec->nodeStats.m_addr_name);
         case Direction:
-            return {};
+            return QString(rec->nodeStats.fInbound ?
+                               //: An Inbound Connection from a Peer.
+                               tr("Inbound") :
+                               //: An Outbound Connection to a Peer.
+                               tr("Outbound"));
         case ConnectionType:
             return GUIUtil::ConnectionTypeToQString(rec->nodeStats.m_conn_type, /*prepend_direction=*/false);
         case Network:
@@ -206,10 +95,10 @@ QVariant PeerTableModel::data(const QModelIndex& index, int role) const
         switch (column) {
         case NetNodeId:
         case Age:
-        case Direction:
             return QVariant(Qt::AlignRight | Qt::AlignVCenter);
         case Address:
             return {};
+        case Direction:
         case ConnectionType:
         case Network:
             return QVariant(Qt::AlignCenter);
@@ -223,8 +112,6 @@ QVariant PeerTableModel::data(const QModelIndex& index, int role) const
         assert(false);
     } else if (role == StatsRole) {
         return QVariant::fromValue(rec);
-    } else if (index.column() == Direction && role == Qt::DecorationRole) {
-        return rec->nodeStats.fInbound ? m_icon_conn_in : m_icon_conn_out;
     }
 
     return QVariant();
diff --git a/src/qt/peertablemodel.h b/src/qt/peertablemodel.h
index 386d8d6545..a0174c3af4 100644
--- a/src/qt/peertablemodel.h
+++ b/src/qt/peertablemodel.h
@@ -9,14 +9,12 @@
 #include <net.h>
 
 #include <QAbstractTableModel>
-#include <QIcon>
 #include <QList>
 #include <QModelIndex>
 #include <QStringList>
 #include <QVariant>
 
 class PeerTablePriv;
-class PlatformStyle;
 
 namespace interfaces {
 class Node;
@@ -42,23 +40,22 @@ class PeerTableModel : public QAbstractTableModel
     Q_OBJECT
 
 public:
-    explicit PeerTableModel(interfaces::Node& node, const PlatformStyle&, QObject* parent);
+    explicit PeerTableModel(interfaces::Node& node, QObject* parent);
     ~PeerTableModel();
     void startAutoRefresh();
     void stopAutoRefresh();
 
-    // See also RPCConsole::ColumnWidths in rpcconsole.h
     enum ColumnIndex {
         NetNodeId = 0,
         Age,
-        Direction,
         Address,
+        Direction,
         ConnectionType,
+        Network,
         Ping,
         Sent,
         Received,
-        Subversion,
-        Network,  // Not used, just kept at the end to avoid excessive code removal
+        Subversion
     };
 
     enum {
@@ -77,29 +74,30 @@ public:
 
 public Q_SLOTS:
     void refresh();
-    void updatePalette();
 
 private:
     //! Internal peer data structure.
     QList<CNodeCombinedStats> m_peers_data{};
     interfaces::Node& m_node;
-    const PlatformStyle& m_platform_style;
-    void DrawIcons();
-    QIcon m_icon_conn_in, m_icon_conn_out;
     const QStringList columns{
         /*: Title of Peers Table column which contains a
             unique number used to identify a connection. */
-        tr("id"),
+        tr("Peer"),
         /*: Title of Peers Table column which indicates the duration (length of time)
             since the peer connection started. */
         tr("Age"),
-        "",  // Direction column has no title
         /*: Title of Peers Table column which contains the
             IP/Onion/I2P address of the connected peer. */
         tr("Address"),
+        /*: Title of Peers Table column which indicates the direction
+            the peer connection was initiated from. */
+        tr("Direction"),
         /*: Title of Peers Table column which describes the type of
             peer connection. The "type" describes why the connection exists. */
         tr("Type"),
+        /*: Title of Peers Table column which states the network the peer
+            connected through. */
+        tr("Network"),
         /*: Title of Peers Table column which indicates the current latency
             of the connection with the peer. */
         tr("Ping"),
@@ -108,7 +106,7 @@ private:
         tr("Sent"),
         /*: Title of Peers Table column which indicates the total amount of
             network information we have received from the peer. */
-        tr("Recv'd"),
+        tr("Received"),
         /*: Title of Peers Table column which contains the peer's
             User Agent string. */
         tr("User Agent")};
diff --git a/src/qt/peertablesortproxy.cpp b/src/qt/peertablesortproxy.cpp
index f386da41d5..a70b5d4e29 100644
--- a/src/qt/peertablesortproxy.cpp
+++ b/src/qt/peertablesortproxy.cpp
@@ -27,9 +27,6 @@ bool PeerTableSortProxy::lessThan(const QModelIndex& left_index, const QModelInd
     case PeerTableModel::Age:
         return left_stats.m_connected > right_stats.m_connected;
     case PeerTableModel::Address:
-        if (left_stats.m_network != right_stats.m_network) {
-            return left_stats.m_network < right_stats.m_network;
-        }
         return left_stats.m_addr_name.compare(right_stats.m_addr_name) < 0;
     case PeerTableModel::Direction:
         return left_stats.fInbound > right_stats.fInbound; // default sort Inbound, then Outbound
diff --git a/src/qt/psbtoperationsdialog.cpp b/src/qt/psbtoperationsdialog.cpp
index 6efd8ec073..5a4b4442f3 100644
--- a/src/qt/psbtoperationsdialog.cpp
+++ b/src/qt/psbtoperationsdialog.cpp
@@ -83,7 +83,7 @@ void PSBTOperationsDialog::signTransaction()
 
     WalletModel::UnlockContext ctx(m_wallet_model->requestUnlock());
 
-    const auto err{m_wallet_model->wallet().fillPSBT(SIGHASH_DEFAULT, /*sign=*/true, /*bip32derivs=*/true, &n_signed, m_transaction_data, complete)};
+    const auto err{m_wallet_model->wallet().fillPSBT(SIGHASH_ALL, /*sign=*/true, /*bip32derivs=*/true, &n_signed, m_transaction_data, complete)};
 
     if (err) {
         showStatus(tr("Failed to sign transaction: %1")
@@ -120,7 +120,7 @@ void PSBTOperationsDialog::broadcastTransaction()
     CTransactionRef tx = MakeTransactionRef(mtx);
     std::string err_string;
     TransactionError error =
-        m_client_model->node().broadcastTransaction(tx, DEFAULT_MAX_RAW_TX_FEE_RATE, err_string);
+        m_client_model->node().broadcastTransaction(tx, DEFAULT_MAX_RAW_TX_FEE_RATE.GetFeePerK(), err_string);
 
     if (error == TransactionError::OK) {
         showStatus(tr("Transaction broadcast successfully! Transaction ID: %1")
diff --git a/src/qt/qrimagewidget.cpp b/src/qt/qrimagewidget.cpp
index 712e25cbf9..f6e712a047 100644
--- a/src/qt/qrimagewidget.cpp
+++ b/src/qt/qrimagewidget.cpp
@@ -5,7 +5,6 @@
 #include <qt/qrimagewidget.h>
 
 #include <qt/guiutil.h>
-#include <qt/optionsmodel.h>
 
 #include <QApplication>
 #include <QClipboard>
@@ -30,7 +29,7 @@ QRImageWidget::QRImageWidget(QWidget* parent)
     contextMenu->addAction(tr("&Copy Image"), this, &QRImageWidget::copyImage);
 }
 
-bool QRImageWidget::setQR(const QString& data, const QString& text, const OptionsModel::FontChoice& fontchoice)
+bool QRImageWidget::setQR(const QString& data, const QString& text)
 {
 #ifdef USE_QRCODE
     setText("");
@@ -49,71 +48,36 @@ bool QRImageWidget::setQR(const QString& data, const QString& text, const Option
         return false;
     }
 
-    QImage qrImage = QImage(code->width, code->width, QImage::Format_RGB32);
+    QImage qrImage = QImage(code->width + 8, code->width + 8, QImage::Format_RGB32);
+    qrImage.fill(0xffffff);
     unsigned char *p = code->data;
     for (int y = 0; y < code->width; ++y) {
         for (int x = 0; x < code->width; ++x) {
-            qrImage.setPixel(x, y, ((*p & 1) ? 0x0 : 0xffffff));
+            qrImage.setPixel(x + 4, y + 4, ((*p & 1) ? 0x0 : 0xffffff));
             ++p;
         }
     }
     QRcode_free(code);
 
-    int qr_image_width = QR_IMAGE_SIZE + (2 * QR_IMAGE_MARGIN);
-    int qr_image_height = qr_image_width;
-    int qr_image_x_margin = QR_IMAGE_MARGIN;
-    int text_lines;
-    QFont font;
-    if (text.isEmpty()) {
-        text_lines = 0;
-    } else {
-        const int max_text_width = qr_image_width - (2 * QR_IMAGE_TEXT_MARGIN);
-
-        // Determine font to use
-        if (std::holds_alternative<OptionsModel::FontChoiceAbstract>(fontchoice)) {
-            font = GUIUtil::fixedPitchFont(fontchoice != OptionsModel::UseBestSystemFont);
-            font.setWeight(QFont::Bold);
-            font.setStretch(QFont::SemiCondensed);
-            font.setLetterSpacing(QFont::AbsoluteSpacing, 1);
-
-            const qreal font_size = GUIUtil::calculateIdealFontSize(max_text_width, text, font);
-            font.setPointSizeF(font_size);
-        } else {
-            font = std::get<QFont>(fontchoice);
-        }
-
-        // Plan how many lines are needed
-        QFontMetrics fm(font);
-        const int text_width = GUIUtil::TextWidth(fm, text);
-        if (text_width > max_text_width && text_width < max_text_width * 5 / 4) {
-            // Allow the image to grow up to 25% wider
-            qr_image_width = text_width + (2 * QR_IMAGE_TEXT_MARGIN);
-            qr_image_x_margin = (qr_image_width - QR_IMAGE_SIZE) / 2;
-            text_lines = 1;
-        } else {
-            text_lines = (text_width + max_text_width - 1) / max_text_width;
-        }
-        qr_image_height += (fm.height() * text_lines) + QR_IMAGE_TEXT_MARGIN;
-    }
-    QImage qrAddrImage(qr_image_width, qr_image_height, QImage::Format_RGB32);
+    const int qr_image_size = QR_IMAGE_SIZE + (text.isEmpty() ? 0 : 2 * QR_IMAGE_MARGIN);
+    QImage qrAddrImage(qr_image_size, qr_image_size, QImage::Format_RGB32);
     qrAddrImage.fill(0xffffff);
     {
         QPainter painter(&qrAddrImage);
-        painter.drawImage(qr_image_x_margin, QR_IMAGE_MARGIN, qrImage.scaled(QR_IMAGE_SIZE, QR_IMAGE_SIZE));
+        painter.drawImage(QR_IMAGE_MARGIN, 0, qrImage.scaled(QR_IMAGE_SIZE, QR_IMAGE_SIZE));
 
         if (!text.isEmpty()) {
             QRect paddedRect = qrAddrImage.rect();
-            paddedRect.setHeight(paddedRect.height() - QR_IMAGE_TEXT_MARGIN);
+            paddedRect.setHeight(QR_IMAGE_SIZE + QR_IMAGE_TEXT_MARGIN);
 
-            QString text_wrapped = text;
-            const int char_per_line = (text.size() + text_lines - 1) / text_lines;
-            for (int line = 1, pos = 0; line < text_lines; ++line) {
-                pos += char_per_line;
-                text_wrapped.insert(pos, QChar{'\n'});
-            }
+            QFont font = GUIUtil::fixedPitchFont();
+            font.setStretch(QFont::SemiCondensed);
+            font.setLetterSpacing(QFont::AbsoluteSpacing, 1);
+            const qreal font_size = GUIUtil::calculateIdealFontSize(paddedRect.width() - 2 * QR_IMAGE_TEXT_MARGIN, text, font);
+            font.setPointSizeF(font_size);
 
             painter.setFont(font);
-            painter.drawText(paddedRect, Qt::AlignBottom | Qt::AlignCenter, text_wrapped);
+            painter.drawText(paddedRect, Qt::AlignBottom | Qt::AlignCenter, text);
         }
     }
 
@@ -126,11 +90,6 @@ bool QRImageWidget::setQR(const QString& data, const QString& text, const Option
 #endif
 }
 
-bool QRImageWidget::setQR(const QString& data)
-{
-    return setQR(data, "", OptionsModel::FontChoiceAbstract::EmbeddedFont);
-}
-
 QImage QRImageWidget::exportImage()
 {
     return GUIUtil::GetImage(this);
diff --git a/src/qt/qrimagewidget.h b/src/qt/qrimagewidget.h
index 7f775cf146..d9ca2b899f 100644
--- a/src/qt/qrimagewidget.h
+++ b/src/qt/qrimagewidget.h
@@ -5,8 +5,6 @@
 #ifndef BITCOIN_QT_QRIMAGEWIDGET_H
 #define BITCOIN_QT_QRIMAGEWIDGET_H
 
-#include <qt/optionsmodel.h>
-
 #include <QImage>
 #include <QLabel>
 
@@ -14,9 +12,9 @@
 static const int MAX_URI_LENGTH = 255;
 
 /* Size of exported QR Code image */
-static constexpr int QR_IMAGE_SIZE = 252;
-static constexpr int QR_IMAGE_TEXT_MARGIN = 8;
-static constexpr int QR_IMAGE_MARGIN = 24;
+static constexpr int QR_IMAGE_SIZE = 300;
+static constexpr int QR_IMAGE_TEXT_MARGIN = 10;
+static constexpr int QR_IMAGE_MARGIN = 2 * QR_IMAGE_TEXT_MARGIN;
 
 QT_BEGIN_NAMESPACE
 class QMenu;
@@ -31,8 +29,7 @@ class QRImageWidget : public QLabel
 
 public:
     explicit QRImageWidget(QWidget *parent = nullptr);
-    bool setQR(const QString& data);
-    bool setQR(const QString& data, const QString& text, const OptionsModel::FontChoice& fontchoice);
+    bool setQR(const QString& data, const QString& text = "");
     QImage exportImage();
 
 public Q_SLOTS:
diff --git a/src/qt/qvalidatedlineedit.cpp b/src/qt/qvalidatedlineedit.cpp
index 4b32b4583e..b646332001 100644
--- a/src/qt/qvalidatedlineedit.cpp
+++ b/src/qt/qvalidatedlineedit.cpp
@@ -7,95 +7,33 @@
 #include <qt/bitcoinaddressvalidator.h>
 #include <qt/guiconstants.h>
 
-#include <cmath>
-
-#include <QColor>
-#include <QCoreApplication>
-#include <QFont>
-#include <QInputMethodEvent>
-#include <QList>
-#include <QTextCharFormat>
-
 QValidatedLineEdit::QValidatedLineEdit(QWidget* parent)
     : QLineEdit(parent)
 {
     connect(this, &QValidatedLineEdit::textChanged, this, &QValidatedLineEdit::markValid);
 }
 
-QValidatedLineEdit::~QValidatedLineEdit()
-{
-    delete m_warning_validator;
-}
-
 void QValidatedLineEdit::setText(const QString& text)
 {
     QLineEdit::setText(text);
     checkValidity();
 }
 
-double ColourLuminosity(QColor c)
-{
-    const auto Lr = std::pow(c.redF(),   2.2) * .2126;
-    const auto Lg = std::pow(c.greenF(), 2.2) * .7152;
-    const auto Lb = std::pow(c.blueF(),  2.2) * .0722;
-    return Lr + Lg + Lb;
-}
-
-void QValidatedLineEdit::setValid(bool _valid, bool with_warning, const std::vector<int>&error_locations)
+void QValidatedLineEdit::setValid(bool _valid)
 {
-    if(_valid && this->valid)
+    if(_valid == this->valid)
     {
-        if (with_warning == m_has_warning) {
-            return;
-        }
+        return;
     }
 
-    QList<QInputMethodEvent::Attribute> attributes;
-
     if(_valid)
     {
-        m_has_warning = with_warning;
-        if (with_warning) {
-            setStyleSheet("QValidatedLineEdit { " STYLE_INCORRECT "}");
-        } else {
-            setStyleSheet("");
-        }
+        setStyleSheet("");
     }
     else
     {
         setStyleSheet("QValidatedLineEdit { " STYLE_INVALID "}");
-        if (!error_locations.empty()) {
-            const QColor normal_text_colour = palette().color(foregroundRole());
-            const QColor bg_colour = palette().color(backgroundRole());
-            const bool dark_mode = ColourLuminosity(bg_colour) < .36;
-            QColor error_colour;
-            if (normal_text_colour.red() > normal_text_colour.green() && normal_text_colour.red() > normal_text_colour.blue()) {
-                // red is dominant, avoid fg red
-                if (bg_colour.red() > bg_colour.blue() && bg_colour.green() > bg_colour.blue()) {
-                    // bg is yellowish, fallback to blues
-                    error_colour = dark_mode ? Qt::cyan : Qt::blue;
-                } else {
-                    error_colour = dark_mode ? Qt::yellow : Qt::darkYellow;
-                }
-            } else {
-                error_colour = dark_mode ? QColor(255, 159, 159) : Qt::red;
-            }
-
-            QTextCharFormat format;
-            format.setFontUnderline(true);
-            format.setUnderlineStyle(QTextCharFormat::SpellCheckUnderline);
-            format.setUnderlineColor(error_colour);
-            format.setForeground(error_colour);
-            format.setFontWeight(QFont::Bold);
-            for (auto error_pos : error_locations) {
-                attributes.append(QInputMethodEvent::Attribute(QInputMethodEvent::TextFormat, error_pos - cursorPosition(), /*length=*/ 1, format));
-            }
-        }
     }
-
-    QInputMethodEvent event(QString(), attributes);
-    QCoreApplication::sendEvent(this, &event);
-
     this->valid = _valid;
 }
 
@@ -144,33 +82,23 @@ void QValidatedLineEdit::setEnabled(bool enabled)
 
 void QValidatedLineEdit::checkValidity()
 {
-    const bool has_warning = checkWarning();
     if (text().isEmpty())
     {
         setValid(true);
     }
     else if (hasAcceptableInput())
     {
-        setValid(true, has_warning);
+        setValid(true);
 
         // Check contents on focus out
         if (checkValidator)
         {
             QString address = text();
-            QValidator::State validation_result;
-            std::vector<int> error_locations;
-            const BitcoinAddressEntryValidator * const address_validator = dynamic_cast<const BitcoinAddressEntryValidator*>(checkValidator);
-            if (address_validator) {
-                validation_result = address_validator->validate(address, error_locations);
-            } else {
-                int pos = 0;
-                validation_result = checkValidator->validate(address, pos);
-                error_locations.push_back(pos);
-            }
-            if (validation_result == QValidator::Acceptable)
-                setValid(true, has_warning);
+            int pos = 0;
+            if (checkValidator->validate(address, pos) == QValidator::Acceptable)
+                setValid(true);
             else
-                setValid(/* valid= */ false, /* with_warning= */ false, error_locations);
+                setValid(false);
         }
     }
     else
@@ -198,28 +126,3 @@ bool QValidatedLineEdit::isValid()
 
     return valid;
 }
-
-void QValidatedLineEdit::setWarningValidator(const QValidator *v)
-{
-    delete m_warning_validator;
-    m_warning_validator = v;
-    checkValidity();
-}
-
-bool QValidatedLineEdit::checkWarning() const
-{
-    if (m_warning_validator && !text().isEmpty()) {
-        QString address = text();
-        int pos = 0;
-        if (m_warning_validator->validate(address, pos) != QValidator::Acceptable) {
-            return true;
-        }
-    }
-
-    return false;
-}
-
-bool QValidatedLineEdit::hasWarning() const
-{
-    return m_has_warning;
-}
diff --git a/src/qt/qvalidatedlineedit.h b/src/qt/qvalidatedlineedit.h
index 63fc15de50..b1ae013957 100644
--- a/src/qt/qvalidatedlineedit.h
+++ b/src/qt/qvalidatedlineedit.h
@@ -16,12 +16,9 @@ class QValidatedLineEdit : public QLineEdit
 
 public:
     explicit QValidatedLineEdit(QWidget *parent);
-    ~QValidatedLineEdit();
     void clear();
     void setCheckValidator(const QValidator *v);
     bool isValid();
-    void setWarningValidator(const QValidator *);
-    bool hasWarning() const;
 
 protected:
     void focusInEvent(QFocusEvent *evt) override;
@@ -30,12 +27,10 @@ protected:
 private:
     bool valid{true};
     const QValidator* checkValidator{nullptr};
-    bool m_has_warning{false};
-    const QValidator *m_warning_validator{nullptr};
 
 public Q_SLOTS:
     void setText(const QString&);
-    void setValid(bool valid, bool with_warning=false, const std::vector<int>&error_locations=std::vector<int>());
+    void setValid(bool valid);
     void setEnabled(bool enabled);
 
 Q_SIGNALS:
@@ -44,7 +39,6 @@ Q_SIGNALS:
 private Q_SLOTS:
     void markValid();
     void checkValidity();
-    bool checkWarning() const;
 };
 
 #endif // BITCOIN_QT_QVALIDATEDLINEEDIT_H
diff --git a/src/qt/receivecoinsdialog.cpp b/src/qt/receivecoinsdialog.cpp
index 716c0d194c..be7741e8a8 100644
--- a/src/qt/receivecoinsdialog.cpp
+++ b/src/qt/receivecoinsdialog.cpp
@@ -22,8 +22,6 @@
 #include <QSettings>
 #include <QTextDocument>
 
-#include <ranges>
-
 ReceiveCoinsDialog::ReceiveCoinsDialog(const PlatformStyle *_platformStyle, QWidget *parent) :
     QDialog(parent, GUIUtil::dialog_flags),
     ui(new Ui::ReceiveCoinsDialog),
@@ -31,9 +29,6 @@ ReceiveCoinsDialog::ReceiveCoinsDialog(const PlatformStyle *_platformStyle, QWid
 {
     ui->setupUi(this);
 
-    m_sort_proxy = new QSortFilterProxyModel(this);
-    m_sort_proxy->setSortRole(Qt::UserRole);
-
     if (!_platformStyle->getImagesOnButtons()) {
         ui->clearButton->setIcon(QIcon());
         ui->receiveButton->setIcon(QIcon());
@@ -56,6 +51,21 @@ ReceiveCoinsDialog::ReceiveCoinsDialog(const PlatformStyle *_platformStyle, QWid
     connect(ui->recentRequestsView, &QWidget::customContextMenuRequested, this, &ReceiveCoinsDialog::showMenu);
 
     connect(ui->clearButton, &QPushButton::clicked, this, &ReceiveCoinsDialog::clear);
+
+    QTableView* tableView = ui->recentRequestsView;
+    tableView->verticalHeader()->hide();
+    tableView->setAlternatingRowColors(true);
+    tableView->setSelectionBehavior(QAbstractItemView::SelectRows);
+    tableView->setSelectionMode(QAbstractItemView::ContiguousSelection);
+
+    QSettings settings;
+    if (!tableView->horizontalHeader()->restoreState(settings.value("RecentRequestsViewHeaderState").toByteArray())) {
+        tableView->setColumnWidth(RecentRequestsTableModel::Date, DATE_COLUMN_WIDTH);
+        tableView->setColumnWidth(RecentRequestsTableModel::Label, LABEL_COLUMN_WIDTH);
+        tableView->setColumnWidth(RecentRequestsTableModel::Amount, AMOUNT_MINIMUM_COLUMN_WIDTH);
+        tableView->horizontalHeader()->setMinimumSectionSize(MINIMUM_COLUMN_WIDTH);
+        tableView->horizontalHeader()->setStretchLastSection(true);
+    }
 }
 
 void ReceiveCoinsDialog::setModel(WalletModel *_model)
@@ -64,54 +74,32 @@ void ReceiveCoinsDialog::setModel(WalletModel *_model)
 
     if(_model && _model->getOptionsModel())
     {
+        _model->getRecentRequestsTableModel()->sort(RecentRequestsTableModel::Date, Qt::DescendingOrder);
         connect(_model->getOptionsModel(), &OptionsModel::displayUnitChanged, this, &ReceiveCoinsDialog::updateDisplayUnit);
         updateDisplayUnit();
 
         QTableView* tableView = ui->recentRequestsView;
-
-        tableView->verticalHeader()->hide();
-        tableView->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
-        tableView->setModel(m_sort_proxy);
-        m_sort_proxy->setSourceModel(_model->getRecentRequestsTableModel());
+        tableView->setModel(_model->getRecentRequestsTableModel());
         tableView->sortByColumn(RecentRequestsTableModel::Date, Qt::DescendingOrder);
 
-        tableView->setAlternatingRowColors(true);
-        tableView->setSelectionBehavior(QAbstractItemView::SelectRows);
-        tableView->setSelectionMode(QAbstractItemView::ExtendedSelection);
-
-        QSettings settings;
-        if (!tableView->horizontalHeader()->restoreState(settings.value("RecentRequestsViewHeaderState").toByteArray())) {
-            tableView->setColumnWidth(RecentRequestsTableModel::Date, DATE_COLUMN_WIDTH);
-            tableView->setColumnWidth(RecentRequestsTableModel::Label, LABEL_COLUMN_WIDTH);
-            tableView->setColumnWidth(RecentRequestsTableModel::Amount, AMOUNT_MINIMUM_COLUMN_WIDTH);
-        }
-
         connect(tableView->selectionModel(),
             &QItemSelectionModel::selectionChanged, this,
             &ReceiveCoinsDialog::recentRequestsView_selectionChanged);
-        // Last 2 columns are set by the columnResizingFixer, when the table geometry is ready.
-        columnResizingFixer = new GUIUtil::TableViewLastColumnResizingFixer(tableView, AMOUNT_MINIMUM_COLUMN_WIDTH, DATE_COLUMN_WIDTH, this);
 
         // Populate address type dropdown and select default
-        auto add_address_type = [&](OutputType type) {
-            const auto [text, tooltip] = GetOutputTypeDescription(type);
+        auto add_address_type = [&](OutputType type, const QString& text, const QString& tooltip) {
             const auto index = ui->addressType->count();
             ui->addressType->addItem(text, (int) type);
             ui->addressType->setItemData(index, tooltip, Qt::ToolTipRole);
             if (model->wallet().getDefaultAddressType() == type) ui->addressType->setCurrentIndex(index);
         };
-        add_address_type(OutputType::LEGACY);
-        add_address_type(OutputType::P2SH_SEGWIT);
-        add_address_type(OutputType::BECH32);
+        add_address_type(OutputType::LEGACY, tr("Base58 (Legacy)"), tr("Not recommended due to higher fees and less protection against typos."));
+        add_address_type(OutputType::P2SH_SEGWIT, tr("Base58 (P2SH-SegWit)"), tr("Generates an address compatible with older wallets."));
+        add_address_type(OutputType::BECH32, tr("Bech32 (SegWit)"), tr("Generates a native segwit address (BIP-173). Some old wallets don't support it."));
         if (model->wallet().taprootEnabled()) {
-            add_address_type(OutputType::BECH32M);
+            add_address_type(OutputType::BECH32M, tr("Bech32m (Taproot)"), tr("Bech32m (BIP-350) is an upgrade to Bech32, wallet support is still limited."));
         }
 
-        connect(_model->getOptionsModel(), &OptionsModel::addresstypeChanged, [this](const OutputType type) {
-            const int index = ui->addressType->findData((int) type);
-            if (index != -1) ui->addressType->setCurrentIndex(index);
-        });
-
         // Set the button to be enabled or disabled based on whether the wallet can give out new addresses.
         ui->receiveButton->setEnabled(model->wallet().canGetAddresses());
 
@@ -203,10 +191,12 @@ void ReceiveCoinsDialog::on_receiveButton_clicked()
 
 void ReceiveCoinsDialog::on_recentRequestsView_doubleClicked(const QModelIndex &index)
 {
-    QModelIndexList selection = SelectedRows();
-    if (!selection.isEmpty() && selection.at(0).isValid()) {
-        ShowReceiveRequestDialogForItem(selection.at(0));
-    }
+    const RecentRequestsTableModel *submodel = model->getRecentRequestsTableModel();
+    ReceiveRequestDialog *dialog = new ReceiveRequestDialog(this);
+    dialog->setModel(model);
+    dialog->setInfo(submodel->entry(index.row()).recipient);
+    dialog->setAttribute(Qt::WA_DeleteOnClose);
+    dialog->show();
 }
 
 void ReceiveCoinsDialog::recentRequestsView_selectionChanged(const QItemSelection &selected, const QItemSelection &deselected)
@@ -219,128 +209,63 @@ void ReceiveCoinsDialog::recentRequestsView_selectionChanged(const QItemSelectio
 
 void ReceiveCoinsDialog::on_showRequestButton_clicked()
 {
-    QModelIndexList selection = SelectedRows();
+    if(!model || !model->getRecentRequestsTableModel() || !ui->recentRequestsView->selectionModel())
+        return;
+    QModelIndexList selection = ui->recentRequestsView->selectionModel()->selectedRows();
 
     for (const QModelIndex& index : selection) {
-        ShowReceiveRequestDialogForItem(index);
+        on_recentRequestsView_doubleClicked(index);
     }
 }
 
 void ReceiveCoinsDialog::on_removeRequestButton_clicked()
 {
-    QModelIndexList selection = SelectedRows();
+    if(!model || !model->getRecentRequestsTableModel() || !ui->recentRequestsView->selectionModel())
+        return;
+    QModelIndexList selection = ui->recentRequestsView->selectionModel()->selectedRows();
     if(selection.empty())
         return;
-
-    // Collect row indices in a set (sorted) and pass in reverse order to removeRows
-    // to avoid having to keep track of changed source indices after each removal
-    std::set<int> row_indices;
-    for (const QModelIndex& ind : selection) {
-        row_indices.insert(ind.row());
-    }
-
-    for (auto row_ind : row_indices | std::views::reverse) {
-        model->getRecentRequestsTableModel()->removeRows(row_ind, 1);
-    }
-}
-
-// We override the virtual resizeEvent of the QWidget to adjust tables column
-// sizes as the tables width is proportional to the dialogs width.
-void ReceiveCoinsDialog::resizeEvent(QResizeEvent *event)
-{
-    QWidget::resizeEvent(event);
-    columnResizingFixer->stretchColumnWidth(RecentRequestsTableModel::Message);
+    // correct for selection mode ContiguousSelection
+    QModelIndex firstIndex = selection.at(0);
+    model->getRecentRequestsTableModel()->removeRows(firstIndex.row(), selection.length(), firstIndex.parent());
 }
 
-QModelIndexList ReceiveCoinsDialog::SelectedRows()
+QModelIndex ReceiveCoinsDialog::selectedRow()
 {
     if(!model || !model->getRecentRequestsTableModel() || !ui->recentRequestsView->selectionModel())
-        return QModelIndexList();
+        return QModelIndex();
     QModelIndexList selection = ui->recentRequestsView->selectionModel()->selectedRows();
-    QModelIndexList source_mapped;
-    for (auto row : selection) {
-        source_mapped.append(m_sort_proxy->mapToSource(row));
-    }
-
-    return source_mapped;
+    if(selection.empty())
+        return QModelIndex();
+    // correct for selection mode ContiguousSelection
+    QModelIndex firstIndex = selection.at(0);
+    return firstIndex;
 }
 
 // copy column of selected row to clipboard
 void ReceiveCoinsDialog::copyColumnToClipboard(int column)
 {
-    const QModelIndexList sel = SelectedRows();
-    if (sel.isEmpty()) {
-        return;
-    }
-
-    const RecentRequestsTableModel* const submodel = model->getRecentRequestsTableModel();
-    QString column_value;
-    for (int sel_ind = 0; sel_ind < sel.size(); ++sel_ind) {
-        if (!sel.at(sel_ind).isValid()) {
-            continue;
-        }
-        column_value += submodel->index(sel.at(sel_ind).row(), column).data(Qt::EditRole).toString();
-        if (sel_ind < sel.size() - 1) {
-            column_value += QString("\n");
-        }
-    }
-    GUIUtil::setClipboard(column_value);
-}
-
-void ReceiveCoinsDialog::ShowReceiveRequestDialogForItem(const QModelIndex& index)
-{
-    if (!index.isValid()) {
+    QModelIndex firstIndex = selectedRow();
+    if (!firstIndex.isValid()) {
         return;
     }
-    const RecentRequestsTableModel* submodel = model->getRecentRequestsTableModel();
-    ReceiveRequestDialog* dialog = new ReceiveRequestDialog(this);
-    dialog->setModel(model);
-    dialog->setInfo(submodel->entry(index.row()).recipient);
-    dialog->setAttribute(Qt::WA_DeleteOnClose);
-    dialog->show();
+    GUIUtil::setClipboard(model->getRecentRequestsTableModel()->index(firstIndex.row(), column).data(Qt::EditRole).toString());
 }
 
 // context menu
 void ReceiveCoinsDialog::showMenu(const QPoint &point)
 {
-    const QModelIndexList sel = SelectedRows();
-    if (sel.isEmpty()) {
+    const QModelIndex sel = selectedRow();
+    if (!sel.isValid()) {
         return;
     }
 
-    if (sel.size() == 1 && sel.at(0).isValid()) {
     // disable context menu actions when appropriate
     const RecentRequestsTableModel* const submodel = model->getRecentRequestsTableModel();
-        const RecentRequestEntry& req = submodel->entry(sel.at(0).row());
+    const RecentRequestEntry& req = submodel->entry(sel.row());
     copyLabelAction->setDisabled(req.recipient.label.isEmpty());
     copyMessageAction->setDisabled(req.recipient.message.isEmpty());
     copyAmountAction->setDisabled(req.recipient.amount == 0);
-    } else if (sel.size() > 1) {
-        // multiple selection
-
-        copyLabelAction->setDisabled(true);
-        copyMessageAction->setDisabled(true);
-        copyAmountAction->setDisabled(true);
-
-        // disable context menu actions when appropriate
-        const RecentRequestsTableModel* const submodel = model->getRecentRequestsTableModel();
-
-        for (auto selection : sel) {
-            if (!selection.isValid()) {
-                continue;
-            }
-            const RecentRequestEntry& req = submodel->entry(selection.row());
-            if (!req.recipient.label.isEmpty()) {
-                copyLabelAction->setDisabled(false);
-            }
-            if (!req.recipient.message.isEmpty()) {
-                copyMessageAction->setDisabled(false);
-            }
-            if (req.recipient.amount != 0) {
-                copyAmountAction->setDisabled(false);
-            }
-        }
-    }
 
     contextMenu->exec(QCursor::pos());
 }
@@ -348,46 +273,26 @@ void ReceiveCoinsDialog::showMenu(const QPoint &point)
 // context menu action: copy URI
 void ReceiveCoinsDialog::copyURI()
 {
-    const QModelIndexList sel = SelectedRows();
-    if (sel.isEmpty()) {
+    QModelIndex sel = selectedRow();
+    if (!sel.isValid()) {
         return;
     }
 
     const RecentRequestsTableModel * const submodel = model->getRecentRequestsTableModel();
-    QString uri;
-    for (int sel_ind = 0; sel_ind < sel.size(); ++sel_ind) {
-        if (!sel.at(sel_ind).isValid()) {
-            continue;
-        }
-        const RecentRequestEntry& req = submodel->entry(sel.at(sel_ind).row());
-        uri += GUIUtil::formatBitcoinURI(req.recipient);
-        if (sel_ind < sel.size() - 1) {
-            uri += QString("\n");
-        }
-    }
+    const QString uri = GUIUtil::formatBitcoinURI(submodel->entry(sel.row()).recipient);
     GUIUtil::setClipboard(uri);
 }
 
 // context menu action: copy address
 void ReceiveCoinsDialog::copyAddress()
 {
-    const QModelIndexList sel = SelectedRows();
-    if (sel.isEmpty()) {
+    const QModelIndex sel = selectedRow();
+    if (!sel.isValid()) {
         return;
     }
 
     const RecentRequestsTableModel* const submodel = model->getRecentRequestsTableModel();
-    QString address;
-    for (int sel_ind = 0; sel_ind < sel.size(); ++sel_ind) {
-        if (!sel.at(sel_ind).isValid()) {
-            continue;
-        }
-        const RecentRequestEntry& req = submodel->entry(sel.at(sel_ind).row());
-        address += req.recipient.address;
-        if (sel_ind < sel.size() - 1) {
-            address += QString("\n");
-        }
-    }
+    const QString address = submodel->entry(sel.row()).recipient.address;
     GUIUtil::setClipboard(address);
 }
 
diff --git a/src/qt/receivecoinsdialog.h b/src/qt/receivecoinsdialog.h
index b0aaff6a6b..0bb02ebcf2 100644
--- a/src/qt/receivecoinsdialog.h
+++ b/src/qt/receivecoinsdialog.h
@@ -13,7 +13,6 @@
 #include <QKeyEvent>
 #include <QMenu>
 #include <QPoint>
-#include <QSortFilterProxyModel>
 #include <QVariant>
 
 class PlatformStyle;
@@ -52,8 +51,6 @@ public Q_SLOTS:
 
 private:
     Ui::ReceiveCoinsDialog *ui;
-    GUIUtil::TableViewLastColumnResizingFixer *columnResizingFixer{nullptr};
-    QSortFilterProxyModel* m_sort_proxy;
     WalletModel* model{nullptr};
     QMenu *contextMenu;
     QAction* copyLabelAction;
@@ -61,11 +58,8 @@ private:
     QAction* copyAmountAction;
     const PlatformStyle *platformStyle;
 
-    // Returns QModelIndex in source model
-    QModelIndexList SelectedRows();
+    QModelIndex selectedRow();
     void copyColumnToClipboard(int column);
-    void ShowReceiveRequestDialogForItem(const QModelIndex& index);
-    virtual void resizeEvent(QResizeEvent *event) override;
 
 private Q_SLOTS:
     void on_receiveButton_clicked();
diff --git a/src/qt/receiverequestdialog.cpp b/src/qt/receiverequestdialog.cpp
index d31307885a..b4322ddc0f 100644
--- a/src/qt/receiverequestdialog.cpp
+++ b/src/qt/receiverequestdialog.cpp
@@ -12,9 +12,7 @@
 #include <qt/walletmodel.h>
 
 #include <QDialog>
-#include <QLayoutItem>
 #include <QString>
-#include <QTextEdit>
 
 #include <config/bitcoin-config.h> // IWYU pragma: keep
 
@@ -23,62 +21,14 @@ ReceiveRequestDialog::ReceiveRequestDialog(QWidget* parent)
       ui(new Ui::ReceiveRequestDialog)
 {
     ui->setupUi(this);
-
-    while (QLayoutItem * const child = ui->gridLayout->itemAt(1)) {
-        if (child == ui->horizontalLayout) break;  // stop at buttons
-        ui->gridLayout->removeItem(child);
-        auto child_widget = child->widget();
-        // NOTE: Unparenting causes isHidden to be unconditionally true, so just make it sizeless and exclude it from the layout
-        child_widget->setMaximumSize(0, 0);
-        m_info_grid.append(child_widget);
-        delete child;
-    }
-    m_info_widget = new QTextEdit(this);
-    m_info_widget->setMinimumSize(0, 50);
-    m_info_widget->setFrameShape(QFrame::NoFrame);
-    m_info_widget->setFrameShadow(QFrame::Plain);
-    m_info_widget->setTabChangesFocus(true);
-    m_info_widget->setTextInteractionFlags(Qt::TextSelectableByKeyboard | Qt::TextSelectableByMouse);
-    ui->gridLayout->addWidget(m_info_widget, 1, 0, 1, 2);
-
     GUIUtil::handleCloseWindowShortcut(this);
 }
 
 ReceiveRequestDialog::~ReceiveRequestDialog()
 {
-    for (auto& widget : m_info_grid) {
-        delete widget;
-    }
     delete ui;
 }
 
-void ReceiveRequestDialog::updateInfoWidget()
-{
-    QString html;
-    html += "<html><font face='verdana, arial, helvetica, sans-serif'>";
-    int i = 0;
-    for (auto& widget : m_info_grid) {
-        ++i;
-        QLabel * const label = dynamic_cast<QLabel*>(widget);
-        assert(label);
-        QString text = label->text();
-
-        if (!label->isHidden()) {
-            if (i == 1) {
-                html += "<b>" + text + "</b><br>";
-            } else if (i % 2 == 0) {
-                assert(text.endsWith(":"));
-                text.chop(1);
-                html += "<b>" + text + "</b>: ";
-            } else {
-                html += text + "<br>";
-            }
-        }
-    }
-    html += "</font></html>";
-    m_info_widget->setText(html);
-}
-
 void ReceiveRequestDialog::setModel(WalletModel *_model)
 {
     this->model = _model;
@@ -97,11 +47,8 @@ void ReceiveRequestDialog::setInfo(const SendCoinsRecipient &_info)
     QString uri = GUIUtil::formatBitcoinURI(info);
 
 #ifdef USE_QRCODE
-    if (ui->qr_code->setQR(uri, info.address, model->getOptionsModel()->getFontChoiceForQRCodes())) {
+    if (ui->qr_code->setQR(uri, info.address)) {
         connect(ui->btnSaveAs, &QPushButton::clicked, ui->qr_code, &QRImageWidget::saveImage);
-        connect(model->getOptionsModel(), &OptionsModel::fontForQRCodesChanged, this, [&](const OptionsModel::FontChoice& fontchoice){
-            ui->qr_code->setQR(uri, info.address, fontchoice);
-        });
     } else {
         ui->btnSaveAs->setEnabled(false);
     }
@@ -140,8 +87,6 @@ void ReceiveRequestDialog::setInfo(const SendCoinsRecipient &_info)
         ui->wallet_content->hide();
     }
 
-    updateInfoWidget();
-
     ui->btnVerify->setVisible(model->wallet().hasExternalSigner());
 
     connect(ui->btnVerify, &QPushButton::clicked, [this] {
@@ -153,7 +98,6 @@ void ReceiveRequestDialog::updateDisplayUnit()
 {
     if (!model) return;
     ui->amount_content->setText(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), info.amount));
-    updateInfoWidget();
 }
 
 void ReceiveRequestDialog::on_btnCopyURI_clicked()
diff --git a/src/qt/receiverequestdialog.h b/src/qt/receiverequestdialog.h
index 7f2ef2b3ac..d64fee3663 100644
--- a/src/qt/receiverequestdialog.h
+++ b/src/qt/receiverequestdialog.h
@@ -8,9 +8,6 @@
 #include <qt/sendcoinsrecipient.h>
 
 #include <QDialog>
-#include <QList>
-#include <QTextEdit>
-#include <QWidget>
 
 class WalletModel;
 
@@ -36,9 +33,6 @@ private Q_SLOTS:
 
 private:
     Ui::ReceiveRequestDialog *ui;
-    void updateInfoWidget();
-    QTextEdit *m_info_widget;
-    QList<QWidget*> m_info_grid;
     WalletModel* model{nullptr};
     SendCoinsRecipient info;
 };
diff --git a/src/qt/recentrequeststablemodel.cpp b/src/qt/recentrequeststablemodel.cpp
index ec19d0da93..a8d54cdc0c 100644
--- a/src/qt/recentrequeststablemodel.cpp
+++ b/src/qt/recentrequeststablemodel.cpp
@@ -87,8 +87,6 @@ QVariant RecentRequestsTableModel::data(const QModelIndex &index, int role) cons
         case Amount:
             if (rec->recipient.amount == 0 && role == Qt::DisplayRole)
                 return tr("(no amount requested)");
-            else if (rec->recipient.amount == 0 && role == Qt::EditRole)
-                return "";
             else if (role == Qt::EditRole)
                 return BitcoinUnits::format(walletModel->getOptionsModel()->getDisplayUnit(), rec->recipient.amount, false, BitcoinUnits::SeparatorStyle::NEVER);
             else
@@ -99,20 +97,6 @@ QVariant RecentRequestsTableModel::data(const QModelIndex &index, int role) cons
     {
         if (index.column() == Amount)
             return (int)(Qt::AlignRight|Qt::AlignVCenter);
-    } else if (role == Qt::UserRole) {
-        const RecentRequestEntry* rec = &list[index.row()];
-        switch (index.column()) {
-        case Date:
-            return rec->date;
-        case Label:
-            return rec->recipient.label;
-        case Message:
-            return rec->recipient.message;
-        case Amount:
-            return QVariant(static_cast<qlonglong>(rec->recipient.amount));
-        default:
-            return QVariant();
-        }
     }
     return QVariant();
 }
@@ -228,6 +212,12 @@ void RecentRequestsTableModel::addNewRequest(RecentRequestEntry &recipient)
     endInsertRows();
 }
 
+void RecentRequestsTableModel::sort(int column, Qt::SortOrder order)
+{
+    std::sort(list.begin(), list.end(), RecentRequestEntryLessThan(column, order));
+    Q_EMIT dataChanged(index(0, 0, QModelIndex()), index(list.size() - 1, NUMBER_OF_COLUMNS - 1, QModelIndex()));
+}
+
 void RecentRequestsTableModel::updateDisplayUnit()
 {
     updateAmountColumnTitle();
diff --git a/src/qt/recentrequeststablemodel.h b/src/qt/recentrequeststablemodel.h
index f79f46343c..151f8322a8 100644
--- a/src/qt/recentrequeststablemodel.h
+++ b/src/qt/recentrequeststablemodel.h
@@ -75,6 +75,7 @@ public:
     QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const override;
     bool removeRows(int row, int count, const QModelIndex &parent = QModelIndex()) override;
     Qt::ItemFlags flags(const QModelIndex &index) const override;
+    void sort(int column, Qt::SortOrder order = Qt::AscendingOrder) override;
     /*@}*/
 
     const RecentRequestEntry &entry(int row) const { return list[row]; }
diff --git a/src/qt/res/bitcoin-qt-res.rc b/src/qt/res/bitcoin-qt-res.rc
index ca228ad9b6..e590b407b0 100644
--- a/src/qt/res/bitcoin-qt-res.rc
+++ b/src/qt/res/bitcoin-qt-res.rc
@@ -1,5 +1,5 @@
-IDI_ICON1 ICON DISCARDABLE "rendered_icons/bitcoin.ico"
-IDI_ICON2 ICON DISCARDABLE "rendered_icons/bitcoin_testnet.ico"
+IDI_ICON1 ICON DISCARDABLE "icons/bitcoin.ico"
+IDI_ICON2 ICON DISCARDABLE "icons/bitcoin_testnet.ico"
 
 #include <windows.h>             // needed for VERSIONINFO
 #include "../../clientversion.h" // holds the needed client version information
diff --git a/src/qt/res/fonts/RobotoTonalMono-Bold.ttf.in b/src/qt/res/fonts/RobotoTonalMono-Bold.ttf.in
deleted file mode 100644
index ff2514c58f..0000000000
--- a/src/qt/res/fonts/RobotoTonalMono-Bold.ttf.in
+++ /dev/null
@@ -1 +0,0 @@
-{Wp48S^xk9=GL@E0stWa761SMbT8$j;a-oo?Ogx>08$Dh#jy0P$+p>SQymfk9vxSmNsrB60!o3DTAULm>7&i^wR+J5VvY?Ve<>2Lf=2|ld!nk=WRbboPeAC_c00T1U-To{LPmQMo1*a9DVm&!q8Z9%tB>Duh|!fIEv0~m^WEbcoZogbP752+&gKPJr-EB;*cm{*A174AdZZ15ni-~5#(*upDx8v}6KL7&2JccKYCs1;$`=dgh%|AAS@i)rdGi-8w@HzVD(*OL0vT-)UAbNJ8jP)Aw_sRHiX0-qDU4W}(z+C<25%o+M~36<ER0wPDh*qUs|+mbUcM7T+yN|Q$7j~8a&{a2b_%GDbBQg!=lkiu;$kw^A3Gl3G;V&(;x-D71FZ82K%bxB7A^Jd6F32q!fKf-N_5wnEb@P_LD(rcP@H9Nn9gYHffbz^X5^`-yQJV*eN!a!**>N$kWv?~9Nvi@Dd_vd;cNP=t&CK%G${&>Zs31WnO@yp@B?rfbYw(iPL@hfWOC=)6Zj*E>DH-`thjcD+spTDmzH>lYx4_rXWNBSKN>i)kMmmt-#m%Lyh7>GOub4UT0z4H-6pw3FAY>!1=@z(8N_eCj>$+cMBE1@)Ej3os@r)HsW*FUL~Q4T1T7Rd`#?ImZ}Z)jL|+$JNxF@eo)H{iLN-81AFH0So=5NeIRGv!O%ehVBfW<y2(nH7WL$Ckxb0|Tj0BI<3S}njO|0{n7IHcA@lWP){^VaL%VG9ft$Xk4S5$u?lCW9GSK;QLc*+z<g<)$uHkkX}v)V$g&vqM-`DI$Iz?ODMtbgG3??lw&X~A!AnouCyzh*6GUh-U-50?&MjJbEOYg+F1^x9!#HVuO>VUx$=vAv9QU>q|}VV(5k^A~Wb9KKZ=&nUtKdYDZ7to2omm;_9NND}8ckoyL~`7Iuvnk4>5Nz0D%M|6@bsjlLt^yNm%wPKUbBJJyrDzB3mV_h%B3rjHYI<qli^c`Md^+<P}Ckn;I*h`)Oz;B;+O$sxk#7p|6^<fv24{+esCDdZ^a3p#Uc6FEIY_B_O@0xdC8LQ{as3@j&N{LHeqNDK<=T9rZqHvfdMZ}EPuBr~7t)y8)6}2G%)SKq@x$XYY(g*aeQyUjcDqG8?PDW^kxrq*g=BCK{hK}EEv3IZ}6rew@n1N)+xdTlrSd$hQ$;QmuQfwm9pv|e*NfCazU54eqy<8bJ_&JHqw%)e%-(%g_&0b&nkSp<_0hg`4n!G!fxURn1lW6pjv5umakt2lJu8p5pf9fXMZhZFtbE)vj*eGLQ_|@p?0RokROkuV>4jV4lc)v-e{|^#IEJ`lu7nXnvD@PUow={?>L~jvZZS9L-`Dr3cqrl`}`d8o_ooDUYsxV@XYn58lYtl;gpk#zj@UlDFBl5{`erT)OYm-ui)VD{avz`VT0#H&!ufB0+yIYkZlZ>;DVdt4_Eq(pWa1Ev@u7KHZ4-9Yu`cKe`Z5BEAA-OFFy&r<jm}zlB17=L6qYJ7&l`*<zE(0Pqb<N*o9bH&VDVd+;fPU@`ub)V`N7}$7g-GxP@QbR10>Hh?XRP@~s<y$z8<kmp<jj+_A8)op{hE9=chW<vfb+03rMnfZ(5KU;0$pK=fB$^J1F|DHYA}oK@YPM$%=xEe4dT&Ii%7!f7+${dbUtZlehPrm&~3|y)7k}#v;6Iw_&cBF7HZk-Wvmiz4FEZsf}gJ7*eA+^A2VD<qbg$)Gc-O)HC{TZ+uY1Q{uL4z5r*AbR{1hEUq?`tSUiD`YGj6@0uq1q&Z)rbJaviiR^DNcN;3?imSBei64Ut+eZubb#;aoJ8V31Z&#6*JXh>=PO}L7Fr_gXUTr=dBkMqSG)F&<WqZvuGW4|9Gh*#idrirV6#~jGv%>ZWUW6TQ=BzU~df?0I_yDtIk*e2p-YaHa%Za@d3hGO*Cmh)>GCLs=S#X&s1p!bkfA&^T`xJX=3pgrOb7<QnQGonamZ_P(~DNgG_^?`%rECZT|OS9w>MzOg`fT8d9$1#wH_m)o-Agom!tg@hy5JYt*_DzP^g-QG6pi1VFSQ{Zgb@3=-hWa;|pMg8M%6iuc^~Ze3?6ET}*`lvym>*SYZ|L(`ia`o@unM|Do4<G(!<x~l7C<?*?B>vK49nLXS#ggXq<{!lOD&$-Tl;%7<DVOjOdS(AB2`9FizOmVH50jWpbQB};EQv4OKd2wToWqo=Eiod8EGHadv7kOLV6vBiL~|qA(QkBaR`zj64bs*94@TI>yx2n#YIVuu5%TOPL5(J4u>YIx(uEdW|2Q80oIE@ujRoLm#yL)32UA28Vor$qapWSI|!tVjVnEf+JOkPyF1@>L=A67rZrfdO+;pU1?uD4@%vYGR5JhS2|2dgfEh~+)Xdes4mncw?vZGa?Nem#tx{YB+Ts`(VjEQiC|jI)>+UZRhMa=90Ou_gd4TYTs2GbbbsY`loRbIG01+^Ee%W-3N;=K3`0bC<zzZGL;qs<DCVBG9mNVbJHtPsYuF3DWV{@$bFEY)j)r6{Bw;CNG%1Lg25(EvA!eUh)M9vD&GAm&n*>XCxPPjy|!g&z$%SaUbP_aXrLC;~EF|DhL_Y9uHdpd&Ry~oK9YQDB1g5@?+_pOuMfPD^2XnoFT_50D#MA+P{z{Z+(cnD~y4G@w>#CJp+QS5^b#IQOdKSS(pPk5fc@fsAAkMaLB9N6=U;+QL=$75C3?rdOG@G-?V_07VKd_!MUg%_CB6UOTKATZ3eQM7GZT@{ReL3>TG{hVC>C5H}S=ztVUz>63ZEInkbwp7N8wMNl8Viaya6LlKuf%;l{&I-}J>faGFugbYWHP@T*1K7p@;Jii1HNr8ooy9BYjy-T0bQfilJVu^ZRV7*Go!Xw9Sld@H?dC7;SXz<}bqyym^ezy+CB~z;5>v-)@1Z}SJykl~q^UcRntqfd;Sqt*%NLr_u&;pADQ70Kf=;gWQ1VFulbvrMiuF{k-qDiAq!Bn^2Fx`K*ieTOsB&K6(WH_l*WH#|l^;D<t6vEYKpJQHa9QVcwu02<5QP)afD<CgzorAlm#zPCxcTy1T5x>`ANj4HhO?fpr+ZZ;j#R!)pX+K+0k?x9!dh4-M5FPckG*{|%Mb~@&JG(a@8@u<i}cg0{T=uFcMhP6TN{=e&x<YhqXej`?%}*3?uDz?xeqAutedX#z7yUnQk!Ck|KN)$AyT-Q59Grf(%?$(+<7$e+BL&JlsK!Xo7TzQeD!5aj~>c}wV(|(&Hw4-_53;0_&ps(<M=qPkLF4(-!pXSLcw7SyDI@mj)R)aKk{Tjp^EI<8HBy36-gDiGyBs^XnesdcZw>sklVXry;gM$eHvN<F?n>bvq}(?a5@iOqDQ%CcEhpzeL1H2v3B3HCGwWYLg-ZSd(u-GU{f9~Td3OArl4)@SiT9Hv3+2*IY~^UMJ{nVyx%jar#TcCKRy5P@L_xj+L7?=GA}f&7oqX(X~Di*kSERuteXMD7TO|a*O-rr1OBg%J-G%Zyod=yn~UMG;m3PzXu%w@VoQlNl}VO{(O|`b8?PRtAp8|SVARnE7E!tj>hDLEe};#<?{I?^xwsu1e6-0ju3zknZI+=YKpu^@$<N4J`fKQ|pwkLvD?_K5b`i7`6W+kFt9&G^v1S~eco0Q6ac_1<{;W&9f!w7pq$P`)k1;nXm4BT#F3k9Gz|8{J5_9vgw*ZpGlu7NzUDnc_Yp2>4&afiy&jhT<2<NWe+EL{VvH0RdemC}{f2(4t;bw^`ZqbVK>57IrsMa&}5Z=R(@uCvddq}-o_JvXIsq{~v>{v&L8)kW~Bd9_r-aI(d<j2(lUTmMNzeX0RvFYyOG5#2*2{V&6zOJN+HwUWhD5bw(7&CTgc4T1t!7H9{P|QQml6F;C(z4^Y2Mrri*6gm|Oq0xpSkKdfQdq&Z`{*(+Fq_Uv#C?v)yZCz;Q|=vK_lUc<I$$@90u`>_h>d!zoEH0%b$No^NX+|CcsMq~$K#5P**%hn>-Ag6jI%Ll`6>kj+WY#lyqA49nm-h=o}9TLEG>NW2;n3j53|N!JrNy&y58VN*MmvIn?y2AWLp`QTHnp%<7(5%V)LUIbgxO(;pAdz5#JiKo&&{yHbFYy1$<`RWYrYcuLIob@G9#Ou$h^q4Nul&V{}yp_jkyC;VFLOGQO<5b;wD2i7X)Y8M)FF|IvXoI<X-Q|0V0$*2QSRqg0X-9AX2Q)8uE7=I49V&DqGvCcrn<ijvIEs|4*9mAPtA64<eXDUq0Gk+E79rU@42JVRy1I!VcBy9g*>57;&#BSw#)=yu;FP8sgtH)=+;wYubUV9r`ou!vsxil!$CdZlO`7YYa59tjy}_hDEOkppl#DA+UVRgK5*Bc&i!q1ryIp1!to1WovI-bqB&vHz)yim@L0z}6RcbccgA>lfG2!w4@(Y>{!Qxg<WZP<ZDyrFO#r#q20cz~g`e@>K~p?6hirSRhJ_KAkX;{5Pqk63PziFD%?W0lG9pMNP$35)4d4h<f%FusX6Jq|DNe!FSeW;UOccY%T}$N*R&%7_OG0Y>I-Ov#)Hx!4m|}kM6c&O7)jzG$Ix|t&`C0(jBb;ny9hL*VkjHkBs%)kzm_Q0Z$ZyveEz{3#ES+_*&1y+yq<0LQiI!+!uC(tdDO&rg86_uUc8!Sp3y!8kv2>2>y)6I}$S{2J!Kila?hFsVw2kn>e^PT_wfCK71kAbbDxlOVxeAK5k}~OssV*UOhW#EA$W4Fl`^H4sXVE39W}BtJy(b_-~mg;f9~(T7Wx}zmFdSKnHAadwMGM6s8V>NE=RJ6~~OWpE>$YC7u^LM7%&xz(F)YF6azAT$RzGdQP7u&-W~vm(iYKn2%bvPF)HJb>|))Ow%Wq7cDQ`J*CAkf<TbnwQW~qhQ=4hB5QS5&K-l?zeP+eh8a0UfmgTUE%jTcE=RylZS3e4uNwHrDLBo=XF7!Kf(%nv0^m~5uE9h8bl;%m{yZtbV$URIr(>;-D3aNgDXR9%K-t8i1_HIb`?pQv!~dYR-FaVv^9AbBk$OwaH@f9<oz?>uvfxZPTO>uRg&PwpGMbhzIdo|)L#{{#5FVFbweM}d7HVB*oQFhV+y&sDUdz8v%cm1W*{6fx6{o4QN>k;eN6%1KB&Hx>p!|k;xq{Nq;yu(`7d5mqz61CQgu)$6VmTL<Kb$rAWc9?K6v|8~G|cIy++|@*GIQJqkr0FNh_M(%j{WKl%GJV<f%Y$${2ysiG5%5V`zaR1bR<@EJ1hO@GyTNcA`)ziVCOp@o5!V|lGfa~PwH!QWQpMOl+{$^?j=lKf!ip=lG%bc-bZ}~xaxx2V!2&miM?AZnzNDX${>T(l0Yd`^^=w=LD|p%JiQR^x3?TTWHVOl{@MiGd2xh%<!YZEP-5<z!Lr6q8vKufL9Hh;Dp>ex*nRWIwGBvk{H2S%n)P<{4j#B6jot%`+FfH~%3wQ3@z+GLvNT6BCAs8Aqve<$r;?7@Su-5Nr-)?^3-yuVXD3Y1K)9q3LYmI-#e-4fcgDCtifKztNASXg|8she0ZlTIWc@u`Emn$i+nU5LZyP%IrKJSDa*qcK0Gv72cH>BC0n0kY$lPN^24#KyjzeRNCP8rUIZ8wCE)Hd*z@;&SO_V(S5|xE+;!b<3%=2-NxQ&{R>9H@DTS6DO7^O==xkVMkmQtzl<++iRz4&wa2~Hz~J73vrnMl&B7x&MG2XzrccLX`_*p2_)<S<db3atv2`0QEHI5MrAg{<I)-+oON&pudqc3qNc5T7FCWD)BP=JMH#EdN}ATF--M%KsXeb%i1_{K6@Rj~=zILG3B}fzbQ8{(y%Xa=gyEo4nz9ls2%ZE6LKlG2bO~*|-9SoZ-LLdj$UT=x4fLxAO>wN<6=G78epaUi};99IKll8LrR<RN!;6nME^Lo<hSsxlVN8FbQy*xbY398YaUAqv{)<;Td+v&T~rdxs1=I%jKHCWjI1rPtPqMZC!j~y9kT_wl<?&p12OfWlrw-R#+iVl)v}WU<-ImowIE~_|{ikbd^YZdW@F6z0W>)R}B+lcbAqD(zWL7yBQ_n|DJ|+WhO$e;MH5|XG^~H$lH8$Xy*yn|B$NjA71yHSKHpa!|t{NN8pX391*gW<Jva@PrQQh1Yo0QfNvJQ^Q-G|ET-3({cgm+)oDo7vRJGB>z5NxTh&i7A>9cP7j;+)8E$4p^%A32jP&^s3(B3mrA%sb)m1ufdX%#xoV~T<haSHU0X6tcc7*2a4T9*z>h>aq^UH;65D)~gQui&Rn)$Z#+|^JL^&M?^7Ha(3MmABSH~JrFL%S4oT%CG-@!xqT!kLYlvaE0E_sroh;lE^~T7`RTay71@!j$mPsn0ei?}SO%pXV(>UCerY+9ozsJ@nl{1?WTmXXQ|6P%%Uwlqs+i9x%Ps<^(;wD$hPL0wt8&svE7Yf=Fd@k*%=UOH0aw39g*(fpheg5}^dcJW(<sP*aJOTl(1O>{h~Kz2{ZCXzp?5iC~ZV+ax=~?(tFr$KG)y_)FJ6vthxpet4dRW?uT_O##QaY_B(k#$vq%CO}mcfCrGNXH5PMy`r3w)QNLA339Ezw_I_%XlYafPs92mCT!C%+i68sNfrBJ@{GS4%SW;7q9%^e0+?!}Lq-dTE|*Hodj>-0Y4dohjWNI6N*V!t&RgG0)3G$52h4`(qiu0_jBQ$kmlavvQQ*5rNkAk~_~HzJDpAkkK_|9{aTgy~pX8JB!gFm{N7EwY0y=FK*t@q_kIewmG?3q(5k@wffVG~z!?UwUaF>G#<aeE9y1b6nLi$UPf#a>4?C~HKrd1Cz2d0n9UD?@g$i;g*P0MF^@n=$eg)*ziARy+=VNO8ks$rV!?r$@lno2TlA<2^M148JyV9!~1$B)wdpyQy#O^YqTiY|gQXtVqmR~yteY9$OWgl)m4PVxM}=@Basox)a}_w>J#O7}ufTUGfJ61Njk8UCBvr1h#yd$2=E3(0#dBY#vA=L`2W><dpCAN=wALSeITG*t8jjiT-QE-7K`n0LKN*1heUX0<+OjSOW(UC9yfG`3N;ofp!b_^}Ppgz33vmF0FUF_AP$WeeKGjebY}`k&#tH<k@5j696&#6$XPquxy>kXgUEa*tfA=F9I+prUCeFp1d}yQw<PG5~Il6d}}w#6heN8#za`^<OMEO=hk591!K_^foapC2Alwz2R*A3N0~{vXh>Www^^p*-#`0-J?b$f!qo36h{g}Y&5JJHvQwqJS0!2o>=_K0>8;}{itYJW((vq?5X!21g>4FaDDsKW&<3bJ1_|&Db)dogtq6w#XUIUx-BaoU|+q`FTz8NqmY3+_;BVm<}#4ZjEuyc!*VFiMZwBD%q)V6l}`}h9(XNZiY(~VmX+2cvk1@=pPP2r^VQF(VaC-xYv+xh$ZINE(W)q9Q54vcPQX%696hQ=YKwMt+!K4D=Xw1IGdC;Mp)6GEq8m2JS<pk%HUme&W--VrA{XPUcHuYkE6TzaJbFB9@j}oF=5U}GnvVBt%8n+$q4xC)y|##2@;aHpTDi5cIB45PLA`ic0*t+iGHSou9KpS>W6Sxb#q`-_tkISg{V}zAGsQd1JvtaYry|^(z0Snlk_2%Ie5cD_WtP4Wk-u+I`pCR6!}H3%K$-I-anDo3mcaa{BF*09|K?_=uTw1~h_E=xG4}g<JZ+Gvlkd&G5DIgY`TbKJmYW?_9FmZ4$=Sd<n3EISW3w|!CuN804?KA-y+|dh#1+7D<`klzLVqdz_w5vSKDv)6`~e)c<pQB?7gMVOEbswD-!iP*E)!YQ8XdStwwTLLl#_!ZuP&{lrC1vAXSogE+)BVw=N&DZ-_%r6(t|b}#hB{QfLLoU`E4twRb|NtDXxNHSYCvs?Ghxysh$EtPB!XfCZ!)24VoogoJ=zp{!phVc*s7O&*IFF^Bq=gy)&vWm<%na^mrmrBv{;C>k`~TNM$w5rLB%K2|Yc4Kwr<-tcmDs{i^LF9b^b`54HedLUkxcsV7@=lO<Mi!}PF5Myu`sHMpj`8T3#bzg82qk8a5&Lrk&kd7zp-@&l{-fuBXH4xIa^y*Ho!(Xu^c;ggRPo%4M`w1y_Ded}&yD&AG5BK_AX#n39wqh$J1Pqhiu`dSioa(CkPA9;xe{%sO*w9+QBtG0?45Pd5G5bi~d;8b7=TQl3$o&IA$pg4b=v~Rv|HBIEmA$h&)$<}*ts*Dg*9XDSctTjZ@Xd(hOnK>x67=jo{Z^l{74i78cXQ8SCS_L#ex2=wlJ?`st&16h#k>tE57cs0hdkE#ZEtVdF-{vSmpoW<fWst)mXHeotpL^NuK-C2#ZTyiL|A{?`eM~YuNz-ekVN{77Fo!?t_N2d37cT^k2ONBE-f^T?HA_?->r*I8on)h{0`dOGH@N}J^t;~z$%x{%cX19|v8vQIf3`3sck>vS2xL0FK<42J(ol1jPQ=#AUwF2A0z(&%9%X^t#3l-tUY45iW@5(Fq+{@U!`Yrj++uTlE@HF=7K)C#M9z&omKq5PgX}K|cSN7W>OSx23y$>s^AW{G&oJU+_fFPSVWIr-76CTnAdZW-CRA#EacRAB+5;ZL$>MPzSw^)egYgdus#iwKMEf}SI)*7{+^-`_eta`83Gs7U%F)4Oc|hi>EY|{j@Xayw_1(>zVpGd)Yc>uehpYKR*PNTok{b$R6)C(lWuS2GcpAUEd+j*F@rVE3hqTgk{grOASc(NOt=L{;(gE+cGbFT*yA49!f(1&5zHZ}#n<2kbBTqJ!Qed)Ww3f`X+i3CsWLdTGunI;j_4u$fB6SQs77Zw1(AL~-hv}dIl*5DIWJRB|Vvi<QTz2(fC_M;|VKa5trd_gCnaAQX=Ck@(201dNG|c88<qm-&V|sYictB;I6r04XwQLdkqC+_P8=;6YS*1+qU|-t%3q#^`xI`|D&Rc4XBXs_IwECSa21yA3;fnhT)8MK$<C{P;Rs^khs#y5ma3b0AD4YLWM6pOi$34vDANVS?SZ)K;tD1a9U~U-b%G|`1|Ct=|(m{V^Lla6&2J1V<Pr27X;pAz;)n_S8C{R>Y?Jw^v%T&DoIfhPnG=!9nLsB*cApf!GQHL3YezjNaw>H%M&Y??|rDGTGz78Tt5_4U2ptXKBW2=XId3+UVUNDO&Rp+*Vqvz1E3kHf}i!*G)n(Y^BVj6plq2U|BJCLl^(4&Ig3hceY$61o%aE90Xt2Jz2%AcQkRCVlY_IrY7HSt7C_@#De?Z!OO$_R`WN%O5chCJ=7t?#03;$f6>!W5K>?7<+bxgHJ~iJp83R+V~F{UTSauFmq3|4NBb7_wp1iY_U@J%oQjlW#w}YLZ?BR2B!uS{9~_40=M6QHel0w*4d<oT4WlSz6@A^@d2WxEnn!8$?%v=ask&1QYjw(O8ZkD^t0e`d{uR0y4@1$zm5Fs8v8#J2ibhvqamb4{Kag_aiW-PFS?<8;nNX`_pq#@u&zy$}O*~@Swp5_TjNy0mF~FVrE%3v?<phs_1>d8CphZ0>9uz>gaK2UC(01<u<l;iL9KmAw^pig70m$kWS36K~s7$cG7i_G-K)PDeRLH0wo#hiF%akgk^U70DtfGI9YqdNF9ZCF6c~k*z|7vcT5<qwYLx+I{$saYFP?YzH~%4@#kzS(|Gv;Z})_b@CJad2jY1_s!rYz8X*RmTU7=YKoJQsl7ZBxH>Z86ogbkEgEAj2$j<en)qTLz`lmH`orwPJi;}Z^Ur6(ublUj~VA3>2M@{FgMB;m7;$Z_!ywi7T2iQ2yN-&iFbr|;z=g+V86UU0)pRcNj({FTafTr-L30YVvg?u)09%?=^f64xcjRfe8@5>rdiVnq3R&23MUNipQXK(Jl4aFZ|D^Y3cm*R$+ko!3!g{1KZfGov+seL%w+DYPTZ*#Qs0@zMN)I%F6O*{9rzS;G&qS1$K(VRm<fBuGz_jfZD6a4|EN!5Dc1@qGx0!g2Ip1(OY;luhn-@qe#BO+U7yw3Rqh9zZx{>Q#HAQ(Y)yzaOJ%{kQ3u&-9}3eQ#_oWna%NOpeHrRo`rQVnI&&ZshBCMa7M<;Qw*Cw6_m5V)jWJZcvntd3-=pFa%GYF6h|KgjpBrD*#I6RZJpijTNt`#LQ9X>@G~!Jn~It@QSKm;J>18N>D0UV=H<5)H5c{VC`*XP&1Lnslgz`|*3u4zFDp+=5?Qwly5d37|<}XH4&dkL2(zbf@ucX@^_9?agASJ&e&g)t`1q`O2H%-ylx7TmAt7$@FrkUFF+o%<sC68bybV-XpdcgTfs$ZPBM8nXY%ZvfOMda7VGpX68drg@ue=ceNiXs39&B3{;V<d>Kei*q8(?;n1IF0Hp_!g6q?+(LtdHPfbrjkkfYcYG~}z7&sLv0>a%UCUPA?)+iHkIvHr9xFD;zCF~vAhu~W6kf5BY5*!f;M=H<O<^(;;+FJ<jV!q&=XZ;*?`N|~KBi!goK+fdA{BGyexYQsNWEn@+oC9{w-F}L+f8)WZ#}cZ41!kxSgdxdD(RR8a40DSgmP=PiRQJ`AR1~ULnk=D--ihyd5{cFc0GA7gmgTtQnHssPbs!F(I0Ph{D8K8)rj>ZG!(;sFDsxDV`K_nxLZe}N&m04WMIQdXRIM^`ElFJEn6Bb516&u=jjTEB%=cMOBhjthP*XrC$Ek1?o(gl%{ow_b2*amDq5-qBmoxG8VBJ&8OIQmOmvsq6&h3PjCgdh(+pc*e7BJ^taiFV}5cTac2y=R)SK2w`*`>q#Lcy!|hSJpsVcPm6v0z|tZ0*_Gg@CKxP}RwFz!tX3n)X@n$-ul!srdc!>9&otb{>+TTwx4%R)n8ysUk`hIH61M+Zvh(+<1v65KD~WH!Dwbs%#Yaah<sD*M3_T(gR)R+I`~Z;ip-B`0=vHk`}Scwm3D`yM3}ONBL!@c#6Pspt|Bs%E+&p&U(fDU^e!%m;n<!>#|0|OKnp=N@*}DycD886@9rh2BE3-BkzWzsF`KpM<_A7>T`PTNfnPgG%vR0(HUwlQ&xu$990J0FK6&Yuwz;wJ0Mz+8g0^NZUC&x8LD5Hx?0d%fftYs*&2`K18BNp+D!$q6yj=GW?M?gnY-kCFxE-YrAsBrenS8)W=kf0^N+6#`%qGg%Xm`|rZu{WU`*>{ie0I;?dmufCTIVS-9Qx&Zkqo}r59w$3?!8JUr*g|M4R7UY_eXy7h7RL5Yhx!DLJXi2y)0(mR$YR;b_?jp(HeKiz7YY!AJyD8i!9WRPQ{A_HE}CLlHp=vmpX&8!g$d8W;4R-ZM|<!_wmV&dhqis0f6O6LnS5y=0<3e2b@r&6$1KYy_ade}|<IC-3Hl8@rXA){v1GB!-JU`YP0RZ5jp%Im<zTG!^g`zozm*HRsVt3X;k|DU&kTT0;>al-OOK)+6*v`!0SlBWDtK=X?ls-lccfpf;J*<Hf)zZZ4|2DYtklZlLx$pS?>T>=(lq)6Zyu`9zkW(ulHYu6k7>^BIG|d%ANfP>#^dQ1hFbyb1OA;;)Ad@$aNZIZib>o4ciGj1J_jNak2~=s{X~Z%a<?6q}-G5hYzy`9oj7sW~U2)JgnDbT^I^M3@t5-p?VIVcc+SOWl?&tW({s{T8f=rQ0ixA_2u(y?m(C;p^iSpC!O`c3qz6`mD$pR8_Wu=$;O6{o$c@Rub@+Gj%QX#t(pEIb+78QP$}apI?p@9)qW+f9gbbiXhI$S`N}l?*S;RQzT^V>o_r54@AbFWZ+)mk=?Ydd}Jm7ODRHIHQ#B!H9!jJi}xBXNi{vQ4HREFPlwB{zl&aysQ;&*Sfb>D4l!G=0sfQQm9S39+WI5rLg^OGrh&7GU@KU_dSxr*kgFeLl>n_0nrMy$eWZ;$GJIZ<F!en==)<{$U=N5IX4nJ4Rl0y|b=11HUG_)IZmB=es5hdtW7eJo#&{CE==aiKZWVf82Ir%bCGDyTcF{|sa{1j6_n~^0O7}hSXH)-L7pUumXK>-f6C=Yi!=?u(o=Ta!T$w+!;N-`C%}9P0XXiOIA$8u~2TfWfO@nboOD+hrqyaBld_rQrJ%Fn=y{TZ&uLpT<;LvWP@%{bM_$%SITJpAI3>EWOvu;kfKMsV+UK_}_8T&`)E?VuM+BE&Vk%PS3h=X<hzW6V7bLsN%n4@w##v?#g00zp7(*KU1s9*vdu}*~(T!C}6h5|wpJ%I8^*|_1&h#Zkuc0*%&dj-QG&9XkLlj{b_H^0GiG-9U|kAXXhDHXPTjM_Ned9TGB$meGT9&lg{cPP-~bS9GpPFAY=_+)~l!Qc?vDHH>!2)CPy{U+`-05#4XUYg2{KyuEHj>|7AJ{7Q1s_@PJ>(pPc`B>!J`MT?*Q1!!K)kym{meLrKl@HBB`<j{kP&tAi%_qH#mepw-ybOU>w*gNrW)Qup8vXf2ZigzIh;S)?06ry-m#z(y0sU6BxmD{N%)tY(&uL2|Ru6<5%6b!0=qzcB%K$~>oK7^>qHh2=t`TqK%RItCR8SfdM1*uw8+u11K|hx%#*+3k96IzAn7Ra`tg2xw991$&(XZvD6Mr@lD7X-WG78)OobkYYg()j8F0_0AK#LIDmVw@&=VJ}W$N4<HPP3y0P#HR>#rGg#kPX@g8wojP<`G{Btn@)Hj?{?)N^mCpOY|c5OHXS3n<jyp|CLX4+^|23Cp1^Ee#KRg+~DT6g%4yZtNPch({uiA)+^6l!+imw;wW@>@R;sq@S0#v(qAU)#AK`pV8N%fl(9Il6fb@?zaJsJEi^WotWV$DXta(S^pi&i%+gjCmfAp&Id>sjm&ni3=$?TiruH2FJ>U(FxFJ}UNZ33qXz-`k&{zY-&vcru3c-Qa6;WON-&#2>wkSsr)fj6y2&#;?ZuN_sZ+#aeKzu!bhROM`+1_aFMWYd$#4@OxCh}{%gWEySi7JK2*#RN<0Ytf6B&}HWj69@GyEmZr>h%kgUAXby*z!k+T3-Gj$PZU@dL$Iod&W=9x5k<&M=*=q0{2_=W6m*%U>bEv$1H*9Jys1!1)j2`pjmtK_DZUk{b37@VToVT-!nR(?ZlZ<syLlso^49hgaHWN7-m_9({n|?s4O0*FqG#kpe&qYqaCqx*9S}tpLAF}nq_)9_o~(V{R$VE92NwP{6kGsPy-E5EBP1`yVdV)vxEJMV>uluJH=T<xg(%F2x%~*E*~|iDoTExz@UPLNm~7KDJ7S+5YQyV1RgFx91MMQloyN3*%)tZvCdW&I!Irv!YBSXA3u!Y;X9mPSQ4Dmj!Zyp)$7^n`q0hq!wr=lSA2Wx)r;*A$<7IU0L5bH3{X#Aj4kB{o_pwaANa@DO?coXuW>die|Kq`BSVS)hOf6cjtJ5lom9pJG!!u+_h^>#mUiExiTnBl@K~w!s?4Xp&&$nEiu(HcJUX1_V8Br_OaVhwElj(Zbkn3DjCK7b1Ejh+$R}+MEE1X}w@MpaiNiz6DQuKvO?XI+WJmupGtPVgBZ>oF4S5HxXMa+Xbz3!fb-MZ*mAfuZ1KVrd*nQNj3eC5QmOf{HRH5_m+RCM;1XUr3m4G70UA|V;!le(0?dU(ih+-c<ZB7LmcFiugI1P3%jS~uk^$o+W&lvHtL};cqov+PrC2@=cA$Gw}4mk2S-2>Uj)D(iF5^G3WAGXZ0FTJtwvr{|T82rq2e)!M8QuvMhk0zl+n{MeFfFmdY^$0yayQ#ZM@c=$&P6Vfc6F4asPkZGiHT;<6sBx~b*1?^8ToRi&4Wzif)#)<<!n;p!ixo*b2uwXe1CEBQl59Q2g`bpTK_pF-VdTwUz+J#6s4F%wrmwSPkryiuMPGp;m>LqHlQZ6vIBada`>4Y4sI~)%dZ9!Bs8h=0wg>ZZDS5hms`yQMzTRQpOL)*tH12dgcBK?`!$+;}#9s+|KET|>;1p`@8E#c%7uSH6R@cN`MN#}h>3PKrnbKp6w6599<nSx4@_$_In%z#03vR@fT{=Yt=()~eXBx@v3i{sGea9%r=T9R7Ph%&V@gJnK|MUV09V-*Hqu<bMx*(Gpmnv%Y%#`AZI7B9E=6NsY<5Jg$8cx+;M>d4Jb$Wnnt6JKtH97RHa>ORs8swhhT@{<!S|w=PMGBt5JWPLJQk^UEI+b~xewV{^`^oSG6$5K&Rvyp9pikTod|*o4JY0on?_BXTDpiqaq~Z;h7D7E7FD<YQxc(EDc*HRAMjIm=IeibGCuR_<a<mA8x95OlTX=$P5U-1qJ#vv^FU&XBsi6cKA#hX=ybfNMNrHeno#L9yFj^S*C-LHVh>#?|cVAE3k66?z;$4UCAElWa?;x%VH!ip}lnR#wOAiDWsoU7pcg;1k+1=sl>B%r#D-Q9>Q9?6mjNu*QJEAIX#{ovj3&cA$)F+|)1%@n~Er)U&76@&orc>>)S0@49U3c{rZPqi4k+MOopr3Cv10Y(uxq|SD2SY?qA|_#C&%rwCINLKaBVwdt9tyebpox)CqIE-8?x>IkhJ^))L+Nl$>oc`CbHd=4CzhM7x7y)_zYpDfJl_)GiezsT1@awCK>7xULj?3A4k4v~3<jp#bIce=D2|p%1i9B7mUe-WmGicpE0QSBbNNySyZTNg9V2##(M%+0*hmBp1tnkM&Ri-oke8Xe2?%}8TDWOggV6gg#;JJK!p2_BoN&D-zvpI+c0tZ4z_xeuuhtpOnelI~3H(}|*c?URrGgv`RZ}Y!w3b|!^g8HawZ<>&|B%aj!jge52;vowgq-b@Ky-_Ce8b+g^|;n`v_xpaJ)2RQ_zd+H$}$IE3}LQo7*3dwZcujdooJS6s(*ET5u_W;I67a<=U$AL=iqI_*D9Z#8Y=fo;+-~=il1agA2O2*G`&Eqasd5@W69F2SHQ!y-4yU%WgkkA8gH9U;sDqhu)nqiwWMNq#K5ItIqsiq7H8#(coOAUge7}?^pUC0mwUkwc#yIkMaM3E8rh85&#&Xo5q|8W&$P6AVg$olE25rz%uH1ls;|-D6e~;V=p;rfV|9d}Qa=y-zs)Lq<F(1(#7Eqv0*vB-eG6M8DO_F}@r5q$n_C_X9f**Pc-S=T6wOkvmAAYuaFnxt>SB)$Tn@HQdZRx2sOnlY?Bnl>c4NX9w<rtBQE0O57CK6Bh{Q$4MDJXn11uetTDT(3jj@3n$5Fl5ptqZpQVOe}N3Lh!bwJgh6xvh?$~E103#w()OoV;0amJ4}V=2w!J_PJUug)rn{!U?xZ794d1MG-)pYlqQK^_7hIW<v$b*uU@7e<?@`L4nKv6PTfh`Q`m!}O@p%T@htXK3of6Ac#XLWF#*cZR_4H*V##iSuCxT&cZL$91LWH>#c-q0Nm`bN4}1z9ATZ<5kz=JZl@$={iq5%U}XexYf+1dY9C*XoDMU##RiYAy@TUM7Fk(e?6;m?q{@bUDHu0P~tsG1MfwnU`{hw!^-f}nX>aOBw{#Lq!c;LPt)wCc-e3fdS`A<iZ1^1@AxT_bq#29qPW?(Ho61B4~9`L)Kv)s9b{7E>|=TKTGh$R%YYFXnL-&-<?1x;Lsbr?%Nwt`!5s^;P~rX(`Ad)DXr48X5i<6V6rIwsg4+H3qfU(8CF(q5I|?nRtduI#Y;LVE`D`gij>mEwz(V&q-Has!=jr;cT`kjV8I7=mtz&TBWt7p$ttdi++-DYah5`Y}<b>OAw&(iA@9RE8od{hJCY!M`Evg-@QT^d|48q^7N_JT|C0zepp*USwI6?~e4B?*pZuESq$8o>FUyL{zB6qdt+3vL;7`!rd@|tf_x!agTqbN$(7%*nrYyL=OL`9CamAyN!T{j`mtJ;$;X8n-3lRRXETsqUteB!s;uq{0SkeYW_RR0uke{TnLhn~y|B0W52CjaiSvey2t^l%9lwzN`Gk#RDblram%Vca@&qTlg07t>|dn#PM(Eh*OjmY*J#o41oloTQ>J3BnRS^11q{tm&%9e}ZXjf`aAO>&nM^=<}9v45Ak#WXnp9SYZUT_Uy*(A+A^_WwTnIeFz6-6Fyk^ZvaL`fWpBFYt}Lbd%g5i_-y6A=l=7-u@2s2uxgVA=D3%W|I-9>7vU#@-#aP8_dkOioL~Q1UXV0iSDQjup@K|?nUM+@G>5A0=xq-&Pz9eQ9F*A7nq;?nr>eGXl;Z-TTeZn2z2GB}&j7RQlbGV9m#njDK$82Xb~fv_bu>AIS$AxV9fcY5g09r7I9aGhnY&Xphv1rY=3uTl{7gFKz)tDoU6@R}QxY@cEr05v(s6m2y%`0UIB7Wkvt-Zm99er|nJ8UMufmN5@4A?JyW`M$o-9NnP_+>_QYal!-X?n~%#|uf@MM`0o-y*i%8UI!dSiUd@QyDI-^D8I<_kh-lDR?C%e|9|Kpl<31kOy)dd!cfqh@L`=_C-<(Lw8d78Smy=Ol5Ro8jyMn3L?${vMlb+2ySu7!1m&5d`)~oh@m%yQGprvduR7$h=QW$`XOqlt&>eJgYa1gx!m!Mq;8~o!@%AE^MuEv_byapJt)gFyZ{+njg9mwp)H#$ch9vpBy6&^}?Aqwl4{g4&w%cQej@@!H0*UUD-5*Z2quYHO2xP1>mH{m>*(5xhN|M+yZ&;OEx$61CFD{=oY5i3_jznpo>Hy)}0uRD<MPxT)0bNoP@jJy+*~HLc4{fm9*H|*6hst<43HYD}1~U*F1J0bMA5heUJcV9O({*ODlj}UPngof<f^;#+sSnCyupSZeIO+HEj}M=t@ogoJy{wPm_`E2~ss`rLu!<?e<SPs4~B$zrd=Kb1fjCy9U*~bp$bDnlA7gGma1C0y`>1K>2F0EQ|DOnRBENRE!;KAibQ1t*{jx;kA<k_w~MyvF3W%I${lyKhW!!MfnLd8gJr`(fL-TElt~?wVtSi42RT>vB8@x$bIT`pbV@DPUiaKxBOI>U|Oi+NVBD;-G-7KjxaB3j5+PFIBPI$16)+3N&I&cRO0cUb~8njrQB_d$=Q90w=YG49WM(!fwoHbM}{25+|$wQ>4ves<kJ`I3zuM0sUl+AyNh)M4+1BKaI8cp^w-r!S0%?AU>qa8g&6a?|9INT)OfO<1XRkE9hm?*M6J{%xcQxwrWL)=A9T54QY(5DS<H_u`#!SvgdgxgWxV7%71kzFYr8#!MV!uW&9T9z^(k`GR|TucpUO_!bKdiORAY3q!ugJ^Y++M}LB<}oA3Mia%!^<9ucy~TAceI7QPVh^h%<uTBGrc%tD=aI6+Ey5xP^tL-MO=cBJnX?5;PTA<CH!4IR=Er;I)L?QVbu6Z_Sns+;EYwuqsi9=Mf$Z!lh(k&+Lbl7xppd#g6siT}=BPk07K{JeTSIBm$|f+D2^7#aNtyc>iRdFw6_PNs2-`niOGlrA30l4lR^ey>4P!ISH_4>KO(sb;4M+BKtcL5{;-I#p8O5?Z8ZJC}XQ{wUOPL3kqI*1I8dcs@v(!7S&&VXJXpdOI4Cl!>(XCZ`b|g6H*IO7X`H5c`O*~p5e)ME-o{&%o>_Z<`w?%(LD!0!VQVVI|H?T^`s#Jiz6(-%vrdXWD+vCUlJloQq%6k`o@tg6PXnioruqsQ1pUIs=I_zm_$@l<RqI5$va%MXh3O$+pKpPtFmzc_Z@5Aea#&dEsm&L1l~r;&Eht>E@(zysbey^wgNXXZiJ6`JTYVE?IACqlW!!;wo-LT%@8+40ID>2nTweBZ-jHdY|m@)=~+x5Ed#Ww%DG9dSDRMRp5wvxnbN36M(dm~KP{sMJ?L4z?c}<)W;V%spwUdFO@yaEd+-<=*G0%?6^;T5&C{}0Pfw&gcm)dZtFCqd^mL)lhiw(G;(RToL9IBosEMr=o%@@YOvm7m19Jw`u`+<FwRw#&HfvUm1$0qqR?Sx~-NO9KLGX?$nwqryt1QdcB?v&4GU%<djPS$kc@p~r&7G*rJU@y2<~<(Vyi|v7+X1x<XqdhuT=}>V^9L_`L?4$|ZIqiaXB3}Hf^LVt_2equ?*LfAp|p&sRN&cpCjxuJsL=GO)rw{q)4DYWmcY@J(8+F}Lv48`!it|wwo?`&S)cr`Bx$_%`=UorO)4oteLwy?O(OB&KXl|0z&4}|J1<!}VJxpIg0O161_#=q9EsHCq-;DwExV2uMmX-(Vh4J)-h7F_GTK0xh<!@aV#~&r$T4imH%!9&_cvxZ5WpIJtVfS8mzDh64fSmGi{szNgMQPe{&_?33-4id&S$cEt91hjoo~0<_vcLMt&}7f_D@EDZSMCVnVmJ9a>(T^kWMseb#>bpub@j%DfRHIW$Y+S`uBrQH&A1lp)pcF<|GQ)>|@Cu?w<p`r*c$@gMB<ff`~`Nx`}#QV8rVh){Qyf&C^*VqVyD@2<0JEj|s2ufp<9Z`&;tm$=<&beeZq_jD-Sl`unK#iX4)_%)pu`>YlIICDZRnlauLK%snh6F_jQ4{-w?`_+!;_0%EYoiljRQpuld??3K=JywLW|#ar-fFbS?47`=^bkS3f9gr<E~`2V=bG;8P9doEmQy)5uC7pA1k*AXtGe!A&O?y;~l&lzb3ZhtQ}HZ#O&Ep>BG`%!e+??T)<!{V!`r7#&=K}R1Y@aRv)jFWoN`fxiQQ4v>SxGv`vmBh>o$ElRm96HR5E~XFZL$G_l*>a=NQ!j<5eL7-}!&qy$k3dI$@xtyuNOY~aj8!q7&33>ET~~@fh}}iBGfX8sgPCUG3_g%{{orAmn~VV>fqGhLcDwa@gJ~2b0_{LAS>QamBE4X_!wl5NvJ!ThL88ZPDZ_;josqLdks&_4NZ8}}a8G91_LEPviO5`FF1;z?v|UhjOUXu9Qq(S8Rvt8K%Pz!b<ZUYob1{TnA8jVM;wx@UK={lMJ#fnk#O~!bo1BSfeoT*Pw@FLqwI~+dg`G155hf>q#ZWS|)WtiupE!;EiEh_YJ)_UaZcLy$6zFJ<pJ^ukwPv0*a<KR{v$jI(Br4=#^U4SmrHR*{_cc%#*MMH-$95~KiP_!)J<vuS>r0dB5WlGO7H;}Kv4O7vED%jPf8fk5q%aD<0d!HXlVAg5eR5h*wx3dHPcjt^aBigMS*^oH^eJxldy<Ol&sH1pC3q;xEE1sV)Aznnndqa1dImwT1Nm<Zr{8=Zju4*U2-WZlSGur7i>}CMq_8O`V8zp(hRooD!;Xe4#1e7J?Sx(|u|s5F{R4Zf;iy$2osq@I;4&2N|3H5hQuZqLS|W6Q+b7N-g=WpN+<dBmfn<M~<ZLKfcw@tors@(y(*IsoL^2=ceMsZboN(3?3t@HaOss_Zu)xhKG;9pBG_WGBj10cUJycUI(l#q=`mF=upSkd)^$V$<E7Id5%EUXhEKOSWJe{pAd?X%qh4z!4QdJ*S@7ELM*J~w$!yZJU{P)e~>+)QWH`c=0zQnq&2Pvxre##MuCZ&K%NsazOAN@bc=s1D1+aRoMVQNZr4h(#KQxL38Bo0`cW016;Mso<Kf~GL3+q*pw0TI{Y<jO3&FBP6t0Ne9vSyD@<CeduAqbCE9C*h281(gAEQQ~0wOy9#}iQM2SDNz=|@YNE>Hg3NOF5RPn3J=91U(Ih{+$Lr9xa=D3Q**5Cz<vk<p(4dX=%#tfFWfMi&2#`gd&QX+ua=ZIfm@cQiO1SJA&L%-z`WmrAFz^<Hr{8Cdvz?r26h`~8J%?@ZBEs?etTbnY)fG7?*{tDbnBRNSd@IZckR!dwQ!YuNo91Wza?bWOt+`Fu{jExP=5rKsb=07QaxX(!jjBs51i;p<J?MZzOfvFmq^-FUQW_jH^g*Rlq}EZ(~<56oDLdM``J86-5!$S72g5Bsw`Ymxu*c+DuI4=2XB>f3Dp*@y63M=MdZ8%StClc<6J?tpj!JpR|gP)yWbrwhB_I1XWDmhU{wV+)Qo#?Ke<*y?#8Q$EcxQwwYDy*kut4+tyE20y?xEH7~?OE8h=rV5U%rYPL*rbYu+454XYdI)=BM$g3R-o#n@LY6J27Q3c&zR(FTWI)SzWvGWAPLMm+4C&{Nm~50c8m_TH(6A&{qk*fB@;S30*5UG_uhcERkmneW-UPZ`r3G2z5nU3`@F`T7^MW2xqkVtANkqjzhsg9)YtH0s26&@41pGE(sZ#cD?1LY4#l|92JJIk^q*bZwQ##vmg6U52Eo-W5@}x|*m+4mAmDH!Ee^_6^8;+DT&41WhAa6H7sW*$}y*to(vu0^uf}uQ)_^q5V=9C^6&d2q1AES6dJ|b3*Sn6z?%b{T!>|@{)8-D2RG_CvU(3MH}OZ2lbmXm=QN`O{6j^^-?O{(h>vjDI7-pjm7*0*2_6%o(&&n+bqo-_(<K~)S3A%bv3W2Q;H=h0Dr|}tSF#rFb>N~LzN?vIzKe-=F)MaONjM9tN?QrWtwCwMY4)$Aqyf5QSu!j@*lC+=$aP3rfR<N99McNn}YwA-&_CDvEji$ee$VJq-YSWduNoAczRrEV|Z!e8%50=4!iMK{6x8rh3d&M$j<)>8oP<)L<G3t5<3z6eS&fCjZ~Vo;=W2;7{6{&;}Gos>sM~t%+6@7dtNW3nMb(ag>9eKkGJs!>BVumkXZaFEpn@ifF2ugcY1rH@|C)p2VSPQeSN7RGq0ylFx^1IJ4h+Yp|}<9DX3h^!SjIQ<orM<1lr?{n-<kY2ecwd<es@j|9?Jdvd6x->ka1@ETKJL8ZB7J)lJ6oH3H6zd@W`7ufe^AhAP3ULLVgQIc2SZB@o$3$PvzC*3E2LHI+<$*zgeBbV{FT0_WSWILZena9mlAeo1?i8I}*aDDLI8?Ef;GMda2YvNF3YPV2H2YP6pG)p{wB6)te{u9b<0n)d3qKy13ag^LZO=4T3elh`%IPThZi(zopp<_2?XnzqCX7&mpz1$z=l+3qglV|(Ss1|wW)pQkMk?TqvrJe=wJE?$XJ1uu6>(mq=OYTkxPH<`O#`!o*60@0a4I%Fh(!asq720*vVL<uufsbYE3P9&wH?F;VW&07!D^x~i70`il8bm04<tmuyeX%iYxif_T}L#>WF>`iH(X%J+)C118Ai;&8ZWqDC$b#$i72h}D)U;9rhPg-DM<Jzk+wa@`Ee=5lj5~xE<O#)pX*ySFx9ywd}tJpl_^n_u&GhXsQgl<BiN9Mlbe^W8qQ<SVwXq-`0vn!TfpN2`^2nFz(M+fsY^KH|U0pwt(EjyMTfm6fb<fnp%2@8)YOac*C%MBjMx$wJNVh0{%J0GTmJTeHLB&B*cVqF({$`n^Pq%|7SaS8Zs{$mTb`vg&D-kg=THn{%AQf2m5LIkOV-rSY2>9vrKtQLy#)t{WE&=sBR8deNrZ@Ab$SmAZ$@VeoYSqbFu{pK$AU;FE}gdA~`*!_Ck3WM@5MDj*tJ$BnVghoZUUlZ2NK6GX{(06LPwSXE@l_Ba8i7d#fd};`Z2@17{U`?sTP!XiWN6EDWs?2u!X?$k%(LexZ<pI~;&=g|1Se^*68NA<53*P0)R}6WRC3EOv5@>78F4D=ds4_OTe<C8D2`@D!Q=jNZ1T{Ok%sF>ts{x02dX#U2L8is@cdhq-ji!(lNr1vp5J>3}OpX#lrvn(PB4Ft#Q}z^f=^*%_pf;AyAIctkU}3SJZ@=fn0M0L`hzXO3hFsyFekp+8d)~TQn4m1|&4x#<5DcE+<#P{F%e`IN2)Ft)kro2<Ho9TINfT3Odnnz@i4Cg_Uygy3G(Mj~>Eb}D8pl_#ak}>vFbd~YOj@^`q4F|TXg@IU=1mGN>(>g=OfQ0N#y*Y8<Y9hLNz*goQTQPfrP*_VvRYaeacD%$SzxHD+3GJ0AX)uGg(OTOEBtgev_7wJk3xV|@RdYlc7A&3WS>D3$hhG-Koe0n5?zpCKwaMD=^VOBE@nNF)w6vR@RU%LxPyw{?{ZTn5VX%PO*$zcKXpvzZTf-Pb6}N*t52r|?pk^OP_>U?vS+@yn$?z9mRPb0M1aaRhp^JEn^3#38X5F5HluZWOhn?~b}J)KLe1OHHNXLfLp#oYs2YSe2S6-oe!=m$<w2d|LBYys-1hIM?!#r$IcN_WW)2`G_j=6@RWK^tYQT)jKed&P8O4R3_O#v7FbI#9OP-|)W5FFz5+Wa(+fIJts|%b)cB&R8f;~O&=PLS0gnJFDLIpjt+GLSR!r#{tyM}~IE7G!o)6ui+K3SJm;gi>kX<iEV^iPIa=oVQ9oSG#8;Z|tq{y!s_>R}r*sy?{AS(HgCUe4npIRIYc=lHYATO}bQdDa>{a>h_(Hx5ZP<)Jx&LD~A)d%h2<312{lt*RJ(9AuAPSpE7S4e8cPxGo~ybruS19=`jCMIhCKg7F(zwQJoGzuX5olYh3<lD)2r{?jPwvLPl8W!rEIB_(0+wk7sJ*&D_z{G#Bz5S{X4=6f#|aD9?6v>>xTfJLTI$;vyf#U}BE80+ZuC!ElAa5g#IINx>owazlt@`Rt#nL}z=EE&I1`Ey8+gD`;Kk9#;a*hA-Zo`XH)+)Qj5N$W3;TXi%idUff`5Ks$4`C5{j!w&Vnu^B10wcxnw5~j}2C?jwr`QG<w3t-UY#91q`8WolpFb68NT9^N@Sj=m6pRuuhT9BYky$a|_L#dV9E-&>kcZ-M^>|p&*Dhrhi)FH}+jFaKiP0sMG?n<i7@+B#y$1OE(3Xf~LHi@AwJumVT(M;ObGTN<KTIU8VGe?eI@L3_#P(c{xoa<hYjT*mCwC_x_PDZcUBBCA69;PlSuB%7_7&Zz(NlO_o3Serbd}8d9r?OLntd6_0tLAo}et%$wHGH$}t!Q>EBzDxLk0uYaa#0uadbSA=wY3S!A))|Nk}Pt$R`ef(Cw3;i&@K|K<HC(BrUwabvFz(D1x0D`Q_rp%?x(E0QAeq&j3<m%=>e}3DUXpy%Mb@N1Zlsp1bW2si*{MfS>P+cu!*f6yud@-)sdL>wSjGkIeu$odo3J}N?#@2Y&eN!gMDt(zrk)w9;<+w4HZ)6xA^FU!tcuC@fUNhN9Ie@(bmCRJf(=9n29Q`$oKB-YOe}yZ5F~0vA0gbU#svdWSd!KSf@pG@NR%Z6*-=h`XF7W4)#T0H?P`+KpSTLZ0pyxu(XSk*b*dE&4#e9CVQ27i0S2RqW#XoZRP{M0FK)&2>ghzJn3<{Jqh;c=FU?`(PkgkN*(=0;xq5FJ~MMh=f12i56-57)v=R!hl-2d%~*_Oo0M4^$J%G-@9?x)#et}BYkb3IKRocsoi)BGI|2$ZG1A7+rpD0+LHghqY+M$Ksjc#Hb*kFWr)Nno0{m|WO->+eo5XqVW#pIUWz7`821D3H0&{0>#ij5TB?jZeE}W<0ezM#HsPBy9Nu(j4NiM}M;fi?MGAWmxRyH^Sut$hu^G({cBsoVz*Hrk{s)4o4wO5z5YHOW>xTAUnCavk%QR!w3=C^XIg3QN6u;|h-N{s;uJK+j#2}3~i>!8y7^}zOZindL%ScNfm#0gJSwkNF@r0DF+NEOMYEqCH?z1<ZMUUn;N9&(>@=xL!;qp@y2i_hQa4iTU1&WG^xu@6tMLfL2DuF5$XeVx4tE~4sD8wtR2W=Ym)sapv?zhj9|`m2#9wrtK$taRaanLPEKY-&Y{i}bpH(s{<uofeYUOE}-C^2mKnt^|zJ>D0k&*luVShTt#1{=hhP&{!KqFZ%#=ubIr0KV#O^2ti}ss>8h}&T#0F6OubuOIix4k0<>V@|+T$2<UY#ab6ktZ*z*V_D1OK2(<}6>;2p`gte>x2iLJnvo7ap(y^BU8uXwk2@08Lb@Jz7a7=a?_#e%-cJ8Q=A<nD9WMU|?|82+D*3>naCJTee@bal_orB2%Pd=-y^Re*culVzcTKlh^*1h>mLB70flZp!|)p4UJC{{exj0tCKkFN7;Kd1z)+?4D5yR9$t2)yrJcFJvWAxM-wIFOahTS}8S*`~q_s5(N_G-+DEjSp~G!eb5_cviRj$FKbo;842Vp&bAowRNDf;IDs{+4d!lXg2$~{b!Qux}jy|OI3m>j&u9Yj;HdaH&GC;w(e40yOaf80)d;U?`iS_^YFQ|57r|eEbfqq=|Qy9p+=z9r&%>dF;oe((R2boSGttFJX|~cNWVYNOVxqb0NI6ei>0g)is#86@(LY7#fqC$>T7F4A@PXk_7m;8gz1+}qddfX{>n_lcWs~4tt%^TdTUKt5dHy|oxN~R(2KgEzTL^fROzTir1+gsln8+hvAikLPb#MLGU<C-G%dIpL<HY@jg@hIl4X%y0gc(x_(uDtV^)oIyFeqsSu&h;W5HvvzXy1~w<KvLf&HTp10j9!e~U!^RFB+zyxZHVHiPDgurL%}%J`@2d<$6Zz#DCFr+3Ub07^)2h^JS^T<Xu^oWjOhe%S^M@>Gio3H->1Gny5+S;9-lOGQ+iJS;l193#lL2&sb>Uw*mYcTFI{(fGw`$(*F8GlnE)6PH;q`yHhkQP`+6GNM;jdy=z(j0T;ocS~zMtp<K|=m~}_gya-;WHuIlJW|$`obyBoF5|w`7~5{JQlm)aMR)ovL31G=Z-ey`*6MPTjtDuLudYkUNHq>+j0n7VP%(Cy)Bm|`XT((vH=Ut~mH%Obv|$&A1nQZDCHG;{uNn4GpsA<s=ag9jK4+nANQ^X27n|AMaifhUN?eMg2S3Eg8^N(YAe$kyzoBCl=O;jB00AktBR^*gJ`|eV>?#8IAJCT!8MEZ~==wZ%68`B<yJt_(oP*X25D`hjhyNpL1~y9SxIQCUkQ~J}NDhb&ohRYw#{&9FZ@X7`^H$?@ATdcMeJh3a_wvD@N{|y_pkf{t+zezO9iy-ye`)HMDDnI(sLsZ<poVt1$e9p~9m;wZ7sPWX;W>H6`JCv_LN*!1<sW6u_S0MHi(a!)00ew6u#nC%S@SzpDcFl2d}etPgGOLUZA}bI5HA|&t(&f7@*m%E7<?Y0rNG<)&?5wN5T|M?z`skN`Qog?m!5zdtZeR?;C4ECdc}*&TKt?O{mn@NiB5yus!t=?aV#LXs*2d#n6m4yK1Djo0}kqd0gYjZhYV~f{z?57G4ktz2r=4Z?&3RNq3PaFiY9pOk$$CRpUmFRg~*Bw{sU#?NyJ(^Z8DZy(DT0`rM7eh!yBbNZosH8Gu62S%5>BB2ZMxtgj@|&7!G=@d~7nU7B+gks;wXpJ<W<vLg-|a*dAlMQCB~y9VXo5ZnezsOe;mmeo1w$I?+kOt?`=9C;chpTUP%7T`{=>L#9AxO0zL7?RE}$LV?)}lxI14DkNTME{E|oe52;N{g^MT!rAg)TQ+ds{=<CTt#W~eoyD60zaSe`lfzs~d^wES^?V5mv9GarO)lh0&ZZhJ%<vDuVaPP`W0XNqRp1%!v$wu7f>iv<`Gi{RtFVNLdo0kx3N28YV2bd4Wb5Xm1kDIGCIQ1jOo}h3z(42_6@<7!6ql!JStWam{y;=OVL5^yVXtn7@`ao)L88A^lk2S+LCXj0g7bXt)6*JDzEn%iH7+%udqII?57+En);V;j1t_@L;ZEjP+m>o29Nv=7yskCX*-K~*VcptGIBBg$i>qtXcCnLetaGvvO!Gd9R_v%T*XhXzqMHoq<b!JFeAQ=;x6wGu1&NAJkz`{PADu%b*r8#mvRM+?q@5vUUQUqY!5!XCj;|k6;hp2ELTM&-NM6eIcY5p1Vy-7*b<F|#+;cTKdAk=w;3RkvQkcs_tv*TQsGzJjR&VrOgIJ!VpU4@Ee^3POzb?Lr9!kTKts?L0pFK%LNQbei>raqLQqUKc0>IY7_wgO6WuFk(TUngeeP}$9Pmw0q*gPbX@w{3WM%N7N_2jAD@t>MqD$jXbbTqE3V3+@G-_M@G?$@{a$}EcwdT6vJa$>(1mIPA2#Nqlrx6Kxf&cbcvp$mTmdRAQibB6zDr`lG4*j|uxXis+*wB8|gjY7kjlifmqBI(0MV_0B_(n7^JbJ!7H$rhy<P90oFl?(6yfHj;-f9JTYs5wVzzmW?mYA)?ol3&a6G5f&l0n&AX>9NLjz0Y^23c;iSd?ZKhDbRx_>_BOc;4Rd*CyM!%3*?bZi7~DQOkZ}DMZgANDD@>iT{*r2JN*;rSyr$;!<};6*EDYFZg!T*x%mg70SCx?5857~6P@;%9J~{NL1&bi#WN&@3K{J_E=M4vNd#v<ck=f2*L>|6Z#b8Vp~`qbBr-zy>h>Ig?>Z!fP9VHaoNySTK!29zw+#`UVZ$Z()M01p&-UL=^PVDV-y@g^v9LBfmST4orCYTEO}Z0KhJ#Z-^*w^{@~M&%cJ3pJ1Vwnu(1BANL{JvPG-81AC3%(!)>^&5WYd0VzA(n6@%#rXff{Q{=g8mQpm9ao^{hQW2@^bi(-c-U@<|`T!b7nEXRB&u{!_bHb{k{#VZj$KrN{aRUOW2_u9F^+LaZqwl7a6B*>X!hXff|;P1IuS62=|X2O12-WT)@HtWNWxauMLulQ{4b1tYCg;qhnaA_x)8j#TkzTT{zT)so}?Z+naRrw#q|xFB)#EV&F;;zX=5VN)#fAHQcZ@i+t;r_mu{0#FJB3z{%{K&P#)EPO5DV_9yUR6V8x(?rR2_mA=fOkn~^^v@cBa_u516zt;obyH4upoAinB<&3;E(o6L@X_f=g=xzRbVwJH<TN%LJ`cU_P(@f0V?3RsOld|OdQKS@c&0|Y9+NFq!FaIS4eVs%_!TujIwQ(){QDhFnsD*pCAFQ^QlwRM5D%N1SA!iXF#0=pGhk$+6<XT9023}du|S3Uh*z#S-y_D=XV+nphm*~`n#9$G{uv&I=$7+#hcx$jeewd$1KZ4={_KKIsK(wBX;-vb9ANuRS7$uA*@5oi>@$OYn&*aMeGys3Df4IV_c%VH*5bB!Q@YR?a0^{G^Sw*48WLe0>d$VRXSs_Jb!ZHdcFDr+<YIY<xD~GOZ$XD;^5k<_@GSJR;0vNlMc%(=l$<)ra3|AilddK9h|S>{FWbMA8hnFl1mKFxO<_UdB8O&uB$~*<c(7~+QnPHL5jLV$Fb+<GHgcoONiaGxPhDKlWU2s4gywk1_^7o;VXO#1Q@?Y(@z<ntCCrDC9XG^iXvZbGu3hk~&!xl2oVj8TESu~LNoTC4XgX{Yz#Qb4*wFl|3i4PwuvG-A`FW31Q6OI<?^LTv2zhVv8Q}SeSe*`J8zg!re>5ASZO<pEJR~s%njW6JGCfl&E&>Q4dJKG0gJaA8D_TMM`of8y#pwlfKp1$UR2RzWhtaYtBH!zShJsakI{Di$o76u!L}*v&aW+7&KH(F!#ng&n15C;Om%rcD>jXe8Oh)8tQ^w&YPy1FORjbn6bTe`TboGBODmQ?)!`jVN@9PySMq?N=!m5^bniAy=Mf`?xfP|bYKM>iR{B0;FUa|8IUFds7*5EQ0U6Ad_h-!Fn<EzY$<-=tICE$O=dyzNG$gKh$JA{4Xzf*_NvI%;u^d5XP)k(YiD;)BZoQa0ME%P9qwlk(a+0>4#r6oYSwG^PZmEVl`5F|xngNlZ+=vkQ~LcEO@NV1V~)}D9E<HCbd4s&Rb6ObNb6)D%auFr(A{B1PS+WonQ`xSae*GhHIL_HDWKOYxEP0o1^xK7xO05K7=weyu9#!jq(l-JML;tS^d@$<ZZVSSxGK9J-%+4@^pb;Ee4|FP*7f6b`pp8wLO^qVWD%^(hiDaCDRXWTdhS29Mma>7Wi;=P^TfIF}}0JQU+l0cjCO~cO`L}bywlCA_F6N7i4(zy7QYDMkI0!)BU951>xsJhOZf~PY;e;de<`Gt3cFLe!lrr`mR6}Lx`^*!2i3#ot(L%kwi=I{_(uNcDQ3rLIjtJOC@wkIiNKHs(=)3es<c>QxOg;+b$!)BWNpABy>cBn|W#Rj&AE4S*>6Uc+vM_;;pk^&9@Kz>qTz<Z2!R~NWnk!!}0<Wr4fWHk>4rGLy_;UQ25>{7xzo)_tOkj`8^btt1%H&SYS?8H}X_b~em+dj!2w~{pGT>b|~(im{UIm6yk6qqHu8l0NK1!B{82P=0v%CQR8DhJyC5ihq`5QR7aT#P%w-)8uHmxn)FNS_qxBPB`l7cZBQUi%go64Q+8XavzNx;GA_Q;xHcz_CrKsMJ=woLUTIl3PP$Kf8Qqb!&yR0Xa|CsSZ70+>Schr0>WltW=5uE_xCdU&rANNAot>oJZPLo%Ks&s51<u0jXoojr27ppLNwJ)bRm(=W{5K!IiZZC023_G=C3M0f)towbMr{%mz;90^rXXI#GXWB}oPG)~IKD($y>@8!rzDCgAOSM-jQ&A?(YAWbnJ{i`rFQzQ<s^Uz2qA&>oKIkYSpM1b_8ID%pDHTnCthJ7sz3*-_q#AsB)+@TOEOK&-u=k7_F*XkBmb%<(_k-XTs(TcFB^1sDmJe&C!60>1Fjo8gXB=P_Il0hYHVE`{0VAu!JQB)F+(@?8*>4v$BaO7)k83TY}FXD=nM0<$E_65<EYOz0Qdr#jNcE1H%+vYY1qr^$??5(fYJ287;eCV+jlV|k$V9%5At1b)o%cMxfh+vY^<3@hO0QeH3e!0x-#I9yOo;SEfSs+=&6PNe<wO+Y2Nzhyf>FnfgbGx7bhS-rPtOegQz91zG1SV$dGi9|eK%(5NwyGMrVw7&%(t<hHJ4Z*Ki4KN#`McoOXaO{RqWWMeqaGyjd@7l@rC2fq)%hob$dc=N(1!L{Y2P7-DoE0VXExOoAP)N#imICR<DSWi{V)ZLqhsM^n;i%@B<=DNv!YpAU#*_B8%76p^;85Js2FrcycP3#ds%J{O4qL1lDY{sxz7B?DQm*wlWxyo@x|S0R^picZRxs7AJCT|6D=$&nxBuDK1`{}Sf?Pp0nyX3?CWSUC(<DG!v-+|4fHFbCZvdUzuOe8lO%WHfHjI-5eliVxW+-W|1!~C)cw64G0X@;>X6h?wDuq{UtxZmiJ5j8;yBm&p>?&ad89auB&kY%ixhdHCWFSy=b^K({CU<q|GNRab_XIPT$UUfD&cZBd5n^2^{GUsHzQ|;^^f|^gKr0FNt9jDg$Gq(6feS&$V^0RicXds9=Kswij=q!n4Az+QGXJ2MkY88%Z3JVTfPqZ9lHv9v#zl_X(MYt<q@b;``BAkOnLC^ioZtEsnyNo>UGr0RYEbB|Q2$YMYd*dzZDw6ApCRpsF?5vj2=i>BC!{iCf2Fb34J?VvjqG!O3uQ_-?I!G4cCh6|Y`7Xc54vu+Lnr=Qoqz#q|DvSD?p!9L4O0(lgZXVg27%f<qx2mBmwyB3Ywf+WT>hgu=TtKAs_fu4CnQ!zN;d!!8{e`b>0iaG8C6)%BHAIEK$mZN4d4_(wv!Ia=9fzNC3^VH+H;YD<l|YfUI^iZ)uQTh;PW$_VzfjGF_w_ZJYyp%+HUn!^n8dF(^lbA__>UHgo(<YQeZDG`5d(ay^|~AE4mZ-99@$3keaW@11M|KHn%7`pZbBu7_*fF<m?aV-k&!s%f-ou@R{kKVmb2*B}AGE5dHk@5p4urF<>m(_jzPRr`cLezLv^J4i6WEp8=;V2r`P_IFCU|id)F1J{A+MB#v01_?pMM_)Vkjvkv1zg5L?Y8EA`Cob#F{*w5k>buVXxEiK=pf-Ap^zC=NJt+JktwwLcNs~Bz0&0#R`H}z<zg7Zz%$JSbD;tu4v-O&KIQf)m$r2G_A*(@=75rD28qS#4-ACZWN=N_00d*Dc0x{!N(R#rS%#D|C&J~rc2lh*TKJ2*H5dw7<_5O>)dQbL(ShEi2FhE}d5SBU(F^u?0sbvD`67@2dV*LAmyQPul%_9{=Vp8VP&a-~_|Z%^38p2Y*^d{=qHb>*8MiBr}5vQny|fk6C~qCJ4=M3EfZOtqCfOO>;CJVlC!F9O;tvZjEqfA{hhtOo$VqF3}c&L&WM$!ES^vkl}rL@N^&{}Gm1EiKmqVGjjjpzg04ZVsHtrvnKKy=Q4T1zPBCIsK`?4wk=Ly?C2h;Tr&OC*qZ4pL{k1;lmnGU0z|FD8U~MH~=EW-e3-*u*%eO@1u2&U7{Zj`ZuBn4s4%Vtek&)la)#1VA@4<*-*nn?dQs~wp+EV{osVlxIdLCcyV^KBQlZC+FE2V22!Ed&J|Sg6F$5L7;oG;59i!LKLb@1sJK1SLKTf79E%aX{a2k!SfWM#nNlRFT{JOgYplQ@XIRNP9)Lx`EG)xf8drB5l1-nsOc^9(`hH*Mf*XAio+(8R@1lS2z3?oTQ@us8&*^zDVuU2X_qYfdoC+L13C6IeO81iw*)wC?WFW1a7sc)x7<L3f(49m-s6k$jC`Ym^qi#pl@b{t1VaSu|Qr>l;e4r$jZ(@F68{Hfyw`~HmTzfb!HmE?g=-?lQcNUpu3Y(kOtP*vJ-42-S_EAII^(hlat7GQg7ci))C4Z;dyhzxUUS{;c_Wt>yBYhM2QokU<;}O_tO1K)hZ_C>dkeLfRLLP)DLqYh5!}-U~BN(s$172<hf7SzD!w(dL<>y7ssbXcsjcOwlScGHhgxZnIiGlL+pzqzswgUE7E~=-HK|*JP+z8{K&m}&uIX8E%8-*Y^!nEX+|0)FA@DO*_j8MHr{dEsE;LAk(1AvWeAMEhl9Yby_M+e8oBHPTc)y+$Nk`70Gm=D0%WL?hn`-_!n*Jgb*PjF=`F_gEy!Nl=+9p{D$e+jTL<?^Fq-fb6v;Jl8#D}yNeXm1XpgGu5nq45ekCe+6|d?4A1ql>1`_UU@yDE7BPp?&6zQHXR1D(GT4Rut+$ebqkQ!^BaF8ctagvX!EtcO`+}42IMcOFc@Q?QnMJz8)Qt*-~GsNX8y4O^TErIq*%TPD0(ky?b@&`*<geXJ=RH>fUgxE`XBb>l0@?Mgk?U+|a=W=T&3OWz>jUa)~A&ih_%02%}@IkHDK<<ew{sk5WBF$bc4LzA-nZqz&-#jJ|6>WtK-~Zim`qsXlX<7tWkjyD6!<c=@={%EsD)m`sP``}d!8%Qq~zrD7%EBkn$K=*}%fUo!~9*J8L7LyN{S2bbOu!|z}n@qYFz*$C^T42_R}p!%A@YB253RI(mAK>y)Y)K^1V*!ohm;!^U97{|Tpf|1x}D~4Bx5B=J??OUa{D6Ml3fSJ4Da+JIK04Fn6h`b+I4K{_dBJ7$X9hT!B?bfon5FXbxw8g2I@E&<`BP)L7RhpIWcF>6+n4x+91>G+(V;jeY1eWwLe^*{47i@fko%OS>-9T425T$c@Ejmi4h!^Y%h*c&_)>+ll%{BQOW`f^dCCO=ggxIT;(2KsQQsoSRakrPL?#fYK>@MG~rH7N4Wl+eKdt8ke8RNQ!8VG?HS_Z<Ac?Bay0Q$U%ogXo28EYnuhunFL3JUi5%sH?34$OxM=@>m`oh&y|`jx&NV+f3H=&c*5WF5q9ERvOd)@&cjtNV;G)~gGvVTF#Qj>yjrRZ<r-0!+3nS~EdzRqq}NOy?l}*7iuvNeTM&F0{b%!#Ix}dw;vIdmy(?)U1&@cqcqC@6_Kci43S7=<{FHz$NM(Mf#Z}kVOX<|H3>~)w;CmW^1nHG-Bz<84EP`cr+kxX%qMU67;7AGeA$$>EKppk$sSCPo%}kD+rGNWfRYrtTLO)znxbhFR_H5>eS0O<A=o%cCi%sF>}U$J;#pkhZMRJ$N{=k=!mfT-;X?HvsS`7BI`0pzRFV<;Vy7MNTA!m660n{V&1+09Al+9;NnbPIW0V1rZ_e14YSGr(0LsujsR@L_9NUPT#;xXqT>pM!r4@jXs!vfi#D&NF^s|k!-hc_nML>%=w{CTTd;oUGU08NK0q5Y9%?Y+e{FVUiSaxXQC!Uzr)-v#M4uoZK-TUjUTVQa4Czf-h#!E1P?!TRGcg$AIa{u-B8#BzC61|1j!ojSdP8P3yE``d@7yP1H6qRA9%KUgL~D~J;Qs+qF(l8gX54!mLy_;PC{j<yD?h+k^vJl`d1IwqhT664(Ua_S!{<8bUJE<&OQb6mAXZl$^v~bh@l<Bcb<%T;_;d82g;jl99^ISFz_v$EODeNr{%-mZxI5h6c68%6p&EI(e-}E`0fm1UtXnS1=#&T!A*f2%TF!E8<DjYIStfN_QhF78qH?xMvPh-RJ`y?6R*ax$@dK4&MyC-B@B76c?~Qo)M=B-7SS4A_9W@%-=6|(uZrZl|`>W=d!>K^Re_(u3pA<)iM;Bs<SpP*YLRO%=_oX)_h^lk^{{%6Ou9NS6%(HfzA8XIZX+b&a{*Bo)j#;sWL7bNAMuy}v2u{2EPb~7aA!ms-b#ajU>^y^JeLr9aK8&f)Cos^Z#C3YNk@;#kpjm1x)R+3x#z&n-I4h%JJk9i9BB<xKS~Ug$Rbu|cGXWck;Eo~Yru4gN6omt%&(uzNHG-sMw1qzb@G7@#NZ|3+7c7Wq*nqJ4t&8#L>y>mc9Z+Jj0sLT@==fX}Z~z~u7z5hQ0iAo$7Q%HeG%7X8V*;pS$6u`67SGc1UuRXWs{oit;^e!4=l$b88Y(Q^#FbqMn%q`_tf&a*QvcpW(6iaFZ_><Sp+|GB;w0l5ov=aqxqeIw7hj|dhe82axt21M$L$c7-VbE0uFL4DqU|1I{HgL6L|S5LU*C-#tC79g8*)}wAo#U{<sOV#=m<i9KMRspX<c0dtbLES(nRxnrT-4tcpS+nNPr}0n4Yyb!l{B1#F&MQw`wm3`PNAN0hAa;<&%{77B_5m#Te9BJn;es-~-pbyU>|T7~<DCs$aLNzpo$si86H@y7=+yP6-GrHog@!VQv#bl?;dCnAj*!$T28WLMv@`ObT?u0s{1YXO46!kJH_jD&zs3taDTV93E}|V_9Eqs3mrA?Q)T;3HZC}L+;NdZLl6Cq2O>rwI2fXM&{qS`{UC@1Cy|?<u-6UAA0ZpR-s9+a_hUa>pJ2B(qM=~DAa-Y6J~hAFv?E3k=yu{ysOMbqw^u19`_b8*(ry=fc*P4#Bkx}^k(yJ>K0|k8pac{M`Yrz@Ht#_{tDcn@1!6JA2VO;iE%XtcV@m@)BOJ8e=XZ&d_70Ur5hFNa6wQe8OPT{0<q<%-{B$a-2wXn<Ev3+=W1n-dP>CW%SR;YCj5UdN$ZJQs1n$D+#&5%guJJDDnG**P-~7k1f)2pHRn%)3dIqE>b?AukKfpb<XfQQ7fpES#3|YRM38)hE*Ak7j8@%G8M{$)b!G!h9PhBx0toD}V5?hnziEm5atSAG?`=9^zSR5;u?sWJ^<e+c-=gS(<M`C8s4IkaXBoD(3k1PD!38~(XYq<SN?UNSs{8q3I=Qh(Q^t?eUCKqM-%4(~J%g0u<hlDK6)TgFkg~$ubq_q^_E{Z!Y7fu6sY1gW0p5p&)Uftn<FH@{rX8HGdXjI*_33Uq>xTu?Em*1o&h%eFFNC#xI-~I)Urp0w@rw{CRT8G$QW*@=g99W{sD!G7>+0t?=<k_<ED4*(?S3AFwTKZ7Dg(EJsmgEwY)+=Q)KIEVE1_n={~Sp%Ydv(+Nf0T}LB%@_<tc6L;ec5%mC#^IHSr?H1)HagrsU2FRh<RlF(aL>D3sOm`6oNJmWr`XQYAoOC6W`1YGFk|oo2LSWkOz8%>20Crw397V!cl%91vfx&l+WGW$np}-hN6HX8ru&^Rt6%v8$+mXuOb=U<77t^lpZmftnQC&<(U?anw8jfs(E&@jSQ2CFnooqpW)v`YM;o0+a7}tZ)Mj6nw6rFp&nyf$SKWMUnolqZH}zmQG_yZPe~A=z9O(kq)p=b!_+oob>k^H?v1Aq+8EOAO1esX$r=`sIXBAc$f^oK%BY}tgYYX<jnQ~Za7sGGvb5-?kne^IJ?kj-%i8NoQRRmYm}wLeN1u$8H?MeVbA$~j><4sx-Q7V*Uwsf(Wm~|aXYO_*}0HSeLCzo3X=t53|+=$qe@;H*l;+&rH=7jV8>>m@Tljst<VY(WI%`4R=dDA2567oEE`X-N70IB0V8R$u@x_!N~c7fBZ}eh#f+6MzQVAb^DxNG9%krmffjJXS=K8e!We`QWu202G9s8UbFT80S@~vmZPn=j?iU4aGOyg`@^abkm!)TM9PmN;(EpdY#AQq@LyYiyayh!->O=Ukp2YtFugSnsOygR#{9};R0FWGDzb1MFiJ-p3%t?BDvhNe((=KCe*Ia+jj^<bx*uhp#)|BAb&a;ZRg5bim`#I!;nDg3520nqHQs!&3FOdhF*qcq6ekd$@o`8)lX|P@FI=+2WJ${YJp!36qhghAW0z5UTv1OHFZxN*^Fx_rYJRjG){{tgb1~>(DGi>N?{H~ED!}Gx9#}sc>|FvxB62?-LMgN0#Kr=%ro*cHq2_=tvxHg7ikoUPM5}p1xUNMm?qLCgCnlEdIZWX9ym3twl0yb4ri(%6)Uqdo@nRhy@g`1dKs=UpuV!$=MYJ-zIhTQk1d_t|y5{opabF7DEJwKAN5(6g)^FZNgxcYkEV*jVuj!xFaJ-zq}kDJ=}Vwm19t|p_D;6koKM)e?}k?{@n-dgTXf>n&P%cfw6Az50gE}rW~_d(m589okc)M&p=sA%+_vCcAe_al_);og(713C>J@eIN@aM&^I&5Bja$f9I~rEqc#bB&7hbM>BaNtX}jyRymb>&Zv3H<8A|ZxQgAJM^X*8Vs66?0hV3H31JV(cP^0UZD5<&I;fQDj_F;dbE>YiQK4tJD|wg2wyHfa-UMKfwpNzAswu5kEiZbdWtq$C=n<5WpL?(9g6TuM=BoZ__iD3{?UL7ed^JA2e5zX)V$m_&s_)s?ROZcu8N@ckeS(P!X*Z%)w?g~GEkioGNAEOH9s8u?NY<|6#yLPM-qp=9#XNiRqLC>D%MeNiTBCpS02k2LOq+!Jq|(lzemWon%OF{bsH;p%{!N*IEfR6r;}j;@Ch4$MFpSJRCsA&VyKlWd7n|Z&4&`QQeAtT7F5w@hvnH;^o$C1kuNVNF%3$n6cDnu-%bvO*52zguQZQ>50=x^G?bwHMv>dePenfH0|BCS)xV&s%W=rh%eVbL`Clj_x}=^tmGv^(yh&pmO6<sVE|8t+r~P`i!a#q^E8Y8;9?$<MlVuxwOUx14Mlfa;-7`1gk}0w+d{l|+^wEWmqHP<5dpiulnyr>9IbcCI?l4uG(Uh9-M%{jyt}yG-Nw%+Vr4N4a>sRg~Y7hl*nawrR2g`rPV_rs<xs~2v#V0v4uAnqTx6_Ev{b*Uz>hR}*O+u26nCwkl*<IiJ-D!K0!#QKha*yx41>^~MFl6_+-@V2>IgwabR%F`qfRqDWT||CggqGr!{+FY;RUu^*)kF1pBKbuUK5b^aPx)#tI@G&XTpQ=~r)@qnD3{W;qkm~IcM=pbn-2r4`2vE*j<okMoK@>8I^Z#Y-i_GGG27`^^BAh{9YP*(qsujC>S_gSB4CDYt0@okZ}I@y@2YojvB(`(@9yO@R;)AAH)jSU`T)vAg$<CXlqFQBRu*3Fa>VQC|5+5t{H!D-gOc|R3X-vO3;g+-$nVDD5O!cP>7$?T-bCNk2%-guu)NDiJt^C>uC7#lfmguYwExEW-P<YA!HptVw-~ht1UtTPF38M7vRS`E323OkDzAkwQi!=nBmT}wCXTaVAx%`dXKNJ?h^G`5l1UZ7VwN~~Lwi)g;Bt4)Gr!OgjE>%L&RjgSc*OYdI-PJlH62RtFvi&Wh$lN)a;}4bn#D@f{Z&u7il9HJwb=#z;j@2Qceix(9lwrWOkGia*72;6!rm8egLGusY<agnNWM7+*Le#g(rjyDcN{(wlXB0Q*?KZo8EO1Ow4%f5oSkcx+Biai^#wG-F#HYM@33zug$Xk2Ba*uBI|XpLmI6X4RVxrB)%O10`#&r*aPr`)e-H6<wOT7so3jmfT?rA}1i^=9xvS?t1?pHYG#Vc6(9|$#``B3&sO%;ADg>T1?ScV#==CZP&)Ai*lUh@nKyc}#G+H^HaWjDDv00%!wTmIoF~mr%OeX9pGSwmGVYkt5R73PnBm^53LA)I+<^*Xzy?CN+@tpL6%>_M&Vp@}_?np+-ws4^Eg~~gOfUKh(hg#<!FA(6TRpnn*apZ>k`|8C>xf6|h#l2YlQEh^Gj!`nVuu1oIzy8EpmbKafuk#1?DwI@Zg?{qr35aM03oTI&O2TDF74WJh4<^=nGp|^$Mn_md0x372AvhZ+d0&-(2LvmkZeP(=J!xm$n(Qr8^Tg(fcTKR7m!(d5h;<e=>=m%aUwaT}Kw=rW)P|bwTi36D7I&%p@GEZN?Or7~8=tM;B4I&heVE2WT#RGC%v6apcZb#J5Ijl^MUJTxE!(k>DK)|8_H@D{CIeEz8ZL9vWir59nlSUzO<D}TJ8c4ToPB3%5Gmp&gF6%w<K2J@7RwXe`>`+}CL-hF9NZ=q;`Coir>nw+t_|O48F%4KZS{SKT*s;z*U6^zKNs;!`?eVJtw|%J2Q5{sY73~nkLq1sMcz8w+7cWg&x8&rwv(g+SqvE5DqPRSixB3#%Mc~E=6sJFmy%LTF{3UcAvhuF$^(D(-c?5J9F1yPxLCo<rDPoE#azRaZjx`}mxS`R^A`;#!zI&b+%95bjGg9zj&|fYfS`KwqnCp)jj7TD5t>%z@^`^n`u)~E8}n!6MCe6PK+SHz-M_ea7x$$(lem_o01D*qb%bMN`b-J=bwC3j=c^w;>!Xa=so?Z{3pkNeThQl(z9&?LZVgvs6~f_$7yos*efWg*z)+*LT$?V=50{<n>%y`*`u~+n+~#07_X9kqE8lZN8g}(kodi4f$v6Vy&6cXVRb_L}xbWHb66reXeE+f$$XAG2!5v$_=@~jsz|-i56yz^$hWkFfkKxBUaPG}$Hh;Qj#|Q;_`P!j<=Z44Si-HVoCb;MzXiyHz2)pxL96LVtLr+dam4R@nK{1dkfqjMPX+ZCia+TN-E^&#9JNmL$c9tNKZ}5-`%D13T3RB%uBtR#nyvqnstsVXLF$rDDa3MkbDpU8SDu=*hGfTnoCcBnXB_nN}r$STlIh$TTYiDeN(Sut~;*mBcT4~8by~N4X7_0@*Am;o^S1MT@i9vy8P}{Hs(vO^mHwu);tew8%_SV14-Y<{!58Er81|G0Z(*l&x=Ulh2gw`IyFy`?&O}yIRLGv`=24o(SYXHTbkPlzDZoV3~)g;-L%NE(LNPgXSYW1YjX0Z&N9>2q9=e{lf^$9a9jPZ0E^8<I>@gyI`@f@sEL-kmh5C)OB#}ZMcR|va0e)_esY2j?8&S%+Rl>Dv2Mk~$qht9;uq7r#+boym+$z~N+v1Q{{UmaT{MyU!8C>m~y3~3r6K%*1O?|v9k+9%Cxp#-M8BOx--cZ-FP<ElL;;vRt?7`tA!7Z^9{l8A=l{^rW7gDX-x$aaBYB3ayG0VeSMpQ<6W!C9?pI!&QsDZougFp2!Ty)?1w33$Dp$=!imO-fzS|5-Ia!DjC-d2`GHl=%@5{^9z~DGTLOkR{;BO#91(|88Y=(3$1m?wP48_Z|2NCZchW^kKK7=y|w2%C@MG9Zd`&nNK&15VVL*NoZ;<2mxYQg+qStDWgnHy~E*{=WBx<#=;hRgJ`VcW+yB)Z9^OuUUtn=BPw4UJ$`D^w|)|+8DUbl{#6mcY+{uQuYteIluBjokX}@QwZ3C_LSNpm7#473RPt9EacRbdLh1SRB)dXBMMlBP&<py(PZ&0@QL~C8hQ$Z#tFxdO|6D*wc*|%wKl`Nh5f7SwQs}bl?}tnEVmP;l(6QqK;jfcVNuKy7u`K9JpCd{}@4?yx^3b@-;1t(R;`EVJj^j5gTCpW!iNa9cyJJ^RDxrfFuguumBSCTJN+G}J2iqq!H2qX=UsQ|OID#QHXSr>2ha(0oQ_z}vAXUEGZEyAWo_q+@e?h*frF`0ETK+)#OsJHRscp@^lN@wPpJl;QWV3e))MOMymp`1=<-|sbj6kDd=YPV@V|~?n**|Y}Hlis@mm?VsETe9m&+c_71Eo|!FOjdq-zoX$wzYGtO*O?$GeYq-t3of;!xdA~fX^O<9aKY@ttYb0m2;~cyS%ptR#2b30sp&>s2l=TMqd{c54WCz4G0LUKPSwXn^w>wRaUe?YFP>vVv8qll@*^ZuH5NTgmzD-QX^7z=+Xi;U(`$Qvyyx;potB=@70xTQ4^EMjD>PCkpSSEE#p!1wjBE+&GLi+z`D(Lw%oqSy|5C-G(~979D&Z`Bz-BphR3{YNk|I-`STl8f4+EtE0~X02Wcv(u<DcaOc_vdN^lelp;`?20>Vd+32Jo867NYhbjvz4W2peKdFA4iqoVZq$E%QaL19Ndu=&_<H@B;4haeO!_+Mo@h{v4+<gta~4v&x@m)|bFZ+&JJYqRQ*@NCjw8{_%kB(4}-?)c^k$rG>;QD+r&_(=18Nc4=ljP123qH!9;Eb2Q7s7df1D1KDiC%ZEva;q`PPDZC-w?Hv6fsqg#kwCxSe3hT&hY_w`Lk|ZF10mSNZsM<(V2r*^tUSX($>`H8D_v-jihhoszb7-TpQ!jUIPzLCRw{kw-aEA6A0q4pQ`?Mlv(RDfMvCiG4o(zO@5m$wDf-XAOSDj1sx+2=rA@?pdgV<?l-O0g1v~RapE!$$om<iE)@KB`Lt)2}4XripCG)yPnjq(=F2}rPJ`z*ZEQhdXi!_=+{VcPp)~!@ToP5a%1!s30V~_@Sl!a@6fAL&Y41+)C8v1Lp;28bw($k7mEarpM!^Lz$c}@EFQl3%fn-N_3ZNDx5@>)0j&PA?NP6n*OaZR70PApu!^hOBKQ_ojpSO)Kid|k-~2STh8FrL1}A}C#tw)Pm<GsV?XLb8#-n4vu0CP%FXG?2O1N+A-Ep$~c7j}uBJu)&qWH6N3)?m6*yUYJ2-j4er(?`C83`+Fh2QI#?D5Mb$sVb`VThOn>kQ-yLYPL6NQmEIw@KxyM<rcnmjodBdv%z6{r<C=orM}$q$H^6V#WMxNyRtK2~AWybq!vgaM(inAW79q8mvQzh4Amxvgn1+aFRdRtWIsNy24P?w>NT|)3$A4gMC{RF+54#;J6O!s_p@DPsQJj*8_yN`82dkz+_)il%e1e<8^byu>2-~Vuy+a{&dY2+d;+<lxm^y%3Up_<Bq)sT;Vx=o#FisNz>dJzma~22!M$Z%xtG^_`ZYtz_3sb?$OkLf0H=p~*Zd4xIe4hXB;$4KmDJ9Uzw(^&1@YK+XxSe|aj?E>QtR8eWUh<aKp#@dEf6psP;_2{3@x|t8_Tth&z8DH<nT_mY#a|&5Hr{}`O9hLn5ES5m)r%(v!oLse^>H49j3y308}cCTe+SsuFZftWu7`C4ch3;o%Vr*~G>-7_j_?bM9G++?oQXEp!8IlfY|(;ro{Uhg@dt*chbHCCHIg36mC^PTkD;>}vt2`NFJhtGTp0jZ-1-I|uWx0mi;ieY?03ny;iNB%hy`1r;CA2NISYQA8QDEhI-D>s8#*YHb(v&ruQzb~;`I?9Xt2FLk`y}LCSv3U%{K3fBVry4Fx5wwl|_ws&{Gq8MqS+Jw~I8*vNqI%S@ZZWtKsi=yb|g>V~WZaoy?Kuc-@sOQtyCG=e8g>+;cUx40|D#)*?H8`sz{4x~x^kuNgM#Gvu8kJ?fu-1sBzs{eQBtW=Xj+?)`76?V7x1uM?|e=8oc*RN%u|?h_9~j6i#`oRLa`SIXyCk!f?A32XJILk~4!TcInA1^2S;i+WxJ4RAra8%YMi{R5W+z{RLLdZxH}DI@vMpZ%sn(%};JkMdx4Ff~1^%!=y>h80T1H~kQX?W<^L)*=UMRP9n)Huan_Cz?08IoZ&dh3@!9*Cmd<i7A@ST<90v_|N7>>G+5!G5iEb&*odur%YG1z)G~w@t(^eIjWG+vFQa<O(n9c)v1}<{VyV;=opLz1c)OA>7bfYohceUuL9WqoTdXUXpVJGX-41JAg&clx=A7JUBl_GFYq=|Z9lj_d2Y!{lcG3obW&ZVe0mt><GjzIbt|p*1U7qgDH{*4lm~Oz`v}74U+<z6<<Ahy5(sKTO2?C><}-$QaW_`~$`q@&@mELCwJLRP0d5V&WrdUZmE?SR)XvJ2fgv#-m`&Z$`@p@-aF(As+rtN_Nwk8~>YP)hCDdjB@L)ukK0tf+qu|w*mhqz9xvB(kx8l{!F4SWJ_+6f}2;a7=mGh&9#c!O|Q8+B<WgC2rsRZe%yMMNK;#m&a_Q&O+?B3{M$@1g_FD%yTlsYW4?tSx*Wt+YKD4o+BZby8~-(?@C8Q7$#t1@w1giNIXZ?>H|RP=sY>_!CJ`%Q!7-)tewoB>aPG8a0bVY!mcb25t-Ti1<5^+>jM(0;X3Ty63{(nj13WO&J5!y$rw_mgU_SKhGSqN;OS&>Y;M`X(aP^q<**&sRwS{3|$3O9*3uuPdL!{BZzqAJJ%1v*6iZb-O{;?C5%9fGH5}jDQKN)j7b0R(PPbL;GkZRgbly?Ps={%Y+clG)P!`b2>p27fLj7HFau%I(!n=(^MPr;-@?<qc7^OpQ4aantN3a%6)qV<W|kOYj6|_QV&GK?=Hm6RW{Mx?y$mGsNES#M`;?JqP@7NS=Du`JUn_*22=(9s4Z!kz2)lLT+`?hp!}Tg=aYm*SY52Nvz5QqNb40t%i4$qaJzv0&Q^7M)pB%*4H`Yfxk%)9y#<@ykazCc4Aj*)LrAHbW8aKLX9Iy3Yzt;CH2<-XjbDVl=%C-6+(kPT2c9Xlx-LCCjT(U@^3CCRb{i!)dsTj^K_^pAGU50>l%Guj!Mna6$9^2JjG2hJ1PZlIa$7%TZ)I`tIY=#pa>r&Q-irpj22aK=O&RN@X<k!2^&;SMpG!1Eda9Ht5C-}mc7OH8g7)%U7~yNd*h6FbGIi6}irp@*zz{;=_Z`g;I>%=WO`)P=Yr+!rj`nmsm@%#`v0G`RcK%WC{ANl!4*#<UTq)CBTq2ohIQ1g-9%br+>P?!K#&v)oE%J#lF`w?x3a%#_$;wI^`RTI}c^MI&lZ33ZnI)-1XzJe(Jk?$r5CK5E^c3KNCOCWvCMFrq1hoH`nYhLVdmUJxnuj_M+<Z&paA6nf-zW}cxw2;#>=S6G;{b@(=yrY}#$H^{^zL(Dl`bnQZL=KpfQjYY_CPdt^#U~BT5cOi4u!L{RUZ(|Hf##`QJWD~nqVZH=qq4F+HReV7yE~Q@L-UTeClelbN1v?-x8T?NkoW$qSqjz>SFB45aSt}Z9aex@{D(mLNvL9ovg)kWq?A2k%g5)-T?^sRTI;gVaMF&;uFV=5?4(pdniluv7|hwqL*edEK5oTXB_K~2>%-fBJq>OY>;q7ES0T9w8Y=0385DW@*iFiOV;bEp<smrffP{TYZ04B|6fGit<{z#@Y@NHc->l@o*7^}L4&nCa0R6H?&=McH({mDCS(9z*ql-ff0><C$co#~ZP<;45)`5tSlk`TvRG%QyUg?HG>G>dpw%aGTximvbJ8-?^B@tM7k>K(zr_!uhKu3{ZJKg)jH;yhs-H_s9+1RPr4OOO$U?Ep25rB<R%nEokpS}Nlf*ihg2G-CeDCP+KHJsGYLGC70z1==VZU#n8XLv6Uo>6<G4`B*6DM5kfptU1*`Ez5baHm=_Qf|vZp3Qb@G&f26FA~WB8tS93KH{Q%I84*m{&_opHxYC4rVvV)0+CGQFJB;x%KcGmkW;WUF(&JKlyFVyCRSZ1WRTQ_})uHNV5^(lDwSBWO=0?h8Pb4d3rQ%*{4EO?7`f+ux*>c=LGf_AnepzW6{Q9FoRVrw}t@Zyi@&idlmeI{hP#RR`RINs<Q8=$wBlI`iRj-RiB1(LFui7tqgt-h>nzSi_|lb_bT$F|BSTi@|$qZD!9Aq3DD`h9Qr})z-VGmFQIRkyNqu2;$M{HLbyFhv&1G3Q_e3wyOX6X0?c?rR9`lrn~C4Xf^Ub)4_bR`1eh{&XY<g#LyBmYd2bW&2ST&Nvrcj~bpudKN``19KxTji-UD(Nk^^A4;{`mOX+F<nqp|$pr6NZ=eWLsB@0RR<sK97hh%fB})awQ8XR>4J(Uf#lqGBLTi_%5JbS?lclvGLf2x>&ZYgWE`toYL+g)bI094gU9l;g-tV^ec2v_llw33z<sLcQl->$Ln8fW!y!S{4skZ&2kyma;)sVx7*HZ8-!yi_)IOR5iq;G1BCLlkU&2_GZ93YDn|A*W1hbeiFxe7!cVQRXAxZj%FfsgY;~UL^iSX`}&kxBU}7Y6hxunIAs@_W9`z)S=+TlOm}sZUTC}mh7uAQ&Oc>5+RP^pmjdv0`$uu8Clrg;DUK@zL&DiL!xv@Ky#7Y8i9waoR4vu--j54f4^`Na&GZw1E~+5}hQ9^%7=7=<3s=;rLyCAW*=FxK6}R<97momp9%cMAv!nG@U$~2u|6Md~f&d85O!XhQf1Ec(j6^iF{@Xh^-wwBy2+HF0=>+(9$;&CJfJ%IbqPq{K(}4z8#{wPbgsmRI!(sH%B_zvVE9r$cZ`_8F95DN(!Pmpx7BJv#1UN|owvnx_ha2<`_ZfTe^zm3{jUBDDwSKprun6~elB5MtQdrFNwNM$H=l(P9VG$|hU;8>v(zY6z-i&CY$KVdZ=5oFgJn68nZ%5ZUHoz|ZlD*Dh-k<e)HV_gK)NZJ}cNmPOKu*-}x49imSE;wzzhX}~xASRm5vwIK-!lFIe%+7$&;vpMgxbf$wIV~pu$GCr3xs+;frMqoilTw7b8L?hWlO<Ku}3XRn8A%%nUb(t1+xK`v5;E1yKEJW;IX3(aG2L#TReIWf)aT{&V|+t44fE*M#<^5eucM9JNomE2?61z5EwL8q!Zk=pO__RAsnz~W3f(9t`0lzYmgCX6CyZ4fa?H(@3@X31J+F{WVM*=)?aB2@C{ldaT+XjAx%wUK8LrxLf@2*E<Xjupw1RS8yTQ*^EtDF`iO4<G#$*Zsd$aRB<Y^=RY1tBT>m^rN{QPoEYh!oM2<7gEULF-Seq|yWbp_z4#cONntOUMg;)Y$^+?{x`xB(YJt_>%iXR22$ulEm)Va(|_HaiWz0>tTmYgl1(xm3h>n5tTse?$Y6Bd(cQA}=t(+>=}zSrv%gd0`74{2lr`Yu&T-J@CLfyh3`KxCg4!GsGuCb1rs@nWi+)~k$)1X$2UOD{bnv#F8N+W|#|#C}{omT10o-w6<^6X|5CfL1_Ve39Jg4U7M<^avSSLh{ZL{aJI1dyzeZtk;T|{&2vvBM~rIX&H8<?j3l$Cr<#mjT$oA#L#C~@}PQGqGHJRKc#6m3HKmr4zQf`?AomgcwCedkU6Atnsun9MlEu2{o=oMxTA3a>c<@sY<AKiu?%zuLe0*f`+s>V$R!Oz4pE3{n-pcg!!D~Eea6*8-t*C&B&Oyi-u{(#%9)3rIN)Lz2?n?Nl75yGGV@@iQm!7043_ePJ*cT_ks3EYGBZ%J&0!*Ob8KeKH}a7xv(murY)w+qLS7ki&>)+fXe$U~L|cZ-VE|V_pe%3^rYjoLTXNaG+>&=s3^2U<96usU5T4sLPdOYr=Hi~c4#0#K{(C)N7{H1(cr8Fr%%%&Q$r2|+JQA*_QzlXNaZlv4Tej|#D>9o%15Dp`A6wJQyiJ8G&$};cyw%;?+Q3MCgdum)U<*HOz!qG4)`Q1;IYRggUse?Ow=^hV0qBezRRw5MGASUo*1`CQR{dzLLneD_Q?~mhA%PC}SpRCF1HZAFfJ;hp(Iv+=uxzU%6lUx^FXmx~KuGYVt&i%I%{KYu04Puf6wWV+c10`zYP>o$Ys(17LyLjP_zgf!bbZK`jn8LastsNgXxQz4*=Ylvx_7W+fG*(TbVtGbvYImy&`35_!nL6wjpS#J&Z9LuUi!4)1YCiQ@z{RmnQ9^NL{t0RVwPd<@Bz;{F^r1Bnm++&tu4Y)d;S^oGX9d(y6f#%PPme}^nKunq<4X~rF7p_f1}AI6OW$ewAFFsYttPll0)`uvvzB97lkjpICdF-XKs<hEsHCRDTs?6hS`?NDKK?H;O=)e9bh){NhsnPIAx3d>GqI>+q3GKgZN#otqQQ(Ph0gBW*Y;VQ`%6T7(XMqHpB_P7$7G<-9QSfEDS`D%>bePB_O}92YOzvpVmrwk{`tO(JiCwF-3`=7~4`p13hiA2AO2D^Q&ZG@)x(~duC9b2;XarZMU&H$@C)@+%O7WsXwwNqZgm{9bXr-Y_UtYoLdMR;7nbN%FSL^H^%eO!xD_Ov=b&&zNd^4L`<4}AP0q!f<@^q?GIz=fFf@KQtiBd^?%M#Rr&+p{mY#-S6I<-{iCU+Sr$+X{*nm>*aVZ2TAZtUGD7M7$ZJ8d?o{UM?wYtDFI4v6^C0e)-+Tbr89${A*PR!DRoz2f?@57D|8tzF<OtY&NTUr;CzXPu@aX-JOk>DNndDDn-yYf``WN3E&yN9ogx5tt?4UWc+_aD&c+m-p7m)YSXw?ELBizDe1?iqJE4C{$R5QARYCNft4dLgtV29!+a^X50c4xm!YZ&*2aF7@v4s3qkLst(Y467;qW7&{pa4Jr}sE2lXg@@a%reqlq=&@D|!uq+q0dceE$eWM#!F)nuPT7RC8sK5c!PE$>ma&Yy3Cod&r`f&3tg*~+HZ{=wy#pww4Q`n>weNGCO^<**@X>ZgugMr}GBCxd_r3Fjcb7I+8#BUsC_(*XiNlYI_U*IFf>{K~dT5}hzK>MZj5l(syUqBL13#*y@SdO0;u?;(8iUS*PPD*>A*9tt=g^UOM<yc$K2$?SbM`0)g)gucDX+9CEh4pF%`miwPnB^c<Y;c<ah@)kU>;@R5t<1if+t%}?pK3jSqq&&QNDKz=+`qz2giczMa+``xfFW%C%nifpwBkX#jDA4=`|RfJe%vH7+k+oi)CRBy@k69CVlLNROn>#{1)Q`tguv@h%{Lc7-0?1QNbrI8m^T3Z=iNmBZE$5nqMOjl@|{i==V&QoPNd@lZnP+o#NXLA=@nxsg#W`6+bl~5=I*x&Y%XJlcreT+h^6gWXet~ZMw7Aw-YV&KvfW$<G@Z;?PD?ebvUvXC|MF67bZUGn=dye-%3+#tL}fLJMhE2z)?$8SEl{1DnJ`w5we{~Q8qu5k{!ib`E(NP`LcgwpAh=OEZp`l2I;~05<NqcVGQ$19GU7tQJ^pqd4xuE#_jT>vzrGjr5vwreVZd3TP1-+h#QY#B*$n|-!vKYrtYKf-i#1cxHH22;L6*)bDhKTffQ#gGc5NNgtV>N?1pd_7^O(~wRnQ<2ZI_gUWsk{91dOey<a@c#ggA@o?q5p<TNrWOik?AZ{HU4X6Kes7<>4$wDW+Kw)be$a7n1+Z*BbaYO4#oZl6X~em3K~Z8f{wZe7j(I<KqJ2|#da@DKQW%dce6J;ndt?LLT)f4H&n;d)3UF#{+>O0E_&h!-7XkenYkl??=f<gMJnhS~||-lDc8=42MFa{szq*r5|uM6Wic?s6X>Ys@HN<{-}2K8UVIIWVaMF{CX9QQ@d}Xp;rwupm+PxDA0lMTSYxNEgq}?3x0DHung<k6^c{iK{n46XHBn*mtE}DdA53kHJLXe-rsnO1aKb`b4+lg3hoIG`e>>en_b%6JNz%3*7)jvG{p#*9H%rx}T*l?=i3+l%A*tvy{yzQ`toxsQ{KVf}lY^Xc=;w7#>~l3-~4pn6O|QF5FQMpsCF>7H-ehvV6|fm$Bo#-@P=7?3bxVMbMw=8e#+fk|f6Cy2bw}qD^cebdW2E^%4U=Sp69y=b>9g(tJ2N%=aJUA(wT9TCzFB+B6+VWR2v$ypPm;hQsEqxftbJ*Vv@&kUj*>D<NsZd~y=O;F`msY{u;=4<zV9Na#1Fw$b0sB;6i=?F%A#c7<P*o~h%YKvo{AR#%CR6X9e=alluWqOsrMXdZ}9qC1Q|M76F0je);W204wKNrDG?8d4T(e47z2GyAnq|Bp{bG7Vh!MNVvjv=pBd5ao`k7m2t&yDl7{xQejA9zb}#4pDZdquAZz<)6d4A!pJ4S5<8))Q5c46RiAvvqVEvhOt}`T<#*2GBdP8V%YVHyT!l>z~;@~Le_p(6M?^<{;hVH)O+JO`9s=dcu}vEJ;nC$$-GuGA^s6-G$XZ>;^xijBZ9rNJINGQM?_XFL7qR7aN{k~&eXV-|21Bw&Z8&3i_|RvLJeRbA$WcloI|f(iuIea6kni(lLfQBK`vBS1ios1C6;72oGT_!+HMV`4LpZt0ik53MPcD<ivXOm?#gQndZ~ty!_DC_EvJBPj?BUkV5`TEy#c1xzGTk2SC@X?B3lQjPaA;Jf3J04^Nlcptk0_=^2Ll#o>PDoLCaa$P(lN&2!KdS7y6KncsWa47}XL~TP2CkLtT7sdXTtLtxhw=+*1ap69j2Z&<b&GTb=;)P$~9cw(3jC+@$`X%A={4T=Y};*P=F<{>9RbuzrN%{d2!8X5{`kGe6J^;3@RwLV3w+V~i5S?3`LtD#CF@<k<J5ZRjS+q9I<J%!s{9bXZBq8dVfLo4nSFnoSQ~BXVD6O*2E8*&Te+e~12Fu3#bgR`G}kUP_9gSJ&)`35Zs7o``LS4GxP=Yu*uDCIg>Y$D$;`BTT5{s5U;U&;YeE605F<V4YF*RVXu-XwnCK4+?IJtilfxrs|2d;<|T(bf2Lb;e*H4qr`WC(z$30U2;nz{&~p!e(OqJzOJf<MbX0Yt4X~d&WePlJlbjr)Oq8E;kbI!^>ShPbyd!<&Ip*#F^%TP;E7J0MC+5;ZE00ilV;;8x7wK!EA*qxqlu*+wje_M=Hu<>@|$_DuA5g#izUc!SJ{tKk3X77D}D3p8oXq_yHtN{POl5Ij!7ZIu3{3`-Q7X956fT`SoI{b+gw-ORyCj^5B#$wumC6~icz?1a^QFKf?9_pCrl?jVC?MKa_p#OTpx~I4aW}HOjL6K<xs&A!V#BFXEXrWLZ{@S3ZrbJ#~Z&4j&_0*-$1Xh9MNy8?wGVwRYQ*x8d>YxfqNM8(>Z<)t?H^>$6PT5n&C$gfS^LIv2gs)c7!>_&cZcU;mKSbCf;yeEO%6>q&EjL``9D#@a?RxlTkO?3Ng3839uz+y#MQPeB_jP3252gmRY?BhOJ{kF$_Q6(Be^i_SA-nFQ8eZL~?gIel>TB;f&T8@B76imowem#g8<&z0$$HwsNckb!9+f<95WTk+vx<{A=9GK{UHECQxi07W}dJV}?>b2fVz<+rg{vT=EV+l3|e8-<tMOH}kA`m)upeV}nPhQX~}f0h*2`xJR?P{c85O5_@%!_oQO{4f47LJ=vWWk&cA{8hrGe>_O66cTwK}Nj=F=elK@vPC^h73I5xGSJ4l@l4+r!1+?7sP@a&~2Ucu1kE=rd;gIfnf51E@k4MNg#_0HM7U{Al+_7`RZK>bl#vbxyoGm7k`Q)Yen!p*l5__h|oi-%x?lR2Xr*d$Tgm^r(4lM;#QJ|-R;)7Th?0ht#r2|J@v0(}{OjE@kGi+BtIJ|Y$wVyONo$t|j9{x?uFm^G9-m#mLqKz2Q6>)23a?B9ND5I&`49uRR?FtKAwe;<p9R%$zRE=j1!}>%?wTqfJpOA>83y5q3#)JE1p5__vwqmg>4LeRu*7|CTi~OB@$VCBR5b4~+*79$`2I1SuBRZW+#4xc_&wa$!c>_g{a#@MxW4NW>=-&*8(}B)5;Tq+r@~<2cA480&z9^9q^DomknM=6QUbZhs1{f+_`}?k50u^wo9{AYxB9ZM;W2Tb#EFpw5eop^+mTG%6JO2rU_I42bKT0<Lw9Z!YjtWTVUzoRv`=Bg1KY-jgIwc?&U4}BxfnHxhMKYLj>q_eO$}gQVU(HtdNInlDG1~?4c8Qyh%-DB%qsZ5GU9h!BO>Il}!sb!QIrm@83AgCc7>B<u9<hB?mlw(7y`Y#wV?dHXl?`8K_<ucop(N-3<kX#D`HLVj<W(}>6kixn$@|OEa>~Tjs?x5&+^u{=3QN0Ilgumop;^2vI0acV5mSrXKVC=;%To25tbWbXA}u-BTNoYIt;SKHCc(^d%iXJtXvvmChI1Zn+Gs9xoqvbaVmhrmg9ZoQ_I0M4exp&7=Up>UKAtq3nWU)8vp$D+&zH?!Ism%iKHeHp=N4zmS8U?@piacAsDhsZ3G{o3+%L5Mu!w&kj#j(M6q^C+T}yT$e|3+j(3PcRq2y+9n7^1?K7A<BI&ki&Y=bLxC@z4qQu1e`=e_*(7%JQT9|*+@;h{!YsJktS*&c=KRc%AURpX~ZD<chc5B+tHwT?+ZB1r=06;$e|aSUZZdBQ_1^=&S3(m!-6(?z}cT+!RD^bsdvIpd2vXo<It>eh8z?!vxRd%vSi@e9DSO#2Y3RoHKO7phlKL15Jfq$61{3%cvLWL{wMiZg8=Xhyh)5=>SU;1KrCe>dj4f>Ckmu2i?%`Q{8>C_Uav`d_5S6T;3Y9P;TLuwjdVu3g9K9q^I#^H9!A+F~2%Cw~8J=@l>}Dn;4@367Y;55NsEaBt#K!D%{TLMX2<@dA6W=olVE`$o7Iu@1&!8Jr_w%p7O8-{U<B^Ve+7Rp4G`xetw8G8Ck+?TqM`xq_X2j5egy9au~BSq*E8vV?@WR}{GVGO?dn;<+DM6csl5*RPx6cW7&E*wr&v<i^kR?E`r@m6pZn_hyOg7#a0pS;CMhE*Kw($8`6UskgzMM99cMI>-`tRP!5$if5U~XsttvfP@C+WmPe_qL2ZEbARk*;(@QwV&1E&PgWxp^olfTlZ}J<gJMF@)ncj>{5L9^`pSK<Xtm$_2jLf;fDS^6S^s;g8?M`x*R>v~Ci5F)%947w({rh=rxKRSXi%>$X7rIaTZ<pWYj43R@*~5x5L*|!VbOcj>^NKxw|ccL)Y&AaoRrbLwfLi`i?!NPLVZqvuP9b-{uVw$OO)oa>4sUa3;(*N-=hWTZt0=b_R|KJT1ldl^<m#WKT55+4a#O~5T(z@Ze9x!L^~%wduo%Pv1nS_lM!QWjTFMIB`P^93u6qPYXFCd!{@HCH+JW(EQY1xml%O~0^{ZnJg#~;HKRM~Q)L=%asc<M`R&9D;v(dCa0}rA%H+&2;7bm_ZQKwdg3116ceG&8opob3F(Ygwcuc#@K6o*`!#n+Or-m;f`?+D?wX<txRrpe^_=nyB!R=l-iD8XvV!dmk3U^8nU}Uma%Zky-nbm=8k#h48_3n6xd8nio??Try?nVsJ8>P5Z(23ix$VR_B--F4yfo+H4dE0_|ntubkDqaTIhs|V*5pjY!E%Y7I5p_@Acz|A6230&G(m(|<r#b-&O144p0@e5Y?g0!*HIoj6bV@%peFaol&L<&n;S8!0n|T8B*%DaQy=^bWET1TNWQ8UHhI8vK0%^qNtqfhhGJ+8t5c{S|&a&&!d>W3v7z^@qd%ZFj<5j*WAQnw`xJJ&b#vgvh@QYJPEJYNNRW>$ZSxM3G>J?9J^0=t{|G!(8!6ICU3TolK+FRC-cxwDH&~jSIMi*S-W&y2}Ooy{Ki98s2-l=NbL1X2(O^ZEP+k7|(J1f6J%;|JnmqxYnN%QZFKURLfHg!D{O?#kg2X%W#k-|Mky13JRd~uELoI`Ja8NCTuV{ugfn7rcJNghZkyBIawTa5EWu;7z#$8L=BTg~OguJEKPh;OX4*tB4#V4^*j`@&}N?-#ky$vn9j1gx>gHnHWAVR%k+Gh^IP$PubGzcS)vDCDfjHIlbs3S6)e^I2UBnNqjrY|C?kZh^y!-!|FV8CQQh7q{NMRi+{1SiF0B#f4dn_9R!j;lCvCgz7v%(s3y<Jff7680sdlsf;91!=2Way|UOo9aG_5w@G_HA_ATDLAlNg{DjeHRnNQ;W|7a#%1KGFi58(6*}X0!;N?zjKj7yLp;3-%P8fkCk%v$j9Fv;OZuCLD`lpmoiJGXHxI*~SNEZ)Bjd&OctXG`JO>{ujze%}3Ga>fRO&IwQgjR~)3VNbN5i3B~5L2&h!Jny)m6*1f&rgWzyEVtb;LE!4Q{_FSV>HFJ2{*K-t$#E8r;{;`))R6=BHq<>YLF1QIR~f%88e2)KiFPB%-%*XBhu}Ap$5Z`Dd6-~)K(R&aGKY9@ux@L|Nd5@VWZ9YJQ!T3$!ZlfXKMtVWq<Hh`+Z&;;SIjw2ZT^j3AF`0mC0oI6+Nx+>S9Y`DhC2nj>b#5?*}y{-gq>Fm^X_mFITPs+cxZ8=tWk|2M5EAArEL!mTCwi8z{;pxe0!4M#t=cz1${LiR$I~P<<*j%xUSloOG501Rw%LRx)4r4QDxsc755zenyU=TRi{z&@?aQ^GHD?Z_+_cgugp|3$YkpUJ_+ej;w+v9`dJ5x}U&oklbNxY8BCaXAntps_3To2c;{Z4fa$8%>4u_Dz%S6yjN~eHHw)~di-2w3nk>B^;kNv29}x?jvF=aHq&i>&jw82$YIDz_s#!sHp}S7?w91A7fK=ACLR)y?7uR>nt$S$PT|>6n7E+Kx+E%W)@TJkjlf=aiesz7szLIT+5#a#CPS1pQ=P87Xibq=MP`?3{NPxtgM;LDk3hR4W02|TyWyZEBlyUlLRwH}S%bv?v9K->)AsI2)rO$H;E^b!fc?<)HT!RJl-ZquIqwKj7?CXq=Ssi14<!7=VCz8FW24$Gv><^)Wvzf`ONR^vcunv9WN9(d9#?Z((4|N@T@uYX<M)Gep_&wF2>%t&R?qY>gVC*$O5<HKrc%?GXefvY5@YSmEBf8fwiRfgorP|M#DA_QopQ&(dYXk^v8XFAX@XZw^bO;CDL7`cteHi^NTd&QfBFdWS4xXzE<Gby0X0=U__i>>2q;JHXdZhc>Y2`TaeNsi$CpE8*KHkNK}xdHy(I@M-5=fZ1*pP>sPZr`HCFI?&Vh~VypzmI#PAE`JbJ$I49#kStA2mv_5;MoFw9u9&7X!p*^f^(PanKGG{g0^VYH3-K+JPwQM7-pf>U)2duJr_C3;~ftsLW*D*3#?PK0!Z>g0eDXtlA(Ig#E0S161Jj$sY?z^V5}RMOA14oiEYpsYn?MeaHNu}A0_=PsIBoWJ{G249ldmO!jJshvJvXE&p@*R=?f2Ls<PAnPYK?K(2mCtGcE>jPr(l6?Atr+PdIARydCOf7zud9Ah;b|msO3UmYbV#Y0#?J+8wSp$2I6=mU1J9pyt#MP&rBA2r*u6j2pXA~i|$S%hwt*SU*ivrivUC_aih}a2skS3A}-Ci~m<8Wtq^bY~m{Uc~{A_Ms!c1}pDgu0htSZC>0O-x#45U8NNY8+gUcU#<Ggq8j+Cg~9)B^AP@JkHrxI5uI8JZHouV;E<r2$?6QlOTnN2p5H6Gl_K+IIamyAi%dUawR0~)NycTg2BT=xsNi)K3+ecmS=EoC3tcI2ETOX;!faA%5I!CEoD|6S1sxL%v)IVgonlCofBHr=uTHDP=Hg%H#*IhbXv8S5Ia|VZ5fIQ;}@YQ$g;aUOfMSOSqNJ@75k>h#HnN<Z=EqZG8ut%F7Id=)WYIB${Tpr{Nk1*J-8yYRpeV^Wlxy-gkqqgDEB%n*wCKnnfQ1I2A@Y_;w5d0Dz)RLrD7N~SaM}JNFg8k>BoBS2I~AWV^q~g(sk>m_m}fUpwdnE?=8+Tjbik@Jy{gm4m@Ky*Fx9CTYq@|W-+j^UG5EY{~zk>EV})0RlrmJ&Nj-o6ulhqJ?6Lby+S-kQi_cdh8!;8%X(<d6F?(R1tp~M#DQ3F9hr|hWIjo(6l^Gi*cH|-VxC;-Bivfys62s1Erv7ShtoRpd^|h&)L|6^YV!!H754#<&7MaE!hfTXO^bs`1hWQl-cEI}NO>{%eKy!N7EQcd%%w1Vw2%?W0l&=;8p7X5%Oa*sDJ?O^Ep1n5lGt=&q>|vSt0}UPeH(pPRS!QS1vHDXd{qPWNut<L*DsqzkYkT1QwPeVu<9mPf?pKhc!mhiK?nKdVXLf={lw>>D_HP%y?KePkjDAB3(JF;Lc;H@Y=8u+S3b=E0gxV=7qFz6l-2dAB0BpA8BA)7f(4Otkj?rR59!&D8NoTrCTp(gPqCKT3y+U~sc}Bukg_l3Ov8W_2}4fym@7)2zZUkrAK5(T&yDEB{D^$#FcO+jjOPAlcaMh|??rPS^Ph+xuC=NT=*11c&;R8Qu-&FR1*i-`V1d}UlSH`n`FQyY%4{#Ze*jUTK8$zkzfb`lQ`Q#XjZWC4e#j-ms^Vsnm6DH1($Z%=2zPS7CWZ^tB`dDCF<8N=w&1`8(q;o{Uv~EE)LWlNpqibLDDO71Rde;GV8^gKTMhv$Lr|{9d$F(@kBV>HgBj+};%>7#N?JJ)W|nFzz^QW>50_m&OQAyOA##<YoyLuaYn~*PcY$@A*@RVkj~Ph*%j8(Cf2>QsW8S6}BDC6qxNglF!GSgbyi_|G<FJT~%#ozccI{hd>fmy4HQ2a5WeG&LJC)wuXmHB?rpZ#iVVF8nBu~kh00v#4gc&m(Zo2)c4j@aSF^Q{jZdfDDT)PqiZuHJEEsA4CU(HU?X+M728cxA5X%q_l+-s_s{uYv<zZP;Isxbd_Bi`1#Sg?(DX!Lu}0LDUP5fW;?B4Kk*wki=Ujx7=BC$U*qcu(_GRp!<*nRtPnk4Qy{=8W-1L#Fp3NVD>vGJIeVq&=You-uTcT4>f46ED`+K`(9-?3gByHk5JkGcU`)2>hb|T+yPw3u0;(0<)!BN`ROI)ZRI(SE$mZ)-VtuIV=~eu=*C;_JDuFUz-cf;Q8bW{$z(=>6=iRhe&@h9#Xs#`Idwi#5x7*>+Z99+gge`enhl<;p=b<pP6in9v!S+QWiIkm&MHz#3^qfSh+oh8d8%OkNo$>X8*lQzNH%O)fOovbn<8xJnv$KTVNH+4Bz%ql-`djb>T^ZQ)b`j!Cuphs3o-eKw}KIuh{jrYcUbs5##3aTAYkB16cjEaa&e|hMf0hlSbpQvwjF>v><hFlUgWn>%WKkVb!VYM6e)^RDvJVqfd@M=(!u6OM|O%e{;!E)QJp{1&ClQN?vPaOa8la7>5|Uk*zGuNq)=Or`&LeYi|={jTPDWnJin&aol7%Lfx%-%{?TE;dHn+Ki=9YjAyEvgrFp?M6N{0Uv;@dO69=_|G6@gWl1Mh@JPsleM(GxyC|xxVgyJyi#p={)~D(<_BA1!i_)~J@uAglj?z$tJOio5N4JxdBF0anZYi^$z(HDj+1s3c7pT-fZa#eIDtRo(&2?iU5>Pnz>aH0#292(J3yWn|-M|*GU4#b#Iuq&?F-*0sG93<CKqKbPc_As{4|D$d>1QUv2d>MJYR%Scns*C*U332aIp&M(N_iB)sBs>PZ>v-BIa~sg+elrJ+js=)Op6%eST8gGm_{UPtPGiQ$j!vL2<xBCd@mgwKne5mB_Q#JUr9wsHP5g^jg-|O6Z>}JaH0G(V6N_G7DG`YfG51=Tcbr72hgv#qr}7}UKFRP3m$~h_xKAaP#Ex*kP&Pz;iWqXJbQM*VpPKo+xm$*M3?XlEj)7+NUd1*Z#KXm(C(YvqBY^onMLx{h;x7Fxh=HGCAe6m>8~PSIwYV=Bl$pmH8Ap6X9YhObDPdFa9K#q9ClbL;_vwaPe;Wc5>y=DID?gb(~w&@YbUBm>TyZG0|1Pbzc24TsL^YeQxzE`fuh}fr8+smKlzb**CQyR+-f!tfmx378|nS0CFnv}oxG!K9Nb8#*i#iI4z#0kdpCXm=eR%7!g4LPJ^}--A!u3ulo>i^FMG!#^~QKu8u`(0?@ppaVxXGCxuJoON2ju*j5sr=*$H2<dJeW|YW-{j*5%_##-)OD$WCy*tIJPB#KjV_<;<4#FZzj^`3GmdaA_Qg!k--b9B@yr#!GF}RD?cxPW4_m#q$C%?28lU?80Yh152I=7N~-T*HV+Sw7*gTVJye60>T1xgW0Fo_}~D7ipw+NuA6;z9nD2`0AbeZkxSVA+M?n&TN7e+Dm#>b<D7$n+g6i0+^7=9KP(4IbOa|me6vxAxK*|hzum8~KF*qk+E)0bjbAMJWN)E^kKZ--`1<ObbViWL`Y;iq2D1NJmg^rm_xa||E~?;ZhIvT^46A@P{QUc?7>5MIMNX>>LC60q1y1Gn?x$Q&DXvf4nEdWKNfvw{XZxD(>|?PallMpK&c<x~?>~3BG!fvhNWD7WwgEbmv}`?G)yEkbXe2Y7nBll%=?YGhP^}!GM&&T4ZF?9tb-*HPC0}ZXzNF&pH!tlIFvQUVZu_3jLreb3*Tv)GA0-WE=%SYqFu8zt9)&+*H}R{$h|~iCuK6vup8<o}=xURz%{}8%w(>6sn7w>!eE-eeX;aE?qkzMiF8t9F7_`E_P)amJV7Fu(4+aYi9;<7})Cl}&DO>EXtff&pz#QFnhkZ}yBIvwhr)JNjoHagNpqzTfREL)04;OA}rsBDZk=@vJUCAo?4je{(t22|*8`<oI7wq+rUIrS$GN?+thje_NGC3(cd%?wi_$6WB(IX^1lAbYhyXdaotS2KjB3>MQ1&ykqsK`28xZ5av8KmG~K&5JZVrCEQb7-%!n)qW$5GZ{Bmk;`&FPl~*{Bc9j(y*YV@Y#RofhBCt?rRvzSQ^Px=L)E48n<aab3UI#HiulnhXAa%)9!D@QGVumV%I*7Wr51ArT@oF!2%kTB3=sD%xASg%vI_CglbGwN!M+UepZ_wV&2X9+33LShWo73!s6_vLlP|jP5*Ak6Dg8Jzw5G-MQM_Lx+rwLTqJ2a@aq?;in_w`*}IWIEPj*-MEJD}FbbRnJwB?hd4T4mE-1dt+esLKp=6HS=7I0Q)nJu|I3A(VZ>!Yi^<nj1kBsCG-S?7<&t*Q)0*5gcO*FUbf-=0OtE3O^PlvmtU1}stC(u_RY($h<h>Ih~bxD7<UkB;rkk;{T(J6R+Nr)rBYt_4^>%nJ&k$s1W>V<up1y~)kNZzh_t*Y0N%Sq`>HFR9pYyV~#;~Q^8=2x?+muB;vsovHwk)K5p$zsGjCbKyW!+?(ZL${FT7(wdu1O$8b=7@hS&F@UoGHfY{mBS&vpqDq6R65$b*}_<z4>8$leRR}?yO9!yZV+ruXWqts7mrJ=XaNvlXV}n+%t`RtqJ3?e$`}wpYw1xZ;z@;>Try0=v8vQKS7#aoYc$if*uN;!niBCSjNBz8`L=NNs{kZ$p7F&|ke7O24DTXUpwZ3fi90P6pRVk{9>Q@J)t2{zEf0N=Svn0S3H^IyFCkm)*_hs^dMv1gwm!q+)u{%bN-9(^WfhH`5qf457WG5VnGjKmTdAqM0w_foLl`hTM2XXl#FQ47bKIjASi7R4FZ}_JC4;&dSV{#uM9=4B--<?@&um~ak?2c(x86tiDa1ceyF4r!V+ut*;~a~9=i0Q;Yz8jOtn1L~EGg0a4J&{o3W9Ss%<aRSKfqqo+`vfGS@4EyW^*o6+=)@^+(p*V2ZGpa1$@Rn39dd1s!5$`wgab)Fgh82!#Wz<wRa?==N#gRTM`#lEL&z5!hoYCf1g@AdV6!BzoF*}MC1~^w;LbX!C2s{agGpFe-FPiVcw>=vnQiu>pTL-Ukr8V1Nk&E()G?vcflKzzU>=LqB@61wcF){>M}n*y(VZfk;(KN%KU=5pdn}`mAS1&L`)sS-EPpho6N{?RlFf}1*7BQz~TE*m;-vjkQNQev|y`j|6nLpzXwRoymGX)gyq<N#c(~nhkWdicDWtm5)8v@+E8=_A~w>FfHE<VTmk@&?2j>3&{^Nm2=uJdb0%om#+((!sRZ`|ySULpJSUUgxF9NLibNPd9Xs-|_!kvHuaz~_R4NKU%B-1v@fvzo&WNZfcS--V^vRmYhX8!(&nF_&!ZOvdC~F<?6;W7o{^^x8(#-JkZAl{b(d=$aYa+T3kgy}L=Sz18x8l$n_Fpo0^dA6^|IIdb^p7d<$YROzvZpvv0mTt}CRN#{_1rEMi{=aTL;ts}^D7y79AQ_!kr9I#4foJD${g-<PS6f78A<UT)0y6oTm$cc(nI(Pfqr7+5$E+JQ8*Ro3Ng?PSU<V|nK^r;;d!ryRI|WN)=I<ZdERvctiJ=AH)1S;<Fo%kk+dj&X2;T`nfd7p4m{z@Doz-vRi_c9Ss1}hoST6)rDa~F!W>O>yWOMUOO@}_*wu$)Xr$s~?3QQY2y63@<D9Tke$>V2zu}eLBC1nc!!6Mk#RUCmfj2kQS$QxpNu_{bz)OARl$yy}W;O?o;ZvN?7)Wl~*L6t){xIqqg|`2j46direyDXz%i2L`tIvTZp9126W`HLn-NPKgH~0@A9uW)hCD8|+qwPs>5l}uswz$s|SJE&j`JVg<(aEF$L-Ga@bdt<1^?rtQnFpgoOC6TCv{B9p`JXCFU&qmlCIl6fd;L_~fSYaCu1O_uYKHxH1L$V;=W}!YNWnwkH6yXLG4$xK8U3pA^jFWY*q(E)X0Hv&M8!C+-5h1&t&n8eDwwSvPHHRzNeU7+8rLB%xrJg*C2#%T&uLo*k{fz%2Uhj_4^0vHD=4L*c<;SSm8P^@Z!e7WrZrN6E)5~&68L)nm=#-jQDLW?IYE4Ql(DFtR3MqxrhN?ws1>?pqYYd;tJw0L6Yov(PDw_x{j~v=jK8<K+)dz8O+dRE0tH`5EiGGSlqL+sp?5mFnmQX6;M39z>)u>E*az1+DGi8OJlIkS*|?LuF8*C)Ibeadd#XBAB~U&8`%U#d^Ukx938N57C;mfr^I3~zwF~BwE3azE45&VvdG-K8GECk!n708_SUUKfL$?Kz3Yh4u2`kQWzYRiU%_vB{T3I8rf~Iu7<Ym+adu~#!U|L|*BtnB#1iuEa0>B1N854R9OS3lv=xd*Chl=;+^9h$P<P9C;G5GfoTa9BTje7nPNIhTeu&1`F4ve}pSl@qny3OQOS2yTENQ{ccFP-8J4K#@$fNngmucuXO#PV|h_<<byQEfeCMotFDJPc5vC02d-x#cw=7=r6&ngx)V&e+I>lehc<$u^tsR)8Zx=`;4sn048SY6S96W-k=w8r`Bgcw_h85OM<?_Y$M6`M(!@tQ-_Ie5e^;AA(0EGm4=ubwgp^n=(ARDa^I^cSJ9>T7?mKY4F#UJJbAxyYmYn3ql0m(kGcOeEql8gJLX!<;!_%(a>Ctq0MZ{tufQ0IZNw3h9P7i117T_lbdx!zYmLqAcY+xv~wJLxh;Etd{~Ecpg?it6wPL4f+$qVA466lyuDRce|j?$Gxb@1U=>=TYz_);3Hq9~g-?{#jo0cyS#qF=d}+b_a}jh949fJY3|L+=QMntL_x}M#czoOM3-+Io107)lji(krk<7|!h&_s_`q!7asRrjR$|b~M@ejMa*xZPNutf{gS$6FJ_v6+}QLE;e?tP4uPm_>Z^##iSD=2(Yw#`Y1l@kBAG24sker6EcG3Ugoyz7^J)9SiA4BzP}hui{g!Z{W{_@5U*RFTfjo5qZ^g#Y$_R(9#G%<)W>nHZfNR@uIPeEs)#7lbjeA>hEe5sg`HKJ^syK#gHRU%TB%{aZ%=`XnUg|E@r_ID0xh_*awo?}Bblo(PUzv(Qo8>a&Y2AVaVk9m|+wu8k%kIWAhB7FJ}iE%x>vd{&@*D+>iGdFvTnb~oi~2cKClJ5~@F#<HL2wPb>O89}wd?@;GM;WbqlNx4hy82apfg;eb5!K8iEisqKwL&BW6{VBunYbuSv4LS6_8lu4MWHPZaY4jg-G_LWZFa5Z=u1=2~RJC(ch%sEs8Gq)&aBHzMHVifE8gXp1OhGjW=2VcqGlV(IIv2cxbdiU3g<+B@cII9P^msc;e-;BF9${yqH;y>=ZQD@4m(B%3(??k^^))RN(C!@OqzkO|>J&k+=U$g#LquSwkT51{(GeDN3mP?OZb(4oh<Fg-{Hev^^*p!{*_|)K$xrh8XFcb-r#x7}*zXja_Su_<jrG&{uv2H5{A`jP(-19NGHHmj?cF#v?yn|6Jb-)m>9gNLXK8@2_2#eT?{CCLt}YjAyCL-Olu-+ZI1S6M+pcNRXrw_)<oz<$Im(1P#vYZ?{KwX<o!E!P)G-yq`K-oXH)DT%#kd{QI-6ZBjWN>|m)BYl;hhSuT!2k6ZV3(UGFV2&;*ETi!$ZmKVQ$2T&O{Yyao?#@_^EM_sfnbI|20Dz8b%iP1c~|ohw`_QL5yzcIxK_!Lx&Bg9wv`%Np*`J1_`-q<t>piSc0Oi0s4vn+e-qU)X78`8*+&ejozQ}D*5>yO=^@(JU}x&wEcGhjV_#}BBYdxi&XnHRhlH?)fQTr`c{Jb7j<Es0y0C7iCa@hDfAttXFbj8ft;L^sYigxHtm0BPvm5-%rX9y-^A7o0ULsKCui;%UfuG27F9Vc6zn8Xn0eBBC;g$9EC`<vMycHTTG0*Muf9oSAN&D)K>4V`_4be&)_~(btF>?s-4h=-8x1I;W#V$!*fm^l6!n7KOcL)YJJKfw@02z?&UU6SP1vE=UP{)7ZGr*%;|DmIsY^cWx@XLow2CR@p&x`FQfk{_`(HCZsHX9{e6fuQz%W<$kEsc7xvmp&*;N%JQvDjHYQlvi4x7yw@s?TfmKcFHxppy_59?l|Har;^rI+epN3ACh=AS8jUX&~a!;6oA5uoSr;Q&kSt!ov#rd=jLO;17)m&^Iag*sB+fis|ZBq9ZEo*Md4-q(9S>tZm?(Wp8Sl272rmVd<{fk)(4edl~xiLkN^(j3%Mjb|XD+Hu}Ig+OHeyhiExuPc9i8|L+PF`FO^Vs5FovZ-djOe+^^xztE|lJHT#1V|YnGdLn<CmZ{CST6z-xC8c_ev@MpI-sF@MmPT54%uEB7(7krWD*%NQ8PI#j4x~gdE@DFT2kJ<{!|a<STVJ}D^?oc-}1hvge+&a!(*yMsxP{G085p5XmrVY7NxhE_KzQTm!wZ0&VZ@b3FiUSci^G>-)c^2m{5@EI+xFVF|U96)JxUV3jJZuh8z@shs<`YB-#Cr!3<?ubUBFKRuCL&E|`M5!mCG2K5zW$%ula*Aq+wgnf0uDsaQC|g}jBsJAZl0A=;Yto#K~=KOlav;QHQ2Tvj=2x%w-vUGr~)l%1mSfL_h7M{()qhEx8RKl=aIU9%kdA_m@fUi1KtQOp*Pl-3k*(B4%goPLh<Y&x{cSWBnZDIC`k<$9`aqS0y$QRB}AUwbCBhL<K6KkSEh%{6k{aHqK0$Q}}Z3FkRo3mBkwly#X3u`NK9sv=9oo%Q1*1|ix>CpBkP%Mb`MBNyc#0Hf#KQIH`J&T{^gjEp{v^>w`aJqai*<lR6yL}Anc-@a+{kGd(32uutXff1Qc*fjNbW$dR=LCd(SmB4P(vmO(dCGsh6OyqMZgGMK5AA7(@5Uzd8lca2>a1Bj9a=$4YNbAZFZ7S4hm^kQP|8X1`IA5x(tRcqZacI%SebdE6wx7y7@<Am+x3>D=KEI_t<?9Ohir;TM6X5Eud4ibuS}xD0&pq0o{9>y+LA{Fp<8D;DkB-ThKZnTsl0OX|MI1QUM8YmhSI-Q$PK{Pyg&Sr|e#Voe)C=c;0`cPm71XCN{vC~3zPpq9*3MpAB<`q)Rp2E8ZB+rthOBVs>dCaaF@U_<geQjUH<E5zBBa>@M2IuU;LYvtG=45oBdgt30D$Kcj4@m8+e_X2rUPAZ$ZP?JQgTy?DO|UeS(FltcmT~`+*hSA{@#sB!>tb_rzD6dq@wK=CeYS4UsYoZ(9)`n-n8q8VtI7T?dkC@QpCuFE1vOe2}LqrTxe%tzs{}(vg~^JUe6@%VXj=V$u-k2(HKhUczecSBU1?e&KWi?J8^i8feWR6X_3G&^5-IE3MWXnbi|v!X~mZk5zgL$2?9BkbfIo<e1yLV4EEE{6g5jcuA^-N$o06!QfYK`O|R&iVKVqIpR$63=c>5sy;Ay!-lCJ%g^C%SlDxM@jjaV2idl)2Pb($T#v%sjsIWx0X?}#lUDcmXpEhY58*{-rk!iaFQ#z%Up5d+2hpD`LP*aAZ=c337{I`iV>ta-OV=>|E$O#y$mDPlElm|8+JdpxVtWUxDw3Qis@$|Z9rzi6hK9hGt&aEOHzRLMOElQ^Qwmv_IbQ_X<=cP(zaeF(Wp(Bxmt)#vJ)g4K3RVaifJ`IEPa{9gV<|}p#Q+zoaA6I0pSfPvnH*n!nYAoJU6dh$js|V)QW%9pS<G==Y$UVRY7>_=OjKLxC`*T6Pr<r1N=x*519?#zvqST3#Vw?Y^)j`5wJOBxV!k*yy-_&Uy7WiEdDYN4c3Vh`4fVP&@1wkDcUGn#BEq)d|fq+T?W+8TR%h~cgQrVxdDXw)*7$5g6WWMglZWgUxn^R+{A#yXU@WLTbauE`qiZ(&&Ocujhkwj(}IHUmpq1XUV_j=*gW?3z+)ZL%B3nQPS&X3V~2<%3=JBU7+&d=%kn7pgn4#xHRD3iQRT3(lBJAf&%9Jncw(Hh~srz>rPXjd9V9F=&8ee=3I%#jKWP>2SsGaZFjgE^Y32-9tEy7l?m>kkz83I^Ij97b>lhEJGAV*3RbEL~R}@7a?tWE|`}@dtFg=wx1@y2j4k7)PVWe$N8Wt9{L_(yw3%u!;BU4iLr;?X&>ZM8zvTl>Let3ABYBs2>uJjv}pVw5fm>R2dW_Dbo!*L`_DY2!)O&zePUeMV-t3k9*b=>RjHSA{U#400000=hQtF`GUP900D{c0+780k(I^7vBYQl0ssI200dcD
\ No newline at end of file
diff --git a/src/qt/res/src/bitcoin.svg b/src/qt/res/src/bitcoin.svg
index d08d2e6625..14cf0c5e11 100644
--- a/src/qt/res/src/bitcoin.svg
+++ b/src/qt/res/src/bitcoin.svg
@@ -1,21 +1,15 @@
 <?xml version="1.0" encoding="utf-8"?>
 
-<!-- Designer: Steven Hay & andhans
-     License: MIT
+<!-- Designer: Jonas Schnelli
+  	 License: MIT
 -->
 
 <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
 <svg version="1.1"
 	 id="svg2" sodipodi:docname="bitcoin-logo-noshadow.svg" inkscape:version="0.48.2 r9819" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1in" height="1in"
+	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1024px" height="1024px"
 	 viewBox="-34 -34 580 580" enable-background="new 0 0 1024 1024" xml:space="preserve">
 
-	<defs>
-		<clipPath id="clipPath54" clipPathUnits="userSpaceOnUse">
-			<path d="M 0,896 H 909 V 0 H 0 Z"/>
-		</clipPath>
-	</defs>
-
 	<!-- nice shadow with alpha 0.35 -->
 	<filter id="dropShadowAlpha">
 		<feColorMatrix result="matrixOut" in="SourceAlpha" type="saturate"
@@ -30,339 +24,35 @@
 	</filter>
 	
 	<g>
+		<!-- white background circle for making B not transparent but still keep inner shadows -->
+		<circle cx="255" cy="255" r="200" stroke-width="2" fill="white"/>
+	
+		<radialGradient id="innerBtop" cx="277.4905" cy="196.4412" r="34.3969" gradientUnits="userSpaceOnUse">
+			<stop offset="0" style="stop-color:#F9AA4B"/>
+			<stop offset="1" style="stop-color:#F7931A"/>
+		</radialGradient>
+		<path fill="url(#innerBtop)" filter="url(#dropShadowAlpha)" d="M254.647,174.6l-13.983,56.08c15.855,3.951,64.735,20.071,72.656-11.656
+			C321.568,185.928,270.503,178.552,254.647,174.6z"/>
+		
+		<radialGradient id="innerBbottom" cx="261.9153" cy="284.5671" r="39.8381" gradientUnits="userSpaceOnUse">
+			<stop offset="0" style="stop-color:#F9AA4B"/>
+			<stop offset="1" style="stop-color:#F7931A"/>
+		</radialGradient>
+		<path fill="url(#innerBbottom)" filter="url(#dropShadowAlpha)" d="M233.608,258.984l-15.425,61.832c19.04,4.729,77.769,23.584,86.448-11.296
+			C313.703,273.144,252.647,263.736,233.608,258.984z"/>
+				
 		<radialGradient id="coinShape" cx="256.0276" cy="256.0027" r="255.9878" gradientUnits="userSpaceOnUse">
 			<stop offset="0" style="stop-color:#F9AA4B"/>
 			<stop offset="1" style="stop-color:#F7931A"/>
 		</radialGradient>
-		<circle cx="256" cy="256" r="256" fill="url(#coinShape)" filter="url(#dropShadowAlpha)" />
-<g id="B_gradient" filter="url(#dropShadowAlpha)">
-    <g transform="scale(0.5,0.5) translate(-120,-66)">
-	<g transform="matrix(1.3333333,0,0,-1.3333333,0,1194.6667)">
-		<g>
-			<g clip-path="url(#clipPath54)">
-				<g transform="translate(408.9102,324.0937)">
-					<path style="fill:#006837;fill-opacity:1;fill-rule:nonzero;stroke:none" d="m 0,0 -1.226,-0.003 -12.627,-0.026 c -4.297,0.108 -7.732,1.555 -10.292,4.301 -4.542,4.874 -4.504,12.168 -4.476,13.164 l -2.83,231.423 0.006,0.102 c 0.027,0.484 0.68,11.928 2.079,17.977 2.488,10.781 14.484,14.51 14.994,14.664 0.427,0.137 4.524,1.389 13.33,2.41 0.068,0.008 1.095,0.099 1.941,0.175 0.576,0.051 1.07,0.095 1.117,0.1 L 2.008,284.26 c 1.026,0.068 2.358,0.154 3.878,0.247 2.041,0.124 4.401,0.261 6.753,0.38 3.367,0.169 7.166,0.262 8.873,0.323 0,-0.006 0,-0.012 0.001,-0.018 2.602,0.047 6.12,0.159 6.157,0.158 1,-0.006 2.025,-0.019 3.065,-0.035 0.695,-0.01 1.392,-0.022 2.105,-0.037 0.27,-0.006 0.55,-0.013 0.823,-0.02 0.628,-0.014 1.255,-0.029 1.898,-0.047 0.358,-0.01 0.729,-0.024 1.092,-0.035 0.573,-0.018 1.141,-0.034 1.725,-0.055 0.41,-0.015 0.833,-0.033 1.248,-0.049 0.552,-0.021 1.099,-0.041 1.66,-0.065 0.478,-0.02 0.969,-0.044 1.453,-0.066 0.512,-0.024 1.018,-0.045 1.539,-0.071 0.561,-0.028 1.138,-0.06 1.708,-0.091 0.46,-0.024 0.913,-0.047 1.379,-0.073 0.587,-0.033 1.19,-0.071 1.786,-0.107 0.468,-0.028 0.927,-0.054 1.4,-0.084 0.575,-0.036 1.165,-0.078 1.749,-0.117 0.51,-0.034 1.013,-0.065 1.529,-0.102 0.596,-0.042 1.208,-0.088 1.813,-0.133 0.517,-0.038 1.027,-0.074 1.55,-0.114 0.639,-0.049 1.293,-0.103 1.941,-0.155 0.508,-0.041 1.007,-0.079 1.521,-0.122 0.69,-0.058 1.397,-0.121 2.098,-0.182 0.485,-0.042 0.962,-0.082 1.454,-0.126 0.689,-0.062 1.394,-0.13 2.093,-0.195 0.522,-0.049 1.034,-0.095 1.561,-0.145 0.739,-0.072 1.495,-0.149 2.245,-0.224 0.5,-0.05 0.991,-0.097 1.497,-0.15 1.032,-0.105 2.083,-0.218 3.136,-0.332 0.237,-0.025 0.466,-0.048 0.703,-0.074 1.298,-0.142 2.612,-0.289 3.943,-0.443 0.007,-0.001 0.012,-0.002 0.019,-0.003 -0.091,3.034 -0.263,6.424 -0.56,10.218 -0.466,5.962 -1.291,13.56 -2.37,19.915 -11.586,0.041 -35.356,0.079 -52.993,0.111 0.003,0.014 0.005,0.027 0.008,0.042 0.003,0.019 0.008,0.04 0.011,0.059 -5.48,0.004 -10.866,0.006 -16.113,0.006 -0.001,-0.009 -0.002,-0.016 -0.003,-0.024 -3.426,10e-4 -7.893,10e-4 -8.38,0.002 -2.117,0.002 -4.224,0.004 -6.32,0.007 -38.7,0.043 -73.648,-0.005 -92.446,-0.215 30.082,-13.77 30.936,-32.082 30.959,-32.957 l 2.75,-272.407 c 0.202,-2.524 1.132,-27.509 -37.941,-48.497 5.037,0.131 11.95,0.397 20.523,0.725 17.66,0.677 43.979,1.685 82.075,2.676 0.036,0.001 0.207,0.004 0.48,0.011 0.413,0.011 0.814,0.022 1.229,0.033 -0.99,6.703 -1.291,13.054 -1.321,18.977 C -1.054,-10.441 -0.535,-5.846 0,0"/>
-				</g>
-				<g transform="translate(492.9453,281.3125)">
-					<path style="fill:#006837;fill-opacity:1;fill-rule:nonzero;stroke:none" d="m 0,0 c -0.03,-0.12 -0.051,-0.204 -0.054,-0.214 -0.032,-0.126 -0.067,-0.249 -0.1,-0.375 -0.086,-0.33 -0.173,-0.657 -0.263,-0.983 -0.036,-0.129 -0.072,-0.257 -0.108,-0.385 -0.116,-0.409 -0.233,-0.812 -0.353,-1.207 -0.01,-0.03 -0.018,-0.063 -0.027,-0.093 h 0.002 C -0.917,-3.303 -0.932,-3.349 -0.945,-3.394 -0.957,-3.432 -0.969,-3.466 -0.98,-3.503 -1.134,-3.996 -1.289,-4.479 -1.448,-4.938 h -0.001 c -0.17,-0.492 -0.343,-0.962 -0.519,-1.401 -2.673,-6.682 -6.598,-13.488 -8.106,-15.646 -4.379,-6.267 -9.087,-11.141 -12.265,-14.126 -6.046,-5.68 -6.963,-5.68 -7.771,-5.68 h -0.84 l -0.717,0.436 c -4.698,2.853 -16.421,11.284 -23.811,27.909 -0.253,0.571 -0.488,1.127 -0.71,1.673 -0.074,0.182 -0.141,0.359 -0.212,0.54 -0.142,0.357 -0.28,0.712 -0.409,1.06 -0.078,0.21 -0.15,0.417 -0.224,0.624 -0.51,1.431 -0.923,2.783 -1.267,4.076 -0.001,0.005 -0.003,0.009 -0.004,0.014 -0.267,1.006 -0.5,1.981 -0.703,2.931 10e-4,0.002 0.002,0.004 0.004,0.006 -0.043,0.2 -0.092,0.405 -0.133,0.602 -0.034,0.165 -0.502,2.238 -0.916,4.436 -0.336,1.778 -0.633,3.748 -0.672,3.984 -1.447,8.643 -1.551,19.602 -0.28,31.152 0.194,1.766 0.384,3.418 0.547,4.794 0.016,0.131 0.031,0.26 0.046,0.386 0,0 0.261,2.34 0.348,3.072 0.092,0.769 0.368,2.928 0.368,2.928 0.018,0.138 0.037,0.276 0.057,0.415 0.183,1.322 0.416,2.659 0.675,3.998 0.218,1.183 0.46,2.366 0.738,3.549 0.16,0.677 0.349,1.346 0.525,2.019 h -0.018 c 0.115,0.436 0.237,0.871 0.358,1.306 0.064,0.229 0.127,0.457 0.193,0.686 0.31,1.078 0.639,2.15 0.989,3.216 0.052,0.158 0.107,0.313 0.159,0.469 0.341,1.017 0.699,2.028 1.075,3.033 0.048,0.128 0.093,0.257 0.141,0.385 0.413,1.09 0.848,2.173 1.301,3.25 0.064,0.154 0.13,0.307 0.195,0.46 0.956,2.244 1.994,4.46 3.108,6.646 0.03,0.057 0.058,0.116 0.088,0.174 5.876,11.479 13.808,22.126 22.549,31.751 -1.222,1.355 -2.427,2.68 -3.543,3.907 -1.096,1.203 -2.103,2.309 -2.956,3.259 -2.127,2.37 -3.942,4.499 -5.722,6.743 -20.131,-24.054 -29.604,-44.45 -34.03,-58.838 -0.016,-0.049 -0.029,-0.096 -0.044,-0.145 -0.142,-0.463 -0.28,-0.922 -0.412,-1.372 -0.026,-0.094 -0.051,-0.182 -0.078,-0.275 -0.116,-0.403 -0.231,-0.804 -0.34,-1.197 -0.052,-0.192 -0.101,-0.377 -0.152,-0.567 -0.078,-0.287 -0.157,-0.577 -0.23,-0.858 -0.122,-0.468 -0.239,-0.929 -0.35,-1.381 -0.051,-0.209 -0.098,-0.439 -0.148,-0.652 h -0.001 c -0.589,-2.513 -1.109,-5.359 -1.557,-8.5 -0.002,-0.001 -0.004,-0.002 -0.007,-0.002 -0.012,-0.084 -0.025,-0.164 -0.036,-0.248 -0.03,-0.208 -0.152,-1.231 -0.267,-2.206 -0.116,-0.978 -0.392,-2.917 -0.593,-4.781 -0.084,-0.777 -0.174,-1.704 -0.26,-2.767 -0.055,-0.677 -0.306,-4.19 -0.39,-5.12 -0.1,-1.108 -0.323,-4.591 -0.351,-5.558 -0.053,-1.824 -0.064,-3.902 -0.016,-6.383 0.101,-5.257 0.267,-10.892 1.093,-16.841 0.074,-0.534 0.33,-2.165 0.455,-2.876 0.11,-0.631 0.246,-1.401 0.364,-2.078 0.127,-0.728 0.242,-1.388 0.333,-1.908 0.123,-0.705 0.385,-2.07 0.478,-2.52 0.094,-0.453 0.193,-0.911 0.292,-1.369 0,0 0.001,-10e-4 0.002,-10e-4 0.023,-0.11 0.044,-0.217 0.068,-0.328 l 0.101,-0.468 c 0.17,-0.79 0.356,-1.566 0.547,-2.338 0.186,-0.737 0.38,-1.465 0.583,-2.187 7.473,-26.664 27.968,-42.636 45.831,-53.672 6.625,4.46 32.956,23.343 43.893,48.561 0.27,0.621 1.087,2.397 1.968,4.593 0.671,1.672 1.382,3.621 1.774,4.712 h -0.003 c 0.122,0.332 0.246,0.687 0.371,1.048 0.037,0.106 0.073,0.209 0.11,0.318 0.126,0.374 0.254,0.763 0.382,1.17 0.012,0.04 0.024,0.077 0.037,0.117 0.135,0.432 0.269,0.889 0.404,1.36 0.045,0.155 0.089,0.318 0.133,0.479 0.091,0.325 0.181,0.661 0.27,1.005 0.025,0.1 0.055,0.221 0.086,0.351 C 13.485,0.281 6.644,0.183 0.021,0.08 0.014,0.053 0.006,0.026 0,0"/>
-				</g>
-				<g transform="translate(425.4902,603.1548)">
-					<path style="fill:#006837;fill-opacity:1;fill-rule:nonzero;stroke:none" d="m 0,0 c -3.794,-0.166 -7.389,-0.381 -10.299,-0.577 0.199,-2.499 0.397,-4.436 0.506,-5.333 0.106,-0.877 0.23,-1.752 0.37,-2.624 0.048,-0.299 0.107,-0.595 0.158,-0.893 0.099,-0.573 0.196,-1.145 0.308,-1.716 0.07,-0.354 0.152,-0.706 0.227,-1.059 0.109,-0.513 0.215,-1.026 0.334,-1.537 0.088,-0.374 0.187,-0.746 0.28,-1.119 0.121,-0.486 0.24,-0.974 0.37,-1.458 0.104,-0.386 0.219,-0.769 0.329,-1.154 0.134,-0.469 0.265,-0.939 0.408,-1.407 0.119,-0.393 0.248,-0.783 0.374,-1.174 0.146,-0.456 0.29,-0.911 0.444,-1.365 0.134,-0.398 0.277,-0.794 0.418,-1.191 0.158,-0.444 0.314,-0.888 0.479,-1.33 0.148,-0.398 0.303,-0.795 0.458,-1.192 0.169,-0.436 0.337,-0.873 0.513,-1.308 0.162,-0.4 0.331,-0.799 0.498,-1.197 0.179,-0.427 0.359,-0.853 0.544,-1.277 0.176,-0.401 0.356,-0.8 0.536,-1.199 0.189,-0.419 0.38,-0.838 0.575,-1.256 0.187,-0.399 0.378,-0.797 0.57,-1.194 0.199,-0.412 0.399,-0.823 0.603,-1.232 0.2,-0.401 0.403,-0.8 0.607,-1.198 0.206,-0.401 0.413,-0.801 0.624,-1.199 0.212,-0.402 0.428,-0.803 0.645,-1.203 0.212,-0.39 0.425,-0.779 0.642,-1.167 0.224,-0.404 0.452,-0.806 0.681,-1.207 0.217,-0.38 0.436,-0.758 0.657,-1.135 0.237,-0.403 0.474,-0.805 0.715,-1.205 0.222,-0.371 0.447,-0.741 0.674,-1.109 0.247,-0.403 0.496,-0.806 0.747,-1.205 0.225,-0.359 0.453,-0.715 0.681,-1.071 0.26,-0.405 0.52,-0.81 0.784,-1.212 0.226,-0.345 0.455,-0.689 0.685,-1.032 0.272,-0.408 0.544,-0.815 0.821,-1.22 0.224,-0.328 0.451,-0.654 0.677,-0.98 0.287,-0.415 0.575,-0.829 0.866,-1.24 0.219,-0.309 0.441,-0.616 0.662,-0.923 0.303,-0.421 0.606,-0.842 0.912,-1.259 0.21,-0.286 0.422,-0.569 0.633,-0.853 0.324,-0.436 0.648,-0.871 0.975,-1.302 0.192,-0.253 0.387,-0.503 0.58,-0.754 0.348,-0.453 0.696,-0.907 1.047,-1.355 0.17,-0.217 0.343,-0.432 0.514,-0.649 0.379,-0.479 0.759,-0.958 1.141,-1.431 0.124,-0.153 0.25,-0.304 0.374,-0.457 0.43,-0.529 0.861,-1.057 1.295,-1.578 0.052,-0.063 0.105,-0.125 0.157,-0.187 4.33,-5.192 8.798,-9.985 13.115,-14.29 0.093,-0.093 0.328,-0.327 0.581,-0.579 0.235,-0.232 0.468,-0.46 0.702,-0.69 v -0.006 c 0.04,-0.04 0.078,-0.077 0.105,-0.103 0.677,-0.666 1.349,-1.32 2.015,-1.958 7.364,-7.049 14.964,-13.461 22.454,-19.195 0.003,0.002 0.007,0.003 0.01,0.004 0.44,-0.338 1.457,-1.113 2.04,-1.554 0.896,-0.673 1.789,-1.34 2.68,-1.994 0.03,-0.022 0.061,-0.045 0.091,-0.067 0.938,-0.687 1.872,-1.36 2.803,-2.025 0.457,-0.327 0.912,-0.646 1.368,-0.967 0.391,-0.277 0.783,-0.552 1.174,-0.825 0.037,-0.026 0.075,-0.053 0.112,-0.079 0.005,-0.003 0.012,-0.008 0.016,-0.012 0.658,-0.457 2.019,-1.39 2.366,-1.629 0.037,-0.025 0.074,-0.05 0.111,-0.075 0.569,-0.387 1.138,-0.771 1.703,-1.149 1.992,-1.334 3.959,-2.612 5.893,-3.835 -0.003,-0.002 -0.005,-0.005 -0.008,-0.007 0.818,-0.518 1.631,-1.027 2.435,-1.524 0.181,-0.112 0.36,-0.221 0.54,-0.331 0.78,-0.479 1.554,-0.951 2.321,-1.41 0.217,-0.13 0.43,-0.256 0.646,-0.385 0.725,-0.431 1.447,-0.858 2.158,-1.271 0.255,-0.149 0.506,-0.291 0.76,-0.438 0.666,-0.384 1.331,-0.765 1.985,-1.133 0.298,-0.169 0.591,-0.329 0.887,-0.494 0.6,-0.334 1.2,-0.667 1.787,-0.988 0.352,-0.191 0.694,-0.373 1.041,-0.559 0.525,-0.281 1.051,-0.566 1.566,-0.836 0.417,-0.219 0.823,-0.426 1.233,-0.638 0.431,-0.223 0.867,-0.451 1.29,-0.665 0.514,-0.26 1.012,-0.505 1.514,-0.752 0.311,-0.154 0.629,-0.315 0.935,-0.464 0.065,-0.032 0.248,-0.121 0.522,-0.254 0.12,-0.058 0.268,-0.129 0.424,-0.206 0.074,-0.035 0.153,-0.073 0.234,-0.113 0.144,-0.069 0.293,-0.142 0.458,-0.222 0.158,-0.077 0.323,-0.157 0.501,-0.243 0.095,-0.046 0.182,-0.089 0.283,-0.137 0.859,0.584 1.704,1.167 2.575,1.752 1.018,0.684 12.775,8.824 17.166,12.377 0.771,0.625 1.532,1.252 2.285,1.882 -0.397,0.155 -0.805,0.315 -1.219,0.478 -0.066,0.026 -0.132,0.052 -0.199,0.078 -0.451,0.178 -0.912,0.36 -1.379,0.545 -0.092,0.037 -0.183,0.073 -0.275,0.11 -0.459,0.183 -0.925,0.369 -1.395,0.557 -0.101,0.041 -0.201,0.081 -0.303,0.122 -0.467,0.188 -0.936,0.377 -1.408,0.569 -0.103,0.042 -0.206,0.083 -0.309,0.125 -0.474,0.193 -0.949,0.386 -1.42,0.58 -0.085,0.035 -0.169,0.07 -0.254,0.105 -0.453,0.186 -0.904,0.372 -1.35,0.558 -0.065,0.027 -0.132,0.054 -0.197,0.081 -0.469,0.196 -0.931,0.389 -1.387,0.581 -0.099,0.042 -0.197,0.083 -0.295,0.125 -0.448,0.189 -0.886,0.376 -1.316,0.561 -0.09,0.038 -0.18,0.077 -0.269,0.115 -0.427,0.183 -0.842,0.363 -1.245,0.54 -0.087,0.038 -0.173,0.076 -0.258,0.114 -0.402,0.176 -0.791,0.349 -1.164,0.517 -0.065,0.03 -0.13,0.059 -0.194,0.088 -0.383,0.173 -0.751,0.342 -1.096,0.503 -0.037,0.017 -0.071,0.033 -0.107,0.05 -0.362,0.17 -0.705,0.333 -1.018,0.487 -1.168,0.573 -2.364,1.173 -3.582,1.794 -0.815,0.415 -1.653,0.853 -2.489,1.288 -0.342,0.178 -0.678,0.351 -1.023,0.532 -1.099,0.578 -2.215,1.177 -3.343,1.787 -0.046,0.025 -0.092,0.049 -0.138,0.074 -1.141,0.618 -2.298,1.257 -3.463,1.907 -0.067,0.038 -0.133,0.073 -0.2,0.11 -0.233,0.13 -0.466,0.261 -0.699,0.392 -0.19,0.106 -0.381,0.216 -0.571,0.323 -0.449,0.254 -0.898,0.508 -1.35,0.766 -0.249,0.142 -0.494,0.279 -0.744,0.422 -0.34,0.195 -0.685,0.398 -1.028,0.597 -0.343,0.198 -0.685,0.397 -1.029,0.598 -0.036,0.02 -0.071,0.041 -0.107,0.062 -0.678,0.396 -1.353,0.79 -2.037,1.196 -0.101,0.06 -0.206,0.124 -0.307,0.185 -0.434,0.259 -0.871,0.525 -1.307,0.787 -0.642,0.387 -1.282,0.767 -1.929,1.162 -0.33,0.201 -0.66,0.406 -0.99,0.61 -0.287,0.176 -0.575,0.361 -0.862,0.539 -0.596,0.369 -1.192,0.741 -1.788,1.117 -0.32,0.2 -0.636,0.394 -0.955,0.596 -0.208,0.133 -0.415,0.263 -0.623,0.395 -0.174,0.111 -0.35,0.228 -0.524,0.34 -1.068,0.684 -2.137,1.377 -3.209,2.082 -9.109,5.989 -18.265,12.707 -26.727,19.98 h -0.01 c -0.913,0.785 -1.818,1.575 -2.714,2.373 -0.092,0.082 -0.188,0.162 -0.281,0.245 -0.189,0.168 -0.613,0.557 -1.071,0.977 -0.621,0.571 -1.303,1.2 -1.552,1.431 -0.424,0.393 -0.834,0.794 -1.253,1.189 -0.512,0.485 -1.027,0.967 -1.532,1.455 -1.144,1.107 -2.272,2.222 -3.374,3.348 -0.117,0.12 -0.232,0.241 -0.348,0.361 -0.919,0.947 -1.82,1.901 -2.705,2.861 -0.361,0.392 -0.724,0.782 -1.079,1.175 -0.345,0.384 -0.684,0.769 -1.024,1.155 -0.457,0.517 -0.908,1.036 -1.354,1.557 -0.272,0.319 -0.545,0.637 -0.813,0.956 -0.714,0.852 -1.418,1.706 -2.101,2.566 l -0.027,0.034 c -0.759,0.956 -1.497,1.919 -2.216,2.886 -0.029,0.04 -0.059,0.079 -0.089,0.119 -0.717,0.967 -1.413,1.94 -2.087,2.918 -0.047,0.068 -0.092,0.136 -0.139,0.205 -0.6,0.875 -1.18,1.754 -1.744,2.636 -0.093,0.145 -0.187,0.29 -0.279,0.435 -0.595,0.943 -1.171,1.889 -1.721,2.839 -0.057,0.097 -0.109,0.194 -0.165,0.291 -0.481,0.839 -0.943,1.682 -1.389,2.526 -0.111,0.211 -0.223,0.422 -0.332,0.633 -0.482,0.933 -0.947,1.869 -1.383,2.809 -0.038,0.082 -0.072,0.164 -0.11,0.245 -0.392,0.856 -0.762,1.715 -1.115,2.576 -0.099,0.242 -0.197,0.484 -0.294,0.726 -0.373,0.941 -0.731,1.884 -1.054,2.831 C 6.573,-11.543 5.552,-2.558 5.441,-1.55 5.394,-1.122 5.337,-0.518 5.277,0.211 V 0.213 C 3.514,0.152 1.764,0.077 0,0"/>
-				</g>
-				<g transform="translate(573.5146,625.2163)">
-					<path style="fill:#006837;fill-opacity:1;fill-rule:nonzero;stroke:none" d="m 0,0 c -1.368,0.456 -2.737,0.893 -4.104,1.311 -0.015,0.004 -0.03,0.009 -0.045,0.014 -0.668,0.204 -1.336,0.404 -2.002,0.599 -0.069,0.02 -0.136,0.039 -0.203,0.059 -1.977,0.577 -3.948,1.118 -5.903,1.622 -0.202,0.052 -0.403,0.101 -0.604,0.153 -1.147,0.291 -2.289,0.574 -3.424,0.842 -0.074,0.018 -0.148,0.034 -0.222,0.051 -1.258,0.297 -2.508,0.579 -3.747,0.848 -0.065,0.014 -0.13,0.027 -0.195,0.041 -1.245,0.269 -2.48,0.524 -3.701,0.766 -0.11,0.022 -0.217,0.042 -0.327,0.063 -0.533,0.105 -1.065,0.209 -1.593,0.308 -0.079,0.015 -0.159,0.03 -0.238,0.045 -0.552,0.104 -1.104,0.206 -1.65,0.305 -0.186,0.033 -0.367,0.064 -0.552,0.097 -0.442,0.079 -0.885,0.158 -1.322,0.233 -0.137,0.024 -0.271,0.046 -0.406,0.069 -0.48,0.081 -0.957,0.163 -1.431,0.241 -0.247,0.041 -0.49,0.078 -0.735,0.118 -0.36,0.058 -0.72,0.117 -1.075,0.173 -0.25,0.039 -0.495,0.075 -0.743,0.113 -0.348,0.054 -0.698,0.108 -1.043,0.159 -0.304,0.046 -0.604,0.088 -0.906,0.132 -0.278,0.041 -0.559,0.083 -0.835,0.122 -0.419,0.059 -0.83,0.116 -1.242,0.172 -0.156,0.021 -0.315,0.044 -0.471,0.065 -0.373,0.05 -0.739,0.098 -1.107,0.146 -0.192,0.025 -0.386,0.051 -0.576,0.075 -0.476,0.061 -0.945,0.12 -1.411,0.177 -0.074,0.008 -0.149,0.018 -0.221,0.027 -0.397,0.048 -0.785,0.094 -1.175,0.139 -0.144,0.017 -0.292,0.035 -0.435,0.051 -4.737,0.545 -8.914,0.89 -12.303,1.108 1.05,-5.132 1.906,-10.835 2.45,-17.359 0.497,-5.967 0.777,-11.682 0.852,-17.144 2.535,-0.541 5.113,-1.146 7.713,-1.813 0.003,-0.001 0.006,-0.002 0.01,-0.003 0.517,-0.132 1.033,-0.268 1.551,-0.405 l 0.032,-0.009 c 1.03,-0.273 2.065,-0.557 3.099,-0.851 0.044,-0.012 0.088,-0.025 0.132,-0.037 0.481,-0.137 0.962,-0.276 1.443,-0.416 0.027,-0.008 0.055,-0.016 0.081,-0.025 0.497,-0.145 0.994,-0.293 1.492,-0.444 0.033,-0.009 0.067,-0.02 0.101,-0.03 0.487,-0.148 0.974,-0.297 1.463,-0.45 0.081,-0.025 0.163,-0.051 0.245,-0.077 0.444,-0.139 0.888,-0.279 1.333,-0.423 0.048,-0.015 0.096,-0.031 0.142,-0.046 0.476,-0.153 0.951,-0.308 1.424,-0.465 0.07,-0.023 0.139,-0.047 0.207,-0.07 0.451,-0.15 0.903,-0.302 1.353,-0.456 0.109,-0.037 0.218,-0.076 0.327,-0.113 0.411,-0.142 0.823,-0.284 1.233,-0.429 0.115,-0.04 0.228,-0.081 0.341,-0.122 0.406,-0.144 0.812,-0.288 1.217,-0.435 0.116,-0.043 0.232,-0.086 0.349,-0.129 0.399,-0.146 0.798,-0.293 1.197,-0.442 0.142,-0.054 0.285,-0.109 0.428,-0.163 0.371,-0.14 0.741,-0.28 1.111,-0.422 0.165,-0.064 0.329,-0.13 0.494,-0.194 0.347,-0.136 0.693,-0.27 1.038,-0.408 0.164,-0.065 0.327,-0.132 0.492,-0.198 0.345,-0.139 0.691,-0.278 1.034,-0.419 0.169,-0.07 0.338,-0.141 0.507,-0.211 0.334,-0.139 0.668,-0.277 1,-0.418 0.192,-0.081 0.381,-0.164 0.573,-0.245 0.31,-0.134 0.622,-0.266 0.931,-0.401 0.184,-0.081 0.367,-0.163 0.551,-0.245 0.312,-0.137 0.625,-0.275 0.935,-0.415 0.205,-0.092 0.407,-0.186 0.611,-0.28 0.287,-0.13 0.575,-0.261 0.86,-0.394 0.215,-0.099 0.427,-0.201 0.641,-0.302 0.273,-0.129 0.548,-0.257 0.819,-0.388 0.229,-0.109 0.455,-0.221 0.683,-0.332 0.252,-0.123 0.505,-0.245 0.755,-0.369 0.242,-0.12 0.48,-0.242 0.72,-0.363 0.236,-0.119 0.473,-0.237 0.708,-0.357 0.228,-0.117 0.454,-0.236 0.68,-0.354 0.242,-0.127 0.486,-0.252 0.728,-0.38 0.247,-0.13 0.49,-0.264 0.734,-0.395 0.217,-0.117 0.435,-0.232 0.648,-0.35 0.256,-0.14 0.509,-0.283 0.762,-0.424 0.203,-0.114 0.407,-0.226 0.609,-0.34 0.238,-0.135 0.472,-0.273 0.709,-0.409 0.212,-0.123 0.426,-0.244 0.637,-0.368 0.243,-0.143 0.483,-0.289 0.724,-0.433 0.199,-0.119 0.4,-0.237 0.598,-0.357 0.252,-0.154 0.5,-0.31 0.749,-0.464 0.183,-0.115 0.368,-0.227 0.549,-0.342 0.256,-0.162 0.508,-0.326 0.761,-0.489 0.171,-0.11 0.344,-0.219 0.513,-0.33 0.252,-0.165 0.498,-0.333 0.746,-0.499 0.168,-0.112 0.338,-0.223 0.504,-0.336 0.238,-0.163 0.472,-0.328 0.707,-0.492 0.172,-0.119 0.346,-0.237 0.515,-0.358 0.253,-0.179 0.5,-0.361 0.75,-0.542 0.147,-0.107 0.295,-0.212 0.441,-0.319 0.246,-0.182 0.487,-0.365 0.728,-0.549 0.147,-0.11 0.294,-0.219 0.439,-0.33 0.238,-0.183 0.471,-0.369 0.705,-0.554 0.143,-0.112 0.287,-0.224 0.429,-0.337 0.233,-0.188 0.462,-0.378 0.691,-0.568 0.137,-0.113 0.276,-0.225 0.412,-0.339 0.243,-0.204 0.48,-0.41 0.717,-0.615 0.117,-0.102 0.236,-0.202 0.353,-0.304 0.248,-0.218 0.491,-0.44 0.734,-0.661 0.1,-0.091 0.203,-0.181 0.303,-0.273 0.23,-0.213 0.455,-0.428 0.679,-0.643 0.108,-0.102 0.219,-0.204 0.325,-0.307 0.238,-0.23 0.469,-0.464 0.701,-0.697 0.087,-0.088 0.177,-0.175 0.264,-0.264 0.217,-0.222 0.428,-0.446 0.639,-0.67 0.098,-0.103 0.198,-0.205 0.294,-0.309 0.198,-0.213 0.389,-0.429 0.581,-0.644 0.104,-0.116 0.21,-0.231 0.313,-0.348 0.181,-0.207 0.356,-0.417 0.532,-0.626 0.107,-0.127 0.218,-0.252 0.322,-0.379 0.178,-0.216 0.348,-0.434 0.52,-0.651 0.097,-0.123 0.198,-0.244 0.294,-0.368 0.176,-0.229 0.346,-0.46 0.517,-0.691 0.085,-0.115 0.173,-0.228 0.256,-0.342 0.175,-0.243 0.343,-0.488 0.512,-0.734 0.072,-0.105 0.148,-0.208 0.218,-0.313 0.167,-0.248 0.326,-0.497 0.485,-0.747 0.067,-0.105 0.138,-0.209 0.204,-0.315 0.146,-0.235 0.285,-0.474 0.426,-0.711 0.072,-0.122 0.148,-0.243 0.218,-0.365 0.129,-0.225 0.249,-0.452 0.373,-0.678 0.075,-0.138 0.154,-0.274 0.226,-0.412 0.113,-0.216 0.219,-0.435 0.327,-0.652 0.074,-0.151 0.154,-0.3 0.226,-0.452 0.107,-0.225 0.206,-0.453 0.307,-0.681 0.065,-0.145 0.134,-0.289 0.197,-0.435 0.099,-0.231 0.189,-0.465 0.282,-0.698 0.058,-0.145 0.119,-0.288 0.175,-0.434 0.093,-0.247 0.177,-0.496 0.264,-0.745 0.047,-0.134 0.098,-0.265 0.142,-0.399 0.083,-0.25 0.156,-0.503 0.232,-0.756 0.04,-0.134 0.085,-0.268 0.124,-0.403 0.074,-0.259 0.137,-0.521 0.204,-0.782 0.032,-0.13 0.07,-0.259 0.1,-0.39 0.057,-0.238 0.104,-0.48 0.153,-0.72 0.032,-0.156 0.07,-0.31 0.099,-0.467 0.048,-0.254 0.085,-0.509 0.126,-0.765 0.023,-0.145 0.051,-0.288 0.071,-0.434 0.039,-0.279 0.069,-0.559 0.099,-0.84 0.014,-0.125 0.032,-0.248 0.044,-0.374 0.026,-0.283 0.043,-0.57 0.06,-0.856 0.008,-0.124 0.021,-0.247 0.027,-0.372 0.019,-0.411 0.029,-0.825 0.029,-1.241 0,-0.407 -0.011,-0.822 -0.033,-1.245 -0.006,-0.122 -0.021,-0.249 -0.028,-0.372 -0.021,-0.304 -0.039,-0.608 -0.071,-0.919 -0.016,-0.162 -0.042,-0.331 -0.061,-0.495 -0.032,-0.279 -0.063,-0.555 -0.104,-0.839 -0.026,-0.182 -0.062,-0.369 -0.092,-0.552 -0.044,-0.275 -0.085,-0.548 -0.138,-0.827 -0.033,-0.175 -0.074,-0.356 -0.111,-0.532 -0.059,-0.295 -0.116,-0.587 -0.184,-0.887 -0.045,-0.193 -0.098,-0.393 -0.146,-0.588 -0.07,-0.289 -0.137,-0.575 -0.214,-0.868 -0.055,-0.204 -0.119,-0.414 -0.177,-0.62 -0.082,-0.291 -0.16,-0.581 -0.249,-0.876 -0.065,-0.212 -0.138,-0.429 -0.205,-0.643 -0.094,-0.295 -0.184,-0.588 -0.284,-0.886 -0.076,-0.223 -0.161,-0.451 -0.24,-0.676 -0.104,-0.296 -0.204,-0.591 -0.315,-0.891 -0.081,-0.219 -0.172,-0.442 -0.257,-0.663 -0.119,-0.311 -0.235,-0.62 -0.362,-0.935 -0.092,-0.228 -0.193,-0.46 -0.288,-0.69 -0.13,-0.312 -0.257,-0.622 -0.394,-0.937 -0.102,-0.238 -0.215,-0.479 -0.322,-0.718 -0.14,-0.313 -0.277,-0.625 -0.424,-0.941 -0.112,-0.241 -0.233,-0.486 -0.35,-0.73 -0.152,-0.318 -0.3,-0.634 -0.459,-0.955 -0.128,-0.257 -0.264,-0.518 -0.396,-0.778 -0.157,-0.309 -0.311,-0.618 -0.475,-0.93 -0.141,-0.27 -0.293,-0.545 -0.439,-0.817 -0.165,-0.306 -0.325,-0.611 -0.496,-0.919 -0.151,-0.272 -0.311,-0.547 -0.465,-0.82 -0.177,-0.313 -0.35,-0.624 -0.533,-0.938 -0.16,-0.277 -0.33,-0.556 -0.496,-0.834 -0.188,-0.315 -0.372,-0.629 -0.565,-0.946 -0.173,-0.282 -0.354,-0.568 -0.531,-0.852 -0.196,-0.315 -0.389,-0.628 -0.59,-0.945 -0.187,-0.292 -0.383,-0.587 -0.574,-0.88 -0.203,-0.312 -0.403,-0.623 -0.612,-0.936 -0.195,-0.294 -0.4,-0.59 -0.6,-0.885 -0.215,-0.316 -0.426,-0.631 -0.646,-0.948 -0.213,-0.306 -0.433,-0.613 -0.651,-0.92 -0.218,-0.307 -0.431,-0.614 -0.653,-0.922 -0.23,-0.318 -0.468,-0.636 -0.702,-0.955 -0.223,-0.302 -0.441,-0.603 -0.668,-0.906 -0.237,-0.315 -0.483,-0.632 -0.725,-0.948 -0.235,-0.308 -0.466,-0.615 -0.706,-0.923 -0.251,-0.322 -0.51,-0.645 -0.766,-0.967 -0.241,-0.304 -0.478,-0.606 -0.723,-0.911 -0.269,-0.332 -0.546,-0.666 -0.82,-0.999 -0.244,-0.296 -0.483,-0.591 -0.731,-0.887 -0.282,-0.338 -0.573,-0.677 -0.861,-1.014 -0.25,-0.294 -0.497,-0.587 -0.75,-0.88 -0.294,-0.34 -0.597,-0.68 -0.896,-1.019 -0.259,-0.294 -0.514,-0.587 -0.776,-0.881 -0.306,-0.34 -0.619,-0.681 -0.931,-1.022 -0.267,-0.293 -0.53,-0.586 -0.802,-0.88 -0.152,-0.164 -0.309,-0.329 -0.465,-0.494 -0.079,-0.085 -0.16,-0.17 -0.24,-0.256 -0.086,-0.091 -0.172,-0.183 -0.258,-0.274 -0.276,-0.293 -0.548,-0.586 -0.829,-0.879 -0.24,-0.25 -0.485,-0.5 -0.729,-0.75 -0.142,-0.147 -0.283,-0.292 -0.426,-0.439 -0.231,-0.238 -0.461,-0.476 -0.696,-0.714 -0.342,-0.346 -0.693,-0.691 -1.04,-1.036 -0.012,-0.012 -0.025,-0.024 -0.036,-0.036 -0.15,-0.148 -0.297,-0.296 -0.448,-0.444 -0.128,-0.128 -0.255,-0.255 -0.385,-0.383 -0.355,-0.348 -0.719,-0.696 -1.082,-1.044 -0.119,-0.114 -0.238,-0.229 -0.356,-0.343 l -0.002,0.001 c -3.299,-3.156 -6.836,-6.293 -10.619,-9.375 -4.699,-3.829 -19.983,-14.365 -22.301,-15.955 -0.785,-0.538 -1.556,-1.075 -2.33,-1.612 -0.879,-0.609 -1.749,-1.218 -2.614,-1.826 -0.474,-0.333 -0.948,-0.666 -1.418,-0.998 -0.713,-0.505 -1.419,-1.009 -2.122,-1.512 -0.574,-0.411 -1.15,-0.822 -1.717,-1.232 -0.585,-0.423 -1.162,-0.844 -1.74,-1.266 -0.637,-0.464 -1.276,-0.928 -1.904,-1.39 -15.948,-11.745 -29.332,-23.14 -40.556,-34.014 1.672,-2.297 3.493,-4.437 5.803,-7.009 1.405,-1.565 3.435,-3.475 5.583,-5.498 0.759,-0.714 1.543,-1.453 2.331,-2.205 14.756,12.572 26.612,17.196 35.179,22.947 0.592,0.397 3.949,2.501 4.486,2.863 1.372,-3.207 4.547,1.734 4.389,2.003 -1.463,2.497 0.348,0.731 2.576,2.29 2.493,1.745 4.038,1.392 6.872,2.481 2.208,0.85 3.135,5.223 4.198,3.245 2.509,1.483 2.01,5.591 5.199,7.569 h 0.001 c 1.832,1.135 3.754,2.343 5.761,3.626 l 1.359,0.928 c 8.952,6.105 22.478,15.497 28.771,20.211 1.705,1.277 4.568,3.511 5.165,3.99 0.141,0.114 0.282,0.231 0.423,0.345 v 0.001 c 0.059,0.046 0.117,0.093 0.175,0.141 0.768,0.619 1.535,1.241 2.299,1.87 0.149,0.122 0.298,0.245 0.446,0.368 0.841,0.696 1.678,1.396 2.511,2.1 0.229,0.194 0.456,0.388 0.684,0.582 0.797,0.678 1.59,1.36 2.378,2.047 0.131,0.116 0.264,0.23 0.396,0.345 0.903,0.792 1.801,1.589 2.69,2.391 0.128,0.115 0.256,0.23 0.384,0.346 0.431,0.391 0.86,0.782 1.287,1.175 0.292,0.269 0.585,0.538 0.875,0.808 0.418,0.389 0.833,0.778 1.248,1.169 0.292,0.276 0.584,0.552 0.875,0.829 0.409,0.39 0.813,0.781 1.216,1.173 0.287,0.278 0.575,0.555 0.859,0.834 0.404,0.398 0.803,0.797 1.203,1.196 0.276,0.276 0.555,0.551 0.828,0.829 0.401,0.405 0.797,0.813 1.191,1.22 0.265,0.273 0.532,0.544 0.792,0.818 0.403,0.419 0.797,0.841 1.193,1.262 0.247,0.263 0.497,0.526 0.741,0.789 0.418,0.452 0.827,0.905 1.236,1.358 0.213,0.235 0.429,0.469 0.639,0.704 0.522,0.585 1.035,1.172 1.543,1.76 0.09,0.103 0.184,0.207 0.272,0.31 0.595,0.693 1.179,1.386 1.752,2.081 0.173,0.21 0.339,0.421 0.51,0.631 0.395,0.485 0.789,0.969 1.173,1.455 0.217,0.276 0.425,0.552 0.639,0.827 0.327,0.422 0.656,0.844 0.974,1.268 0.227,0.301 0.445,0.603 0.666,0.904 0.293,0.398 0.588,0.797 0.873,1.196 0.225,0.314 0.441,0.628 0.659,0.942 0.272,0.389 0.543,0.777 0.806,1.167 0.217,0.321 0.427,0.642 0.638,0.963 0.251,0.382 0.502,0.764 0.744,1.146 0.208,0.328 0.409,0.655 0.61,0.982 0.234,0.378 0.465,0.756 0.69,1.134 0.195,0.33 0.385,0.66 0.574,0.989 0.216,0.376 0.429,0.752 0.636,1.128 0.182,0.333 0.36,0.665 0.536,0.997 0.198,0.374 0.392,0.747 0.582,1.121 0.168,0.333 0.333,0.667 0.495,1 0.181,0.374 0.356,0.747 0.527,1.12 0.154,0.333 0.304,0.666 0.45,0.999 0.164,0.374 0.32,0.747 0.474,1.121 0.137,0.331 0.272,0.662 0.401,0.993 0.146,0.376 0.284,0.752 0.42,1.127 0.119,0.328 0.238,0.656 0.349,0.983 0.129,0.38 0.247,0.759 0.364,1.138 0.101,0.323 0.204,0.646 0.296,0.969 0.111,0.384 0.208,0.768 0.307,1.151 0.082,0.316 0.167,0.632 0.24,0.948 0.092,0.394 0.17,0.788 0.249,1.181 0.062,0.304 0.128,0.607 0.182,0.91 0.073,0.414 0.13,0.826 0.188,1.238 0.04,0.282 0.089,0.564 0.122,0.846 0.055,0.458 0.089,0.913 0.125,1.369 0.019,0.235 0.047,0.471 0.061,0.706 0.041,0.689 0.061,1.377 0.059,2.063 C 64.368,-39.416 42.66,-14.213 0,0"/>
-				</g>
-				<g transform="translate(655.5654,394.8437)">
-					<path style="fill:#006837;fill-opacity:1;fill-rule:nonzero;stroke:none" d="m 0,0 c -0.006,0.123 -0.01,0.247 -0.017,0.369 -2.084,39.78 -34.466,65.277 -52.671,76.538 -1.902,1.176 -6.685,3.577 -11.144,5.577 -0.186,-0.141 -0.31,-0.234 -0.342,-0.259 -8.905,-6.963 -17.885,-13.258 -26.007,-18.614 0.987,-0.496 1.95,-1.011 2.892,-1.541 0.138,-0.074 0.265,-0.143 0.364,-0.2 20.623,-11.715 31.074,-31.364 31.099,-58.542 0.023,-30.396 -18.699,-52.83 -54.147,-64.879 -0.943,-0.32 -1.885,-0.628 -2.827,-0.927 -0.333,-0.105 -0.665,-0.204 -0.997,-0.306 -0.603,-0.187 -1.207,-0.373 -1.808,-0.55 -0.321,-0.096 -0.64,-0.186 -0.96,-0.278 v 0.001 c -2.921,-0.842 -5.811,-1.584 -8.634,-2.235 v -0.002 c -0.046,-0.01 -0.091,-0.019 -0.137,-0.03 -1.11,-0.255 -2.211,-0.496 -3.299,-0.724 -0.346,-0.073 -0.687,-0.14 -1.032,-0.211 -0.36,-0.073 -0.726,-0.151 -1.084,-0.221 -0.002,0.002 -0.005,0.004 -0.007,0.006 -0.62,-0.122 -1.25,-0.253 -1.86,-0.368 -0.059,-0.01 -1.678,-0.33 -3.307,-0.604 -1.635,-0.274 -3.278,-0.506 -3.325,-0.514 -8.653,-1.3 -15.779,-1.781 -19.931,-1.957 -0.057,-0.002 -1.644,-0.051 -3.213,-0.076 -1.733,-0.028 -3.46,-0.031 -3.46,-0.031 l -5.483,-0.011 -12.978,-0.028 -31.249,-0.067 -1.423,-0.003 c -0.185,-1.542 -0.426,-3.601 -0.674,-5.848 -1.286,-11.692 -1.08,-23.106 0.566,-31.315 0.041,-0.202 0.08,-0.402 0.119,-0.603 0.646,0.014 1.313,0.027 1.965,0.042 0.21,0.005 0.334,0.008 0.355,0.008 10.427,0.224 21.552,0.44 33.394,0.646 0.24,0.004 0.475,0.009 0.715,0.013 1.836,0.031 3.693,0.062 5.564,0.094 0.321,0.005 0.634,0.011 0.957,0.016 1.463,0.025 2.952,0.048 4.436,0.072 0.666,0.011 1.323,0.022 1.994,0.033 0.027,0 1.579,0.037 3.062,0.06 1.689,0.026 3.337,0.038 3.359,0.038 6.526,0.103 13.247,0.198 20.176,0.292 0.031,0 1.748,0.031 3.387,0.076 1.527,0.044 2.983,0.104 2.997,0.104 0.702,0.035 1.488,0.08 2.312,0.131 0.497,0.03 1.021,0.064 1.561,0.1 0.236,0.017 0.482,0.035 0.727,0.052 0.418,0.03 0.846,0.063 1.286,0.096 0.292,0.022 0.591,0.047 0.892,0.071 4.422,0.36 9.843,0.928 15.949,1.831 0.053,0.008 0.105,0.015 0.158,0.023 0.982,0.146 1.984,0.301 2.999,0.466 0.098,0.015 0.195,0.031 0.293,0.046 0.984,0.161 1.984,0.33 2.997,0.507 0.135,0.025 0.271,0.048 0.408,0.073 0.993,0.175 2,0.361 3.016,0.554 0.161,0.03 0.319,0.061 0.479,0.092 1.008,0.193 2.026,0.397 3.055,0.609 0.174,0.037 0.348,0.073 0.523,0.109 1.025,0.215 2.061,0.438 3.104,0.672 0.182,0.041 0.367,0.082 0.55,0.124 1.042,0.235 2.093,0.481 3.151,0.736 0.186,0.046 0.374,0.092 0.56,0.137 1.065,0.26 2.135,0.53 3.211,0.811 0.182,0.047 0.365,0.096 0.548,0.145 1.088,0.287 2.181,0.584 3.279,0.893 0.168,0.047 0.337,0.097 0.506,0.145 1.118,0.318 2.241,0.646 3.367,0.988 0.143,0.044 0.286,0.089 0.428,0.132 1.155,0.354 2.314,0.72 3.475,1.1 0.104,0.034 0.21,0.07 0.314,0.105 1.188,0.391 2.376,0.794 3.566,1.214 0.064,0.023 0.13,0.046 0.194,0.069 1.184,0.419 2.368,0.855 3.552,1.303 0.092,0.035 0.185,0.068 0.278,0.104 1.172,0.447 2.344,0.911 3.513,1.387 0.134,0.055 0.267,0.108 0.4,0.162 1.142,0.469 2.28,0.954 3.416,1.452 0.158,0.07 0.317,0.137 0.474,0.207 1.116,0.495 2.228,1.005 3.337,1.529 0.174,0.082 0.347,0.163 0.521,0.246 1.096,0.523 2.188,1.063 3.274,1.617 0.178,0.091 0.357,0.182 0.536,0.274 1.079,0.555 2.15,1.127 3.216,1.713 0.181,0.1 0.363,0.201 0.544,0.301 1.062,0.592 2.116,1.198 3.162,1.82 0.175,0.105 0.351,0.21 0.526,0.316 1.048,0.631 2.088,1.277 3.117,1.94 0.164,0.107 0.327,0.214 0.491,0.321 1.037,0.675 2.063,1.366 3.078,2.076 0.146,0.102 0.291,0.206 0.436,0.309 1.026,0.726 2.042,1.467 3.043,2.229 0.122,0.093 0.243,0.188 0.364,0.282 1.02,0.782 2.026,1.581 3.016,2.402 0.091,0.077 0.181,0.155 0.271,0.231 1.015,0.849 2.016,1.715 2.996,2.605 0.052,0.047 0.102,0.095 0.154,0.142 1.015,0.927 2.014,1.875 2.991,2.849 16.65,16.607 25.094,37.948 25.094,63.429 C 0.093,-2.44 0.058,-1.215 0,0"/>
-				</g>
-				<g transform="translate(494.8076,341.4551)">
-					<path style="fill:#006837;fill-opacity:1;fill-rule:nonzero;stroke:none" d="m 0,0 c 0.127,-1.346 0.237,-2.654 0.347,-3.963 h 0.001 c 0.003,-0.03 0.005,-0.059 0.006,-0.09 0.031,-0.359 0.067,-0.73 0.096,-1.088 0.042,-0.507 0.078,-1.007 0.117,-1.51 0.018,-0.233 0.036,-0.464 0.055,-0.698 0.008,-0.109 0.017,-0.219 0.025,-0.328 0.03,-0.376 0.061,-0.755 0.087,-1.124 0.055,-0.77 0.107,-1.535 0.156,-2.293 4.063,0.172 11.629,0.667 20.813,2.098 -0.005,0.237 -0.009,0.458 -0.013,0.665 -0.001,0.033 -0.002,0.068 -0.003,0.101 -0.002,0.174 -0.006,0.332 -0.009,0.476 -0.001,0.036 -0.002,0.076 -0.002,0.109 -0.003,0.126 -0.006,0.228 -0.009,0.324 0,0.022 -0.001,0.05 -0.002,0.071 -0.009,0.173 -0.014,0.335 -0.023,0.51 -0.002,0.037 -0.004,0.072 -0.006,0.109 -0.003,0.054 -0.008,0.111 -0.011,0.166 0,-0.001 0,-0.001 -0.001,-0.001 -0.009,0.156 -0.02,0.318 -0.029,0.476 -0.027,0.441 -0.054,0.884 -0.085,1.34 -0.015,0.22 -0.031,0.444 -0.047,0.668 -0.049,0.662 -0.103,1.338 -0.161,2.03 -0.01,0.113 -0.019,0.223 -0.029,0.337 -0.069,0.799 -0.146,1.619 -0.228,2.455 -0.014,0.13 -0.025,0.258 -0.039,0.389 -0.042,0.417 -0.086,0.839 -0.131,1.265 -0.03,0.279 -0.06,0.558 -0.09,0.84 -0.051,0.46 -0.104,0.928 -0.158,1.396 -0.029,0.253 -0.058,0.503 -0.088,0.759 -0.086,0.727 -0.175,1.462 -0.269,2.209 -0.158,1.246 -0.339,2.486 -0.541,3.72 -0.154,0.943 -0.329,1.873 -0.508,2.8 -0.045,0.234 -0.083,0.47 -0.13,0.705 -3.311,16.391 -10.709,30.312 -23.687,44.705 -0.21,0.232 -0.421,0.465 -0.633,0.698 0,0 -1.688,1.74 -2.59,2.688 -0.69,0.725 -1.417,1.458 -2.159,2.187 -1.31,1.288 -2.667,2.565 -3.948,3.772 -2.243,2.111 -4.362,4.106 -5.935,5.858 -4.362,4.857 -7.105,8.285 -10.235,13.78 -0.001,0 -0.002,0 -0.003,0 -0.04,0.075 -0.085,0.148 -0.125,0.222 -0.009,0.017 -0.017,0.034 -0.026,0.05 0,0 0,0 0,0.001 -0.23,0.406 -0.573,1.08 -0.837,1.608 -0.047,0.094 -0.104,0.213 -0.164,0.334 -0.045,0.089 -0.093,0.177 -0.137,0.267 -0.153,0.31 -0.292,0.624 -0.439,0.936 -0.212,0.451 -0.43,0.9 -0.631,1.354 -0.149,0.335 -0.284,0.674 -0.426,1.011 -0.184,0.435 -0.374,0.868 -0.549,1.305 -0.139,0.35 -0.264,0.703 -0.397,1.055 -0.162,0.429 -0.33,0.856 -0.483,1.288 -0.125,0.355 -0.238,0.714 -0.357,1.072 -0.144,0.431 -0.293,0.86 -0.428,1.293 -0.113,0.363 -0.212,0.728 -0.318,1.092 -0.126,0.431 -0.256,0.86 -0.373,1.293 -0.1,0.372 -0.186,0.746 -0.279,1.119 -0.107,0.428 -0.219,0.855 -0.317,1.284 -0.086,0.379 -0.159,0.76 -0.239,1.14 -0.089,0.427 -0.183,0.853 -0.264,1.281 -0.071,0.384 -0.131,0.769 -0.195,1.154 -0.073,0.426 -0.149,0.852 -0.213,1.279 -0.058,0.389 -0.102,0.78 -0.153,1.171 -0.055,0.425 -0.115,0.849 -0.162,1.275 -0.042,0.392 -0.073,0.785 -0.109,1.177 -0.038,0.427 -0.082,0.852 -0.112,1.28 -0.028,0.394 -0.043,0.788 -0.064,1.182 -0.023,0.428 -0.05,0.854 -0.064,1.282 -0.013,0.397 -0.014,0.794 -0.02,1.192 -0.006,0.425 -0.017,0.85 -0.015,1.276 0.002,0.4 0.016,0.801 0.025,1.201 0.01,0.424 0.016,0.848 0.034,1.272 0.017,0.4 0.045,0.801 0.069,1.201 0.026,0.424 0.048,0.849 0.082,1.273 0.032,0.401 0.075,0.802 0.115,1.204 0.041,0.423 0.079,0.846 0.128,1.269 0.048,0.403 0.106,0.805 0.161,1.207 0.057,0.421 0.11,0.842 0.175,1.262 0.063,0.403 0.136,0.805 0.206,1.206 0.072,0.42 0.142,0.84 0.223,1.259 0.077,0.402 0.165,0.803 0.25,1.204 0.088,0.418 0.174,0.837 0.27,1.254 0.093,0.402 0.196,0.802 0.296,1.202 0.104,0.416 0.205,0.831 0.316,1.246 0.108,0.4 0.226,0.799 0.341,1.199 0.119,0.413 0.236,0.825 0.363,1.237 0.124,0.4 0.257,0.799 0.388,1.198 0.134,0.408 0.265,0.816 0.407,1.223 0.139,0.399 0.288,0.797 0.434,1.195 0.149,0.404 0.296,0.809 0.452,1.211 0.155,0.399 0.319,0.795 0.481,1.191 0.164,0.399 0.325,0.798 0.496,1.196 0.171,0.396 0.35,0.791 0.528,1.185 0.178,0.396 0.355,0.791 0.541,1.184 0.186,0.395 0.381,0.786 0.575,1.179 0.192,0.388 0.383,0.777 0.582,1.164 0.203,0.392 0.415,0.783 0.625,1.174 0.206,0.383 0.411,0.766 0.625,1.147 0.219,0.39 0.447,0.778 0.673,1.166 0.22,0.376 0.439,0.753 0.666,1.127 0.136,0.224 0.273,0.448 0.412,0.672 0.003,0 0.005,0 0.008,0.001 1.196,1.926 2.479,3.823 3.869,5.68 0.02,0.026 0.237,0.281 0.592,0.695 0.001,0.002 0.004,0.006 0.006,0.008 -4.399,3.585 -8.735,7.347 -12.953,11.256 -0.044,-0.067 -0.087,-0.131 -0.133,-0.204 -0.251,-0.393 -0.515,-0.815 -0.794,-1.273 -0.668,-1.099 -1.349,-2.29 -2.041,-3.562 -0.017,-0.031 -0.034,-0.063 -0.051,-0.094 -0.703,-1.296 -1.416,-2.676 -2.129,-4.133 -0.013,-0.028 -0.027,-0.055 -0.041,-0.083 -0.342,-0.702 -0.685,-1.423 -1.026,-2.159 -0.033,-0.07 -0.065,-0.14 -0.098,-0.211 -0.332,-0.718 -0.662,-1.453 -0.991,-2.202 -0.04,-0.09 -0.079,-0.18 -0.119,-0.271 -0.327,-0.749 -0.651,-1.511 -0.973,-2.288 -0.037,-0.089 -0.073,-0.178 -0.11,-0.266 -0.326,-0.792 -0.649,-1.597 -0.968,-2.415 -0.025,-0.066 -0.05,-0.132 -0.075,-0.197 -0.669,-1.726 -1.32,-3.508 -1.944,-5.341 -0.012,-0.035 -0.024,-0.069 -0.036,-0.104 -0.3,-0.883 -0.592,-1.78 -0.879,-2.686 -0.031,-0.096 -0.061,-0.192 -0.092,-0.289 -0.275,-0.877 -0.543,-1.764 -0.804,-2.66 -0.036,-0.125 -0.073,-0.25 -0.108,-0.375 -0.256,-0.888 -0.504,-1.784 -0.744,-2.688 -0.035,-0.129 -0.068,-0.259 -0.102,-0.388 -0.239,-0.916 -0.472,-1.839 -0.693,-2.77 -0.025,-0.105 -0.049,-0.21 -0.073,-0.315 -0.228,-0.966 -0.446,-1.939 -0.652,-2.92 -0.007,-0.036 -0.014,-0.072 -0.021,-0.108 -0.208,-0.995 -0.404,-1.999 -0.587,-3.007 -0.01,-0.051 -0.02,-0.101 -0.029,-0.152 -0.177,-0.984 -0.34,-1.974 -0.492,-2.968 -0.018,-0.118 -0.037,-0.236 -0.056,-0.354 -0.143,-0.96 -0.273,-1.924 -0.392,-2.891 -0.018,-0.152 -0.037,-0.303 -0.055,-0.454 -0.113,-0.957 -0.213,-1.917 -0.299,-2.88 -0.014,-0.153 -0.026,-0.307 -0.04,-0.46 -0.083,-0.971 -0.152,-1.945 -0.206,-2.921 -0.008,-0.131 -0.013,-0.262 -0.02,-0.394 -0.051,-1.006 -0.089,-2.014 -0.108,-3.023 -10e-4,-0.07 -10e-4,-0.139 -0.002,-0.209 -0.017,-1.028 -0.016,-2.057 0.003,-3.085 0.001,-0.045 0.001,-0.09 0.002,-0.135 0.02,-1.018 0.063,-2.035 0.121,-3.052 0.008,-0.125 0.013,-0.25 0.021,-0.375 0.06,-0.977 0.141,-1.953 0.237,-2.927 0.016,-0.158 0.031,-0.315 0.048,-0.472 0.101,-0.96 0.221,-1.919 0.359,-2.874 0.023,-0.162 0.048,-0.324 0.073,-0.486 0.145,-0.96 0.308,-1.918 0.493,-2.873 0.028,-0.141 0.057,-0.281 0.086,-0.422 0.196,-0.979 0.409,-1.955 0.649,-2.926 0.022,-0.089 0.047,-0.176 0.069,-0.264 0.251,-1 0.523,-1.996 0.823,-2.985 0.008,-0.026 0.014,-0.053 0.023,-0.079 0.3,-0.988 0.631,-1.969 0.982,-2.944 0.039,-0.11 0.076,-0.22 0.116,-0.329 0.342,-0.932 0.711,-1.857 1.099,-2.775 0.062,-0.145 0.123,-0.29 0.185,-0.434 0.39,-0.9 0.804,-1.791 1.241,-2.676 0.076,-0.152 0.152,-0.304 0.229,-0.456 0.447,-0.883 0.916,-1.759 1.413,-2.627 0.078,-0.135 0.158,-0.269 0.236,-0.404 0.378,-0.647 0.784,-1.284 1.19,-1.922 0.056,-0.087 0.112,-0.176 0.171,-0.267 0.304,-0.473 1.189,-1.776 1.395,-2.072 3.827,-5.466 6.72,-9.098 10.794,-13.634 0.845,-0.941 1.843,-2.037 2.928,-3.23 3.204,-3.518 7.113,-7.812 10.192,-11.515 0.339,-0.409 1.402,-1.783 1.621,-2.063 C -11.102,37.246 -6.931,29.4 -4.111,20.594 -2.074,14.229 -0.69,7.3 0,0"/>
-				</g>
-				<g transform="translate(434.3071,645.5068)">
-					<path style="fill:#006837;fill-opacity:1;fill-rule:nonzero;stroke:none" d="m 0,0 c 0.341,1.517 2.536,7.824 3.019,8.953 2.124,4.973 3.949,8.058 4.847,9.454 7.281,11.303 16.23,19.054 16.608,19.379 l 1.713,1.472 1.888,-1.239 c 3.574,-2.345 12.382,-8.703 19.395,-19.47 2.448,-3.757 5.052,-9.568 7.423,-17.227 0.176,-0.569 0.348,-1.182 0.516,-1.83 0.09,-0.346 0.605,-2.791 0.796,-3.698 1.499,-7.16 2.617,-16.861 3.223,-24.624 0.634,-8.106 0.726,-14.453 0.64,-19.349 -0.018,-1.05 -0.141,-3.717 -0.214,-5.268 -0.014,-0.287 -0.025,-0.53 -0.034,-0.724 -0.004,-0.071 -0.007,-0.138 -0.01,-0.207 -0.002,-0.042 -0.004,-0.083 -0.006,-0.113 -0.001,-0.029 -0.003,-0.053 -0.004,-0.082 -0.019,-0.401 -0.039,-0.792 -0.057,-1.152 -0.036,-0.685 -0.068,-1.305 -0.092,-1.862 -0.048,-1.111 -0.115,-2.218 -0.2,-3.319 -0.027,-0.356 -0.067,-0.708 -0.097,-1.062 -0.065,-0.744 -0.129,-1.489 -0.211,-2.229 -0.046,-0.422 -0.104,-0.84 -0.156,-1.261 -0.082,-0.665 -0.161,-1.331 -0.257,-1.991 -0.064,-0.45 -0.141,-0.894 -0.211,-1.342 -0.099,-0.625 -0.195,-1.251 -0.306,-1.871 -0.082,-0.46 -0.173,-0.915 -0.262,-1.371 -0.116,-0.601 -0.231,-1.201 -0.357,-1.797 -0.098,-0.461 -0.206,-0.917 -0.31,-1.375 -0.133,-0.582 -0.267,-1.165 -0.41,-1.741 -0.114,-0.459 -0.236,-0.913 -0.357,-1.368 -0.15,-0.567 -0.302,-1.132 -0.462,-1.693 -0.129,-0.453 -0.265,-0.901 -0.401,-1.35 -0.167,-0.552 -0.336,-1.102 -0.514,-1.648 -0.144,-0.446 -0.294,-0.887 -0.445,-1.328 -0.184,-0.538 -0.371,-1.074 -0.565,-1.605 -0.159,-0.436 -0.322,-0.868 -0.487,-1.299 -0.201,-0.524 -0.406,-1.043 -0.616,-1.559 -0.173,-0.425 -0.349,-0.848 -0.528,-1.268 -0.218,-0.51 -0.441,-1.016 -0.668,-1.518 -0.186,-0.41 -0.373,-0.818 -0.564,-1.223 -0.236,-0.499 -0.478,-0.991 -0.724,-1.481 -0.196,-0.394 -0.394,-0.787 -0.597,-1.176 -0.255,-0.487 -0.516,-0.966 -0.78,-1.444 -0.207,-0.375 -0.414,-0.751 -0.626,-1.12 -0.275,-0.476 -0.557,-0.942 -0.84,-1.407 -0.216,-0.356 -0.43,-0.713 -0.652,-1.062 -0.296,-0.466 -0.601,-0.922 -0.905,-1.376 -0.035,-0.051 -0.07,-0.103 -0.104,-0.154 -0.257,-0.381 -0.508,-0.77 -0.771,-1.142 -0.052,-0.074 -0.132,-0.186 -0.228,-0.317 -0.03,-0.041 -0.069,-0.094 -0.102,-0.14 -0.073,-0.1 -0.149,-0.203 -0.237,-0.323 -0.052,-0.072 -0.109,-0.149 -0.165,-0.225 -0.093,-0.126 -0.187,-0.253 -0.287,-0.39 -0.028,-0.038 -0.056,-0.075 -0.084,-0.114 -0.064,-0.087 -0.125,-0.17 -0.191,-0.259 4.764,-3.823 9.702,-7.465 14.676,-10.907 1.177,1.461 2.361,2.999 2.995,3.876 0.029,0.041 0.06,0.083 0.087,0.121 0.076,0.108 0.146,0.207 0.201,0.288 0.382,0.563 0.747,1.123 1.115,1.684 0.309,0.469 0.613,0.938 0.912,1.406 0.248,0.386 0.493,0.773 0.733,1.159 0.296,0.473 0.584,0.944 0.87,1.415 0.229,0.377 0.457,0.754 0.68,1.13 0.288,0.486 0.567,0.972 0.845,1.457 0.206,0.358 0.413,0.716 0.614,1.073 0.293,0.523 0.574,1.045 0.855,1.567 0.171,0.318 0.348,0.636 0.515,0.954 0.356,0.677 0.699,1.353 1.037,2.028 0.08,0.162 0.166,0.323 0.245,0.483 0.408,0.828 0.8,1.654 1.18,2.48 0.135,0.295 0.261,0.589 0.393,0.884 0.242,0.54 0.485,1.081 0.714,1.622 0.147,0.343 0.285,0.688 0.427,1.031 0.203,0.492 0.404,0.984 0.598,1.476 0.141,0.36 0.276,0.721 0.413,1.081 0.18,0.478 0.358,0.955 0.53,1.433 0.131,0.367 0.259,0.733 0.385,1.1 0.163,0.474 0.322,0.949 0.476,1.425 0.119,0.365 0.237,0.731 0.351,1.097 0.149,0.483 0.294,0.967 0.435,1.451 0.104,0.358 0.209,0.715 0.309,1.073 0.14,0.503 0.27,1.008 0.401,1.512 0.088,0.34 0.179,0.678 0.262,1.018 0.137,0.559 0.264,1.119 0.39,1.68 0.063,0.285 0.132,0.57 0.194,0.857 0.181,0.847 0.351,1.697 0.506,2.55 l 0.034,0.191 c 0.247,1.355 0.467,2.751 0.671,4.168 0.033,0.23 0.067,0.459 0.1,0.69 0.195,1.411 0.369,2.85 0.522,4.32 0.017,0.166 0.032,0.335 0.05,0.502 0.316,3.163 0.539,6.455 0.663,9.879 0.004,0.099 0.008,0.197 0.012,0.297 0.008,0.268 0.022,0.65 0.038,1.097 0.002,0.057 0.002,0.115 0.004,0.171 h 0.002 c 0.07,2.055 0.174,5.376 0.165,6.547 -0.046,5.657 -0.327,11.616 -0.847,17.865 -0.105,1.248 -0.221,2.459 -0.347,3.643 -0.044,0.421 -0.095,0.822 -0.143,1.235 -0.085,0.75 -0.171,1.5 -0.265,2.225 -0.061,0.474 -0.129,0.93 -0.193,1.393 -0.089,0.639 -0.179,1.278 -0.274,1.898 -0.073,0.477 -0.151,0.939 -0.227,1.405 -0.096,0.584 -0.194,1.167 -0.295,1.736 -0.082,0.462 -0.168,0.917 -0.253,1.369 -0.105,0.55 -0.21,1.095 -0.319,1.632 -0.09,0.442 -0.182,0.88 -0.275,1.314 -0.113,0.528 -0.228,1.051 -0.347,1.567 -0.094,0.418 -0.19,0.834 -0.288,1.244 -0.124,0.518 -0.25,1.028 -0.378,1.535 -0.097,0.388 -0.195,0.777 -0.295,1.158 -0.118,0.45 -0.24,0.891 -0.361,1.333 -0.089,0.316 -0.185,0.655 -0.279,0.983 -0.001,0 -0.002,10e-4 -0.004,10e-4 -0.24,0.861 -0.491,1.694 -0.74,2.529 -0.145,0.482 -0.287,0.966 -0.434,1.441 -0.206,0.665 -0.417,1.319 -0.628,1.971 -0.136,0.421 -0.269,0.846 -0.408,1.262 -0.242,0.732 -0.489,1.453 -0.737,2.173 -0.112,0.324 -0.221,0.653 -0.334,0.975 -0.362,1.036 -0.728,2.064 -1.097,3.086 -3.331,9.212 -8.477,17.079 -14.281,23.761 -1.339,1.541 -5.463,5.868 -7.962,7.953 -2.116,1.766 -4.492,3.83 -6.125,5.125 -5.818,4.613 -12.151,8.47 -16.449,11.288 C 17.722,53.114 -11.813,28.247 -17.085,-3.163 -11.853,-3.164 -6.387,-3.167 -0.692,-3.172 -0.455,-2.054 -0.218,-0.97 0,0"/>
-				</g>
-				<g transform="translate(630.5645,327.7324)">
-					<path style="fill:#00ff00;fill-opacity:1;fill-rule:nonzero;stroke:none" d="m 0,0 c -0.977,-0.974 -1.976,-1.922 -2.991,-2.849 -0.052,-0.047 -0.102,-0.094 -0.154,-0.141 -0.98,-0.891 -1.981,-1.757 -2.996,-2.606 -0.09,-0.076 -0.18,-0.154 -0.271,-0.23 -0.99,-0.821 -1.996,-1.62 -3.016,-2.403 -0.121,-0.093 -0.242,-0.189 -0.364,-0.282 -1.001,-0.761 -2.017,-1.503 -3.043,-2.228 -0.145,-0.104 -0.29,-0.207 -0.436,-0.31 -1.015,-0.71 -2.042,-1.4 -3.078,-2.076 -0.164,-0.106 -0.327,-0.214 -0.491,-0.32 -1.029,-0.663 -2.069,-1.31 -3.117,-1.941 -0.175,-0.105 -0.351,-0.211 -0.526,-0.315 -1.046,-0.622 -2.1,-1.229 -3.162,-1.82 -0.181,-0.101 -0.363,-0.202 -0.544,-0.301 -1.066,-0.586 -2.137,-1.158 -3.216,-1.714 -0.179,-0.092 -0.358,-0.183 -0.536,-0.274 -1.086,-0.553 -2.178,-1.093 -3.274,-1.617 -0.174,-0.083 -0.347,-0.164 -0.521,-0.246 -1.109,-0.523 -2.221,-1.034 -3.337,-1.528 -0.157,-0.07 -0.316,-0.138 -0.474,-0.207 -1.136,-0.498 -2.274,-0.984 -3.416,-1.452 -0.133,-0.055 -0.266,-0.108 -0.4,-0.162 -1.169,-0.477 -2.341,-0.941 -3.513,-1.388 -0.093,-0.035 -0.186,-0.069 -0.278,-0.104 -1.184,-0.448 -2.368,-0.883 -3.552,-1.302 -0.065,-0.024 -0.13,-0.046 -0.194,-0.07 -1.19,-0.42 -2.378,-0.823 -3.566,-1.214 -0.104,-0.035 -0.21,-0.071 -0.314,-0.105 -1.161,-0.38 -2.32,-0.745 -3.475,-1.1 -0.142,-0.043 -0.285,-0.088 -0.428,-0.132 -1.126,-0.341 -2.249,-0.669 -3.367,-0.988 -0.169,-0.048 -0.338,-0.097 -0.506,-0.144 -1.098,-0.31 -2.191,-0.607 -3.279,-0.894 -0.183,-0.049 -0.366,-0.098 -0.548,-0.144 -1.076,-0.282 -2.146,-0.551 -3.211,-0.812 -0.186,-0.045 -0.374,-0.091 -0.56,-0.137 -1.058,-0.255 -2.109,-0.501 -3.151,-0.736 -0.183,-0.042 -0.368,-0.083 -0.55,-0.124 -1.043,-0.233 -2.079,-0.457 -3.104,-0.672 -0.175,-0.036 -0.349,-0.072 -0.523,-0.108 -1.029,-0.212 -2.047,-0.416 -3.055,-0.61 -0.16,-0.031 -0.318,-0.061 -0.479,-0.091 -1.016,-0.194 -2.023,-0.379 -3.016,-0.555 -0.137,-0.025 -0.273,-0.048 -0.408,-0.072 -1.013,-0.177 -2.013,-0.347 -2.998,-0.507 -0.097,-0.016 -0.194,-0.032 -0.292,-0.047 -1.015,-0.164 -2.017,-0.319 -2.999,-0.466 -0.053,-0.008 -0.105,-0.015 -0.158,-0.022 -6.106,-0.904 -11.527,-1.472 -15.949,-1.831 -0.301,-0.025 -0.6,-0.049 -0.892,-0.072 -0.44,-0.033 -0.868,-0.065 -1.286,-0.095 -0.245,-0.018 -0.491,-0.036 -0.727,-0.052 -0.54,-0.036 -1.064,-0.071 -1.561,-0.101 -0.824,-0.051 -1.61,-0.096 -2.312,-0.131 -0.014,0 -1.47,-0.059 -2.997,-0.103 -1.639,-0.046 -3.356,-0.076 -3.387,-0.076 -6.929,-0.095 -13.65,-0.19 -20.176,-0.292 -0.022,0 -1.67,-0.013 -3.359,-0.038 -1.483,-0.024 -3.035,-0.061 -3.062,-0.061 -0.671,-0.011 -1.328,-0.021 -1.994,-0.032 -1.484,-0.025 -2.973,-0.048 -4.436,-0.072 -0.323,-0.005 -0.636,-0.011 -0.957,-0.017 -1.871,-0.031 -3.728,-0.063 -5.564,-0.094 -0.24,-0.004 -0.475,-0.009 -0.715,-0.013 -11.842,-0.206 -22.967,-0.421 -33.394,-0.646 -0.021,0 -0.145,-0.003 -0.355,-0.008 -0.652,-0.014 -1.319,-0.028 -1.965,-0.042 -0.039,0.201 -0.078,0.402 -0.119,0.604 -1.646,8.209 -1.852,19.623 -0.566,31.314 0.248,2.247 0.489,4.307 0.674,5.849 l 1.423,0.003 31.249,0.066 12.978,0.028 5.482,0.011 c 0,0 1.728,0.003 3.461,0.031 1.569,0.025 3.156,0.075 3.213,0.077 4.152,0.175 11.278,0.656 19.931,1.957 0.047,0.007 1.69,0.239 3.325,0.513 1.629,0.275 3.248,0.594 3.307,0.605 0.61,0.114 1.24,0.245 1.86,0.367 0.002,-0.002 0.005,-0.004 0.007,-0.006 0.358,0.07 0.724,0.149 1.084,0.222 0.345,0.07 0.686,0.138 1.032,0.211 1.088,0.227 2.189,0.469 3.299,0.723 0.046,0.011 0.091,0.02 0.137,0.031 v 0.002 c 2.823,0.65 5.713,1.392 8.634,2.234 0.32,0.093 0.639,0.182 0.96,0.277 0.601,0.177 1.205,0.364 1.808,0.55 0.332,0.103 0.664,0.201 0.997,0.307 0.942,0.299 1.884,0.606 2.827,0.927 35.448,12.048 54.17,34.482 54.147,64.878 -0.025,27.178 -10.476,46.828 -31.099,58.542 -0.099,0.057 -0.226,0.126 -0.364,0.2 -0.942,0.53 -1.905,1.045 -2.892,1.541 8.122,5.357 17.102,11.651 26.007,18.614 0.032,0.025 0.156,0.119 0.342,0.26 4.459,-2.001 9.242,-4.402 11.144,-5.577 18.205,-11.261 50.587,-36.758 52.671,-76.539 0.007,-0.122 0.011,-0.246 0.017,-0.369 0.058,-1.215 0.093,-2.44 0.093,-3.681 C 25.094,37.948 16.65,16.607 0,0 m -158.959,-77.33 c -2.837,-2.933 -5.313,-5.099 -6.905,-6.41 1.592,1.311 4.067,3.478 6.905,6.41 m -8.944,-4.202 c -4.905,3.33 -13.797,10.798 -19.71,24.103 -0.251,0.565 -0.479,1.111 -0.696,1.647 -0.618,1.533 -1.102,2.958 -1.502,4.32 -0.02,0.069 -0.041,0.139 -0.061,0.208 -0.183,0.636 -0.348,1.259 -0.499,1.872 -0.02,0.08 -0.038,0.16 -0.057,0.24 -0.149,0.615 -0.286,1.222 -0.412,1.824 1.684,0.036 3.389,0.072 5.109,0.108 12.917,0.271 26.854,0.53 41.906,0.772 -0.417,-1.511 -0.869,-2.935 -1.333,-4.092 -2.461,-6.153 -6.127,-12.539 -7.454,-14.439 -5.832,-8.347 -12.353,-14.152 -15.291,-16.563 m 50.725,35.137 c -0.09,-0.344 -0.179,-0.68 -0.27,-1.005 -0.044,-0.161 -0.088,-0.324 -0.133,-0.479 -0.135,-0.471 -0.27,-0.928 -0.404,-1.36 -0.013,-0.04 -0.025,-0.076 -0.037,-0.116 -0.128,-0.408 -0.256,-0.797 -0.382,-1.171 -0.037,-0.109 -0.074,-0.212 -0.11,-0.318 -0.125,-0.361 -0.249,-0.716 -0.371,-1.048 h 0.003 c -0.392,-1.091 -1.103,-3.04 -1.774,-4.712 -0.881,-2.196 -1.698,-3.972 -1.968,-4.593 -10.938,-25.218 -37.268,-44.101 -43.894,-48.561 -17.862,11.036 -38.357,27.008 -45.831,53.672 -0.202,0.722 -0.397,1.45 -0.582,2.187 -0.192,0.772 -0.378,1.548 -0.547,2.338 l -0.102,0.468 c -0.024,0.111 -0.044,0.218 -0.067,0.328 -0.001,0 -0.002,10e-4 -0.002,10e-4 -0.1,0.458 -0.198,0.916 -0.292,1.369 -0.093,0.45 -0.355,1.815 -0.478,2.52 -0.091,0.521 -0.206,1.18 -0.333,1.908 -0.118,0.677 -0.254,1.447 -0.364,2.078 -0.125,0.711 -0.381,2.342 -0.455,2.876 -0.826,5.95 -0.992,11.584 -1.094,16.841 -0.047,2.482 -0.036,4.559 0.017,6.383 0.028,0.967 0.251,4.45 0.351,5.559 0.084,0.929 0.335,4.442 0.39,5.119 0.086,1.063 0.176,1.99 0.26,2.767 0.201,1.865 0.477,3.803 0.593,4.781 0.115,0.975 0.237,1.999 0.266,2.207 0.012,0.084 0.025,0.163 0.037,0.247 0.002,0 0.004,10e-4 0.007,0.002 0.448,3.141 0.968,5.987 1.557,8.5 0.05,0.214 0.098,0.443 0.149,0.652 0.111,0.452 0.227,0.913 0.35,1.381 0.073,0.281 0.152,0.571 0.23,0.858 0.051,0.19 0.1,0.375 0.152,0.568 0.109,0.392 0.224,0.794 0.34,1.196 0.027,0.093 0.051,0.181 0.078,0.275 0.132,0.45 0.27,0.909 0.412,1.372 0.015,0.049 0.028,0.096 0.043,0.145 4.427,14.389 13.9,34.784 34.031,58.838 1.78,-2.244 3.594,-4.373 5.722,-6.742 0.853,-0.951 1.86,-2.057 2.956,-3.26 1.116,-1.227 2.321,-2.552 3.542,-3.906 0.003,-0.003 0.006,-0.007 0.009,-0.01 -8.741,-9.624 -16.679,-20.268 -22.557,-31.742 -0.03,-0.058 -0.059,-0.117 -0.088,-0.174 -1.115,-2.186 -2.152,-4.402 -3.108,-6.646 -0.065,-0.153 -0.131,-0.306 -0.195,-0.46 -0.453,-1.077 -0.888,-2.16 -1.301,-3.25 -0.048,-0.128 -0.094,-0.257 -0.141,-0.384 -0.376,-1.006 -0.734,-2.017 -1.075,-3.034 -0.052,-0.156 -0.107,-0.311 -0.159,-0.468 -0.35,-1.067 -0.679,-2.139 -0.99,-3.217 -0.065,-0.229 -0.128,-0.457 -0.192,-0.686 -0.121,-0.433 -0.226,-0.871 -0.34,-1.306 -0.176,-0.673 -0.365,-1.342 -0.525,-2.019 -0.279,-1.183 -0.52,-2.366 -0.739,-3.549 -0.258,-1.339 -0.491,-2.676 -0.674,-3.998 -0.02,-0.139 -0.039,-0.277 -0.057,-0.415 0,0 -0.276,-2.159 -0.368,-2.928 -0.087,-0.732 -0.348,-3.072 -0.348,-3.072 -0.015,-0.126 -0.031,-0.255 -0.046,-0.386 -0.163,-1.376 -0.353,-3.028 -0.548,-4.794 -1.271,-11.55 -1.166,-22.509 0.281,-31.152 0.039,-0.236 0.336,-2.206 0.672,-3.984 0.414,-2.198 0.882,-4.271 0.916,-4.436 0.041,-0.197 0.089,-0.402 0.132,-0.602 -0.001,-0.002 -0.002,-0.004 -0.003,-0.006 0.203,-0.949 0.436,-1.925 0.703,-2.931 0.001,-0.005 0.003,-0.009 0.004,-0.014 0.344,-1.293 0.757,-2.645 1.267,-4.076 0.073,-0.207 0.146,-0.414 0.224,-0.624 0.129,-0.347 0.267,-0.703 0.408,-1.06 0.072,-0.181 0.139,-0.358 0.213,-0.54 0.222,-0.546 0.456,-1.102 0.71,-1.673 7.389,-16.625 19.113,-25.056 23.811,-27.909 l 0.717,-0.436 h 0.84 c 0.808,0 1.725,0 7.771,5.68 3.178,2.985 7.886,7.859 12.265,14.126 1.507,2.158 5.433,8.965 8.106,15.646 0.176,0.439 0.349,0.909 0.519,1.401 h 0.001 c 0.159,0.459 0.314,0.942 0.467,1.435 0.012,0.037 0.024,0.071 0.036,0.11 0.013,0.043 0.026,0.091 0.04,0.136 0.008,0.031 0.017,0.063 0.027,0.093 0.12,0.396 0.237,0.798 0.352,1.207 0.037,0.128 0.073,0.256 0.109,0.385 0.09,0.326 0.177,0.653 0.263,0.983 0.033,0.126 0.068,0.249 0.1,0.375 0.003,0.01 0.024,0.094 0.054,0.214 0.006,0.026 0.014,0.053 0.02,0.08 6.623,0.103 13.465,0.201 20.507,0.296 -0.031,-0.13 -0.061,-0.251 -0.086,-0.351 M -220.375,6.82 c -0.021,-0.13 -0.041,-0.261 -0.061,-0.392 -0.08,-0.513 -0.157,-1.032 -0.232,-1.56 -0.024,-0.165 -0.048,-0.328 -0.071,-0.493 -0.092,-0.66 -0.182,-1.329 -0.268,-2.013 l -14.43,-0.031 c -2.569,0.065 -4.517,0.842 -5.955,2.374 -3.062,3.262 -2.888,8.881 -2.886,8.926 l 0.004,0.086 -2.83,231.368 c 0.067,1.131 0.711,11.593 1.93,16.864 1.699,7.363 10.795,10.244 10.919,10.282 0.1,0.031 3.619,1.087 11.354,2.017 0.246,0.03 0.495,0.06 0.749,0.088 0.021,0.003 0.305,0.027 0.797,0.068 0.209,-2.634 0.418,-4.674 0.532,-5.614 3.067,-25.292 19.693,-50.59 40.882,-72.236 0.179,-0.182 1.225,-1.242 1.383,-1.4 0.596,-0.599 1.196,-1.195 1.798,-1.789 0.107,-0.105 0.62,-0.609 0.705,-0.694 0.113,-0.11 0.224,-0.221 0.337,-0.331 -5.65,-8.63 -13.887,-25.733 -17.652,-45.083 -3.101,-15.938 -3.941,-37.696 7.065,-56.878 0.368,-0.642 1.768,-2.914 2.089,-3.38 0.591,-0.895 1.207,-1.783 1.855,-2.664 0.431,-0.61 0.85,-1.195 1.263,-1.766 -24.451,-28.912 -34.043,-52.92 -37.767,-68.094 -0.562,-2.29 -1.065,-4.853 -1.51,-7.655 m -2.196,-48.888 c -0.273,-0.007 -0.445,-0.011 -0.48,-0.012 -38.096,-0.99 -64.415,-1.999 -82.075,-2.676 -8.573,-0.328 -15.486,-0.594 -20.523,-0.724 39.073,20.988 38.143,45.972 37.941,48.497 l -2.75,272.406 c -0.023,0.875 -0.877,19.187 -30.959,32.957 18.797,0.21 53.746,0.258 92.445,0.216 2.097,-0.003 4.203,-0.005 6.321,-0.008 0.487,-0.001 4.953,-0.001 8.38,-0.002 0,0.008 0.002,0.016 0.003,0.024 5.247,0 10.633,-0.002 16.113,-0.006 -0.004,-0.019 -0.008,-0.04 -0.012,-0.059 -0.002,-0.014 -0.004,-0.027 -0.007,-0.042 17.636,-0.031 41.407,-0.069 52.993,-0.111 1.078,-6.355 1.904,-13.953 2.37,-19.915 0.296,-3.793 0.468,-7.184 0.56,-10.217 -0.007,0.001 -0.013,0.002 -0.02,0.002 -1.33,0.154 -2.644,0.301 -3.942,0.443 -0.237,0.026 -0.467,0.049 -0.703,0.074 -1.054,0.115 -2.105,0.227 -3.137,0.333 -0.505,0.052 -0.996,0.099 -1.496,0.149 -0.75,0.075 -1.506,0.153 -2.245,0.224 -0.527,0.051 -1.039,0.097 -1.561,0.145 -0.699,0.066 -1.405,0.134 -2.094,0.195 -0.491,0.045 -0.968,0.084 -1.453,0.127 -0.702,0.061 -1.409,0.124 -2.098,0.181 -0.514,0.043 -1.014,0.081 -1.521,0.122 -0.648,0.053 -1.302,0.107 -1.941,0.156 -0.523,0.04 -1.033,0.075 -1.55,0.113 -0.605,0.045 -1.217,0.092 -1.813,0.134 -0.517,0.036 -1.019,0.068 -1.529,0.102 -0.584,0.039 -1.174,0.08 -1.75,0.116 -0.472,0.03 -0.932,0.056 -1.399,0.084 -0.597,0.037 -1.199,0.074 -1.786,0.107 -0.466,0.027 -0.919,0.049 -1.379,0.074 -0.571,0.03 -1.147,0.062 -1.708,0.09 -0.521,0.026 -1.027,0.047 -1.54,0.071 -0.483,0.022 -0.975,0.047 -1.452,0.067 -0.562,0.024 -1.108,0.044 -1.66,0.065 -0.415,0.016 -0.838,0.034 -1.248,0.048 -0.584,0.021 -1.153,0.038 -1.725,0.056 -0.363,0.011 -0.734,0.024 -1.092,0.034 -0.643,0.018 -1.27,0.033 -1.899,0.048 -0.273,0.006 -0.552,0.014 -0.822,0.02 -0.713,0.015 -1.411,0.026 -2.105,0.037 -1.04,0.015 -2.065,0.028 -3.065,0.034 -0.037,10e-4 -3.556,-0.11 -6.158,-0.158 0,0.007 -0.001,0.012 -0.001,0.018 -1.707,-0.06 -5.505,-0.154 -8.872,-0.323 -2.352,-0.119 -4.713,-0.255 -6.754,-0.38 -1.519,-0.093 -2.852,-0.179 -3.877,-0.246 l 0.007,0.026 c -0.047,-0.005 -0.54,-0.049 -1.116,-0.1 -0.847,-0.076 -1.873,-0.167 -1.942,-0.174 -8.805,-1.021 -12.903,-2.273 -13.329,-2.411 -0.51,-0.153 -12.507,-3.883 -14.995,-14.664 -1.398,-6.049 -2.052,-17.492 -2.079,-17.977 l -0.005,-0.102 2.83,-231.423 c -0.028,-0.995 -0.067,-8.289 4.476,-13.163 2.559,-2.746 5.994,-4.194 10.292,-4.302 l 12.627,0.026 1.226,0.003 c -0.535,-5.845 -1.054,-10.441 -1.01,-19.42 0.03,-5.922 0.332,-12.274 1.322,-18.977 -0.415,-0.011 -0.817,-0.022 -1.229,-0.032 m 76.19,356.461 c -11.955,0.041 -27.472,0.089 -44.45,0.13 0.142,0.649 0.284,1.298 0.428,1.935 0.235,1.048 2.308,7.038 2.681,7.911 2.025,4.741 3.735,7.568 4.375,8.564 4.977,7.727 10.927,13.799 13.783,16.521 3.702,-2.689 10.61,-8.372 16.012,-16.665 1.799,-2.763 3.643,-6.952 5.494,-12.479 0.321,-0.956 1.24,-4.216 1.34,-4.59 0.114,-0.424 0.226,-0.868 0.337,-1.327 m -23.883,62.912 c 4.298,-2.818 10.631,-6.675 16.45,-11.287 1.632,-1.295 4.009,-3.36 6.125,-5.125 2.499,-2.085 6.623,-6.413 7.961,-7.954 5.805,-6.682 10.951,-14.548 14.282,-23.76 0.369,-1.022 0.735,-2.05 1.096,-3.086 0.114,-0.322 0.223,-0.652 0.334,-0.976 0.248,-0.72 0.495,-1.441 0.738,-2.173 0.138,-0.415 0.272,-0.841 0.408,-1.261 0.211,-0.653 0.422,-1.307 0.628,-1.972 0.146,-0.474 0.289,-0.959 0.433,-1.44 0.13,-0.436 0.264,-0.861 0.392,-1.304 0.051,-0.176 0.194,-0.674 0.353,-1.227 0.093,-0.327 0.19,-0.667 0.279,-0.983 0.106,-0.373 0.199,-0.707 0.251,-0.901 0.037,-0.141 0.072,-0.289 0.11,-0.431 0.1,-0.382 0.197,-0.771 0.295,-1.158 0.128,-0.508 0.254,-1.018 0.378,-1.536 0.098,-0.41 0.193,-0.826 0.288,-1.243 0.118,-0.517 0.234,-1.039 0.347,-1.568 0.093,-0.434 0.184,-0.872 0.274,-1.314 0.11,-0.536 0.215,-1.082 0.32,-1.631 0.084,-0.453 0.17,-0.907 0.252,-1.37 0.102,-0.568 0.2,-1.151 0.295,-1.736 0.077,-0.465 0.155,-0.928 0.228,-1.404 0.095,-0.62 0.184,-1.259 0.273,-1.898 0.065,-0.463 0.132,-0.92 0.194,-1.394 0.093,-0.725 0.179,-1.475 0.264,-2.224 0.048,-0.414 0.1,-0.815 0.144,-1.236 0.126,-1.184 0.242,-2.394 0.347,-3.642 0.52,-6.25 0.8,-12.209 0.846,-17.865 0.01,-1.172 -0.094,-4.492 -0.165,-6.547 -0.002,-0.06 -0.004,-0.113 -0.006,-0.171 -0.015,-0.448 -0.029,-0.829 -0.038,-1.098 -0.004,-0.091 -0.007,-0.173 -0.008,-0.237 -0.001,-0.02 -0.002,-0.04 -0.003,-0.06 -0.124,-3.424 -0.347,-6.716 -0.664,-9.879 -0.017,-0.167 -0.033,-0.336 -0.049,-0.502 -0.154,-1.47 -0.327,-2.908 -0.523,-4.319 -0.032,-0.232 -0.066,-0.46 -0.099,-0.691 -0.204,-1.417 -0.424,-2.812 -0.671,-4.167 l -0.034,-0.192 c -0.156,-0.853 -0.326,-1.702 -0.506,-2.55 -0.062,-0.287 -0.131,-0.571 -0.195,-0.857 -0.126,-0.561 -0.253,-1.121 -0.389,-1.68 -0.083,-0.339 -0.174,-0.678 -0.262,-1.017 -0.131,-0.505 -0.262,-1.01 -0.401,-1.513 -0.1,-0.358 -0.205,-0.715 -0.309,-1.072 -0.142,-0.485 -0.286,-0.968 -0.436,-1.452 -0.114,-0.366 -0.231,-0.732 -0.35,-1.097 -0.154,-0.475 -0.314,-0.95 -0.477,-1.425 -0.126,-0.367 -0.254,-0.733 -0.384,-1.099 -0.172,-0.478 -0.35,-0.956 -0.531,-1.434 -0.136,-0.36 -0.271,-0.721 -0.413,-1.081 -0.193,-0.492 -0.394,-0.983 -0.597,-1.475 -0.142,-0.344 -0.281,-0.688 -0.427,-1.032 -0.23,-0.54 -0.472,-1.081 -0.714,-1.622 -0.132,-0.294 -0.258,-0.589 -0.394,-0.883 -0.38,-0.826 -0.771,-1.653 -1.179,-2.48 -0.079,-0.161 -0.165,-0.322 -0.245,-0.483 -0.338,-0.676 -0.681,-1.352 -1.038,-2.029 -0.167,-0.317 -0.343,-0.636 -0.514,-0.954 -0.281,-0.522 -0.563,-1.044 -0.856,-1.567 -0.2,-0.357 -0.407,-0.715 -0.613,-1.073 -0.278,-0.485 -0.558,-0.97 -0.846,-1.457 -0.222,-0.376 -0.451,-0.753 -0.679,-1.13 -0.286,-0.47 -0.575,-0.942 -0.87,-1.415 -0.241,-0.385 -0.486,-0.772 -0.733,-1.159 -0.3,-0.468 -0.603,-0.936 -0.912,-1.406 -0.368,-0.56 -0.733,-1.121 -1.115,-1.684 -0.055,-0.081 -0.125,-0.18 -0.201,-0.287 -0.028,-0.038 -0.058,-0.08 -0.087,-0.121 -0.634,-0.878 -1.819,-2.416 -2.995,-3.876 -4.975,3.441 -9.912,7.084 -14.677,10.906 0.066,0.09 0.127,0.172 0.191,0.259 0.029,0.039 0.056,0.077 0.085,0.115 0.1,0.136 0.194,0.264 0.286,0.389 0.056,0.077 0.114,0.154 0.166,0.225 0.088,0.12 0.163,0.223 0.237,0.324 0.033,0.045 0.071,0.098 0.101,0.139 0.096,0.132 0.177,0.244 0.229,0.317 0.263,0.372 0.513,0.762 0.771,1.143 0.034,0.051 0.069,0.102 0.103,0.153 0.305,0.455 0.61,0.91 0.906,1.377 0.221,0.349 0.436,0.706 0.652,1.061 0.283,0.466 0.565,0.931 0.839,1.408 0.213,0.369 0.42,0.744 0.627,1.12 0.263,0.477 0.525,0.957 0.779,1.443 0.204,0.389 0.401,0.782 0.598,1.176 0.245,0.49 0.487,0.983 0.723,1.481 0.192,0.405 0.379,0.813 0.564,1.223 0.227,0.503 0.45,1.008 0.668,1.518 0.18,0.42 0.356,0.843 0.529,1.269 0.21,0.515 0.415,1.035 0.615,1.558 0.166,0.431 0.329,0.864 0.488,1.3 0.193,0.531 0.381,1.066 0.565,1.604 0.151,0.441 0.3,0.883 0.445,1.329 0.178,0.545 0.346,1.095 0.513,1.647 0.136,0.449 0.273,0.897 0.402,1.351 0.16,0.56 0.311,1.126 0.462,1.692 0.121,0.455 0.243,0.909 0.356,1.368 0.144,0.577 0.278,1.159 0.41,1.741 0.105,0.458 0.212,0.915 0.311,1.376 0.126,0.595 0.241,1.196 0.356,1.796 0.089,0.457 0.181,0.911 0.263,1.371 0.11,0.62 0.207,1.246 0.306,1.872 0.07,0.447 0.146,0.891 0.211,1.341 0.095,0.66 0.174,1.326 0.256,1.992 0.052,0.42 0.111,0.838 0.157,1.261 0.082,0.739 0.145,1.484 0.211,2.229 0.03,0.354 0.07,0.706 0.096,1.061 0.085,1.102 0.153,2.209 0.201,3.319 0.024,0.557 0.055,1.177 0.091,1.862 0.019,0.361 0.038,0.752 0.058,1.153 0.001,0.028 0.003,0.053 0.004,0.081 0.002,0.03 0.004,0.071 0.006,0.113 0.003,0.07 0.006,0.136 0.01,0.207 0.008,0.194 0.02,0.437 0.034,0.724 0.073,1.551 0.196,4.218 0.214,5.268 0.085,4.896 -0.006,11.244 -0.64,19.35 -0.607,7.762 -1.725,17.463 -3.224,24.624 -0.19,0.907 -0.706,3.352 -0.796,3.698 -0.168,0.647 -0.339,1.261 -0.515,1.829 -2.371,7.659 -4.975,13.47 -7.423,17.227 -7.013,10.768 -15.821,17.125 -19.395,19.47 l -1.889,1.24 -1.713,-1.473 c -0.377,-0.324 -9.326,-8.075 -16.607,-19.379 -0.899,-1.396 -2.723,-4.48 -4.848,-9.453 -0.483,-1.13 -2.678,-7.437 -3.018,-8.954 -0.219,-0.97 -0.455,-2.054 -0.693,-3.171 -5.694,0.005 -11.16,0.008 -16.392,0.008 5.272,31.41 34.807,56.278 43.078,62.694 m 58.227,-134.036 0.035,0.188 c 0.651,3.565 1.155,7.335 1.518,11.293 0.14,1.543 0.681,8.252 0.733,10.098 0.022,0.802 0.04,1.61 0.054,2.425 29.505,-6.551 66.131,-22.115 66.14,-44.684 0,-10.448 -8.671,-26.861 -24.162,-43.348 -0.349,-0.371 -0.705,-0.742 -1.06,-1.113 -0.267,-0.278 -0.53,-0.556 -0.8,-0.834 -0.352,-0.361 -0.712,-0.723 -1.07,-1.085 -0.286,-0.288 -0.567,-0.576 -0.856,-0.863 -0.296,-0.295 -0.601,-0.589 -0.901,-0.884 -0.919,-0.899 -1.852,-1.796 -2.81,-2.691 -0.051,-0.048 -0.1,-0.097 -0.151,-0.144 -0.533,-0.497 -1.076,-0.993 -1.621,-1.488 -0.121,-0.11 -0.241,-0.221 -0.362,-0.33 -5.592,1.655 -16.687,6.438 -29.896,13.55 0.005,0.005 0.011,0.01 0.016,0.015 -7.891,4.246 -16.54,9.332 -25.221,15.072 11.138,15.313 17.645,29.62 20.414,44.823 M -138.924,80.66 c 14.365,12.183 28.237,21.496 36.587,27.101 0.495,0.332 0.972,0.652 1.43,0.96 2.067,1.39 9.407,5.831 14.409,8.755 0.82,0.479 1.684,0.986 2.586,1.521 0.155,0.092 0.318,0.19 0.475,0.284 0.529,0.314 1.066,0.635 1.619,0.967 0.25,0.15 0.505,0.304 0.759,0.458 0.487,0.293 0.981,0.592 1.485,0.899 0.291,0.177 0.583,0.355 0.88,0.536 0.502,0.307 1.013,0.622 1.531,0.942 0.303,0.186 0.601,0.37 0.909,0.561 0.565,0.349 1.141,0.71 1.722,1.073 0.27,0.169 0.534,0.333 0.807,0.505 0.861,0.541 1.734,1.092 2.625,1.661 1.079,-0.478 2.125,-0.982 3.152,-1.501 0.123,-0.063 0.247,-0.124 0.37,-0.187 1.042,-0.535 2.061,-1.089 3.053,-1.665 18.364,-10.676 27.678,-28.492 27.7,-53.095 0.021,-27.939 -16.784,-47.84 -49.952,-59.151 -4.79,-1.634 -9.594,-2.957 -14.241,-4.037 -1.109,-0.259 -2.209,-0.5 -3.297,-0.731 -0.154,-0.034 -0.306,-0.067 -0.458,-0.098 -1.103,-0.231 -2.196,-0.451 -3.271,-0.655 -0.029,0.69 -0.067,1.407 -0.11,2.135 -0.012,0.198 -0.026,0.4 -0.037,0.599 -0.038,0.596 -0.08,1.204 -0.126,1.824 -0.012,0.158 -0.023,0.313 -0.036,0.472 -0.126,1.65 -0.284,3.387 -0.471,5.207 -0.001,0.002 -0.001,0.004 -0.001,0.006 -0.202,1.962 -0.437,4.014 -0.709,6.167 -2.774,21.957 -11.863,40.082 -29.39,58.487 m 16.773,56.126 c -14.806,-11.039 -27.411,-21.789 -38.126,-32.104 -0.056,0.095 -0.112,0.192 -0.167,0.289 -11.711,21.273 -9.174,47.356 6.752,68.21 14.864,-11.601 30.159,-21.146 43.583,-27.694 -0.306,-0.214 -0.603,-0.427 -0.907,-0.64 -0.769,-0.541 -1.536,-1.082 -2.295,-1.621 -0.777,-0.553 -1.543,-1.104 -2.308,-1.655 -1.069,-0.769 -2.127,-1.537 -3.174,-2.303 -0.88,-0.645 -1.759,-1.289 -2.624,-1.932 -0.244,-0.182 -0.498,-0.364 -0.741,-0.545 0.002,-0.002 0.004,-0.003 0.007,-0.005 m -71.626,138.866 c 13.354,-0.083 30.377,-0.985 51.58,-3.445 -0.021,-4.178 -0.185,-7.416 -0.31,-9.85 -0.036,-0.703 -0.069,-1.338 -0.094,-1.91 -0.73,-16.894 -5.915,-32.676 -14.313,-43.779 -0.258,0.22 -0.517,0.439 -0.775,0.659 -0.321,0.274 -2.266,1.965 -2.589,2.253 -0.513,0.456 -1.023,0.915 -1.53,1.375 -0.192,0.174 -0.384,0.35 -0.576,0.525 -13.217,12.098 -24.015,25.532 -28.772,39.46 -1.037,3.036 -2.01,9.012 -2.513,13.589 -0.031,0.283 -0.068,0.664 -0.108,1.123 m -5.856,-1.779 c 0.111,-1.009 1.132,-9.994 2.799,-14.873 0.323,-0.946 0.681,-1.889 1.054,-2.831 0.096,-0.242 0.195,-0.484 0.294,-0.726 0.353,-0.86 0.722,-1.719 1.115,-2.575 0.038,-0.082 0.072,-0.164 0.11,-0.246 0.436,-0.94 0.901,-1.875 1.383,-2.809 0.108,-0.211 0.221,-0.422 0.332,-0.633 0.446,-0.844 0.907,-1.686 1.389,-2.525 0.055,-0.097 0.108,-0.195 0.164,-0.291 0.551,-0.95 1.127,-1.897 1.722,-2.84 0.091,-0.145 0.186,-0.289 0.278,-0.434 0.564,-0.882 1.144,-1.762 1.745,-2.637 0.046,-0.068 0.092,-0.137 0.139,-0.205 0.674,-0.977 1.37,-1.951 2.087,-2.918 0.029,-0.04 0.06,-0.079 0.089,-0.119 0.719,-0.967 1.457,-1.929 2.216,-2.886 l 0.027,-0.033 c 0.683,-0.861 1.387,-1.715 2.101,-2.566 0.268,-0.32 0.541,-0.638 0.813,-0.956 0.446,-0.521 0.897,-1.041 1.354,-1.558 0.34,-0.385 0.679,-0.771 1.024,-1.155 0.355,-0.393 0.718,-0.783 1.079,-1.174 0.884,-0.961 1.786,-1.915 2.705,-2.862 0.116,-0.12 0.231,-0.241 0.348,-0.36 1.101,-1.127 2.23,-2.242 3.374,-3.349 0.504,-0.488 1.02,-0.97 1.532,-1.455 0.419,-0.395 0.829,-0.795 1.253,-1.189 0.249,-0.231 0.931,-0.86 1.552,-1.43 0.457,-0.421 0.882,-0.809 1.071,-0.978 0.092,-0.082 0.189,-0.162 0.281,-0.245 0.897,-0.799 1.809,-1.586 2.724,-2.372 8.462,-7.273 17.618,-13.992 26.727,-19.981 1.071,-0.704 2.141,-1.397 3.209,-2.082 0.174,-0.111 0.35,-0.228 0.523,-0.339 0.208,-0.133 0.416,-0.263 0.624,-0.395 0.319,-0.203 0.635,-0.396 0.955,-0.597 0.596,-0.375 1.192,-0.748 1.788,-1.117 0.287,-0.178 0.575,-0.362 0.862,-0.539 0.33,-0.204 0.66,-0.408 0.99,-0.61 0.647,-0.395 1.286,-0.775 1.929,-1.162 0.435,-0.261 0.873,-0.529 1.307,-0.786 0.101,-0.061 0.206,-0.125 0.307,-0.186 0.684,-0.406 1.359,-0.799 2.036,-1.196 0.036,-0.021 0.072,-0.041 0.108,-0.062 0.343,-0.201 0.685,-0.398 1.029,-0.598 0.343,-0.199 0.688,-0.401 1.027,-0.597 0.25,-0.143 0.495,-0.28 0.745,-0.421 0.451,-0.257 0.902,-0.514 1.35,-0.767 0.19,-0.106 0.381,-0.216 0.57,-0.323 0.234,-0.131 0.467,-0.261 0.7,-0.391 0.067,-0.038 0.132,-0.073 0.2,-0.111 1.166,-0.65 2.322,-1.287 3.463,-1.906 0.046,-0.025 0.092,-0.05 0.137,-0.075 1.128,-0.61 2.245,-1.209 3.344,-1.786 0.345,-0.182 0.681,-0.354 1.023,-0.533 0.836,-0.435 1.673,-0.873 2.489,-1.288 1.218,-0.62 2.414,-1.221 3.582,-1.794 0.312,-0.153 0.656,-0.317 1.017,-0.486 0.037,-0.017 0.071,-0.034 0.108,-0.051 0.345,-0.161 0.713,-0.329 1.096,-0.503 0.064,-0.029 0.129,-0.058 0.194,-0.088 0.373,-0.167 0.762,-0.34 1.164,-0.517 0.085,-0.038 0.171,-0.076 0.258,-0.114 0.403,-0.177 0.818,-0.356 1.245,-0.54 0.089,-0.038 0.179,-0.077 0.269,-0.115 0.43,-0.185 0.868,-0.372 1.316,-0.561 0.098,-0.041 0.196,-0.083 0.295,-0.124 0.456,-0.193 0.918,-0.386 1.387,-0.581 0.065,-0.028 0.131,-0.054 0.197,-0.082 0.446,-0.185 0.896,-0.371 1.349,-0.558 0.085,-0.035 0.169,-0.069 0.254,-0.104 0.472,-0.194 0.947,-0.388 1.421,-0.58 0.103,-0.042 0.205,-0.084 0.309,-0.126 0.472,-0.191 0.941,-0.381 1.408,-0.569 0.102,-0.04 0.202,-0.081 0.303,-0.121 0.469,-0.189 0.935,-0.375 1.395,-0.558 0.092,-0.037 0.183,-0.073 0.275,-0.109 0.466,-0.186 0.927,-0.368 1.379,-0.546 0.067,-0.026 0.132,-0.052 0.199,-0.078 0.414,-0.163 0.822,-0.323 1.219,-0.477 -0.753,-0.63 -1.514,-1.258 -2.286,-1.882 -4.39,-3.553 -16.147,-11.694 -17.166,-12.378 -0.871,-0.585 -1.715,-1.168 -2.574,-1.752 -0.101,0.049 -0.188,0.091 -0.283,0.138 -0.178,0.085 -0.343,0.166 -0.501,0.242 -0.165,0.08 -0.314,0.153 -0.458,0.222 -0.081,0.04 -0.16,0.078 -0.234,0.114 -0.157,0.076 -0.304,0.147 -0.424,0.206 -0.275,0.133 -0.457,0.221 -0.523,0.253 -0.305,0.149 -0.624,0.311 -0.934,0.464 -0.502,0.248 -1,0.492 -1.514,0.752 -0.423,0.214 -0.859,0.442 -1.29,0.665 -0.41,0.212 -0.816,0.419 -1.233,0.638 -0.515,0.27 -1.041,0.555 -1.566,0.837 -0.347,0.186 -0.689,0.367 -1.041,0.559 -0.588,0.32 -1.187,0.654 -1.787,0.988 -0.296,0.165 -0.589,0.325 -0.888,0.493 -0.653,0.368 -1.318,0.75 -1.984,1.133 -0.254,0.147 -0.505,0.29 -0.76,0.438 -0.712,0.414 -1.433,0.84 -2.158,1.271 -0.216,0.129 -0.43,0.255 -0.646,0.385 -0.767,0.46 -1.541,0.931 -2.321,1.41 -0.18,0.111 -0.359,0.219 -0.54,0.331 -0.804,0.497 -1.617,1.007 -2.435,1.524 0.003,0.003 0.005,0.005 0.007,0.008 -1.933,1.222 -3.9,2.501 -5.892,3.834 -0.566,0.379 -1.134,0.762 -1.703,1.149 -0.009,0.006 -0.017,0.011 -0.026,0.017 -0.01,0.007 -0.046,0.032 -0.086,0.059 -0.346,0.238 -1.708,1.172 -2.365,1.629 -0.005,0.003 -0.012,0.008 -0.016,0.011 -0.037,0.026 -0.076,0.053 -0.113,0.079 -0.388,0.272 -0.778,0.546 -1.169,0.822 -0.002,0.001 -0.004,0.002 -0.005,0.004 -0.456,0.32 -0.911,0.64 -1.368,0.966 -0.93,0.665 -1.864,1.338 -2.802,2.025 -0.03,0.023 -0.061,0.045 -0.091,0.068 -0.63,0.463 -1.671,1.239 -2.377,1.765 -0.074,0.056 -0.182,0.138 -0.303,0.228 -0.583,0.442 -1.6,1.217 -2.04,1.555 -0.003,-0.002 -0.007,-0.003 -0.01,-0.004 -7.49,5.734 -15.09,12.145 -22.454,19.195 -0.666,0.637 -1.339,1.291 -2.015,1.957 -0.027,0.026 -0.065,0.064 -0.105,0.103 -0.171,0.17 -0.444,0.441 -0.702,0.697 -0.254,0.251 -0.488,0.485 -0.581,0.578 -4.318,4.305 -8.785,9.099 -13.115,14.29 -0.052,0.063 -0.105,0.124 -0.157,0.187 -0.434,0.521 -0.865,1.049 -1.295,1.578 -0.125,0.153 -0.25,0.304 -0.374,0.458 -0.382,0.473 -0.762,0.952 -1.141,1.431 -0.171,0.217 -0.344,0.431 -0.514,0.649 -0.351,0.448 -0.7,0.901 -1.048,1.354 -0.193,0.252 -0.387,0.502 -0.579,0.755 -0.327,0.43 -0.651,0.866 -0.975,1.301 -0.211,0.284 -0.423,0.567 -0.633,0.853 -0.306,0.417 -0.609,0.838 -0.912,1.259 -0.222,0.307 -0.443,0.614 -0.662,0.924 -0.291,0.411 -0.579,0.825 -0.867,1.239 -0.226,0.326 -0.452,0.652 -0.676,0.981 -0.277,0.404 -0.549,0.812 -0.822,1.219 -0.229,0.344 -0.458,0.687 -0.684,1.033 -0.264,0.402 -0.525,0.806 -0.784,1.212 -0.228,0.356 -0.456,0.712 -0.681,1.07 -0.252,0.4 -0.5,0.802 -0.748,1.206 -0.226,0.368 -0.451,0.737 -0.673,1.108 -0.241,0.4 -0.479,0.802 -0.715,1.205 -0.221,0.377 -0.44,0.756 -0.657,1.135 -0.23,0.401 -0.457,0.803 -0.682,1.207 -0.216,0.388 -0.429,0.777 -0.641,1.167 -0.218,0.4 -0.433,0.801 -0.645,1.203 -0.211,0.399 -0.418,0.799 -0.624,1.2 -0.204,0.398 -0.408,0.796 -0.607,1.197 -0.204,0.41 -0.405,0.821 -0.603,1.232 -0.192,0.398 -0.383,0.795 -0.57,1.195 -0.195,0.417 -0.386,0.836 -0.575,1.255 -0.181,0.399 -0.361,0.798 -0.536,1.199 -0.185,0.425 -0.365,0.851 -0.544,1.277 -0.167,0.399 -0.336,0.797 -0.498,1.198 -0.176,0.434 -0.345,0.871 -0.514,1.307 -0.154,0.397 -0.309,0.794 -0.458,1.192 -0.164,0.442 -0.32,0.887 -0.478,1.33 -0.141,0.397 -0.284,0.793 -0.419,1.192 -0.153,0.453 -0.297,0.909 -0.443,1.364 -0.126,0.391 -0.255,0.782 -0.374,1.174 -0.143,0.468 -0.274,0.938 -0.409,1.407 -0.11,0.385 -0.224,0.768 -0.328,1.154 -0.131,0.485 -0.249,0.972 -0.37,1.458 -0.094,0.373 -0.192,0.746 -0.28,1.12 -0.119,0.51 -0.225,1.024 -0.334,1.537 -0.075,0.353 -0.157,0.705 -0.227,1.059 -0.112,0.57 -0.209,1.143 -0.308,1.716 -0.051,0.297 -0.111,0.594 -0.159,0.893 -0.139,0.872 -0.263,1.747 -0.369,2.624 -0.109,0.897 -0.307,2.834 -0.507,5.332 2.911,0.196 6.505,0.412 10.3,0.577 1.763,0.077 3.513,0.152 5.277,0.214 v -0.002 c 0.06,-0.729 0.117,-1.334 0.164,-1.761 m 58.76,-271.34 -6.03,-0.012 -44.351,-0.095 c 0.316,2.185 0.734,4.385 1.25,6.569 4.381,18.555 15.552,35.561 28.778,50.228 0.667,-0.721 1.313,-1.45 1.942,-2.186 0.187,-0.218 1.225,-1.47 1.395,-1.68 5.537,-6.856 9.591,-14.387 12.306,-22.871 1.907,-5.954 3.203,-12.457 3.854,-19.329 0.141,-1.5 0.266,-2.962 0.387,-4.418 0.06,-0.718 0.115,-1.426 0.171,-2.135 0.107,-1.371 0.211,-2.739 0.298,-4.071 m -11.602,55.604 c -0.219,0.28 -1.282,1.654 -1.621,2.062 -3.079,3.703 -6.988,7.997 -10.192,11.516 -1.085,1.192 -2.083,2.288 -2.928,3.229 -4.074,4.537 -6.967,8.168 -10.794,13.635 -0.206,0.296 -1.091,1.599 -1.395,2.072 -0.058,0.091 -0.115,0.18 -0.171,0.267 -0.229,0.357 -0.428,0.67 -0.505,0.793 -0.233,0.374 -0.463,0.75 -0.685,1.129 -0.078,0.135 -0.158,0.269 -0.236,0.404 -0.497,0.867 -0.966,1.743 -1.413,2.627 -0.077,0.151 -0.153,0.303 -0.229,0.456 -0.437,0.884 -0.851,1.776 -1.241,2.675 -0.062,0.144 -0.123,0.29 -0.184,0.435 -0.389,0.918 -0.758,1.842 -1.099,2.774 -0.04,0.11 -0.078,0.22 -0.117,0.33 -0.351,0.975 -0.682,1.956 -0.982,2.944 -0.008,0.026 -0.015,0.053 -0.023,0.079 -0.3,0.989 -0.572,1.984 -0.823,2.984 -0.022,0.089 -0.047,0.176 -0.069,0.265 -0.239,0.97 -0.453,1.946 -0.649,2.925 -0.028,0.141 -0.058,0.282 -0.086,0.423 -0.185,0.954 -0.348,1.912 -0.493,2.873 -0.025,0.161 -0.049,0.323 -0.073,0.486 -0.138,0.955 -0.258,1.914 -0.359,2.874 -0.017,0.157 -0.032,0.314 -0.048,0.471 -0.096,0.975 -0.177,1.951 -0.237,2.928 -0.008,0.125 -0.013,0.25 -0.02,0.374 -0.059,1.018 -0.102,2.035 -0.122,3.053 -0.001,0.045 -0.001,0.09 -0.002,0.134 -0.019,1.029 -0.02,2.058 -0.003,3.086 0.002,0.07 0.001,0.139 0.003,0.209 0.018,1.009 0.056,2.017 0.107,3.023 0.007,0.131 0.013,0.263 0.02,0.394 0.054,0.976 0.123,1.95 0.207,2.921 0.013,0.153 0.025,0.306 0.039,0.459 0.086,0.963 0.187,1.924 0.299,2.88 0.018,0.152 0.037,0.303 0.056,0.454 0.118,0.968 0.248,1.932 0.392,2.891 0.018,0.119 0.037,0.236 0.055,0.355 0.152,0.994 0.315,1.984 0.492,2.968 0.009,0.05 0.02,0.101 0.029,0.152 0.183,1.008 0.379,2.011 0.587,3.007 0.007,0.036 0.014,0.072 0.021,0.108 0.206,0.981 0.425,1.953 0.652,2.92 0.024,0.105 0.048,0.21 0.073,0.315 0.221,0.931 0.454,1.854 0.694,2.77 0.033,0.129 0.067,0.258 0.101,0.387 0.24,0.905 0.488,1.801 0.744,2.689 0.036,0.125 0.072,0.25 0.108,0.374 0.262,0.896 0.529,1.784 0.804,2.661 0.031,0.097 0.062,0.192 0.092,0.289 0.287,0.905 0.579,1.802 0.879,2.686 0.012,0.035 0.024,0.069 0.036,0.104 0.624,1.833 1.275,3.615 1.944,5.34 0.025,0.065 0.05,0.132 0.075,0.197 0.319,0.819 0.642,1.623 0.969,2.415 0.036,0.089 0.072,0.178 0.109,0.267 0.322,0.776 0.646,1.539 0.973,2.287 0.04,0.091 0.079,0.182 0.119,0.271 0.329,0.749 0.659,1.485 0.991,2.203 0.033,0.071 0.065,0.14 0.098,0.21 0.341,0.736 0.684,1.458 1.027,2.16 0.013,0.027 0.027,0.054 0.041,0.083 0.712,1.457 1.425,2.837 2.128,4.133 0.012,0.02 0.023,0.042 0.034,0.062 0.005,0.011 0.011,0.021 0.017,0.031 0.692,1.272 1.373,2.464 2.041,3.562 0.279,0.458 0.543,0.881 0.794,1.273 0.047,0.073 0.089,0.138 0.133,0.204 4.218,-3.908 8.554,-7.67 12.953,-11.255 -0.001,-0.002 -0.005,-0.006 -0.006,-0.008 -0.355,-0.414 -0.572,-0.669 -0.592,-0.696 -1.39,-1.856 -2.672,-3.754 -3.869,-5.679 -0.139,-0.225 -0.283,-0.448 -0.42,-0.674 -0.227,-0.374 -0.446,-0.75 -0.666,-1.126 -0.226,-0.388 -0.454,-0.776 -0.673,-1.167 -0.213,-0.38 -0.418,-0.763 -0.624,-1.146 -0.211,-0.391 -0.422,-0.782 -0.625,-1.174 -0.2,-0.387 -0.391,-0.776 -0.583,-1.165 -0.193,-0.392 -0.389,-0.784 -0.575,-1.178 -0.186,-0.394 -0.362,-0.789 -0.541,-1.184 -0.177,-0.394 -0.357,-0.789 -0.528,-1.185 -0.17,-0.398 -0.332,-0.797 -0.496,-1.196 -0.162,-0.397 -0.326,-0.793 -0.481,-1.191 -0.156,-0.402 -0.303,-0.807 -0.452,-1.211 -0.146,-0.398 -0.295,-0.796 -0.434,-1.195 -0.142,-0.407 -0.273,-0.815 -0.407,-1.223 -0.131,-0.399 -0.264,-0.798 -0.388,-1.199 -0.127,-0.411 -0.243,-0.823 -0.363,-1.236 -0.115,-0.4 -0.233,-0.799 -0.341,-1.2 -0.111,-0.414 -0.212,-0.829 -0.316,-1.245 -0.1,-0.4 -0.203,-0.801 -0.296,-1.202 -0.096,-0.418 -0.182,-0.836 -0.27,-1.254 -0.085,-0.401 -0.173,-0.802 -0.25,-1.204 -0.081,-0.419 -0.151,-0.839 -0.223,-1.259 -0.07,-0.402 -0.143,-0.804 -0.205,-1.206 -0.065,-0.42 -0.119,-0.841 -0.176,-1.262 -0.055,-0.402 -0.113,-0.805 -0.16,-1.208 -0.05,-0.422 -0.088,-0.845 -0.129,-1.269 -0.04,-0.401 -0.083,-0.802 -0.115,-1.203 -0.034,-0.425 -0.056,-0.849 -0.082,-1.273 -0.023,-0.401 -0.052,-0.801 -0.069,-1.201 -0.018,-0.425 -0.024,-0.849 -0.034,-1.272 -0.009,-0.401 -0.023,-0.802 -0.024,-1.202 -0.002,-0.425 0.008,-0.85 0.014,-1.275 0.006,-0.398 0.008,-0.796 0.02,-1.193 0.014,-0.428 0.041,-0.854 0.064,-1.281 0.021,-0.394 0.036,-0.789 0.064,-1.183 0.03,-0.427 0.074,-0.853 0.112,-1.279 0.037,-0.393 0.067,-0.786 0.109,-1.177 0.047,-0.426 0.107,-0.851 0.162,-1.276 0.051,-0.39 0.096,-0.781 0.153,-1.171 0.064,-0.427 0.14,-0.852 0.213,-1.278 0.065,-0.385 0.124,-0.771 0.195,-1.155 0.081,-0.428 0.175,-0.854 0.264,-1.28 0.08,-0.38 0.153,-0.762 0.239,-1.14 0.098,-0.43 0.21,-0.856 0.317,-1.284 0.093,-0.373 0.179,-0.747 0.279,-1.119 0.117,-0.433 0.248,-0.863 0.373,-1.293 0.106,-0.365 0.205,-0.73 0.318,-1.092 0.135,-0.433 0.284,-0.862 0.428,-1.294 0.119,-0.357 0.232,-0.716 0.358,-1.072 0.152,-0.431 0.32,-0.858 0.482,-1.287 0.133,-0.352 0.258,-0.705 0.398,-1.055 0.174,-0.438 0.364,-0.871 0.548,-1.306 0.142,-0.337 0.277,-0.676 0.426,-1.011 0.201,-0.453 0.419,-0.902 0.632,-1.353 0.094,-0.199 0.359,-0.758 0.575,-1.203 0.06,-0.122 0.117,-0.24 0.164,-0.334 0.264,-0.528 0.607,-1.202 0.837,-1.609 0,0 0.001,-10e-4 0.001,-10e-4 0.008,-0.016 0.016,-0.032 0.025,-0.049 0.041,-0.075 0.085,-0.147 0.126,-0.222 10e-4,0 10e-4,-0.001 0.002,-0.001 3.13,-5.494 5.874,-8.923 10.235,-13.779 1.573,-1.752 3.692,-3.747 5.935,-5.858 1.282,-1.207 2.638,-2.484 3.949,-3.772 0.741,-0.729 1.468,-1.462 2.158,-2.188 0.902,-0.947 2.591,-2.688 2.591,-2.688 0.212,-0.233 0.423,-0.465 0.632,-0.697 12.978,-14.393 20.376,-28.314 23.687,-44.705 0.047,-0.235 0.085,-0.471 0.13,-0.706 0.18,-0.926 0.354,-1.856 0.509,-2.799 0.201,-1.235 0.382,-2.474 0.54,-3.72 0.094,-0.747 0.183,-1.483 0.269,-2.209 0.03,-0.256 0.059,-0.506 0.088,-0.759 0.054,-0.469 0.108,-0.936 0.158,-1.396 0.031,-0.283 0.06,-0.561 0.09,-0.84 0.045,-0.426 0.089,-0.849 0.131,-1.266 0.014,-0.131 0.025,-0.259 0.039,-0.388 0.082,-0.836 0.159,-1.657 0.229,-2.456 0.009,-0.114 0.018,-0.223 0.028,-0.336 0.059,-0.692 0.112,-1.369 0.161,-2.031 l 0.003,-0.041 c 0.013,-0.176 0.025,-0.35 0.037,-0.524 0.003,-0.035 0.004,-0.068 0.007,-0.103 0.031,-0.456 0.059,-0.898 0.085,-1.34 0.01,-0.156 0.021,-0.32 0.03,-0.474 0.003,-0.055 0.008,-0.112 0.011,-0.166 0.002,-0.037 0.004,-0.072 0.006,-0.11 0.01,-0.174 0.014,-0.336 0.023,-0.509 0,-10e-4 0.001,-0.002 0.001,-0.004 0,-0.019 10e-4,-0.048 10e-4,-0.068 0.003,-0.095 0.006,-0.197 0.009,-0.323 0,-0.033 0.001,-0.073 0.002,-0.109 0.003,-0.145 0.007,-0.302 0.01,-0.477 0.001,-0.032 0.002,-0.067 0.003,-0.1 0.003,-0.207 0.007,-0.428 0.012,-0.665 -9.184,-1.431 -16.75,-1.926 -20.813,-2.098 -0.049,0.758 -0.101,1.522 -0.155,2.293 -0.027,0.369 -0.058,0.748 -0.087,1.124 -0.009,0.108 -0.018,0.219 -0.026,0.328 -0.019,0.233 -0.037,0.465 -0.054,0.697 -0.04,0.503 -0.076,1.003 -0.118,1.511 -0.029,0.357 -0.065,0.729 -0.095,1.088 -0.002,0.03 -0.004,0.059 -0.007,0.09 h -0.001 c -0.11,1.308 -0.22,2.617 -0.347,3.963 -0.69,7.299 -2.074,14.228 -4.111,20.593 -2.819,8.807 -6.99,16.653 -12.607,23.821 m 51.782,248.683 c 0.142,-0.016 0.291,-0.034 0.434,-0.051 0.39,-0.045 0.779,-0.091 1.175,-0.139 0.072,-0.009 0.147,-0.019 0.221,-0.027 0.467,-0.058 0.935,-0.116 1.411,-0.177 0.19,-0.024 0.385,-0.051 0.576,-0.075 0.368,-0.048 0.734,-0.096 1.107,-0.146 0.156,-0.021 0.315,-0.044 0.471,-0.065 0.412,-0.057 0.823,-0.113 1.242,-0.172 0.276,-0.039 0.557,-0.081 0.835,-0.122 0.302,-0.044 0.602,-0.086 0.907,-0.132 0.344,-0.051 0.694,-0.106 1.043,-0.159 0.248,-0.038 0.492,-0.075 0.742,-0.114 0.355,-0.055 0.716,-0.114 1.075,-0.172 0.245,-0.04 0.488,-0.078 0.735,-0.119 0.474,-0.077 0.951,-0.159 1.431,-0.24 0.136,-0.023 0.269,-0.045 0.406,-0.069 0.438,-0.075 0.88,-0.154 1.322,-0.233 0.185,-0.033 0.367,-0.064 0.552,-0.097 0.546,-0.099 1.098,-0.201 1.651,-0.305 0.079,-0.016 0.158,-0.03 0.237,-0.045 0.528,-0.099 1.06,-0.203 1.594,-0.308 0.109,-0.021 0.216,-0.041 0.326,-0.063 1.221,-0.242 2.456,-0.498 3.701,-0.766 0.065,-0.014 0.13,-0.027 0.195,-0.042 1.24,-0.268 2.49,-0.55 3.747,-0.847 0.075,-0.017 0.148,-0.033 0.222,-0.051 1.135,-0.268 2.277,-0.551 3.424,-0.842 0.201,-0.052 0.402,-0.101 0.604,-0.153 1.955,-0.505 3.926,-1.045 5.903,-1.622 0.067,-0.02 0.134,-0.039 0.203,-0.059 0.666,-0.195 1.334,-0.395 2.002,-0.599 0.015,-0.005 0.03,-0.01 0.046,-0.014 1.366,-0.419 2.735,-0.855 4.103,-1.311 42.66,-14.213 64.368,-39.416 64.521,-74.908 0.003,-0.686 -0.018,-1.374 -0.059,-2.063 -0.014,-0.235 -0.042,-0.471 -0.06,-0.706 -0.037,-0.456 -0.071,-0.911 -0.125,-1.369 -0.034,-0.282 -0.082,-0.564 -0.123,-0.846 -0.058,-0.412 -0.115,-0.824 -0.188,-1.238 -0.054,-0.303 -0.12,-0.606 -0.182,-0.91 -0.079,-0.393 -0.157,-0.787 -0.249,-1.181 -0.073,-0.316 -0.158,-0.632 -0.24,-0.948 -0.099,-0.383 -0.196,-0.767 -0.307,-1.151 -0.092,-0.323 -0.195,-0.646 -0.295,-0.969 -0.118,-0.379 -0.236,-0.758 -0.365,-1.138 -0.111,-0.328 -0.23,-0.655 -0.349,-0.983 -0.136,-0.375 -0.274,-0.751 -0.42,-1.127 -0.129,-0.331 -0.264,-0.662 -0.401,-0.993 -0.154,-0.374 -0.31,-0.747 -0.474,-1.121 -0.146,-0.333 -0.296,-0.666 -0.449,-1 -0.172,-0.372 -0.347,-0.745 -0.528,-1.119 -0.162,-0.333 -0.327,-0.667 -0.495,-1 -0.189,-0.374 -0.384,-0.747 -0.582,-1.121 -0.176,-0.332 -0.353,-0.664 -0.536,-0.997 -0.207,-0.376 -0.42,-0.752 -0.636,-1.128 -0.189,-0.329 -0.379,-0.659 -0.574,-0.989 -0.225,-0.378 -0.456,-0.756 -0.689,-1.134 -0.202,-0.327 -0.403,-0.655 -0.611,-0.982 -0.242,-0.382 -0.493,-0.764 -0.744,-1.146 -0.211,-0.321 -0.421,-0.642 -0.638,-0.964 -0.262,-0.389 -0.534,-0.777 -0.805,-1.166 -0.219,-0.315 -0.435,-0.629 -0.659,-0.942 -0.286,-0.399 -0.581,-0.798 -0.874,-1.196 -0.221,-0.302 -0.439,-0.603 -0.666,-0.905 -0.318,-0.423 -0.647,-0.845 -0.974,-1.267 -0.214,-0.276 -0.422,-0.551 -0.639,-0.827 -0.384,-0.486 -0.778,-0.971 -1.173,-1.455 -0.171,-0.21 -0.337,-0.421 -0.509,-0.631 -0.574,-0.695 -1.158,-1.388 -1.752,-2.081 -0.089,-0.103 -0.183,-0.207 -0.273,-0.31 -0.508,-0.588 -1.02,-1.175 -1.543,-1.76 -0.21,-0.235 -0.426,-0.469 -0.639,-0.704 -0.409,-0.453 -0.818,-0.906 -1.236,-1.358 -0.244,-0.263 -0.494,-0.526 -0.741,-0.789 -0.396,-0.422 -0.79,-0.843 -1.192,-1.262 -0.261,-0.274 -0.528,-0.545 -0.792,-0.818 -0.395,-0.407 -0.79,-0.815 -1.192,-1.22 -0.273,-0.278 -0.552,-0.553 -0.828,-0.83 -0.399,-0.399 -0.799,-0.797 -1.203,-1.195 -0.284,-0.279 -0.571,-0.556 -0.858,-0.834 -0.404,-0.392 -0.808,-0.784 -1.217,-1.173 -0.29,-0.277 -0.583,-0.553 -0.875,-0.829 -0.414,-0.391 -0.829,-0.781 -1.247,-1.169 -0.29,-0.27 -0.583,-0.539 -0.875,-0.808 -0.428,-0.393 -0.857,-0.785 -1.287,-1.175 -0.128,-0.116 -0.256,-0.231 -0.385,-0.346 -0.889,-0.802 -1.786,-1.599 -2.69,-2.391 -0.132,-0.115 -0.264,-0.229 -0.396,-0.345 -0.788,-0.687 -1.581,-1.369 -2.378,-2.048 -0.228,-0.193 -0.455,-0.387 -0.684,-0.581 -0.833,-0.704 -1.67,-1.404 -2.51,-2.1 -0.149,-0.123 -0.298,-0.246 -0.447,-0.368 -0.763,-0.629 -1.531,-1.251 -2.299,-1.87 -0.058,-0.048 -0.116,-0.095 -0.174,-0.142 v -0.001 c -0.142,-0.113 -0.283,-0.231 -0.424,-0.344 -0.597,-0.479 -3.46,-2.713 -5.165,-3.99 -6.293,-4.714 -19.819,-14.106 -28.771,-20.211 l -1.359,-0.928 c -2.007,-1.283 -3.929,-2.491 -5.761,-3.626 h -10e-4 c -2.512,-1.558 -4.843,-2.971 -6.944,-4.225 -0.461,-0.275 -1.417,-0.843 -1.453,-0.864 -0.021,-0.027 -7.871,-4.484 -16.001,-9.795 -0.307,-0.206 -0.619,-0.416 -0.942,-0.632 -1.339,-0.899 -2.816,-1.892 -4.413,-2.975 -8.615,-5.842 -20.689,-14.316 -33.133,-24.919 -0.004,0.004 -0.008,0.007 -0.013,0.012 -0.788,0.752 -1.572,1.491 -2.331,2.205 -2.148,2.022 -4.178,3.933 -5.583,5.498 -2.31,2.572 -4.131,4.711 -5.803,7.009 11.225,10.874 24.608,22.269 40.557,34.013 0.628,0.463 1.266,0.927 1.903,1.391 0.578,0.422 1.155,0.843 1.74,1.266 0.568,0.41 1.143,0.82 1.717,1.232 0.703,0.503 1.409,1.007 2.122,1.512 0.47,0.332 0.944,0.665 1.418,0.998 0.865,0.608 1.735,1.217 2.614,1.826 0.775,0.537 1.545,1.074 2.33,1.612 2.318,1.59 17.602,12.126 22.301,15.955 3.783,3.082 7.32,6.219 10.619,9.374 l 0.002,-0.001 c 0.118,0.115 0.238,0.229 0.357,0.344 0.362,0.348 0.726,0.696 1.082,1.044 0.13,0.128 0.257,0.255 0.384,0.383 0.151,0.147 0.298,0.295 0.448,0.444 0.011,0.012 0.024,0.024 0.036,0.036 0.348,0.345 0.698,0.69 1.04,1.036 0.235,0.238 0.465,0.476 0.696,0.714 0.143,0.146 0.284,0.292 0.426,0.438 0.244,0.25 0.489,0.501 0.729,0.751 0.281,0.293 0.553,0.586 0.83,0.879 0.085,0.091 0.171,0.183 0.257,0.274 0.08,0.086 0.161,0.171 0.241,0.256 0.155,0.165 0.312,0.33 0.464,0.494 0.272,0.294 0.536,0.587 0.802,0.88 0.312,0.34 0.625,0.682 0.931,1.022 0.263,0.294 0.517,0.587 0.776,0.88 0.299,0.34 0.602,0.68 0.896,1.02 0.254,0.293 0.5,0.586 0.75,0.879 0.288,0.338 0.579,0.677 0.861,1.015 0.248,0.296 0.487,0.591 0.732,0.887 0.273,0.333 0.55,0.667 0.819,0.999 0.245,0.304 0.482,0.607 0.723,0.911 0.256,0.322 0.515,0.645 0.766,0.967 0.24,0.308 0.471,0.615 0.706,0.923 0.242,0.316 0.488,0.633 0.725,0.948 0.227,0.303 0.445,0.604 0.668,0.906 0.234,0.318 0.472,0.637 0.702,0.955 0.223,0.308 0.435,0.614 0.653,0.922 0.218,0.307 0.439,0.614 0.652,0.92 0.219,0.317 0.43,0.632 0.645,0.948 0.2,0.295 0.405,0.591 0.601,0.885 0.209,0.313 0.408,0.623 0.611,0.936 0.191,0.293 0.387,0.588 0.574,0.88 0.201,0.317 0.394,0.63 0.59,0.945 0.177,0.284 0.358,0.57 0.531,0.852 0.194,0.317 0.377,0.631 0.565,0.946 0.166,0.278 0.336,0.557 0.496,0.834 0.183,0.314 0.356,0.625 0.533,0.938 0.154,0.273 0.315,0.548 0.465,0.82 0.171,0.308 0.331,0.613 0.496,0.919 0.146,0.272 0.298,0.547 0.439,0.817 0.165,0.312 0.318,0.621 0.475,0.93 0.132,0.26 0.269,0.521 0.397,0.778 0.158,0.321 0.306,0.637 0.459,0.955 0.116,0.243 0.237,0.489 0.349,0.73 0.148,0.316 0.284,0.628 0.424,0.941 0.107,0.239 0.22,0.48 0.322,0.717 0.137,0.316 0.264,0.626 0.394,0.937 0.095,0.23 0.196,0.463 0.288,0.691 0.127,0.315 0.243,0.624 0.362,0.935 0.085,0.221 0.176,0.444 0.257,0.663 0.111,0.3 0.211,0.595 0.315,0.891 0.08,0.225 0.165,0.453 0.24,0.675 0.1,0.299 0.19,0.592 0.284,0.887 0.067,0.214 0.141,0.431 0.205,0.643 0.089,0.295 0.167,0.585 0.249,0.876 0.059,0.206 0.122,0.416 0.177,0.62 0.077,0.293 0.144,0.579 0.215,0.867 0.047,0.196 0.1,0.396 0.145,0.589 0.068,0.3 0.125,0.592 0.185,0.887 0.036,0.176 0.077,0.357 0.11,0.532 0.053,0.279 0.094,0.552 0.139,0.826 0.029,0.184 0.065,0.371 0.091,0.553 0.041,0.284 0.072,0.56 0.104,0.839 0.02,0.164 0.045,0.333 0.062,0.495 0.031,0.311 0.049,0.614 0.07,0.919 0.008,0.123 0.022,0.25 0.028,0.372 0.023,0.423 0.033,0.838 0.033,1.245 0,0.416 -0.009,0.83 -0.029,1.241 -0.006,0.125 -0.018,0.248 -0.026,0.372 -0.018,0.286 -0.034,0.572 -0.061,0.856 -0.012,0.126 -0.03,0.249 -0.044,0.374 -0.03,0.281 -0.059,0.561 -0.098,0.839 -0.021,0.146 -0.049,0.29 -0.072,0.435 -0.041,0.255 -0.078,0.511 -0.126,0.765 -0.029,0.156 -0.067,0.311 -0.098,0.467 -0.05,0.24 -0.097,0.481 -0.154,0.72 -0.03,0.131 -0.068,0.259 -0.1,0.39 -0.067,0.261 -0.13,0.523 -0.203,0.782 -0.039,0.135 -0.084,0.269 -0.124,0.403 -0.077,0.253 -0.15,0.506 -0.233,0.756 -0.044,0.134 -0.095,0.265 -0.141,0.399 -0.087,0.249 -0.171,0.498 -0.265,0.745 -0.056,0.146 -0.117,0.289 -0.175,0.434 -0.093,0.233 -0.182,0.467 -0.282,0.698 -0.063,0.146 -0.132,0.29 -0.196,0.435 -0.102,0.228 -0.201,0.456 -0.308,0.681 -0.072,0.152 -0.151,0.301 -0.226,0.451 -0.108,0.218 -0.213,0.437 -0.327,0.653 -0.072,0.138 -0.151,0.274 -0.226,0.412 -0.123,0.226 -0.243,0.453 -0.372,0.678 -0.071,0.122 -0.147,0.243 -0.219,0.365 -0.141,0.237 -0.279,0.476 -0.426,0.711 -0.066,0.106 -0.137,0.21 -0.204,0.315 -0.159,0.25 -0.317,0.499 -0.484,0.747 -0.071,0.105 -0.147,0.208 -0.219,0.313 -0.169,0.245 -0.337,0.491 -0.512,0.734 -0.083,0.114 -0.171,0.227 -0.256,0.342 -0.171,0.23 -0.341,0.462 -0.517,0.691 -0.096,0.123 -0.197,0.245 -0.294,0.368 -0.172,0.217 -0.342,0.435 -0.52,0.65 -0.104,0.127 -0.215,0.253 -0.322,0.379 -0.176,0.21 -0.351,0.42 -0.532,0.627 -0.103,0.117 -0.209,0.232 -0.313,0.348 -0.192,0.215 -0.383,0.431 -0.581,0.644 -0.096,0.104 -0.196,0.206 -0.294,0.309 -0.211,0.224 -0.422,0.448 -0.638,0.67 -0.087,0.088 -0.178,0.176 -0.265,0.264 -0.232,0.233 -0.463,0.467 -0.701,0.697 -0.106,0.103 -0.217,0.205 -0.324,0.307 -0.225,0.215 -0.45,0.43 -0.68,0.643 -0.1,0.092 -0.203,0.182 -0.303,0.273 -0.243,0.221 -0.486,0.443 -0.734,0.661 -0.116,0.102 -0.236,0.202 -0.353,0.303 -0.237,0.206 -0.473,0.412 -0.717,0.616 -0.135,0.114 -0.275,0.226 -0.412,0.339 -0.229,0.19 -0.458,0.379 -0.691,0.567 -0.142,0.114 -0.286,0.226 -0.429,0.338 -0.234,0.185 -0.467,0.37 -0.705,0.554 -0.144,0.111 -0.292,0.22 -0.438,0.33 -0.242,0.184 -0.483,0.367 -0.729,0.549 -0.145,0.107 -0.294,0.212 -0.441,0.319 -0.249,0.181 -0.496,0.363 -0.749,0.542 -0.17,0.12 -0.344,0.239 -0.516,0.358 -0.235,0.164 -0.469,0.329 -0.707,0.491 -0.166,0.114 -0.336,0.225 -0.504,0.337 -0.248,0.166 -0.494,0.334 -0.746,0.498 -0.169,0.112 -0.342,0.221 -0.513,0.331 -0.253,0.163 -0.505,0.327 -0.76,0.489 -0.182,0.115 -0.367,0.227 -0.55,0.342 -0.249,0.154 -0.497,0.31 -0.749,0.463 -0.198,0.121 -0.399,0.239 -0.598,0.358 -0.241,0.144 -0.48,0.29 -0.724,0.433 -0.21,0.123 -0.424,0.245 -0.637,0.368 -0.237,0.136 -0.471,0.274 -0.709,0.409 -0.201,0.114 -0.405,0.226 -0.609,0.34 -0.253,0.141 -0.505,0.284 -0.761,0.424 -0.214,0.118 -0.432,0.233 -0.649,0.35 -0.244,0.131 -0.487,0.265 -0.734,0.395 -0.241,0.128 -0.485,0.253 -0.728,0.379 -0.226,0.119 -0.452,0.238 -0.679,0.354 -0.236,0.121 -0.473,0.239 -0.708,0.358 -0.241,0.121 -0.479,0.243 -0.721,0.363 -0.25,0.124 -0.503,0.246 -0.755,0.369 -0.227,0.111 -0.454,0.222 -0.683,0.332 -0.271,0.131 -0.545,0.259 -0.819,0.388 -0.214,0.101 -0.426,0.203 -0.641,0.302 -0.285,0.133 -0.573,0.263 -0.86,0.394 -0.204,0.094 -0.406,0.188 -0.611,0.28 -0.31,0.14 -0.623,0.277 -0.935,0.415 -0.183,0.082 -0.367,0.164 -0.551,0.245 -0.309,0.135 -0.621,0.267 -0.931,0.401 -0.192,0.081 -0.381,0.164 -0.572,0.245 -0.333,0.141 -0.666,0.279 -1,0.418 -0.169,0.07 -0.338,0.141 -0.508,0.211 -0.343,0.141 -0.689,0.279 -1.033,0.419 -0.166,0.066 -0.329,0.132 -0.493,0.198 -0.344,0.138 -0.691,0.272 -1.038,0.408 -0.165,0.064 -0.329,0.129 -0.494,0.193 -0.37,0.143 -0.74,0.283 -1.111,0.423 -0.143,0.054 -0.285,0.109 -0.428,0.163 -0.398,0.149 -0.798,0.296 -1.197,0.442 -0.116,0.043 -0.233,0.086 -0.349,0.129 -0.405,0.147 -0.81,0.291 -1.217,0.435 -0.113,0.041 -0.226,0.082 -0.34,0.122 -0.411,0.145 -0.823,0.287 -1.234,0.429 -0.109,0.037 -0.218,0.076 -0.327,0.113 -0.45,0.154 -0.901,0.305 -1.353,0.456 -0.068,0.023 -0.137,0.047 -0.207,0.07 -0.473,0.157 -0.948,0.312 -1.423,0.465 -0.047,0.015 -0.095,0.031 -0.143,0.046 -0.444,0.143 -0.889,0.284 -1.333,0.423 -0.082,0.026 -0.164,0.052 -0.245,0.077 -0.488,0.153 -0.976,0.302 -1.463,0.45 -0.034,0.01 -0.067,0.021 -0.101,0.03 -0.498,0.151 -0.995,0.299 -1.492,0.444 -0.026,0.009 -0.054,0.017 -0.081,0.025 -0.48,0.14 -0.962,0.279 -1.443,0.416 -0.044,0.012 -0.088,0.025 -0.132,0.037 -1.034,0.294 -2.068,0.577 -3.099,0.851 l -0.032,0.009 c -0.517,0.137 -1.034,0.273 -1.551,0.405 -0.004,0.001 -0.007,0.002 -0.009,0.003 -2.601,0.667 -5.179,1.272 -7.713,1.813 -0.076,5.462 -0.356,11.177 -0.853,17.144 -0.544,6.524 -1.4,12.227 -2.45,17.359 3.39,-0.218 7.566,-0.563 12.304,-1.108 M -3.285,133.386 c -9.767,8.739 -21.5,16.197 -30.347,20.349 1.426,1.189 2.575,2.166 2.747,2.31 0.318,0.266 0.632,0.536 0.948,0.804 0.249,0.21 0.497,0.419 0.744,0.629 1.94,1.654 3.857,3.335 5.744,5.042 0.097,0.088 0.195,0.176 0.292,0.265 20.222,18.346 36.714,39.536 36.628,59.817 -0.163,37.808 -23.893,65.67 -68.623,80.574 -23.841,7.944 -47.347,10.221 -59.246,10.871 -0.366,1.434 -0.745,2.823 -1.134,4.175 -1.339,4.701 -2.808,8.945 -4.272,12.997 -9.932,27.47 -34.273,43.426 -47.349,51.998 l -2.731,1.792 -1.668,-1.17 c -1.725,-1.211 -41.917,-29.839 -47.885,-69.258 l -0.748,10e-4 c -3.045,0.005 -6.098,0.008 -9.149,0.012 -31.062,0.039 -55.823,0.012 -73.591,-0.076 -10.56,-0.053 -18.74,-0.127 -24.313,-0.223 -3.014,-0.052 -5.333,-0.111 -6.892,-0.176 -2.619,-0.109 -4.881,-0.202 -5.278,-2.758 l -0.331,-2.592 2.463,-0.773 c 39.416,-12.367 40.811,-32.555 40.818,-32.68 l 2.751,-272.477 0.017,-0.286 c 0.027,-0.255 2.194,-25.759 -41.743,-46.22 -1.702,-0.791 -4.55,-2.116 -3.865,-4.957 0.735,-3.041 4.072,-3.002 10.131,-2.927 4.984,0.061 12.657,0.355 24.271,0.799 16.466,0.631 40.478,1.551 74.542,2.476 1.457,0.04 2.934,0.079 4.426,0.118 0.266,0.008 0.531,0.014 0.797,0.021 1.58,0.042 3.176,0.083 4.799,0.125 0.273,-1.439 0.57,-2.893 0.891,-4.361 l 0.097,-0.446 c 7.868,-36.662 39.439,-55.836 51.324,-63.055 l 1.575,-0.957 1.566,0.974 c 1.439,0.894 33.59,21.138 47.166,50.937 0.418,0.918 1.309,2.736 2.277,5.122 0.857,2.109 1.808,4.816 2.06,5.486 0.65,1.737 1.351,3.852 2.024,6.458 0.029,0.108 0.057,0.215 0.085,0.327 0.13,0.513 0.26,1.039 0.388,1.591 0.246,0.009 0.504,0.018 0.771,0.029 0.17,0.007 0.351,0.014 0.53,0.022 0.095,0.004 0.185,0.007 0.282,0.012 0.256,0.011 0.522,0.023 0.792,0.036 0.021,0.001 0.04,0.001 0.061,0.003 1.469,0.07 3.162,0.168 5.045,0.304 0.018,10e-4 0.037,0.003 0.055,0.004 23.119,1.668 75.215,9.013 107.563,41.26 17.832,17.778 26.874,40.553 26.874,67.696 0,25.642 -11.888,49.832 -34.379,69.956"/>
-				</g>
-			</g>
-		</g>
-	</g>
-    </g>
-</g>
-<g id="Rope" transform="translate(-17.1,-17.1) scale(1.09375)" filter="url(#dropShadowAlpha)">
-	<path fill="#8C6239" stroke="#42210B" stroke-width="2" stroke-miterlimit="10" d="M489.61,239.538
-		c-1.499-5.47-5.238-10.585-11.214-15.342c5.53-13.903,2.378-25.404-9.461-34.5c5.531-13.903,2.378-25.403-9.46-34.5
-		c7.497-18.98-4.618-38.813-24.491-41.783c-2.164-14.807-10.647-23.188-25.449-25.141c-2.163-14.807-10.646-23.187-25.449-25.141
-		c-2.995-20.136-23.285-31.481-42.011-24.084c-9.29-11.732-20.828-14.736-34.618-9.014c-9.29-11.731-20.831-14.736-34.621-9.014
-		c-12.679-15.929-35.773-15.485-48.289,0.232c-13.903-5.536-25.403-2.386-34.503,9.452c-13.902-5.537-25.403-2.387-34.503,9.45
-		c-18.985-7.505-38.811,4.628-41.777,24.5c-14.806,2.169-23.183,10.655-25.133,25.458c-14.806,2.168-23.184,10.654-25.134,25.457
-		c-20.132,3.001-31.463,23.3-24.075,42.021c-11.734,9.286-14.742,20.825-9.024,34.617c-11.735,9.286-14.743,20.824-9.024,34.616
-		C5.435,239.5,5.879,262.86,21.599,275.381c-5.539,13.902-2.389,25.403,9.447,34.505c-5.538,13.901-2.39,25.401,9.446,34.504
-		c-7.504,18.977,4.607,38.816,24.477,41.794c2.16,14.808,10.64,23.191,25.44,25.15c2.159,14.808,10.639,23.191,25.44,25.15
-		c2.988,20.136,23.253,31.477,41.98,24.09c9.284,11.735,20.822,14.746,34.616,9.03c9.283,11.737,20.822,14.747,34.615,9.03
-		c12.679,15.946,35.994,15.499,48.51-0.232c13.904,5.529,25.403,2.374,34.498-9.467c13.904,5.529,25.403,2.373,34.498-9.469
-		c18.986,7.496,38.788-4.634,41.743-24.507c14.807-2.175,23.181-10.663,25.126-25.466c14.805-2.174,23.179-10.662,25.124-25.466
-		c20.129-3.009,31.456-23.313,24.06-42.031c11.729-9.289,14.733-20.83,9.011-34.619c11.729-9.29,14.733-20.83,9.009-34.621
-		C488.343,265.032,492.901,251.525,489.61,239.538C488.111,234.068,490.546,242.945,489.61,239.538z M469.511,262.109
-		c-1.674,1.221-3.365,2.419-5.073,3.591c-1.555-4.101-2.273-7.857-2.19-11.283c1.733,2.103,3.829,3.519,6.286,4.248
-		C468.756,259.786,469.073,260.932,469.511,262.109z M460.954,268.154c-11.331,8.958-14.583,20.638-8.947,34.379
-		c-11.731,9.291-14.734,20.831-9.011,34.62c-6.114,4.3-9.83,9.647-11.145,16.041c-4.93,4.451-7.697,10.45-8.303,17.999
-		c-14.291,2.086-22.952,10.571-24.948,25.288c-14.806,2.175-23.18,10.663-25.124,25.466c-7.542,0.709-13.504,3.558-17.888,8.55
-		c-6.362,1.404-11.649,5.187-15.859,11.348c-13.417-5.348-25.163-2.338-34.258,9.401c-13.904-5.529-25.403-2.374-34.498,9.467
-		c-6.842-3.159-13.393-3.689-19.648-1.592c-6.29-2.029-12.841-1.417-19.653,1.832c-8.95-11.334-20.629-14.594-34.373-8.968
-		c-9.284-11.736-20.822-14.746-34.615-9.029c-4.285-6.12-9.619-9.835-16-11.146c-4.441-4.938-10.438-7.711-17.989-8.32
-		c-2.07-14.294-10.548-22.964-25.262-24.974c-2.159-14.809-10.64-23.192-25.441-25.151c-0.699-7.543-3.542-13.508-8.529-17.896
-		c-1.396-6.378-5.179-11.681-11.347-15.904c5.357-13.412,2.354-25.161-9.38-34.263c5.539-13.9,2.389-25.403-9.446-34.504
-		c3.168-6.855,3.699-13.415,1.592-19.683c2.034-6.301,1.425-12.862-1.827-19.684c11.334-8.952,14.591-20.632,8.961-34.375
-		c11.733-9.286,14.742-20.825,9.024-34.617c6.12-4.297,9.836-9.644,11.151-16.039c4.932-4.446,7.701-10.444,8.308-17.994
-		c14.292-2.081,22.956-10.563,24.958-25.279c14.806-2.168,23.184-10.654,25.134-25.457c7.549-0.704,13.515-3.553,17.897-8.549
-		c6.371-1.391,11.664-5.172,15.879-11.344c13.413,5.356,25.16,2.352,34.261-9.385c13.901,5.536,25.402,2.385,34.503-9.451
-		c6.806,3.16,13.32,3.704,19.546,1.635c6.26,1.996,12.778,1.372,19.551-1.873c8.957,11.331,20.639,14.584,34.38,8.951
-		c9.288,11.731,20.828,14.736,34.617,9.013c4.293,6.111,9.632,9.824,16.017,11.141c4.446,4.938,10.445,7.712,17.999,8.322
-		c2.076,14.293,10.556,22.958,25.271,24.965c2.164,14.807,10.647,23.187,25.45,25.141c0.7,7.543,3.547,13.507,8.535,17.892
-		c1.39,6.38,5.173,11.68,11.353,15.899c-5.352,13.416-2.344,25.161,9.394,34.259c-5.532,13.904-2.379,25.404,9.461,34.5
-		c-3.165,6.854-3.693,13.415-1.586,19.682C457.088,254.771,457.7,261.334,460.954,268.154z M454.747,366.533
-		c-2.197,1.695-4.749,2.419-7.656,2.17c-0.098-4.453,1.825-7.746,5.769-9.874C454.355,361.248,454.984,363.815,454.747,366.533
-		C454.1,367.041,454.847,365.758,454.747,366.533z M431.516,359.994c0.43,2.72,1.531,5.018,3.304,6.894
-		c-0.349,1.049-0.634,2.161-0.836,3.354c-2.062,0.218-4.124,0.408-6.19,0.57C428.494,366.507,429.743,362.91,431.516,359.994
-		C431.894,362.185,429.743,362.91,431.516,359.994z M439.431,365.847c0.675-2.472,2.204-3.328,4.589-2.569
-		c0.767,2.087,0.158,3.504-1.824,4.25C441.199,367.088,440.277,366.526,439.431,365.847
-		C439.937,364.822,440.277,366.526,439.431,365.847z M449.429,355.128c-0.277,5.455-6.212,3.387-2.922-1.52
-		C447.569,353.988,448.543,354.498,449.429,355.128C449.389,355.898,448.543,354.498,449.429,355.128z M441.608,355.404
-		c-0.342,1.311-0.396,2.453-0.178,3.436c-2.035,0.821-3.602,2.168-4.699,4.043c-1.343-2.067-1.771-4.584-1.248-7.57
-		c2.207-1.806,4.569-2.633,7.089-2.492C442.167,353.66,441.839,354.519,441.608,355.404
-		C441.267,356.715,441.839,354.519,441.608,355.404z M366.444,453.315c-1.771-0.22-3.445-0.85-5.023-1.876
-		c2.102-3.916,5.386-5.88,9.855-5.89c0.142,2.85-0.543,5.403-2.058,7.661C368.316,453.363,367.394,453.408,366.444,453.315
-		C364.673,453.096,367.394,453.408,366.444,453.315z M351.325,442.617c0.065,0.412,0.149,0.813,0.238,1.21
-		c-0.801,0.716-1.578,1.515-2.326,2.417c-1.894-0.841-3.775-1.71-5.644-2.604c2.699-3.3,5.511-5.75,8.43-7.39
-		C351.329,438.259,351.087,440.379,351.325,442.617C351.391,443.029,351.087,440.379,351.325,442.617z M356.113,445.194
-		c1.834-1.831,3.6-1.817,5.3,0.045c-0.379,2.171-1.606,3.103-3.681,2.795C357.066,447.157,356.525,446.211,356.113,445.194
-		C357.078,444.548,356.525,446.211,356.113,445.194z M370.083,440.679c-2.979,4.649-7.115-0.108-1.809-2.717
-		C369.013,438.806,369.617,439.711,370.083,440.679C369.655,441.348,369.617,439.711,370.083,440.679z M363.144,437.056
-		c-0.994,1.007-1.626,2.012-1.912,3.015c-2.157-0.259-4.171,0.153-6.042,1.236c-0.189-2.469,0.654-4.868,2.544-7.197
-		c2.849-0.521,5.334-0.1,7.474,1.233C364.461,435.855,363.768,436.422,363.144,437.056
-		C362.149,438.063,363.768,436.422,363.144,437.056z M253.333,484.456c-0.59,0.46-1.222,0.83-1.891,1.125
-		c-2.562-1.032-4.468-2.855-5.715-5.47c2.32,0.487,4.173-0.107,5.54-1.824c1.216,1.804,3.151,2.401,5.802,1.801
-		C256.183,481.745,254.942,483.203,253.333,484.456C252.743,484.916,254.942,483.203,253.333,484.456z M237.712,469.514
-		c-1.219-1.676-2.415-3.367-3.588-5.074c4.079-1.546,7.817-2.262,11.229-2.187c-2.107,1.737-3.525,3.836-4.255,6.297
-		C239.995,468.771,238.869,469.084,237.712,469.514z M244.278,475.357c-0.135-1.112-0.123-2.222,0.041-3.327
-		c2.439-0.623,3.921,0.275,4.444,2.695C247.381,476.395,245.887,476.604,244.278,475.357
-		C244.143,474.245,244.947,475.708,244.278,475.357z M258.527,475.299c-4.777,2.398-5.926-3.675-0.163-3.336
-		C258.579,473.09,258.628,474.202,258.527,475.299C257.866,475.631,258.628,474.202,258.527,475.299z M254.465,468.619
-		c-1.36,0.373-2.407,0.925-3.157,1.646c-1.714-1.341-3.649-2.024-5.805-2.046c1.092-2.203,3.029-3.837,5.833-4.891
-		c2.67,0.996,4.57,2.614,5.722,4.845C256.172,468.245,255.308,468.389,254.465,468.619
-		C253.104,468.992,255.308,468.389,254.465,468.619z M133.296,454.687c-1.699-2.204-2.42-4.763-2.162-7.68
-		c4.446-0.052,7.745,1.884,9.894,5.808C138.601,454.313,136.023,454.937,133.296,454.687
-		C132.789,454.038,134.081,454.79,133.296,454.687z M142.475,449.066c-3.266-0.853-0.052-5.181,3.779-2.593
-		c-0.38,1.058-0.886,2.025-1.514,2.906C143.958,449.342,143.195,449.254,142.475,449.066
-		C141.186,448.729,143.195,449.254,142.475,449.066z M136.592,443.968c-2.103,0.767-3.526,0.146-4.27-1.863
-		c0.44-0.986,1-1.899,1.677-2.74C136.49,440.039,137.354,441.573,136.592,443.968C135.416,444.687,137.294,442.785,136.592,443.968z
-		 M132.962,434.755c-1.041-0.346-2.143-0.628-3.325-0.832c-0.216-2.061-0.405-4.122-0.564-6.188
-		c4.296,0.704,7.886,1.952,10.798,3.721C137.146,431.883,134.844,432.983,132.962,434.755
-		C131.922,434.409,133.208,434.535,132.962,434.755z M147.05,442.539c-1.879-1.003-3.885-1.394-6.021-1.169
-		c-0.825-2.035-2.177-3.604-4.057-4.703c2.074-1.341,4.599-1.76,7.592-1.227C146.37,437.65,147.194,440.018,147.05,442.539
-		C146.201,442.126,147.194,440.018,147.05,442.539z M64.594,365.062c-1.146-1.808-2.719-3.129-4.72-3.965
-		c0.267-2.155-0.137-4.168-1.213-6.039c2.465-0.185,4.861,0.66,7.185,2.55C66.358,360.448,65.931,362.929,64.594,365.062
-		C64.085,364.32,65.931,362.929,64.594,365.062z M46.729,369.045c-0.447-2.761,0.15-5.352,1.788-7.771
-		c3.934,2.081,5.884,5.36,5.849,9.836C51.526,371.244,48.981,370.556,46.729,369.045C46.582,368.151,47.294,369.449,46.729,369.045z
-		 M56.113,358.788c0.265,0.965-0.205,1.786-1.403,2.459c-2.161-0.376-3.09-1.593-2.792-3.649c0.883-0.67,1.835-1.213,2.855-1.625
-		C55.411,356.929,55.861,357.867,56.113,358.788C56.378,359.753,55.861,357.867,56.113,358.788z M57.441,368.534
-		c-2.426-2.399,2.53-4.466,4.531-0.411c-0.849,0.739-1.761,1.344-2.737,1.809C58.58,369.51,57.967,369.054,57.441,368.534
-		C56.493,367.598,57.967,369.054,57.441,368.534z M57.348,351.193c-0.407,0.064-0.803,0.146-1.196,0.231
-		c-0.722-0.81-1.526-1.597-2.44-2.355c0.843-1.893,1.713-3.771,2.608-5.641c3.311,2.712,5.766,5.538,7.404,8.471
-		C61.715,351.201,59.591,350.955,57.348,351.193C56.94,351.258,59.591,350.955,57.348,351.193z M31.837,256.82
-		c-0.102-2.115-0.808-4.024-2.117-5.728c1.352-1.703,2.043-3.628,2.072-5.776c2.197,1.089,3.828,3.019,4.881,5.808
-		C35.677,253.779,34.063,255.674,31.837,256.82C31.764,255.954,34.063,255.674,31.837,256.82z M28.05,258.127
-		c-1.137,0.215-2.259,0.264-3.366,0.158C22.348,253.559,28.361,252.444,28.05,258.127C26.913,258.342,28.105,257.118,28.05,258.127z
-		 M27.73,247.093c-0.252,0.968-1.068,1.447-2.442,1.432c-1.657-1.361-1.877-2.835-0.662-4.427c1.125-0.138,2.245-0.128,3.36,0.038
-		C28.045,245.223,27.96,246.209,27.73,247.093C27.478,248.061,27.96,246.209,27.73,247.093z M21.76,251.061
-		c-1.814,1.205-2.43,3.124-1.85,5.762c-2.475-1.315-4.297-3.18-5.466-5.595c1.034-2.544,2.85-4.437,5.447-5.68
-		C19.424,247.857,20.029,249.702,21.76,251.061C19.945,252.266,20.029,249.702,21.76,251.061z M32.504,241.271
-		c-0.345-0.132-0.688-0.244-1.032-0.356c-0.223-1.121-0.539-2.266-0.976-3.443c1.675-1.22,3.367-2.416,5.075-3.589
-		c1.553,4.101,2.269,7.856,2.187,11.282C36.353,243.509,34.606,242.207,32.504,241.271C32.16,241.139,34.606,242.207,32.504,241.271
-		z M45.3,133.057c2.198-1.694,4.751-2.417,7.659-2.168c0.095,4.453-1.829,7.745-5.772,9.874
-		C45.692,138.344,45.063,135.776,45.3,133.057C45.95,132.549,45.201,133.833,45.3,133.057z M68.532,139.602
-		c-0.431-2.72-1.532-5.018-3.303-6.895c0.35-1.048,0.635-2.159,0.838-3.352c2.06-0.218,4.124-0.407,6.189-0.568
-		C71.553,133.092,70.303,136.687,68.532,139.602C68.155,137.412,70.303,136.687,68.532,139.602z M60.618,133.747
-		c-0.675,2.473-2.205,3.33-4.59,2.57c-0.767-2.089-0.157-3.505,1.828-4.25C58.85,132.506,59.771,133.066,60.618,133.747
-		C60.11,134.771,59.771,133.066,60.618,133.747z M50.617,144.464c0.278-5.457,6.213-3.387,2.92,1.52
-		C52.475,145.604,51.502,145.095,50.617,144.464C50.656,143.693,51.502,145.095,50.617,144.464z M58.437,144.19
-		c0.342-1.311,0.396-2.454,0.179-3.437c2.035-0.821,3.602-2.167,4.701-4.042c1.343,2.068,1.771,4.586,1.246,7.571
-		c-2.208,1.806-4.571,2.632-7.091,2.492C57.877,145.935,58.206,145.075,58.437,144.19C58.778,142.879,58.206,145.075,58.437,144.19z
-		 M133.637,46.308c1.769,0.221,3.442,0.85,5.019,1.875c-2.081,3.933-5.358,5.889-9.833,5.867c-0.14-2.842,0.546-5.39,2.056-7.643
-		C131.775,46.257,132.693,46.216,133.637,46.308C135.406,46.528,132.693,46.216,133.637,46.308z M148.75,57.011
-		c-0.065-0.409-0.147-0.808-0.234-1.203c0.807-0.72,1.591-1.523,2.347-2.434c1.893,0.843,3.774,1.712,5.643,2.607
-		c-2.708,3.305-5.528,5.757-8.454,7.396C148.745,61.372,148.989,59.25,148.75,57.011C148.685,56.602,148.989,59.25,148.75,57.011z
-		 M138.687,54.374c0.375-2.162,1.593-3.093,3.652-2.792c0.67,0.882,1.212,1.832,1.627,2.852
-		C142.137,56.251,140.378,56.23,138.687,54.374C138.653,52.996,139.359,55.573,138.687,54.374z M130.008,58.917
-		c2.969-4.607,7.086,0.126,1.813,2.731C131.08,60.8,130.474,59.89,130.008,58.917C130.432,58.259,130.474,59.89,130.008,58.917z
-		 M136.932,62.567c0.998-1.011,1.632-2.02,1.917-3.027c2.155,0.264,4.166-0.143,6.037-1.221c0.188,2.466-0.654,4.863-2.54,7.188
-		c-2.844,0.517-5.325,0.093-7.46-1.24C135.625,63.758,136.311,63.195,136.932,62.567C137.93,61.557,136.311,63.195,136.932,62.567z
-		 M262.188,30.146c1.221,1.675,2.417,3.367,3.591,5.073c-3.997,1.516-7.666,2.235-11.023,2.195c2.12-1.75,3.546-3.866,4.277-6.348
-		C260.062,30.846,261.111,30.546,262.188,30.146z M255.854,24.434c0.116,1.062,0.098,2.12-0.059,3.173
-		c-2.548,0.716-4.103-0.173-4.661-2.667C252.596,23.213,254.168,23.045,255.854,24.434C255.971,25.496,255.107,24.02,255.854,24.434
-		z M250.936,15.321c1.459,1.106,2.613,2.537,3.473,4.277c-3.848,2.188-7.718,2.2-11.608,0.036c1.338-2.548,3.252-4.413,5.741-5.594
-		C249.377,14.358,250.177,14.777,250.936,15.321C252.395,16.427,250.177,14.777,250.936,15.321z M241.356,24.482
-		c5.014-2.644,6.241,3.691,0.174,3.206C241.327,26.606,241.271,25.538,241.356,24.482C242.092,24.094,241.271,25.538,241.356,24.482
-		z M245.645,31.046c1.298-0.356,2.312-0.874,3.053-1.547c1.755,1.316,3.723,1.968,5.907,1.956c-1.106,2.228-3.076,3.876-5.936,4.926
-		c-2.723-0.991-4.657-2.622-5.823-4.878C243.803,31.438,244.738,31.293,245.645,31.046
-		C246.943,30.689,244.738,31.293,245.645,31.046z M366.616,44.931c1.694,2.199,2.415,4.753,2.161,7.664
-		c-4.453,0.083-7.743-1.846-9.873-5.788C361.326,45.313,363.897,44.688,366.616,44.931C367.122,45.577,365.837,44.83,366.616,44.931
-		z M357.435,50.547c3.277,0.853,0.053,5.169-3.758,2.606c0.381-1.061,0.89-2.033,1.521-2.917
-		C355.97,50.276,356.724,50.362,357.435,50.547C358.725,50.883,356.724,50.362,357.435,50.547z M363.34,55.654
-		c2.093-0.765,3.512-0.153,4.256,1.838c-0.441,0.991-1.002,1.911-1.684,2.755C363.438,59.573,362.579,58.042,363.34,55.654
-		C364.516,54.937,362.639,56.837,363.34,55.654z M366.949,64.859c1.047,0.349,2.158,0.634,3.349,0.837
-		c0.217,2.061,0.406,4.124,0.566,6.189c-4.306-0.704-7.899-1.956-10.816-3.729C362.77,67.729,365.07,66.629,366.949,64.859
-		C367.996,65.208,366.706,65.077,366.949,64.859z M352.882,57.086c1.879,0.998,3.886,1.382,6.02,1.152
-		c0.82,2.037,2.167,3.605,4.042,4.706c-2.07,1.339-4.591,1.763-7.58,1.234C353.562,61.969,352.738,59.606,352.882,57.086
-		C353.727,57.495,352.738,59.606,352.882,57.086z M435.363,134.533c1.147,1.807,2.721,3.128,4.723,3.964
-		c-0.266,2.155,0.139,4.168,1.216,6.04c-2.466,0.185-4.862-0.66-7.187-2.549C433.602,139.146,434.029,136.667,435.363,134.533
-		C435.874,135.273,434.029,136.667,435.363,134.533z M453.23,130.545c0.446,2.761-0.148,5.352-1.786,7.773
-		c-3.934-2.083-5.885-5.363-5.855-9.839C448.433,128.344,450.978,129.033,453.23,130.545
-		C453.379,131.438,452.666,130.14,453.23,130.545z M443.849,140.804c-0.265-0.965,0.203-1.786,1.401-2.459
-		c2.162,0.375,3.094,1.593,2.792,3.651c-0.882,0.669-1.833,1.211-2.854,1.625C444.552,142.664,444.1,141.726,443.849,140.804
-		C443.584,139.839,444.1,141.726,443.849,140.804z M442.519,131.06c2.427,2.397-2.527,4.466-4.532,0.411
-		c0.849-0.74,1.76-1.345,2.736-1.81C441.377,130.083,441.99,130.539,442.519,131.06C443.466,131.997,441.99,130.539,442.519,131.06z
-		 M442.618,148.401c0.406-0.064,0.803-0.146,1.194-0.233c0.722,0.81,1.528,1.595,2.439,2.353c-0.843,1.893-1.71,3.774-2.605,5.644
-		c-3.311-2.711-5.766-5.536-7.406-8.468C438.251,148.394,440.374,148.639,442.618,148.401
-		C443.024,148.337,440.374,148.639,442.618,148.401z M468.166,242.763c0.102,2.114,0.809,4.023,2.118,5.726
-		c-1.353,1.703-2.043,3.628-2.071,5.776c-2.198-1.089-3.829-3.017-4.883-5.805C464.326,245.803,465.939,243.909,468.166,242.763
-		C468.238,243.627,465.939,243.909,468.166,242.763z M476.149,253.498c-0.175,0.672-0.435,1.332-0.771,1.984
-		c-1.123,0.138-2.243,0.129-3.359-0.036c-0.603-2.411,0.296-3.874,2.696-4.39C475.928,251.714,476.402,252.53,476.149,253.498
-		C475.975,254.17,476.402,252.53,476.149,253.498z M471.951,241.455c1.136-0.215,2.26-0.264,3.367-0.16
-		C477.654,246.02,471.644,247.136,471.951,241.455C473.087,241.239,471.896,242.463,471.951,241.455z M478.242,248.519
-		c1.815-1.205,2.431-3.126,1.85-5.762c2.475,1.314,4.299,3.179,5.468,5.594c-1.035,2.543-2.851,4.437-5.447,5.681
-		C480.579,251.721,479.975,249.876,478.242,248.519C480.058,247.314,479.975,249.876,478.242,248.519z M485.748,240.598
-		c0.167,0.605,0.28,1.192,0.371,1.772c-2.457-2.532-5.281-4.113-8.477-4.745c-0.972-1.352-2.202-2.738-3.714-4.163
-		c0.777-1.99,1.726-3.894,2.847-5.708C481.521,231.81,484.514,236.093,485.748,240.598
-		C485.915,241.203,484.514,236.093,485.748,240.598z M476.288,206.097c3.291,12.004-5.675,21.071-7.843,32.085
-		c-2.506,0.713-4.615,2.171-6.329,4.374c-0.919-15.736,17.797-29.625,2.353-43.594c0.668-1.992,1.64-3.814,2.913-5.468
-		C472.084,197.393,475.054,201.593,476.288,206.097C478.007,212.37,475.054,201.593,476.288,206.097z M466.353,215.306
-		c-3.676-3.315-4.778-7.336-3.307-12.063C466.723,206.559,467.826,210.58,466.353,215.306
-		C464.448,213.404,467.025,212.698,466.353,215.306z M466.827,171.597c4.686,17.082-18.379,32.757-1.653,47.924
-		c-0.842,1.894-1.711,3.774-2.606,5.643c-24.937-20.419,12.444-41.858-7.56-60.702c0.728-1.884,1.62-3.684,2.672-5.402
-		C462.456,162.59,465.505,166.771,466.827,171.597C468.548,177.87,465.505,166.771,466.827,171.597z M456.895,180.806
-		c-3.679-3.314-4.782-7.335-3.31-12.063C457.264,172.058,458.365,176.079,456.895,180.806
-		C454.988,178.905,457.611,178.36,456.895,180.806z M453.244,158.979c-5.104,8.958-5.746,18.594,2.469,26.042
-		c-0.842,1.894-1.71,3.774-2.605,5.643c-20.078-16.438-2.635-29.18-1.165-46.748c2.4-2.17,4.048-4.937,4.943-8.301
-		C459.791,143.399,456.931,152.117,453.244,158.979C452.078,161.026,457.713,150.661,453.244,158.979z M449.556,123.937
-		c0.376,0.371,0.72,0.747,1.04,1.128c-3.41-0.906-6.662-0.82-9.761,0.258c-1.469-0.643-3.154-1.198-5.082-1.652
-		c-0.323-2.113-0.454-4.236-0.393-6.368C441.501,118.441,446.233,120.654,449.556,123.937
-		C449.932,124.308,446.233,120.654,449.556,123.937z M410.09,92.338c23.104,3.926,17.816,21.903,23.235,38.054
-		c-1.814,1.883-2.903,4.221-3.265,7.012c-8.625-13.164,0.569-34.512-19.759-38.874C409.885,96.471,409.813,94.406,410.09,92.338z
-		 M420.11,111.739c-4.843-1.031-7.81-3.962-8.898-8.791C416.055,103.978,419.021,106.909,420.11,111.739
-		C417.511,111.045,419.388,109.144,420.11,111.739z M398.657,73.654c12.601,12.449,0.472,37.557,22.539,42.325
-		c0.219,2.06,0.406,4.123,0.567,6.189c-31.808-5.207-10.162-42.472-36.91-48.78c-0.312-1.996-0.44-4-0.389-6.014
-		C390.367,68.042,395.098,70.138,398.657,73.654C403.283,78.225,395.098,70.138,398.657,73.654z M394.662,86.598
-		c-4.845-1.03-7.81-3.96-8.898-8.791C390.606,78.837,393.572,81.768,394.662,86.598C392.063,85.904,394.058,84.121,394.662,86.598z
-		 M380.583,69.523c0.059,10.311,4.327,18.975,15.165,21.314c0.218,2.061,0.405,4.124,0.566,6.19
-		c-25.539-4.183-16.927-23.875-24.357-39.825c1.001-3.046,1.103-6.23,0.304-9.553C378.513,52.993,380.345,61.795,380.583,69.523
-		C380.598,71.878,380.291,60.085,380.583,69.523z M359.958,40.857c0.595,0.155,1.15,0.344,1.688,0.548
-		c-3.482,0.854-6.313,2.526-8.489,5.014c-1.608,0.179-3.361,0.544-5.28,1.123c-1.337-1.667-2.512-3.438-3.526-5.316
-		C350.233,40.136,355.438,39.681,359.958,40.857C360.553,41.012,355.438,39.681,359.958,40.857z M325.339,31.844
-		c11.964,3.115,15.404,15.274,23.74,22.676c-0.649,2.529-0.464,5.09,0.559,7.682c-13.919-7.169-16.654-30.061-36.38-23.674
-		c-1.394-1.573-2.489-3.324-3.285-5.253C315.697,31.144,320.817,30.667,325.339,31.844
-		C331.633,33.482,320.817,30.667,325.339,31.844z M328.363,45.047c-4.707,1.534-8.742,0.483-12.104-3.151
-		C320.967,40.363,325.001,41.413,328.363,45.047C325.765,45.75,326.438,43.164,328.363,45.047z M290.719,22.83
-		c17.138,4.462,19.223,32.273,40.709,25.344c1.22,1.674,2.416,3.366,3.59,5.074c-30.139,11.424-30.068-31.67-56.38-23.733
-		c-1.269-1.571-2.385-3.241-3.349-5.01C280.731,22.125,285.877,21.569,290.719,22.83C297.013,24.469,285.877,21.569,290.719,22.83z
-		 M293.744,36.034c-4.709,1.534-8.743,0.483-12.105-3.152C286.347,31.348,290.382,32.399,293.744,36.034
-		C291.145,36.736,291.981,34.193,293.744,36.034z M273.008,28.307c5.214,8.896,13.247,14.256,23.8,10.853
-		c1.221,1.674,2.417,3.366,3.59,5.074c-24.087,9.131-26.61-12.031-40.905-22.183c-0.66-3.173-2.194-6.006-4.602-8.497
-		C262.959,15.058,268.938,21.752,273.008,28.307C274.198,30.339,268.027,20.284,273.008,28.307z M240.949,13.903
-		c0.496-0.135,0.981-0.244,1.459-0.33c-2.546,2.519-4.131,5.409-4.755,8.672c-1.25,0.935-2.529,2.084-3.842,3.477
-		c-1.991-0.778-3.894-1.728-5.708-2.849C232.161,18.127,236.444,15.137,240.949,13.903
-		C241.445,13.768,236.444,15.137,240.949,13.903z M206.447,23.354c11.878-3.254,20.93,5.487,31.794,7.798
-		c0.716,2.533,2.184,4.666,4.405,6.398c-15.64,0.726-29.424-17.75-43.336-2.378c-1.992-0.669-3.814-1.641-5.467-2.915
-		C197.741,27.556,201.941,24.588,206.447,23.354C212.721,21.636,201.941,24.588,206.447,23.354z M215.653,33.291
-		c-3.315,3.677-7.336,4.778-12.063,3.304C206.905,32.918,210.926,31.817,215.653,33.291
-		C213.751,35.195,213.045,32.618,215.653,33.291z M171.944,32.805c17.083-4.679,32.752,18.389,47.923,1.667
-		c1.893,0.843,3.774,1.711,5.643,2.607c-20.427,24.93-41.857-12.457-60.704,7.544c-1.884-0.729-3.684-1.621-5.402-2.674
-		C162.936,37.175,167.119,34.127,171.944,32.805C178.217,31.087,167.119,34.127,171.944,32.805z M181.151,42.742
-		c-3.316,3.677-7.337,4.778-12.064,3.305C172.402,42.37,176.424,41.269,181.151,42.742
-		C179.249,44.646,178.705,42.025,181.151,42.742z M137.442,42.256c17.163-4.701,32.897,18.228,47.923,1.667
-		c1.893,0.843,3.773,1.712,5.642,2.607c-16.441,20.068-29.183,2.633-46.75,1.151c-2.174-2.4-4.945-4.046-8.312-4.939
-		C136.421,42.565,136.917,42.4,137.442,42.256C143.714,40.538,136.917,42.4,137.442,42.256z M124.283,50.081
-		c0.367-0.372,0.741-0.714,1.118-1.032c-0.9,3.408-0.81,6.66,0.269,9.758c-0.641,1.469-1.195,3.151-1.648,5.078
-		c-2.113,0.324-4.235,0.454-6.367,0.393C118.791,58.138,121.002,53.405,124.283,50.081C124.65,49.708,121.002,53.405,124.283,50.081
-		z M99.149,75.537c8.712-8.823,20.997-5.665,31.594-9.228c1.885,1.814,4.227,2.899,7.021,3.256
-		c-13.161,8.638-34.518-0.557-38.875,19.776c-2.06,0.417-4.124,0.489-6.192,0.215C93.717,83.533,95.868,78.861,99.149,75.537
-		C103.719,70.909,95.868,78.861,99.149,75.537z M112.095,79.529c-1.03,4.842-3.959,7.81-8.788,8.9
-		C104.336,83.587,107.265,80.62,112.095,79.529C111.402,82.129,109.5,80.252,112.095,79.529z M74.016,100.994
-		c12.444-12.604,37.558-0.482,42.318-22.553c2.06-0.218,4.124-0.407,6.189-0.569c-5.197,31.81-42.47,10.175-48.769,36.926
-		c-1.995,0.312-4,0.442-6.014,0.39C68.407,109.287,70.501,104.554,74.016,100.994C78.586,96.365,70.501,104.554,74.016,100.994z
-		 M86.961,104.986c-1.03,4.843-3.959,7.81-8.789,8.901C79.202,109.044,82.131,106.077,86.961,104.986
-		C86.268,107.586,84.485,105.589,86.961,104.986z M69.891,119.068c10.311-0.063,18.973-4.331,21.31-15.17
-		c2.061-0.218,4.125-0.407,6.19-0.568c-4.175,25.553-23.882,16.925-39.83,24.375c-3.047-1.001-6.232-1.098-9.556-0.292
-		C53.331,121.148,62.169,119.31,69.891,119.068C72.247,119.054,60.453,119.364,69.891,119.068z M41.238,139.707
-		c0.154-0.591,0.342-1.143,0.544-1.676c0.857,3.476,2.529,6.301,5.015,8.475c0.177,1.61,0.543,3.365,1.122,5.284
-		c-1.668,1.337-3.44,2.513-5.318,3.526C40.514,149.431,40.06,144.227,41.238,139.707C41.392,139.116,40.06,144.227,41.238,139.707z
-		 M32.213,174.323c3.121-11.968,15.288-15.404,22.692-23.743c2.531,0.647,5.092,0.458,7.684-0.567
-		c-7.165,13.934-30.078,16.656-23.695,36.393c-1.574,1.394-3.325,2.488-5.253,3.285C31.511,183.964,31.035,178.842,32.213,174.323
-		C33.854,168.029,31.035,178.842,32.213,174.323z M45.779,177.859c-0.295,1.131-1.468,2.979-3.516,5.546
-		c-1.532-4.708-0.48-8.743,3.156-12.104C46.12,173.9,46.241,176.086,45.779,177.859C45.484,178.99,46.241,176.086,45.779,177.859z
-		 M23.189,208.939c4.469-17.138,32.279-19.21,25.356-40.7c1.675-1.22,3.366-2.416,5.075-3.589
-		c11.415,30.142-31.679,30.059-23.75,56.372c-1.571,1.269-3.242,2.384-5.011,3.347C22.481,218.927,21.928,213.781,23.189,208.939
-		C24.83,202.646,21.928,213.781,23.189,208.939z M36.754,212.476c-0.294,1.131-1.467,2.978-3.516,5.547
-		c-1.532-4.708-0.48-8.743,3.156-12.104C37.095,208.517,37.217,210.702,36.754,212.476C36.46,213.607,37.217,210.702,36.754,212.476
-		z M28.661,226.653c8.897-5.212,14.259-13.245,10.86-23.797c1.675-1.22,3.367-2.417,5.075-3.589
-		c9.231,24.373-12.441,26.609-22.421,41.222c-3.119,0.672-5.898,2.211-8.336,4.617C15.189,236.904,22.042,230.759,28.661,226.653
-		C30.694,225.462,20.637,231.63,28.661,226.653z M14.253,258.978c-0.165-0.604-0.28-1.189-0.371-1.768
-		c2.457,2.531,5.282,4.112,8.476,4.745c0.971,1.351,2.201,2.737,3.712,4.162c-0.778,1.99-1.729,3.894-2.85,5.708
-		C18.476,267.767,15.486,263.483,14.253,258.978C14.088,258.373,15.486,263.483,14.253,258.978z M23.699,293.481
-		c-3.288-12.01,5.69-21.064,7.855-32.081c2.506-0.714,4.616-2.17,6.332-4.373c0.909,15.734-17.808,29.621-2.37,43.593
-		c-0.669,1.993-1.641,3.816-2.916,5.468C27.899,302.188,24.933,297.987,23.699,293.481
-		C21.981,287.208,24.933,297.987,23.699,293.481z M33.637,284.276c3.676,3.316,4.777,7.338,3.303,12.064
-		C33.263,293.024,32.162,289.003,33.637,284.276C35.541,286.179,32.964,286.885,33.637,284.276z M33.146,327.986
-		c-4.678-17.086,18.393-32.75,1.673-47.924c0.844-1.894,1.713-3.774,2.608-5.643c24.928,20.43-12.464,41.855,7.536,60.705
-		c-0.729,1.883-1.621,3.684-2.674,5.4C37.514,336.993,34.466,332.812,33.146,327.986C31.428,321.712,34.466,332.812,33.146,327.986z
-		 M43.083,318.781c3.677,3.315,4.778,7.336,3.303,12.063C42.71,327.527,41.609,323.507,43.083,318.781
-		C44.987,320.683,42.366,321.226,43.083,318.781z M46.724,340.609c5.109-8.957,5.753-18.591-2.458-26.043
-		c0.843-1.894,1.712-3.773,2.608-5.642c20.069,16.442,2.625,29.184,1.144,46.751c-2.4,2.17-4.048,4.936-4.944,8.3
-		C40.166,356.197,43.039,347.463,46.724,340.609C47.891,338.563,42.252,348.925,46.724,340.609z M50.401,375.655
-		c-0.376-0.372-0.719-0.749-1.04-1.131c3.407,0.906,6.66,0.821,9.758-0.255c1.47,0.645,3.156,1.199,5.086,1.655
-		c0.323,2.112,0.452,4.235,0.388,6.368C58.454,381.152,53.722,378.938,50.401,375.655C50.025,375.283,53.722,378.938,50.401,375.655
-		z M89.855,407.268c-23.108-3.935-17.803-21.913-23.222-38.063c1.815-1.884,2.903-4.221,3.265-7.012
-		c8.625,13.169-0.582,34.511,19.747,38.884C90.062,403.136,90.132,405.199,89.855,407.268z M79.841,387.864
-		c4.842,1.032,7.807,3.963,8.895,8.793C83.894,395.625,80.929,392.693,79.841,387.864C82.441,388.56,80.563,390.458,79.841,387.864z
-		 M101.281,425.956c-12.594-12.452-0.458-37.56-22.524-42.332c-0.217-2.062-0.406-4.125-0.565-6.191
-		c31.805,5.222,10.147,42.479,36.893,48.793c0.31,1.996,0.439,4,0.386,6.014C109.57,431.571,104.84,429.474,101.281,425.956
-		C96.656,421.383,104.84,429.474,101.281,425.956z M105.282,413.014c4.842,1.033,7.807,3.963,8.896,8.794
-		C109.334,420.774,106.369,417.844,105.282,413.014C107.882,413.709,105.883,415.49,105.282,413.014z M119.353,430.093
-		c-0.054-10.311-4.32-18.975-15.156-21.319c-0.217-2.061-0.404-4.124-0.564-6.189c25.515,4.184,16.932,23.853,24.33,39.803
-		c-1.005,3.049-1.111,6.236-0.318,9.562C121.411,446.604,119.589,437.809,119.353,430.093
-		C119.341,427.738,119.643,439.53,119.353,430.093z M139.948,458.755c-0.585-0.152-1.133-0.337-1.662-0.539
-		c3.486-0.856,6.319-2.532,8.5-5.023c1.599-0.179,3.341-0.543,5.245-1.116c1.337,1.667,2.513,3.442,3.525,5.319
-		C149.671,459.48,144.467,459.936,139.948,458.755C139.362,458.603,144.467,459.936,139.948,458.755z M174.563,467.786
-		c-11.95-3.12-15.399-15.26-23.71-22.673c0.65-2.53,0.465-5.093-0.557-7.688c13.9,7.186,16.631,30.059,36.352,23.682
-		c1.392,1.575,2.486,3.327,3.282,5.255C184.203,468.489,179.083,468.965,174.563,467.786
-		C168.268,466.144,179.083,468.965,174.563,467.786z M171.544,454.58c4.709-1.531,8.743-0.479,12.104,3.158
-		C178.939,459.269,174.904,458.216,171.544,454.58C174.143,453.88,173.468,456.464,171.544,454.58z M209.178,476.816
-		c-17.142-4.472-19.2-32.28-40.696-25.364c-1.219-1.675-2.415-3.367-3.588-5.074c30.143-11.413,30.053,31.684,56.367,23.76
-		c1.268,1.571,2.384,3.242,3.347,5.012C219.164,477.525,214.019,478.08,209.178,476.816
-		C202.884,475.175,214.019,478.08,209.178,476.816z M206.159,463.609c4.708-1.53,8.743-0.479,12.103,3.158
-		C213.554,468.3,209.52,467.248,206.159,463.609C208.758,462.911,207.92,465.452,206.159,463.609z M226.892,471.348
-		c-5.211-8.897-13.241-14.262-23.795-10.863c-1.22-1.676-2.416-3.367-3.588-5.077c24.323-9.204,26.604,12.368,41.154,22.384
-		c0.67,3.134,2.209,5.926,4.618,8.374C237.1,484.773,230.995,477.965,226.892,471.348
-		C225.701,469.315,231.868,479.372,226.892,471.348z M259.169,485.759c-0.585,0.161-1.153,0.273-1.714,0.363
-		c2.534-2.47,4.116-5.308,4.749-8.517c1.33-0.966,2.695-2.179,4.097-3.668c1.99,0.777,3.896,1.726,5.711,2.846
-		C267.956,481.53,263.674,484.522,259.169,485.759C258.584,485.92,263.674,484.522,259.169,485.759z M293.666,476.29
-		c-11.976,3.288-21.042-5.629-32.024-7.825c-0.714-2.51-2.174-4.623-4.378-6.342c15.712-0.876,29.587,17.778,43.536,2.347
-		c1.992,0.668,3.815,1.639,5.468,2.912C302.37,472.087,298.171,475.055,293.666,476.29
-		C287.396,478.012,298.171,475.055,293.666,476.29z M284.455,466.358c3.316-3.678,7.336-4.781,12.063-3.31
-		C293.204,466.728,289.184,467.829,284.455,466.358C286.357,464.454,287.064,467.03,284.455,466.358z M328.166,466.824
-		c-17.081,4.688-32.761-18.375-47.925-1.646c-1.894-0.841-3.774-1.709-5.644-2.604c20.413-24.941,41.861,12.435,60.7-7.573
-		c1.884,0.728,3.684,1.618,5.403,2.671C337.172,462.449,332.99,465.5,328.166,466.824C321.893,468.545,332.99,465.5,328.166,466.824
-		z M318.954,456.891c3.315-3.679,7.335-4.781,12.063-3.31C327.702,457.259,323.683,458.363,318.954,456.891
-		C320.855,454.986,321.4,457.606,318.954,456.891z M362.663,457.356c-17.159,4.709-32.908-18.214-47.925-1.645
-		c-1.892-0.843-3.773-1.711-5.643-2.604c16.414-20.055,29.162-2.678,46.714-1.178c2.176,2.406,4.95,4.058,8.324,4.949
-		C363.667,457.055,363.18,457.215,362.663,457.356C356.392,459.078,363.18,457.215,362.663,457.356z M375.795,449.539
-		c-0.359,0.364-0.724,0.701-1.093,1.012c0.894-3.412,0.8-6.669-0.28-9.771c0.633-1.46,1.181-3.133,1.63-5.046
-		c2.112-0.323,4.235-0.454,6.366-0.395C381.284,441.479,379.075,446.214,375.795,449.539
-		C375.436,449.903,379.075,446.214,375.795,449.539z M400.92,424.072c-8.699,8.818-20.977,5.681-31.566,9.231
-		c-1.887-1.818-4.23-2.904-7.03-3.258c13.161-8.625,34.502,0.55,38.853-19.778c2.06-0.418,4.123-0.491,6.191-0.217
-		C406.348,416.075,404.2,420.747,400.92,424.072C396.352,428.702,404.2,420.747,400.92,424.072z M387.973,420.085
-		c1.028-4.843,3.956-7.811,8.786-8.904C395.729,416.023,392.803,418.992,387.973,420.085
-		C388.665,417.485,390.567,419.361,387.973,420.085z M426.045,398.606c-12.44,12.609-37.558,0.494-42.312,22.568
-		c-2.061,0.218-4.124,0.407-6.189,0.57c5.187-31.81,42.471-10.19,48.755-36.943c1.995-0.313,4.001-0.443,6.015-0.393
-		C431.65,390.312,429.557,395.044,426.045,398.606C421.476,403.236,429.557,395.044,426.045,398.606z M413.097,394.619
-		c1.028-4.843,3.957-7.811,8.785-8.905C420.854,390.558,417.927,393.526,413.097,394.619
-		C413.789,392.019,415.573,394.014,413.097,394.619z M430.162,380.53c-10.312,0.063-18.97,4.342-21.305,15.178
-		c-2.061,0.218-4.122,0.408-6.188,0.57c4.166-25.546,23.874-16.94,39.82-24.391c3.048,0.999,6.233,1.095,9.557,0.288
-		C446.725,378.444,437.881,380.287,430.162,380.53C427.808,380.545,439.601,380.231,430.162,380.53z M458.809,359.88
-		c-0.152,0.592-0.34,1.146-0.544,1.68c-0.859-3.476-2.531-6.3-5.018-8.474c-0.177-1.609-0.544-3.365-1.123-5.285
-		c1.667-1.337,3.439-2.514,5.315-3.527C459.529,350.157,459.986,355.36,458.809,359.88
-		C458.656,360.472,459.986,355.36,458.809,359.88z M467.82,325.261c-3.115,11.969-15.282,15.411-22.684,23.752
-		c-2.529-0.646-5.091-0.456-7.683,0.569c7.158-13.936,30.071-16.669,23.681-36.401c1.573-1.394,3.323-2.488,5.251-3.286
-		C468.518,315.619,468.996,320.74,467.82,325.261C466.182,331.556,468.996,320.74,467.82,325.261z M454.253,321.729
-		c0.294-1.132,1.466-2.979,3.514-5.548c1.533,4.707,0.482,8.741-3.151,12.104C453.914,325.688,453.791,323.504,454.253,321.729
-		C454.547,320.598,453.791,323.504,454.253,321.729z M476.83,290.64c-4.463,17.141-32.27,19.222-25.341,40.71
-		c-1.674,1.222-3.364,2.419-5.072,3.592c-11.429-30.137,31.667-30.07,23.727-56.382c1.572-1.268,3.242-2.384,5.011-3.349
-		C477.533,280.652,478.091,285.798,476.83,290.64C475.19,296.936,478.091,285.798,476.83,290.64z M463.264,287.109
-		c0.293-1.131,1.466-2.979,3.514-5.548c1.533,4.708,0.482,8.742-3.15,12.104C462.924,291.067,462.802,288.883,463.264,287.109
-		C463.557,285.979,462.802,288.883,463.264,287.109z M471.352,272.93c-8.896,5.216-14.254,13.248-10.851,23.801
-		c-1.675,1.22-3.367,2.416-5.074,3.591c-9.243-24.374,12.434-26.61,22.404-41.232c3.119-0.674,5.897-2.212,8.335-4.617
-		C484.805,262.68,477.979,268.813,471.352,272.93C469.32,274.121,479.373,267.948,471.352,272.93z"/>
-</g>
+		<path fill="url(#coinShape)" filter="url(#dropShadowAlpha)" d="M317.871,7.656c-137.12-34.192-276.024,49.28-310.2,186.44
+			c-34.208,137.136,49.256,276.048,186.36,310.24c137.16,34.199,276.063-49.265,310.256-186.408
+			C538.479,180.776,455.023,41.848,317.871,7.656z M368.807,219.528c-3.688,24.936-17.512,37.008-35.864,41.24
+			c25.2,13.12,38.024,33.239,25.809,68.12c-15.16,43.319-51.176,46.976-99.072,37.912l-11.624,46.584l-28.088-7l11.472-45.96
+			c-7.279-1.809-14.72-3.729-22.384-5.809l-11.512,46.177l-28.056-7l11.624-46.673c-6.561-1.68-13.225-3.464-20.024-5.168
+			l-36.552-9.111l13.943-32.152c0,0,20.696,5.504,20.416,5.096c7.952,1.969,11.48-3.216,12.872-6.672l18.368-73.64l0.048-0.2
+			l13.104-52.568c0.344-5.968-1.712-13.496-13.088-16.336c0.439-0.296-20.4-5.072-20.4-5.072l7.472-30l38.736,9.673l-0.032,0.144
+			c5.824,1.448,11.824,2.824,17.937,4.216L245.423,89.2l28.072,7l-11.28,45.224c7.536,1.721,15.12,3.456,22.504,5.297l11.2-44.929
+			l28.088,7l-11.504,46.145C347.967,167.152,373.904,185.464,368.807,219.528z"/>
 	</g>
 </svg>
diff --git a/src/qt/res/src/nsis-header.svg b/src/qt/res/src/nsis-header.svg
deleted file mode 100644
index 354c51f8ff..0000000000
--- a/src/qt/res/src/nsis-header.svg
+++ /dev/null
@@ -1,359 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-
-<!-- Designer: Steven Hay
-  	 License: MIT
--->
-
-<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
-<svg version="1.1"
-	 id="svg2" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg"
-	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="2.632in" height="1in"
-	 viewBox="-34 -34 1526 580" enable-background="new 0 0 1024 1024" xml:space="preserve">
-	
-	<style type="text/css"><![CDATA[
-		text {
-			font-family: "Tuffy";
-			font-size: 170px;
-			fill: black;
-			text-anchor: left;
-		}
-	]]></style>
-	<g transform="scale(0.54, 0.54) translate(-25, 230)">
-		<radialGradient id="coinShape" cx="256.0276" cy="256.0027" r="255.9878" gradientUnits="userSpaceOnUse">
-			<stop offset="0" style="stop-color:#F9AA4B"/>
-			<stop offset="1" style="stop-color:#F7931A"/>
-		</radialGradient>
-		<circle cx="256" cy="256" r="256" fill="url(#coinShape)" filter="url(#dropShadowAlpha)" />
-<g id="B_gradient" filter="url(#dropShadowAlpha)">
-	<g id="XMLID_3_">
-		<g>
-			<path fill="#006837" d="M267.362,284.56c12.797,13.063,20.853,27.315,20.038,50.53l-17.054,1.63
-				c0-18.271-4.623-30.62-14.189-40.589L267.362,284.56z"/>
-		</g>
-		<g>
-			<path fill="none" stroke="#00FF00" stroke-miterlimit="10" d="M256.157,296.131c9.566,9.969,14.189,22.317,14.189,40.589
-				l17.054-1.63c0.814-23.215-7.241-37.468-20.038-50.53L256.157,296.131z"/>
-		</g>
-	</g>
-	<path fill="#006837" stroke="#00FF00" stroke-width="2" stroke-miterlimit="10" d="M282.99,135.289
-		c-1.986-25.323-23.207-38.778-33.149-45.31c0,0-27.572,19.359-30.367,45.172l14.5-0.797c1.501-13.867,15.867-26.219,15.867-26.219
-		c5.34,3.508,16.171,12.968,17.24,26.571L282.99,135.289z"/>
-	<path fill="#006837" stroke="#00FF00" stroke-width="2" stroke-miterlimit="10" d="M285.313,364.219
-		c-1.884,25.896-33.298,45.424-33.298,45.424c-10.166-6.179-30.208-19.2-33.084-44.438l13.472-0.771
-		c1.721,15.096,12.714,23.357,18.795,27.053c0,0,16.893-11.563,18.02-27.053L285.313,364.219z"/>
-	<path fill="#006837" stroke="#00FF00" stroke-miterlimit="10" d="M258.624,198.976c8.271-9.869,11.998-25.563,10.472-39.732
-		l9.13,1.356l7.543,1.025c2.218,18.973-4.603,33.846-14.45,46.919"/>
-	<g>
-		<path fill="#006837" stroke="#00FF00" stroke-miterlimit="10" d="M245.155,283.111c-20.945-24.394-3.255-62.365,3.613-71.508
-			l11.207,10.161c-11.732,14.165-14.71,34.056-4.357,50.159L245.155,283.111z"/>
-	</g>
-	<path fill="#006837" stroke="#00FF00" stroke-width="2" stroke-miterlimit="10" d="M292.298,242.088
-		c-25.802-11.596-73.829-48.033-73.809-84.929l13.958-0.825c-2.061,36.529,66.376,69.887,77.665,72.504L292.298,242.088z"/>
-	<path fill="#006837" stroke="#00FF00" stroke-width="3" stroke-miterlimit="10" d="M334.596,237.27
-		c0,0,43.137,19.028,43.137,58.166c0,69.071-92.42,68.782-92.42,68.782c-130.445,1.722-149.219,5.693-141.667,2.179
-		c29.979-13.959,28.084-31.828,28.084-31.828l-1.776-176.069c0,0-0.366-14.362-27.736-22.949
-		c-2.829-0.888,138.281-0.284,138.281-0.284s85.6-0.202,85.847,57.323c0.137,32.286-69.803,69.731-69.803,69.731
-		c-8.351,6.159-58.897,35.61-62.733,74.432h-15.122c0,0-1.343-45.08,78.142-97.715c23.004-15.233,36.543-35.399,36.543-46.448
-		c-0.009-18.345-32.452-29.366-52.407-32.277c-53.935-7.855-73.342-1.648-73.342-1.648s-6.985,2.105-8.358,8.056
-		c-0.878,3.79-1.3,11.287-1.3,11.287l1.831,149.521c0,0-0.41,9.121,7.598,9.326l62.954-0.135c0-0.001,67.41,0,67.375-45.81
-		c-0.014-17.696-7.266-31.59-24.364-38.707c0,0,19.186-13.086,21.032-15.036"/>
-	<path fill="#006837" stroke="#00FF00" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M219.046,336.188"/>
-</g>
-<g id="Rope" transform="translate(-17.1,-17.1) scale(1.09375)" filter="url(#dropShadowAlpha)">
-	<path fill="#8C6239" stroke="#42210B" stroke-width="2" stroke-miterlimit="10" d="M489.61,239.538
-		c-1.499-5.47-5.238-10.585-11.214-15.342c5.53-13.903,2.378-25.404-9.461-34.5c5.531-13.903,2.378-25.403-9.46-34.5
-		c7.497-18.98-4.618-38.813-24.491-41.783c-2.164-14.807-10.647-23.188-25.449-25.141c-2.163-14.807-10.646-23.187-25.449-25.141
-		c-2.995-20.136-23.285-31.481-42.011-24.084c-9.29-11.732-20.828-14.736-34.618-9.014c-9.29-11.731-20.831-14.736-34.621-9.014
-		c-12.679-15.929-35.773-15.485-48.289,0.232c-13.903-5.536-25.403-2.386-34.503,9.452c-13.902-5.537-25.403-2.387-34.503,9.45
-		c-18.985-7.505-38.811,4.628-41.777,24.5c-14.806,2.169-23.183,10.655-25.133,25.458c-14.806,2.168-23.184,10.654-25.134,25.457
-		c-20.132,3.001-31.463,23.3-24.075,42.021c-11.734,9.286-14.742,20.825-9.024,34.617c-11.735,9.286-14.743,20.824-9.024,34.616
-		C5.435,239.5,5.879,262.86,21.599,275.381c-5.539,13.902-2.389,25.403,9.447,34.505c-5.538,13.901-2.39,25.401,9.446,34.504
-		c-7.504,18.977,4.607,38.816,24.477,41.794c2.16,14.808,10.64,23.191,25.44,25.15c2.159,14.808,10.639,23.191,25.44,25.15
-		c2.988,20.136,23.253,31.477,41.98,24.09c9.284,11.735,20.822,14.746,34.616,9.03c9.283,11.737,20.822,14.747,34.615,9.03
-		c12.679,15.946,35.994,15.499,48.51-0.232c13.904,5.529,25.403,2.374,34.498-9.467c13.904,5.529,25.403,2.373,34.498-9.469
-		c18.986,7.496,38.788-4.634,41.743-24.507c14.807-2.175,23.181-10.663,25.126-25.466c14.805-2.174,23.179-10.662,25.124-25.466
-		c20.129-3.009,31.456-23.313,24.06-42.031c11.729-9.289,14.733-20.83,9.011-34.619c11.729-9.29,14.733-20.83,9.009-34.621
-		C488.343,265.032,492.901,251.525,489.61,239.538C488.111,234.068,490.546,242.945,489.61,239.538z M469.511,262.109
-		c-1.674,1.221-3.365,2.419-5.073,3.591c-1.555-4.101-2.273-7.857-2.19-11.283c1.733,2.103,3.829,3.519,6.286,4.248
-		C468.756,259.786,469.073,260.932,469.511,262.109z M460.954,268.154c-11.331,8.958-14.583,20.638-8.947,34.379
-		c-11.731,9.291-14.734,20.831-9.011,34.62c-6.114,4.3-9.83,9.647-11.145,16.041c-4.93,4.451-7.697,10.45-8.303,17.999
-		c-14.291,2.086-22.952,10.571-24.948,25.288c-14.806,2.175-23.18,10.663-25.124,25.466c-7.542,0.709-13.504,3.558-17.888,8.55
-		c-6.362,1.404-11.649,5.187-15.859,11.348c-13.417-5.348-25.163-2.338-34.258,9.401c-13.904-5.529-25.403-2.374-34.498,9.467
-		c-6.842-3.159-13.393-3.689-19.648-1.592c-6.29-2.029-12.841-1.417-19.653,1.832c-8.95-11.334-20.629-14.594-34.373-8.968
-		c-9.284-11.736-20.822-14.746-34.615-9.029c-4.285-6.12-9.619-9.835-16-11.146c-4.441-4.938-10.438-7.711-17.989-8.32
-		c-2.07-14.294-10.548-22.964-25.262-24.974c-2.159-14.809-10.64-23.192-25.441-25.151c-0.699-7.543-3.542-13.508-8.529-17.896
-		c-1.396-6.378-5.179-11.681-11.347-15.904c5.357-13.412,2.354-25.161-9.38-34.263c5.539-13.9,2.389-25.403-9.446-34.504
-		c3.168-6.855,3.699-13.415,1.592-19.683c2.034-6.301,1.425-12.862-1.827-19.684c11.334-8.952,14.591-20.632,8.961-34.375
-		c11.733-9.286,14.742-20.825,9.024-34.617c6.12-4.297,9.836-9.644,11.151-16.039c4.932-4.446,7.701-10.444,8.308-17.994
-		c14.292-2.081,22.956-10.563,24.958-25.279c14.806-2.168,23.184-10.654,25.134-25.457c7.549-0.704,13.515-3.553,17.897-8.549
-		c6.371-1.391,11.664-5.172,15.879-11.344c13.413,5.356,25.16,2.352,34.261-9.385c13.901,5.536,25.402,2.385,34.503-9.451
-		c6.806,3.16,13.32,3.704,19.546,1.635c6.26,1.996,12.778,1.372,19.551-1.873c8.957,11.331,20.639,14.584,34.38,8.951
-		c9.288,11.731,20.828,14.736,34.617,9.013c4.293,6.111,9.632,9.824,16.017,11.141c4.446,4.938,10.445,7.712,17.999,8.322
-		c2.076,14.293,10.556,22.958,25.271,24.965c2.164,14.807,10.647,23.187,25.45,25.141c0.7,7.543,3.547,13.507,8.535,17.892
-		c1.39,6.38,5.173,11.68,11.353,15.899c-5.352,13.416-2.344,25.161,9.394,34.259c-5.532,13.904-2.379,25.404,9.461,34.5
-		c-3.165,6.854-3.693,13.415-1.586,19.682C457.088,254.771,457.7,261.334,460.954,268.154z M454.747,366.533
-		c-2.197,1.695-4.749,2.419-7.656,2.17c-0.098-4.453,1.825-7.746,5.769-9.874C454.355,361.248,454.984,363.815,454.747,366.533
-		C454.1,367.041,454.847,365.758,454.747,366.533z M431.516,359.994c0.43,2.72,1.531,5.018,3.304,6.894
-		c-0.349,1.049-0.634,2.161-0.836,3.354c-2.062,0.218-4.124,0.408-6.19,0.57C428.494,366.507,429.743,362.91,431.516,359.994
-		C431.894,362.185,429.743,362.91,431.516,359.994z M439.431,365.847c0.675-2.472,2.204-3.328,4.589-2.569
-		c0.767,2.087,0.158,3.504-1.824,4.25C441.199,367.088,440.277,366.526,439.431,365.847
-		C439.937,364.822,440.277,366.526,439.431,365.847z M449.429,355.128c-0.277,5.455-6.212,3.387-2.922-1.52
-		C447.569,353.988,448.543,354.498,449.429,355.128C449.389,355.898,448.543,354.498,449.429,355.128z M441.608,355.404
-		c-0.342,1.311-0.396,2.453-0.178,3.436c-2.035,0.821-3.602,2.168-4.699,4.043c-1.343-2.067-1.771-4.584-1.248-7.57
-		c2.207-1.806,4.569-2.633,7.089-2.492C442.167,353.66,441.839,354.519,441.608,355.404
-		C441.267,356.715,441.839,354.519,441.608,355.404z M366.444,453.315c-1.771-0.22-3.445-0.85-5.023-1.876
-		c2.102-3.916,5.386-5.88,9.855-5.89c0.142,2.85-0.543,5.403-2.058,7.661C368.316,453.363,367.394,453.408,366.444,453.315
-		C364.673,453.096,367.394,453.408,366.444,453.315z M351.325,442.617c0.065,0.412,0.149,0.813,0.238,1.21
-		c-0.801,0.716-1.578,1.515-2.326,2.417c-1.894-0.841-3.775-1.71-5.644-2.604c2.699-3.3,5.511-5.75,8.43-7.39
-		C351.329,438.259,351.087,440.379,351.325,442.617C351.391,443.029,351.087,440.379,351.325,442.617z M356.113,445.194
-		c1.834-1.831,3.6-1.817,5.3,0.045c-0.379,2.171-1.606,3.103-3.681,2.795C357.066,447.157,356.525,446.211,356.113,445.194
-		C357.078,444.548,356.525,446.211,356.113,445.194z M370.083,440.679c-2.979,4.649-7.115-0.108-1.809-2.717
-		C369.013,438.806,369.617,439.711,370.083,440.679C369.655,441.348,369.617,439.711,370.083,440.679z M363.144,437.056
-		c-0.994,1.007-1.626,2.012-1.912,3.015c-2.157-0.259-4.171,0.153-6.042,1.236c-0.189-2.469,0.654-4.868,2.544-7.197
-		c2.849-0.521,5.334-0.1,7.474,1.233C364.461,435.855,363.768,436.422,363.144,437.056
-		C362.149,438.063,363.768,436.422,363.144,437.056z M253.333,484.456c-0.59,0.46-1.222,0.83-1.891,1.125
-		c-2.562-1.032-4.468-2.855-5.715-5.47c2.32,0.487,4.173-0.107,5.54-1.824c1.216,1.804,3.151,2.401,5.802,1.801
-		C256.183,481.745,254.942,483.203,253.333,484.456C252.743,484.916,254.942,483.203,253.333,484.456z M237.712,469.514
-		c-1.219-1.676-2.415-3.367-3.588-5.074c4.079-1.546,7.817-2.262,11.229-2.187c-2.107,1.737-3.525,3.836-4.255,6.297
-		C239.995,468.771,238.869,469.084,237.712,469.514z M244.278,475.357c-0.135-1.112-0.123-2.222,0.041-3.327
-		c2.439-0.623,3.921,0.275,4.444,2.695C247.381,476.395,245.887,476.604,244.278,475.357
-		C244.143,474.245,244.947,475.708,244.278,475.357z M258.527,475.299c-4.777,2.398-5.926-3.675-0.163-3.336
-		C258.579,473.09,258.628,474.202,258.527,475.299C257.866,475.631,258.628,474.202,258.527,475.299z M254.465,468.619
-		c-1.36,0.373-2.407,0.925-3.157,1.646c-1.714-1.341-3.649-2.024-5.805-2.046c1.092-2.203,3.029-3.837,5.833-4.891
-		c2.67,0.996,4.57,2.614,5.722,4.845C256.172,468.245,255.308,468.389,254.465,468.619
-		C253.104,468.992,255.308,468.389,254.465,468.619z M133.296,454.687c-1.699-2.204-2.42-4.763-2.162-7.68
-		c4.446-0.052,7.745,1.884,9.894,5.808C138.601,454.313,136.023,454.937,133.296,454.687
-		C132.789,454.038,134.081,454.79,133.296,454.687z M142.475,449.066c-3.266-0.853-0.052-5.181,3.779-2.593
-		c-0.38,1.058-0.886,2.025-1.514,2.906C143.958,449.342,143.195,449.254,142.475,449.066
-		C141.186,448.729,143.195,449.254,142.475,449.066z M136.592,443.968c-2.103,0.767-3.526,0.146-4.27-1.863
-		c0.44-0.986,1-1.899,1.677-2.74C136.49,440.039,137.354,441.573,136.592,443.968C135.416,444.687,137.294,442.785,136.592,443.968z
-		 M132.962,434.755c-1.041-0.346-2.143-0.628-3.325-0.832c-0.216-2.061-0.405-4.122-0.564-6.188
-		c4.296,0.704,7.886,1.952,10.798,3.721C137.146,431.883,134.844,432.983,132.962,434.755
-		C131.922,434.409,133.208,434.535,132.962,434.755z M147.05,442.539c-1.879-1.003-3.885-1.394-6.021-1.169
-		c-0.825-2.035-2.177-3.604-4.057-4.703c2.074-1.341,4.599-1.76,7.592-1.227C146.37,437.65,147.194,440.018,147.05,442.539
-		C146.201,442.126,147.194,440.018,147.05,442.539z M64.594,365.062c-1.146-1.808-2.719-3.129-4.72-3.965
-		c0.267-2.155-0.137-4.168-1.213-6.039c2.465-0.185,4.861,0.66,7.185,2.55C66.358,360.448,65.931,362.929,64.594,365.062
-		C64.085,364.32,65.931,362.929,64.594,365.062z M46.729,369.045c-0.447-2.761,0.15-5.352,1.788-7.771
-		c3.934,2.081,5.884,5.36,5.849,9.836C51.526,371.244,48.981,370.556,46.729,369.045C46.582,368.151,47.294,369.449,46.729,369.045z
-		 M56.113,358.788c0.265,0.965-0.205,1.786-1.403,2.459c-2.161-0.376-3.09-1.593-2.792-3.649c0.883-0.67,1.835-1.213,2.855-1.625
-		C55.411,356.929,55.861,357.867,56.113,358.788C56.378,359.753,55.861,357.867,56.113,358.788z M57.441,368.534
-		c-2.426-2.399,2.53-4.466,4.531-0.411c-0.849,0.739-1.761,1.344-2.737,1.809C58.58,369.51,57.967,369.054,57.441,368.534
-		C56.493,367.598,57.967,369.054,57.441,368.534z M57.348,351.193c-0.407,0.064-0.803,0.146-1.196,0.231
-		c-0.722-0.81-1.526-1.597-2.44-2.355c0.843-1.893,1.713-3.771,2.608-5.641c3.311,2.712,5.766,5.538,7.404,8.471
-		C61.715,351.201,59.591,350.955,57.348,351.193C56.94,351.258,59.591,350.955,57.348,351.193z M31.837,256.82
-		c-0.102-2.115-0.808-4.024-2.117-5.728c1.352-1.703,2.043-3.628,2.072-5.776c2.197,1.089,3.828,3.019,4.881,5.808
-		C35.677,253.779,34.063,255.674,31.837,256.82C31.764,255.954,34.063,255.674,31.837,256.82z M28.05,258.127
-		c-1.137,0.215-2.259,0.264-3.366,0.158C22.348,253.559,28.361,252.444,28.05,258.127C26.913,258.342,28.105,257.118,28.05,258.127z
-		 M27.73,247.093c-0.252,0.968-1.068,1.447-2.442,1.432c-1.657-1.361-1.877-2.835-0.662-4.427c1.125-0.138,2.245-0.128,3.36,0.038
-		C28.045,245.223,27.96,246.209,27.73,247.093C27.478,248.061,27.96,246.209,27.73,247.093z M21.76,251.061
-		c-1.814,1.205-2.43,3.124-1.85,5.762c-2.475-1.315-4.297-3.18-5.466-5.595c1.034-2.544,2.85-4.437,5.447-5.68
-		C19.424,247.857,20.029,249.702,21.76,251.061C19.945,252.266,20.029,249.702,21.76,251.061z M32.504,241.271
-		c-0.345-0.132-0.688-0.244-1.032-0.356c-0.223-1.121-0.539-2.266-0.976-3.443c1.675-1.22,3.367-2.416,5.075-3.589
-		c1.553,4.101,2.269,7.856,2.187,11.282C36.353,243.509,34.606,242.207,32.504,241.271C32.16,241.139,34.606,242.207,32.504,241.271
-		z M45.3,133.057c2.198-1.694,4.751-2.417,7.659-2.168c0.095,4.453-1.829,7.745-5.772,9.874
-		C45.692,138.344,45.063,135.776,45.3,133.057C45.95,132.549,45.201,133.833,45.3,133.057z M68.532,139.602
-		c-0.431-2.72-1.532-5.018-3.303-6.895c0.35-1.048,0.635-2.159,0.838-3.352c2.06-0.218,4.124-0.407,6.189-0.568
-		C71.553,133.092,70.303,136.687,68.532,139.602C68.155,137.412,70.303,136.687,68.532,139.602z M60.618,133.747
-		c-0.675,2.473-2.205,3.33-4.59,2.57c-0.767-2.089-0.157-3.505,1.828-4.25C58.85,132.506,59.771,133.066,60.618,133.747
-		C60.11,134.771,59.771,133.066,60.618,133.747z M50.617,144.464c0.278-5.457,6.213-3.387,2.92,1.52
-		C52.475,145.604,51.502,145.095,50.617,144.464C50.656,143.693,51.502,145.095,50.617,144.464z M58.437,144.19
-		c0.342-1.311,0.396-2.454,0.179-3.437c2.035-0.821,3.602-2.167,4.701-4.042c1.343,2.068,1.771,4.586,1.246,7.571
-		c-2.208,1.806-4.571,2.632-7.091,2.492C57.877,145.935,58.206,145.075,58.437,144.19C58.778,142.879,58.206,145.075,58.437,144.19z
-		 M133.637,46.308c1.769,0.221,3.442,0.85,5.019,1.875c-2.081,3.933-5.358,5.889-9.833,5.867c-0.14-2.842,0.546-5.39,2.056-7.643
-		C131.775,46.257,132.693,46.216,133.637,46.308C135.406,46.528,132.693,46.216,133.637,46.308z M148.75,57.011
-		c-0.065-0.409-0.147-0.808-0.234-1.203c0.807-0.72,1.591-1.523,2.347-2.434c1.893,0.843,3.774,1.712,5.643,2.607
-		c-2.708,3.305-5.528,5.757-8.454,7.396C148.745,61.372,148.989,59.25,148.75,57.011C148.685,56.602,148.989,59.25,148.75,57.011z
-		 M138.687,54.374c0.375-2.162,1.593-3.093,3.652-2.792c0.67,0.882,1.212,1.832,1.627,2.852
-		C142.137,56.251,140.378,56.23,138.687,54.374C138.653,52.996,139.359,55.573,138.687,54.374z M130.008,58.917
-		c2.969-4.607,7.086,0.126,1.813,2.731C131.08,60.8,130.474,59.89,130.008,58.917C130.432,58.259,130.474,59.89,130.008,58.917z
-		 M136.932,62.567c0.998-1.011,1.632-2.02,1.917-3.027c2.155,0.264,4.166-0.143,6.037-1.221c0.188,2.466-0.654,4.863-2.54,7.188
-		c-2.844,0.517-5.325,0.093-7.46-1.24C135.625,63.758,136.311,63.195,136.932,62.567C137.93,61.557,136.311,63.195,136.932,62.567z
-		 M262.188,30.146c1.221,1.675,2.417,3.367,3.591,5.073c-3.997,1.516-7.666,2.235-11.023,2.195c2.12-1.75,3.546-3.866,4.277-6.348
-		C260.062,30.846,261.111,30.546,262.188,30.146z M255.854,24.434c0.116,1.062,0.098,2.12-0.059,3.173
-		c-2.548,0.716-4.103-0.173-4.661-2.667C252.596,23.213,254.168,23.045,255.854,24.434C255.971,25.496,255.107,24.02,255.854,24.434
-		z M250.936,15.321c1.459,1.106,2.613,2.537,3.473,4.277c-3.848,2.188-7.718,2.2-11.608,0.036c1.338-2.548,3.252-4.413,5.741-5.594
-		C249.377,14.358,250.177,14.777,250.936,15.321C252.395,16.427,250.177,14.777,250.936,15.321z M241.356,24.482
-		c5.014-2.644,6.241,3.691,0.174,3.206C241.327,26.606,241.271,25.538,241.356,24.482C242.092,24.094,241.271,25.538,241.356,24.482
-		z M245.645,31.046c1.298-0.356,2.312-0.874,3.053-1.547c1.755,1.316,3.723,1.968,5.907,1.956c-1.106,2.228-3.076,3.876-5.936,4.926
-		c-2.723-0.991-4.657-2.622-5.823-4.878C243.803,31.438,244.738,31.293,245.645,31.046
-		C246.943,30.689,244.738,31.293,245.645,31.046z M366.616,44.931c1.694,2.199,2.415,4.753,2.161,7.664
-		c-4.453,0.083-7.743-1.846-9.873-5.788C361.326,45.313,363.897,44.688,366.616,44.931C367.122,45.577,365.837,44.83,366.616,44.931
-		z M357.435,50.547c3.277,0.853,0.053,5.169-3.758,2.606c0.381-1.061,0.89-2.033,1.521-2.917
-		C355.97,50.276,356.724,50.362,357.435,50.547C358.725,50.883,356.724,50.362,357.435,50.547z M363.34,55.654
-		c2.093-0.765,3.512-0.153,4.256,1.838c-0.441,0.991-1.002,1.911-1.684,2.755C363.438,59.573,362.579,58.042,363.34,55.654
-		C364.516,54.937,362.639,56.837,363.34,55.654z M366.949,64.859c1.047,0.349,2.158,0.634,3.349,0.837
-		c0.217,2.061,0.406,4.124,0.566,6.189c-4.306-0.704-7.899-1.956-10.816-3.729C362.77,67.729,365.07,66.629,366.949,64.859
-		C367.996,65.208,366.706,65.077,366.949,64.859z M352.882,57.086c1.879,0.998,3.886,1.382,6.02,1.152
-		c0.82,2.037,2.167,3.605,4.042,4.706c-2.07,1.339-4.591,1.763-7.58,1.234C353.562,61.969,352.738,59.606,352.882,57.086
-		C353.727,57.495,352.738,59.606,352.882,57.086z M435.363,134.533c1.147,1.807,2.721,3.128,4.723,3.964
-		c-0.266,2.155,0.139,4.168,1.216,6.04c-2.466,0.185-4.862-0.66-7.187-2.549C433.602,139.146,434.029,136.667,435.363,134.533
-		C435.874,135.273,434.029,136.667,435.363,134.533z M453.23,130.545c0.446,2.761-0.148,5.352-1.786,7.773
-		c-3.934-2.083-5.885-5.363-5.855-9.839C448.433,128.344,450.978,129.033,453.23,130.545
-		C453.379,131.438,452.666,130.14,453.23,130.545z M443.849,140.804c-0.265-0.965,0.203-1.786,1.401-2.459
-		c2.162,0.375,3.094,1.593,2.792,3.651c-0.882,0.669-1.833,1.211-2.854,1.625C444.552,142.664,444.1,141.726,443.849,140.804
-		C443.584,139.839,444.1,141.726,443.849,140.804z M442.519,131.06c2.427,2.397-2.527,4.466-4.532,0.411
-		c0.849-0.74,1.76-1.345,2.736-1.81C441.377,130.083,441.99,130.539,442.519,131.06C443.466,131.997,441.99,130.539,442.519,131.06z
-		 M442.618,148.401c0.406-0.064,0.803-0.146,1.194-0.233c0.722,0.81,1.528,1.595,2.439,2.353c-0.843,1.893-1.71,3.774-2.605,5.644
-		c-3.311-2.711-5.766-5.536-7.406-8.468C438.251,148.394,440.374,148.639,442.618,148.401
-		C443.024,148.337,440.374,148.639,442.618,148.401z M468.166,242.763c0.102,2.114,0.809,4.023,2.118,5.726
-		c-1.353,1.703-2.043,3.628-2.071,5.776c-2.198-1.089-3.829-3.017-4.883-5.805C464.326,245.803,465.939,243.909,468.166,242.763
-		C468.238,243.627,465.939,243.909,468.166,242.763z M476.149,253.498c-0.175,0.672-0.435,1.332-0.771,1.984
-		c-1.123,0.138-2.243,0.129-3.359-0.036c-0.603-2.411,0.296-3.874,2.696-4.39C475.928,251.714,476.402,252.53,476.149,253.498
-		C475.975,254.17,476.402,252.53,476.149,253.498z M471.951,241.455c1.136-0.215,2.26-0.264,3.367-0.16
-		C477.654,246.02,471.644,247.136,471.951,241.455C473.087,241.239,471.896,242.463,471.951,241.455z M478.242,248.519
-		c1.815-1.205,2.431-3.126,1.85-5.762c2.475,1.314,4.299,3.179,5.468,5.594c-1.035,2.543-2.851,4.437-5.447,5.681
-		C480.579,251.721,479.975,249.876,478.242,248.519C480.058,247.314,479.975,249.876,478.242,248.519z M485.748,240.598
-		c0.167,0.605,0.28,1.192,0.371,1.772c-2.457-2.532-5.281-4.113-8.477-4.745c-0.972-1.352-2.202-2.738-3.714-4.163
-		c0.777-1.99,1.726-3.894,2.847-5.708C481.521,231.81,484.514,236.093,485.748,240.598
-		C485.915,241.203,484.514,236.093,485.748,240.598z M476.288,206.097c3.291,12.004-5.675,21.071-7.843,32.085
-		c-2.506,0.713-4.615,2.171-6.329,4.374c-0.919-15.736,17.797-29.625,2.353-43.594c0.668-1.992,1.64-3.814,2.913-5.468
-		C472.084,197.393,475.054,201.593,476.288,206.097C478.007,212.37,475.054,201.593,476.288,206.097z M466.353,215.306
-		c-3.676-3.315-4.778-7.336-3.307-12.063C466.723,206.559,467.826,210.58,466.353,215.306
-		C464.448,213.404,467.025,212.698,466.353,215.306z M466.827,171.597c4.686,17.082-18.379,32.757-1.653,47.924
-		c-0.842,1.894-1.711,3.774-2.606,5.643c-24.937-20.419,12.444-41.858-7.56-60.702c0.728-1.884,1.62-3.684,2.672-5.402
-		C462.456,162.59,465.505,166.771,466.827,171.597C468.548,177.87,465.505,166.771,466.827,171.597z M456.895,180.806
-		c-3.679-3.314-4.782-7.335-3.31-12.063C457.264,172.058,458.365,176.079,456.895,180.806
-		C454.988,178.905,457.611,178.36,456.895,180.806z M453.244,158.979c-5.104,8.958-5.746,18.594,2.469,26.042
-		c-0.842,1.894-1.71,3.774-2.605,5.643c-20.078-16.438-2.635-29.18-1.165-46.748c2.4-2.17,4.048-4.937,4.943-8.301
-		C459.791,143.399,456.931,152.117,453.244,158.979C452.078,161.026,457.713,150.661,453.244,158.979z M449.556,123.937
-		c0.376,0.371,0.72,0.747,1.04,1.128c-3.41-0.906-6.662-0.82-9.761,0.258c-1.469-0.643-3.154-1.198-5.082-1.652
-		c-0.323-2.113-0.454-4.236-0.393-6.368C441.501,118.441,446.233,120.654,449.556,123.937
-		C449.932,124.308,446.233,120.654,449.556,123.937z M410.09,92.338c23.104,3.926,17.816,21.903,23.235,38.054
-		c-1.814,1.883-2.903,4.221-3.265,7.012c-8.625-13.164,0.569-34.512-19.759-38.874C409.885,96.471,409.813,94.406,410.09,92.338z
-		 M420.11,111.739c-4.843-1.031-7.81-3.962-8.898-8.791C416.055,103.978,419.021,106.909,420.11,111.739
-		C417.511,111.045,419.388,109.144,420.11,111.739z M398.657,73.654c12.601,12.449,0.472,37.557,22.539,42.325
-		c0.219,2.06,0.406,4.123,0.567,6.189c-31.808-5.207-10.162-42.472-36.91-48.78c-0.312-1.996-0.44-4-0.389-6.014
-		C390.367,68.042,395.098,70.138,398.657,73.654C403.283,78.225,395.098,70.138,398.657,73.654z M394.662,86.598
-		c-4.845-1.03-7.81-3.96-8.898-8.791C390.606,78.837,393.572,81.768,394.662,86.598C392.063,85.904,394.058,84.121,394.662,86.598z
-		 M380.583,69.523c0.059,10.311,4.327,18.975,15.165,21.314c0.218,2.061,0.405,4.124,0.566,6.19
-		c-25.539-4.183-16.927-23.875-24.357-39.825c1.001-3.046,1.103-6.23,0.304-9.553C378.513,52.993,380.345,61.795,380.583,69.523
-		C380.598,71.878,380.291,60.085,380.583,69.523z M359.958,40.857c0.595,0.155,1.15,0.344,1.688,0.548
-		c-3.482,0.854-6.313,2.526-8.489,5.014c-1.608,0.179-3.361,0.544-5.28,1.123c-1.337-1.667-2.512-3.438-3.526-5.316
-		C350.233,40.136,355.438,39.681,359.958,40.857C360.553,41.012,355.438,39.681,359.958,40.857z M325.339,31.844
-		c11.964,3.115,15.404,15.274,23.74,22.676c-0.649,2.529-0.464,5.09,0.559,7.682c-13.919-7.169-16.654-30.061-36.38-23.674
-		c-1.394-1.573-2.489-3.324-3.285-5.253C315.697,31.144,320.817,30.667,325.339,31.844
-		C331.633,33.482,320.817,30.667,325.339,31.844z M328.363,45.047c-4.707,1.534-8.742,0.483-12.104-3.151
-		C320.967,40.363,325.001,41.413,328.363,45.047C325.765,45.75,326.438,43.164,328.363,45.047z M290.719,22.83
-		c17.138,4.462,19.223,32.273,40.709,25.344c1.22,1.674,2.416,3.366,3.59,5.074c-30.139,11.424-30.068-31.67-56.38-23.733
-		c-1.269-1.571-2.385-3.241-3.349-5.01C280.731,22.125,285.877,21.569,290.719,22.83C297.013,24.469,285.877,21.569,290.719,22.83z
-		 M293.744,36.034c-4.709,1.534-8.743,0.483-12.105-3.152C286.347,31.348,290.382,32.399,293.744,36.034
-		C291.145,36.736,291.981,34.193,293.744,36.034z M273.008,28.307c5.214,8.896,13.247,14.256,23.8,10.853
-		c1.221,1.674,2.417,3.366,3.59,5.074c-24.087,9.131-26.61-12.031-40.905-22.183c-0.66-3.173-2.194-6.006-4.602-8.497
-		C262.959,15.058,268.938,21.752,273.008,28.307C274.198,30.339,268.027,20.284,273.008,28.307z M240.949,13.903
-		c0.496-0.135,0.981-0.244,1.459-0.33c-2.546,2.519-4.131,5.409-4.755,8.672c-1.25,0.935-2.529,2.084-3.842,3.477
-		c-1.991-0.778-3.894-1.728-5.708-2.849C232.161,18.127,236.444,15.137,240.949,13.903
-		C241.445,13.768,236.444,15.137,240.949,13.903z M206.447,23.354c11.878-3.254,20.93,5.487,31.794,7.798
-		c0.716,2.533,2.184,4.666,4.405,6.398c-15.64,0.726-29.424-17.75-43.336-2.378c-1.992-0.669-3.814-1.641-5.467-2.915
-		C197.741,27.556,201.941,24.588,206.447,23.354C212.721,21.636,201.941,24.588,206.447,23.354z M215.653,33.291
-		c-3.315,3.677-7.336,4.778-12.063,3.304C206.905,32.918,210.926,31.817,215.653,33.291
-		C213.751,35.195,213.045,32.618,215.653,33.291z M171.944,32.805c17.083-4.679,32.752,18.389,47.923,1.667
-		c1.893,0.843,3.774,1.711,5.643,2.607c-20.427,24.93-41.857-12.457-60.704,7.544c-1.884-0.729-3.684-1.621-5.402-2.674
-		C162.936,37.175,167.119,34.127,171.944,32.805C178.217,31.087,167.119,34.127,171.944,32.805z M181.151,42.742
-		c-3.316,3.677-7.337,4.778-12.064,3.305C172.402,42.37,176.424,41.269,181.151,42.742
-		C179.249,44.646,178.705,42.025,181.151,42.742z M137.442,42.256c17.163-4.701,32.897,18.228,47.923,1.667
-		c1.893,0.843,3.773,1.712,5.642,2.607c-16.441,20.068-29.183,2.633-46.75,1.151c-2.174-2.4-4.945-4.046-8.312-4.939
-		C136.421,42.565,136.917,42.4,137.442,42.256C143.714,40.538,136.917,42.4,137.442,42.256z M124.283,50.081
-		c0.367-0.372,0.741-0.714,1.118-1.032c-0.9,3.408-0.81,6.66,0.269,9.758c-0.641,1.469-1.195,3.151-1.648,5.078
-		c-2.113,0.324-4.235,0.454-6.367,0.393C118.791,58.138,121.002,53.405,124.283,50.081C124.65,49.708,121.002,53.405,124.283,50.081
-		z M99.149,75.537c8.712-8.823,20.997-5.665,31.594-9.228c1.885,1.814,4.227,2.899,7.021,3.256
-		c-13.161,8.638-34.518-0.557-38.875,19.776c-2.06,0.417-4.124,0.489-6.192,0.215C93.717,83.533,95.868,78.861,99.149,75.537
-		C103.719,70.909,95.868,78.861,99.149,75.537z M112.095,79.529c-1.03,4.842-3.959,7.81-8.788,8.9
-		C104.336,83.587,107.265,80.62,112.095,79.529C111.402,82.129,109.5,80.252,112.095,79.529z M74.016,100.994
-		c12.444-12.604,37.558-0.482,42.318-22.553c2.06-0.218,4.124-0.407,6.189-0.569c-5.197,31.81-42.47,10.175-48.769,36.926
-		c-1.995,0.312-4,0.442-6.014,0.39C68.407,109.287,70.501,104.554,74.016,100.994C78.586,96.365,70.501,104.554,74.016,100.994z
-		 M86.961,104.986c-1.03,4.843-3.959,7.81-8.789,8.901C79.202,109.044,82.131,106.077,86.961,104.986
-		C86.268,107.586,84.485,105.589,86.961,104.986z M69.891,119.068c10.311-0.063,18.973-4.331,21.31-15.17
-		c2.061-0.218,4.125-0.407,6.19-0.568c-4.175,25.553-23.882,16.925-39.83,24.375c-3.047-1.001-6.232-1.098-9.556-0.292
-		C53.331,121.148,62.169,119.31,69.891,119.068C72.247,119.054,60.453,119.364,69.891,119.068z M41.238,139.707
-		c0.154-0.591,0.342-1.143,0.544-1.676c0.857,3.476,2.529,6.301,5.015,8.475c0.177,1.61,0.543,3.365,1.122,5.284
-		c-1.668,1.337-3.44,2.513-5.318,3.526C40.514,149.431,40.06,144.227,41.238,139.707C41.392,139.116,40.06,144.227,41.238,139.707z
-		 M32.213,174.323c3.121-11.968,15.288-15.404,22.692-23.743c2.531,0.647,5.092,0.458,7.684-0.567
-		c-7.165,13.934-30.078,16.656-23.695,36.393c-1.574,1.394-3.325,2.488-5.253,3.285C31.511,183.964,31.035,178.842,32.213,174.323
-		C33.854,168.029,31.035,178.842,32.213,174.323z M45.779,177.859c-0.295,1.131-1.468,2.979-3.516,5.546
-		c-1.532-4.708-0.48-8.743,3.156-12.104C46.12,173.9,46.241,176.086,45.779,177.859C45.484,178.99,46.241,176.086,45.779,177.859z
-		 M23.189,208.939c4.469-17.138,32.279-19.21,25.356-40.7c1.675-1.22,3.366-2.416,5.075-3.589
-		c11.415,30.142-31.679,30.059-23.75,56.372c-1.571,1.269-3.242,2.384-5.011,3.347C22.481,218.927,21.928,213.781,23.189,208.939
-		C24.83,202.646,21.928,213.781,23.189,208.939z M36.754,212.476c-0.294,1.131-1.467,2.978-3.516,5.547
-		c-1.532-4.708-0.48-8.743,3.156-12.104C37.095,208.517,37.217,210.702,36.754,212.476C36.46,213.607,37.217,210.702,36.754,212.476
-		z M28.661,226.653c8.897-5.212,14.259-13.245,10.86-23.797c1.675-1.22,3.367-2.417,5.075-3.589
-		c9.231,24.373-12.441,26.609-22.421,41.222c-3.119,0.672-5.898,2.211-8.336,4.617C15.189,236.904,22.042,230.759,28.661,226.653
-		C30.694,225.462,20.637,231.63,28.661,226.653z M14.253,258.978c-0.165-0.604-0.28-1.189-0.371-1.768
-		c2.457,2.531,5.282,4.112,8.476,4.745c0.971,1.351,2.201,2.737,3.712,4.162c-0.778,1.99-1.729,3.894-2.85,5.708
-		C18.476,267.767,15.486,263.483,14.253,258.978C14.088,258.373,15.486,263.483,14.253,258.978z M23.699,293.481
-		c-3.288-12.01,5.69-21.064,7.855-32.081c2.506-0.714,4.616-2.17,6.332-4.373c0.909,15.734-17.808,29.621-2.37,43.593
-		c-0.669,1.993-1.641,3.816-2.916,5.468C27.899,302.188,24.933,297.987,23.699,293.481
-		C21.981,287.208,24.933,297.987,23.699,293.481z M33.637,284.276c3.676,3.316,4.777,7.338,3.303,12.064
-		C33.263,293.024,32.162,289.003,33.637,284.276C35.541,286.179,32.964,286.885,33.637,284.276z M33.146,327.986
-		c-4.678-17.086,18.393-32.75,1.673-47.924c0.844-1.894,1.713-3.774,2.608-5.643c24.928,20.43-12.464,41.855,7.536,60.705
-		c-0.729,1.883-1.621,3.684-2.674,5.4C37.514,336.993,34.466,332.812,33.146,327.986C31.428,321.712,34.466,332.812,33.146,327.986z
-		 M43.083,318.781c3.677,3.315,4.778,7.336,3.303,12.063C42.71,327.527,41.609,323.507,43.083,318.781
-		C44.987,320.683,42.366,321.226,43.083,318.781z M46.724,340.609c5.109-8.957,5.753-18.591-2.458-26.043
-		c0.843-1.894,1.712-3.773,2.608-5.642c20.069,16.442,2.625,29.184,1.144,46.751c-2.4,2.17-4.048,4.936-4.944,8.3
-		C40.166,356.197,43.039,347.463,46.724,340.609C47.891,338.563,42.252,348.925,46.724,340.609z M50.401,375.655
-		c-0.376-0.372-0.719-0.749-1.04-1.131c3.407,0.906,6.66,0.821,9.758-0.255c1.47,0.645,3.156,1.199,5.086,1.655
-		c0.323,2.112,0.452,4.235,0.388,6.368C58.454,381.152,53.722,378.938,50.401,375.655C50.025,375.283,53.722,378.938,50.401,375.655
-		z M89.855,407.268c-23.108-3.935-17.803-21.913-23.222-38.063c1.815-1.884,2.903-4.221,3.265-7.012
-		c8.625,13.169-0.582,34.511,19.747,38.884C90.062,403.136,90.132,405.199,89.855,407.268z M79.841,387.864
-		c4.842,1.032,7.807,3.963,8.895,8.793C83.894,395.625,80.929,392.693,79.841,387.864C82.441,388.56,80.563,390.458,79.841,387.864z
-		 M101.281,425.956c-12.594-12.452-0.458-37.56-22.524-42.332c-0.217-2.062-0.406-4.125-0.565-6.191
-		c31.805,5.222,10.147,42.479,36.893,48.793c0.31,1.996,0.439,4,0.386,6.014C109.57,431.571,104.84,429.474,101.281,425.956
-		C96.656,421.383,104.84,429.474,101.281,425.956z M105.282,413.014c4.842,1.033,7.807,3.963,8.896,8.794
-		C109.334,420.774,106.369,417.844,105.282,413.014C107.882,413.709,105.883,415.49,105.282,413.014z M119.353,430.093
-		c-0.054-10.311-4.32-18.975-15.156-21.319c-0.217-2.061-0.404-4.124-0.564-6.189c25.515,4.184,16.932,23.853,24.33,39.803
-		c-1.005,3.049-1.111,6.236-0.318,9.562C121.411,446.604,119.589,437.809,119.353,430.093
-		C119.341,427.738,119.643,439.53,119.353,430.093z M139.948,458.755c-0.585-0.152-1.133-0.337-1.662-0.539
-		c3.486-0.856,6.319-2.532,8.5-5.023c1.599-0.179,3.341-0.543,5.245-1.116c1.337,1.667,2.513,3.442,3.525,5.319
-		C149.671,459.48,144.467,459.936,139.948,458.755C139.362,458.603,144.467,459.936,139.948,458.755z M174.563,467.786
-		c-11.95-3.12-15.399-15.26-23.71-22.673c0.65-2.53,0.465-5.093-0.557-7.688c13.9,7.186,16.631,30.059,36.352,23.682
-		c1.392,1.575,2.486,3.327,3.282,5.255C184.203,468.489,179.083,468.965,174.563,467.786
-		C168.268,466.144,179.083,468.965,174.563,467.786z M171.544,454.58c4.709-1.531,8.743-0.479,12.104,3.158
-		C178.939,459.269,174.904,458.216,171.544,454.58C174.143,453.88,173.468,456.464,171.544,454.58z M209.178,476.816
-		c-17.142-4.472-19.2-32.28-40.696-25.364c-1.219-1.675-2.415-3.367-3.588-5.074c30.143-11.413,30.053,31.684,56.367,23.76
-		c1.268,1.571,2.384,3.242,3.347,5.012C219.164,477.525,214.019,478.08,209.178,476.816
-		C202.884,475.175,214.019,478.08,209.178,476.816z M206.159,463.609c4.708-1.53,8.743-0.479,12.103,3.158
-		C213.554,468.3,209.52,467.248,206.159,463.609C208.758,462.911,207.92,465.452,206.159,463.609z M226.892,471.348
-		c-5.211-8.897-13.241-14.262-23.795-10.863c-1.22-1.676-2.416-3.367-3.588-5.077c24.323-9.204,26.604,12.368,41.154,22.384
-		c0.67,3.134,2.209,5.926,4.618,8.374C237.1,484.773,230.995,477.965,226.892,471.348
-		C225.701,469.315,231.868,479.372,226.892,471.348z M259.169,485.759c-0.585,0.161-1.153,0.273-1.714,0.363
-		c2.534-2.47,4.116-5.308,4.749-8.517c1.33-0.966,2.695-2.179,4.097-3.668c1.99,0.777,3.896,1.726,5.711,2.846
-		C267.956,481.53,263.674,484.522,259.169,485.759C258.584,485.92,263.674,484.522,259.169,485.759z M293.666,476.29
-		c-11.976,3.288-21.042-5.629-32.024-7.825c-0.714-2.51-2.174-4.623-4.378-6.342c15.712-0.876,29.587,17.778,43.536,2.347
-		c1.992,0.668,3.815,1.639,5.468,2.912C302.37,472.087,298.171,475.055,293.666,476.29
-		C287.396,478.012,298.171,475.055,293.666,476.29z M284.455,466.358c3.316-3.678,7.336-4.781,12.063-3.31
-		C293.204,466.728,289.184,467.829,284.455,466.358C286.357,464.454,287.064,467.03,284.455,466.358z M328.166,466.824
-		c-17.081,4.688-32.761-18.375-47.925-1.646c-1.894-0.841-3.774-1.709-5.644-2.604c20.413-24.941,41.861,12.435,60.7-7.573
-		c1.884,0.728,3.684,1.618,5.403,2.671C337.172,462.449,332.99,465.5,328.166,466.824C321.893,468.545,332.99,465.5,328.166,466.824
-		z M318.954,456.891c3.315-3.679,7.335-4.781,12.063-3.31C327.702,457.259,323.683,458.363,318.954,456.891
-		C320.855,454.986,321.4,457.606,318.954,456.891z M362.663,457.356c-17.159,4.709-32.908-18.214-47.925-1.645
-		c-1.892-0.843-3.773-1.711-5.643-2.604c16.414-20.055,29.162-2.678,46.714-1.178c2.176,2.406,4.95,4.058,8.324,4.949
-		C363.667,457.055,363.18,457.215,362.663,457.356C356.392,459.078,363.18,457.215,362.663,457.356z M375.795,449.539
-		c-0.359,0.364-0.724,0.701-1.093,1.012c0.894-3.412,0.8-6.669-0.28-9.771c0.633-1.46,1.181-3.133,1.63-5.046
-		c2.112-0.323,4.235-0.454,6.366-0.395C381.284,441.479,379.075,446.214,375.795,449.539
-		C375.436,449.903,379.075,446.214,375.795,449.539z M400.92,424.072c-8.699,8.818-20.977,5.681-31.566,9.231
-		c-1.887-1.818-4.23-2.904-7.03-3.258c13.161-8.625,34.502,0.55,38.853-19.778c2.06-0.418,4.123-0.491,6.191-0.217
-		C406.348,416.075,404.2,420.747,400.92,424.072C396.352,428.702,404.2,420.747,400.92,424.072z M387.973,420.085
-		c1.028-4.843,3.956-7.811,8.786-8.904C395.729,416.023,392.803,418.992,387.973,420.085
-		C388.665,417.485,390.567,419.361,387.973,420.085z M426.045,398.606c-12.44,12.609-37.558,0.494-42.312,22.568
-		c-2.061,0.218-4.124,0.407-6.189,0.57c5.187-31.81,42.471-10.19,48.755-36.943c1.995-0.313,4.001-0.443,6.015-0.393
-		C431.65,390.312,429.557,395.044,426.045,398.606C421.476,403.236,429.557,395.044,426.045,398.606z M413.097,394.619
-		c1.028-4.843,3.957-7.811,8.785-8.905C420.854,390.558,417.927,393.526,413.097,394.619
-		C413.789,392.019,415.573,394.014,413.097,394.619z M430.162,380.53c-10.312,0.063-18.97,4.342-21.305,15.178
-		c-2.061,0.218-4.122,0.408-6.188,0.57c4.166-25.546,23.874-16.94,39.82-24.391c3.048,0.999,6.233,1.095,9.557,0.288
-		C446.725,378.444,437.881,380.287,430.162,380.53C427.808,380.545,439.601,380.231,430.162,380.53z M458.809,359.88
-		c-0.152,0.592-0.34,1.146-0.544,1.68c-0.859-3.476-2.531-6.3-5.018-8.474c-0.177-1.609-0.544-3.365-1.123-5.285
-		c1.667-1.337,3.439-2.514,5.315-3.527C459.529,350.157,459.986,355.36,458.809,359.88
-		C458.656,360.472,459.986,355.36,458.809,359.88z M467.82,325.261c-3.115,11.969-15.282,15.411-22.684,23.752
-		c-2.529-0.646-5.091-0.456-7.683,0.569c7.158-13.936,30.071-16.669,23.681-36.401c1.573-1.394,3.323-2.488,5.251-3.286
-		C468.518,315.619,468.996,320.74,467.82,325.261C466.182,331.556,468.996,320.74,467.82,325.261z M454.253,321.729
-		c0.294-1.132,1.466-2.979,3.514-5.548c1.533,4.707,0.482,8.741-3.151,12.104C453.914,325.688,453.791,323.504,454.253,321.729
-		C454.547,320.598,453.791,323.504,454.253,321.729z M476.83,290.64c-4.463,17.141-32.27,19.222-25.341,40.71
-		c-1.674,1.222-3.364,2.419-5.072,3.592c-11.429-30.137,31.667-30.07,23.727-56.382c1.572-1.268,3.242-2.384,5.011-3.349
-		C477.533,280.652,478.091,285.798,476.83,290.64C475.19,296.936,478.091,285.798,476.83,290.64z M463.264,287.109
-		c0.293-1.131,1.466-2.979,3.514-5.548c1.533,4.708,0.482,8.742-3.15,12.104C462.924,291.067,462.802,288.883,463.264,287.109
-		C463.557,285.979,462.802,288.883,463.264,287.109z M471.352,272.93c-8.896,5.216-14.254,13.248-10.851,23.801
-		c-1.675,1.22-3.367,2.416-5.074,3.591c-9.243-24.374,12.434-26.61,22.404-41.232c3.119-0.674,5.897-2.212,8.335-4.617
-		C484.805,262.68,477.979,268.813,471.352,272.93C469.32,274.121,479.373,267.948,471.352,272.93z"/>
-</g>
-	</g>
-    <text x="320" y="336">PACKAGE_NAME</text>
-</svg>
diff --git a/src/qt/rpcconsole.cpp b/src/qt/rpcconsole.cpp
index 696eecaae5..ae3f9aa686 100644
--- a/src/qt/rpcconsole.cpp
+++ b/src/qt/rpcconsole.cpp
@@ -14,8 +14,6 @@
 #include <qt/bantablemodel.h>
 #include <qt/clientmodel.h>
 #include <qt/guiutil.h>
-#include <qt/optionsmodel.h>
-#include <qt/pairingpage.h>
 #include <qt/peertablesortproxy.h>
 #include <qt/platformstyle.h>
 #include <qt/walletmodel.h>
@@ -32,7 +30,6 @@
 #include <QAbstractItemModel>
 #include <QDateTime>
 #include <QFont>
-#include <QFontMetrics>
 #include <QKeyEvent>
 #include <QKeySequence>
 #include <QLatin1String>
@@ -42,7 +39,6 @@
 #include <QScreen>
 #include <QScrollBar>
 #include <QSettings>
-#include <QShortcut>
 #include <QString>
 #include <QStringList>
 #include <QStyledItemDelegate>
@@ -79,7 +75,6 @@ const QStringList historyFilter = QStringList()
     << "sethdseed"
     << "signmessagewithprivkey"
     << "signrawtransactionwithkey"
-    << "sweepprivkeys"
     << "walletpassphrase"
     << "walletpassphrasechange"
     << "encryptwallet";
@@ -477,12 +472,6 @@ RPCConsole::RPCConsole(interfaces::Node& node, const PlatformStyle *_platformSty
     platformStyle(_platformStyle)
 {
     ui->setupUi(this);
-
-    // Default tabs are identified by their UI index
-    for (int i = ui->tabWidget->count(); i--; ) {
-        m_tabs[TabTypes(i)] = ui->tabWidget->widget(i);
-    }
-
     QSettings settings;
 #ifdef ENABLE_WALLET
     if (WalletModel::isWalletEnabled()) {
@@ -491,17 +480,16 @@ RPCConsole::RPCConsole(interfaces::Node& node, const PlatformStyle *_platformSty
             // Restore failed (perhaps missing setting), center the window
             move(QGuiApplication::primaryScreen()->availableGeometry().center() - frameGeometry().center());
         }
-        ui->splitter->restoreState(settings.value("RPCConsoleWindowPeersTabSplitterSizes_Knots23").toByteArray());
+        ui->splitter->restoreState(settings.value("RPCConsoleWindowPeersTabSplitterSizes").toByteArray());
     } else
 #endif // ENABLE_WALLET
     {
         // RPCConsole is a child widget.
-        ui->splitter->restoreState(settings.value("RPCConsoleWidgetPeersTabSplitterSizes_Knots23").toByteArray());
+        ui->splitter->restoreState(settings.value("RPCConsoleWidgetPeersTabSplitterSizes").toByteArray());
     }
 
-    m_peer_widget_header_state = settings.value("PeersTabPeerHeaderState_Knots23").toByteArray();
+    m_peer_widget_header_state = settings.value("PeersTabPeerHeaderState").toByteArray();
     m_banlist_widget_header_state = settings.value("PeersTabBanlistHeaderState").toByteArray();
-    m_alternating_row_colors = settings.value("PeersTabAlternatingRowColors").toBool();
 
     constexpr QChar nonbreaking_hyphen(8209);
     const std::vector<QString> CONNECTION_TYPE_DOC{
@@ -594,60 +582,11 @@ RPCConsole::RPCConsole(interfaces::Node& node, const PlatformStyle *_platformSty
     consoleFontSize = settings.value(fontSizeSettingsKey, QFont().pointSize()).toInt();
     clear();
 
-    // load history
-    QMap<size_t, QString> rewrite_replace;
-    int size = settings.beginReadArray("nRPCConsoleWindowHistory");
-    history.clear();
-    for (int i = 0; i < size; ++i) {
-        settings.setArrayIndex(i);
-        QString cmd = settings.value("cmd").toString();
-        QString filtered_cmd;
-        {
-            std::string strFilteredCmd, dummy;
-            if (RPCParseCommandLine(nullptr, dummy, cmd.toStdString(), false, &strFilteredCmd)) {
-                filtered_cmd = QString::fromStdString(strFilteredCmd);
-            } else {
-                // Failed to parse command, so we cannot even filter it for the history
-                filtered_cmd = cmd;
-            }
-        }
-        if (cmd != filtered_cmd) {
-            // Overwrite this line, and trigger an immediate rewrite of history to purge it
-            cmd = QString(cmd.size(), 'x');
-            rewrite_replace[history.size()] = filtered_cmd;
-        }
-        history.append(cmd);
-    }
-    historyPtr = history.size();
-    settings.endArray();
-    if (!rewrite_replace.empty()) {
-        WriteCommandHistory();
-        for (QMapIterator<size_t, QString> i(rewrite_replace); i.hasNext(); ) {
-            i.next();
-            history[i.key()] = i.value();
-        }
-        WriteCommandHistory();
-    }
-
     GUIUtil::handleCloseWindowShortcut(this);
 
-    QObject::connect(new QShortcut(QKeySequence(QStringLiteral("Ctrl+D")), ui->tab_console), &QShortcut::activated, this, &QWidget::close);
-
     updateWindowTitle();
 }
 
-void RPCConsole::WriteCommandHistory()
-{
-    // persist history
-    QSettings settings;
-    settings.beginWriteArray("nRPCConsoleWindowHistory");
-    for (int i = 0; i < history.size(); ++i) {
-        settings.setArrayIndex(i);
-        settings.setValue("cmd", history.at(i));
-    }
-    settings.endArray();
-}
-
 RPCConsole::~RPCConsole()
 {
     QSettings settings;
@@ -655,19 +594,17 @@ RPCConsole::~RPCConsole()
     if (WalletModel::isWalletEnabled()) {
         // RPCConsole widget is a window.
         settings.setValue("RPCConsoleWindowGeometry", saveGeometry());
-        settings.setValue("RPCConsoleWindowPeersTabSplitterSizes_Knots23", ui->splitter->saveState());
+        settings.setValue("RPCConsoleWindowPeersTabSplitterSizes", ui->splitter->saveState());
     } else
 #endif // ENABLE_WALLET
     {
         // RPCConsole is a child widget.
-        settings.setValue("RPCConsoleWidgetPeersTabSplitterSizes_Knots23", ui->splitter->saveState());
+        settings.setValue("RPCConsoleWidgetPeersTabSplitterSizes", ui->splitter->saveState());
     }
 
-    settings.setValue("PeersTabPeerHeaderState_Knots23", m_peer_widget_header_state);
+    settings.setValue("PeersTabPeerHeaderState", m_peer_widget_header_state);
     settings.setValue("PeersTabBanlistHeaderState", m_banlist_widget_header_state);
 
-    WriteCommandHistory();
-
     m_node.rpcUnsetTimerInterface(rpcTimerInterface);
     delete rpcTimerInterface;
     delete ui;
@@ -732,7 +669,6 @@ void RPCConsole::setClientModel(ClientModel *model, int bestblock_height, int64_
     }
 
     ui->trafficGraph->setClientModel(model);
-    if (m_tab_pairing) m_tab_pairing->setClientModel(model);
     if (model && clientModel->getPeerTableModel() && clientModel->getBanTableModel()) {
         // Keep up to date with client
         setNumConnections(model->getNumConnections());
@@ -750,13 +686,7 @@ void RPCConsole::setClientModel(ClientModel *model, int bestblock_height, int64_
 
         connect(model, &ClientModel::mempoolSizeChanged, this, &RPCConsole::setMempoolSize);
 
-        connect(model->getOptionsModel(), &OptionsModel::peersTabAlternatingRowColorsChanged, [this](bool alternating_row_colors) {
-            ui->peerWidget->setAlternatingRowColors(alternating_row_colors);
-            ui->banlistWidget->setAlternatingRowColors(alternating_row_colors);
-        });
-
         // set up peer table
-        clientModel->getPeerTableModel()->updatePalette();
         ui->peerWidget->setModel(model->peerTableSortProxy());
         ui->peerWidget->verticalHeader()->hide();
         ui->peerWidget->setSelectionBehavior(QAbstractItemView::SelectRows);
@@ -764,21 +694,13 @@ void RPCConsole::setClientModel(ClientModel *model, int bestblock_height, int64_
         ui->peerWidget->setContextMenuPolicy(Qt::CustomContextMenu);
 
         if (!ui->peerWidget->horizontalHeader()->restoreState(m_peer_widget_header_state)) {
-            const QFontMetrics fm = ui->peerWidget->fontMetrics();
-            ui->peerWidget->setColumnWidth(PeerTableModel::NetNodeId, GUIUtil::TextWidth(fm, QStringLiteral("99999")));
-            ui->peerWidget->setColumnWidth(PeerTableModel::Age, GUIUtil::TextWidth(fm, GUIUtil::FormatPeerAge(std::chrono::hours{23976 /* 999 days */})));
-            ui->peerWidget->setColumnWidth(PeerTableModel::Direction, DIRECTION_COLUMN_WIDTH);
             ui->peerWidget->setColumnWidth(PeerTableModel::Address, ADDRESS_COLUMN_WIDTH);
-            ui->peerWidget->setColumnWidth(PeerTableModel::ConnectionType, GUIUtil::TextWidth(fm, GUIUtil::ConnectionTypeToQString(ConnectionType::ADDR_FETCH /* TODO: Find the WIDEST string? */, /*prepend_direction=*/false)));
-            const auto bytesize_width = GUIUtil::TextWidth(fm, GUIUtil::formatBytes(999'000'000'000) + QStringLiteral("x"));
             ui->peerWidget->setColumnWidth(PeerTableModel::Subversion, SUBVERSION_COLUMN_WIDTH);
             ui->peerWidget->setColumnWidth(PeerTableModel::Ping, PING_COLUMN_WIDTH);
-            ui->peerWidget->setColumnWidth(PeerTableModel::Sent, bytesize_width);
-            ui->peerWidget->setColumnWidth(PeerTableModel::Received, bytesize_width);
         }
+        ui->peerWidget->horizontalHeader()->setSectionResizeMode(PeerTableModel::Age, QHeaderView::ResizeToContents);
         ui->peerWidget->horizontalHeader()->setStretchLastSection(true);
         ui->peerWidget->setItemDelegateForColumn(PeerTableModel::NetNodeId, new PeerIdViewDelegate(this));
-        ui->peerWidget->setAlternatingRowColors(m_alternating_row_colors);
 
         // create peer table context menu
         peersTableContextMenu = new QMenu(this);
@@ -795,10 +717,7 @@ void RPCConsole::setClientModel(ClientModel *model, int bestblock_height, int64_
         connect(ui->peerWidget, &QTableView::customContextMenuRequested, this, &RPCConsole::showPeersTableContextMenu);
 
         // peer table signal handling - update peer details when selecting new node
-        connect(ui->peerWidget->selectionModel(), &QItemSelectionModel::selectionChanged, [this] {
-            resetDetailWidget();
-            updateDetailWidget();
-        });
+        connect(ui->peerWidget->selectionModel(), &QItemSelectionModel::selectionChanged, this, &RPCConsole::updateDetailWidget);
         connect(model->getPeerTableModel(), &QAbstractItemModel::dataChanged, [this] { updateDetailWidget(); });
 
         // set up ban table
@@ -812,8 +731,8 @@ void RPCConsole::setClientModel(ClientModel *model, int bestblock_height, int64_
             ui->banlistWidget->setColumnWidth(BanTableModel::Address, BANSUBNET_COLUMN_WIDTH);
             ui->banlistWidget->setColumnWidth(BanTableModel::Bantime, BANTIME_COLUMN_WIDTH);
         }
+        ui->banlistWidget->horizontalHeader()->setSectionResizeMode(BanTableModel::Address, QHeaderView::ResizeToContents);
         ui->banlistWidget->horizontalHeader()->setStretchLastSection(true);
-        ui->banlistWidget->setAlternatingRowColors(m_alternating_row_colors);
 
         // create ban table context menu
         banTableContextMenu = new QMenu(this);
@@ -869,15 +788,6 @@ void RPCConsole::setClientModel(ClientModel *model, int bestblock_height, int64_
     }
 }
 
-void RPCConsole::addPairingTab()
-{
-    assert(!m_tab_pairing);
-    m_tab_pairing = new PairingPage(this);
-    ui->tabWidget->insertTab(1, m_tab_pairing, tr("&Pairing"));
-    m_tabs[TabTypes::PAIRING] = m_tab_pairing;
-    if (clientModel) m_tab_pairing->setClientModel(clientModel);
-}
-
 #ifdef ENABLE_WALLET
 void RPCConsole::addWallet(WalletModel * const walletModel)
 {
@@ -1035,10 +945,6 @@ void RPCConsole::changeEvent(QEvent* e)
                 QUrl(ICON_MAPPING[i].url),
                 platformStyle->SingleColorImage(ICON_MAPPING[i].source).scaled(QSize(consoleFontSize * 2, consoleFontSize * 2), Qt::IgnoreAspectRatio, Qt::SmoothTransformation));
         }
-
-        if (clientModel && clientModel->getPeerTableModel()) {
-            clientModel->getPeerTableModel()->updatePalette();
-        }
     }
 
     QWidget::changeEvent(e);
@@ -1275,15 +1181,6 @@ void RPCConsole::updateTrafficStats(quint64 totalBytesIn, quint64 totalBytesOut)
     ui->lblBytesOut->setText(GUIUtil::formatBytes(totalBytesOut));
 }
 
-void RPCConsole::resetDetailWidget()
-{
-    for (int row = 0; QLayoutItem * const item = ui->peerDetailsGrid->itemAtPosition(row, 1); ++row) {
-        QLabel * const value_label = qobject_cast<QLabel*>(item->widget());
-        if (!value_label) continue;
-        value_label->setText(ts.na);
-    }
-}
-
 void RPCConsole::updateDetailWidget()
 {
     const QList<QModelIndex> selected_peers = GUIUtil::getEntryData(ui->peerWidget, PeerTableModel::NetNodeId);
@@ -1316,6 +1213,8 @@ void RPCConsole::updateDetailWidget()
     ui->peerMinPing->setText(GUIUtil::formatPingTime(stats->nodeStats.m_min_ping_time));
     if (stats->nodeStats.nVersion) {
         ui->peerVersion->setText(QString::number(stats->nodeStats.nVersion));
+    }
+    if (!stats->nodeStats.cleanSubVer.empty()) {
         ui->peerSubversion->setText(QString::fromStdString(stats->nodeStats.cleanSubVer));
     }
     ui->peerConnectionType->setText(GUIUtil::ConnectionTypeToQString(stats->nodeStats.m_conn_type, /*prepend_direction=*/true));
@@ -1330,7 +1229,7 @@ void RPCConsole::updateDetailWidget()
     }
     ui->peerNetwork->setText(GUIUtil::NetworkToQString(stats->nodeStats.m_network));
     if (stats->nodeStats.m_permission_flags == NetPermissionFlags::None) {
-        ui->peerPermissions->setText(ts.no_permissions);
+        ui->peerPermissions->setText(ts.na);
     } else {
         QStringList permissions;
         for (const auto& permission : NetPermissions::ToStrings(stats->nodeStats.m_permission_flags)) {
@@ -1480,34 +1379,14 @@ void RPCConsole::showOrHideBanTableIfRequired()
     ui->banHeading->setVisible(visible);
 }
 
-std::vector<RPCConsole::TabTypes> RPCConsole::tabs() const
-{
-    std::vector<TabTypes> ret;
-    ret.reserve(m_tabs.size());
-
-    std::map<QWidget*, TabTypes> tabtype_map;
-    for (const auto& tab : m_tabs) {
-        tabtype_map[tab.second] = tab.first;
-    }
-
-    for (int i = 0; i < ui->tabWidget->count(); ++i) {
-        auto tabtype = tabtype_map.find(ui->tabWidget->widget(i));
-        if (tabtype != tabtype_map.end()) {
-            ret.push_back(tabtype->second);
-        }
-    }
-    return ret;
-}
-
 void RPCConsole::setTabFocus(enum TabTypes tabType)
 {
-    ui->tabWidget->setCurrentWidget(m_tabs[tabType]);
+    ui->tabWidget->setCurrentIndex(int(tabType));
 }
 
 QString RPCConsole::tabTitle(TabTypes tab_type) const
 {
-    const int tab_index = ui->tabWidget->indexOf(m_tabs.at(tab_type));
-    return ui->tabWidget->tabText(tab_index);
+    return ui->tabWidget->tabText(int(tab_type));
 }
 
 QKeySequence RPCConsole::tabShortcut(TabTypes tab_type) const
@@ -1516,7 +1395,6 @@ QKeySequence RPCConsole::tabShortcut(TabTypes tab_type) const
     case TabTypes::INFO: return QKeySequence(tr("Ctrl+I"));
     case TabTypes::CONSOLE: return QKeySequence(tr("Ctrl+T"));
     case TabTypes::GRAPH: return QKeySequence(tr("Ctrl+N"));
-    case TabTypes::PAIRING: return QKeySequence(QStringLiteral("Alt+5"));  // Only used in disablewallet mode - matches wallet GUI's pairing shortcut
     case TabTypes::PEERS: return QKeySequence(tr("Ctrl+P"));
     } // no default case, so the compiler can warn about missing cases
 
diff --git a/src/qt/rpcconsole.h b/src/qt/rpcconsole.h
index 0cc1a297d2..4747e611d0 100644
--- a/src/qt/rpcconsole.h
+++ b/src/qt/rpcconsole.h
@@ -18,8 +18,6 @@
 #include <QThread>
 #include <QWidget>
 
-class GuiNetWatch;
-class PairingPage;
 class PlatformStyle;
 class RPCExecutor;
 class RPCTimerInterface;
@@ -54,7 +52,6 @@ public:
     }
 
     void setClientModel(ClientModel *model = nullptr, int bestblock_height = 0, int64_t bestblock_date = 0, double verification_progress = 0.0);
-    void addPairingTab();
 
 #ifdef ENABLE_WALLET
     void addWallet(WalletModel* const walletModel);
@@ -73,11 +70,10 @@ public:
         INFO,
         CONSOLE,
         GRAPH,
-        PEERS,
-        PAIRING,
+        PEERS
     };
 
-    std::vector<TabTypes> tabs() const;
+    std::vector<TabTypes> tabs() const { return {TabTypes::INFO, TabTypes::CONSOLE, TabTypes::GRAPH, TabTypes::PEERS}; }
 
     QString tabTitle(TabTypes tab_type) const;
     QKeySequence tabShortcut(TabTypes tab_type) const;
@@ -107,8 +103,6 @@ private Q_SLOTS:
     void showOrHideBanTableIfRequired();
     /** clear the selected node */
     void clearSelectedNode();
-    /** reset all fields in UI detailed information to N/A */
-    void resetDetailWidget();
     /** show detailed information on ui about selected node */
     void updateDetailWidget();
 
@@ -148,16 +142,14 @@ public Q_SLOTS:
 private:
     struct TranslatedStrings {
         const QString yes{tr("Yes")}, no{tr("No")}, to{tr("To")}, from{tr("From")},
-            ban_for{tr("Ban for")}, na{tr("N/A")}, unknown{tr("Unknown")}, no_permissions{tr("None")};
+            ban_for{tr("Ban for")}, na{tr("N/A")}, unknown{tr("Unknown")};
     } const ts;
 
     void startExecutor();
     void setTrafficGraphRange(int mins);
-    void WriteCommandHistory();
 
     enum ColumnWidths
     {
-        DIRECTION_COLUMN_WIDTH = 32,
         ADDRESS_COLUMN_WIDTH = 200,
         SUBVERSION_COLUMN_WIDTH = 150,
         PING_COLUMN_WIDTH = 80,
@@ -169,9 +161,6 @@ private:
     interfaces::Node& m_node;
     Ui::RPCConsole* const ui;
     ClientModel *clientModel = nullptr;
-    std::map<TabTypes, QWidget*> m_tabs;
-    PairingPage *m_tab_pairing{nullptr};
-    GuiNetWatch *netwatch = nullptr;
     QStringList history;
     int historyPtr = 0;
     QString cmdBeforeBrowsing;
@@ -188,7 +177,6 @@ private:
     bool m_is_executing{false};
     QByteArray m_peer_widget_header_state;
     QByteArray m_banlist_widget_header_state;
-    bool m_alternating_row_colors{false};
 
     /** Update UI with latest network info from model. */
     void updateNetworkState();
diff --git a/src/qt/sendcoinsdialog.cpp b/src/qt/sendcoinsdialog.cpp
index feb640292b..03173ec80e 100644
--- a/src/qt/sendcoinsdialog.cpp
+++ b/src/qt/sendcoinsdialog.cpp
@@ -464,9 +464,8 @@ bool SendCoinsDialog::signWithExternalSigner(PartiallySignedTransaction& psbtx,
         return false;
     }
     if (err) {
+        tfm::format(std::cerr, "Failed to sign PSBT");
         processSendCoinsReturn(WalletModel::TransactionCreationFailed);
-        const QString msg = tr("Failed to sign PSBT");
-        QMessageBox::critical(nullptr, msg, msg);
         return false;
     }
     // fillPSBT does not always properly finalize
@@ -483,82 +482,11 @@ void SendCoinsDialog::sendButtonClicked([[maybe_unused]] bool checked)
     if (!PrepareSendText(question_string, informative_text, detailed_text)) return;
     assert(m_current_transaction);
 
-    bool have_warning = false;
-    for (int i = 0; i < ui->entries->count(); ++i) {
-        SendCoinsEntry *entry = qobject_cast<SendCoinsEntry*>(ui->entries->itemAt(i)->widget());
-        if (entry && entry->hasPaytoWarning()) {
-            have_warning = true;
-            break;
-        }
-    }
-    if (have_warning) {
-        auto recipients = m_current_transaction->getRecipients();
-        struct prior_usage_info_t {
-            CAmount total_amount{0};
-            int num_txs{0};
-            qint64 tx_time_oldest;
-            qint64 tx_time_newest;
-        };
-        QMap<QString, prior_usage_info_t> prior_usage_info;
-        {
-            QStringList addresses;
-            for (const auto& recipient : recipients) {
-                addresses.append(recipient.address);
-            }
-            model->findAddressUsage(addresses, [&prior_usage_info](const QString& address, const interfaces::WalletTx& wtx, uint32_t output_index){
-                auto& info = prior_usage_info[address];
-                info.total_amount += wtx.tx->vout[output_index].nValue;
-                ++info.num_txs;
-                if (info.num_txs == 1 || wtx.time < info.tx_time_oldest) {
-                    info.tx_time_oldest = wtx.time;
-                }
-                if (info.num_txs == 1 || wtx.time > info.tx_time_newest) {
-                    info.tx_time_newest = wtx.time;
-                }
-            });
-        }
-
-        QString reuse_question, reuse_details;
-        if (recipients.size() > 1) {
-            reuse_question = tr("You've already paid some of these addresses.");
-        } else {
-            reuse_question = tr("You've already paid this address.");
-        }
-
-        for (const auto& rcp : recipients) {
-            if (!prior_usage_info.contains(rcp.address)) continue;
-            if (!reuse_details.isEmpty()) reuse_details.append("\n\n");
-            const auto& rcp_prior_usage_info = prior_usage_info.value(rcp.address);
-            const QString label_and_address = rcp.label.isEmpty() ? rcp.address : (QString("'") + rcp.label + "' (" + rcp.address + ")");
-            if (rcp_prior_usage_info.num_txs == 1) {
-                //: %1 is an amount (eg, "1 BTC"); %2 is a Bitcoin address and its label; %3 is a date (eg, "2019-05-08")
-                reuse_details.append(tr("Sent %1 to %2 on %3").arg(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), rcp_prior_usage_info.total_amount), label_and_address, GUIUtil::dateStr(rcp_prior_usage_info.tx_time_newest)));
-            } else {
-                //: %1 is an amount (eg, "1 BTC"); %2 is a Bitcoin address and its label; %3 is the number of transactions; %4 and %5 are dates (eg, "2019-05-08"), earlier first
-                reuse_details.append(tr("Sent %1 to %2 across %3 transactions from %4 through %5").arg(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), rcp_prior_usage_info.total_amount), label_and_address, QString::number(rcp_prior_usage_info.num_txs), GUIUtil::dateStr(rcp_prior_usage_info.tx_time_oldest), GUIUtil::dateStr(rcp_prior_usage_info.tx_time_newest)));
-            }
-        }
-
-        reuse_question.append("<br /><br /><span style='font-size:10pt;'>");
-        reuse_question.append(tr("Bitcoin addresses are intended to only be used once, for a single payment. Sending to the same address again will harm the recipient's security, as well as the privacy of all Bitcoin users!"));
-        reuse_question.append("</span>");
-
-        SendConfirmationDialog confirmation_dialog(tr("Already paid"), reuse_question, "", reuse_details, ADDRESS_REUSE_OVERRIDE_DELAY, /*enable_send=*/true, /*always_show_unsigned=*/false, this);
-        confirmation_dialog.setIcon(QMessageBox::Warning);
-        confirmation_dialog.confirmButtonText = tr("Override");
-        confirmation_dialog.m_yes_button = QMessageBox::Ignore;
-        confirmation_dialog.m_cancel_button = QMessageBox::Ok;
-        if (static_cast<QMessageBox::StandardButton>(confirmation_dialog.exec()) == QMessageBox::Cancel) {
-            fNewRecipientAllowed = true;
-            return;
-        }
-    }
-
     const QString confirmation = tr("Confirm send coins");
     const bool enable_send{!model->wallet().privateKeysDisabled() || model->wallet().hasExternalSigner()};
     const bool always_show_unsigned{model->getOptionsModel()->getEnablePSBTControls()};
     auto confirmationDialog = new SendConfirmationDialog(confirmation, question_string, informative_text, detailed_text, SEND_CONFIRM_DELAY, enable_send, always_show_unsigned, this);
-    confirmationDialog->m_delete_on_close = true;
+    confirmationDialog->setAttribute(Qt::WA_DeleteOnClose);
     // TODO: Replace QDialog::exec() with safer QDialog::show().
     const auto retval = static_cast<QMessageBox::StandardButton>(confirmationDialog->exec());
 
@@ -1127,61 +1055,30 @@ void SendCoinsDialog::coinControlUpdateLabels()
 }
 
 SendConfirmationDialog::SendConfirmationDialog(const QString& title, const QString& text, const QString& informative_text, const QString& detailed_text, int _secDelay, bool enable_send, bool always_show_unsigned, QWidget* parent)
-    : QMessageBox(parent), secDelay(_secDelay), m_enable_save(always_show_unsigned || !enable_send), m_enable_send(enable_send)
+    : QMessageBox(parent), secDelay(_secDelay), m_enable_send(enable_send)
 {
     setIcon(QMessageBox::Question);
     setWindowTitle(title); // On macOS, the window title is ignored (as required by the macOS Guidelines).
     setText(text);
     setInformativeText(informative_text);
     setDetailedText(detailed_text);
-}
-
-int SendConfirmationDialog::exec()
-{
-    setStandardButtons(m_yes_button | m_cancel_button);
-
-    yesButton = button(m_yes_button);
-    QAbstractButton * const cancel_button_obj = button(m_cancel_button);
-
-    if (m_yes_button != QMessageBox::Yes || m_cancel_button != QMessageBox::Cancel) {
-        // We need to ensure the buttons have Yes/No roles, or they'll get ordered weird
-        // But only do it for customised yes/cancel buttons, so simple code can check results simply too
-        removeButton(cancel_button_obj);
-        addButton(cancel_button_obj, QMessageBox::NoRole);
-        setEscapeButton(cancel_button_obj);
-
-        removeButton(yesButton);
-        addButton(yesButton, QMessageBox::YesRole);
-    }
-
-    if (m_enable_save) addButton(QMessageBox::Save);
-
-    setDefaultButton(m_cancel_button);
-
+    setStandardButtons(QMessageBox::Yes | QMessageBox::Cancel);
+    if (always_show_unsigned || !enable_send) addButton(QMessageBox::Save);
+    setDefaultButton(QMessageBox::Cancel);
+    yesButton = button(QMessageBox::Yes);
     if (confirmButtonText.isEmpty()) {
         confirmButtonText = yesButton->text();
     }
     m_psbt_button = button(QMessageBox::Save);
     updateButtons();
-
     connect(&countDownTimer, &QTimer::timeout, this, &SendConfirmationDialog::countDown);
-    countDownTimer.start(1s);
-
-    QMessageBox::exec();
-
-    int rv;
-    const auto clicked_button = clickedButton();
-    if (clicked_button == m_psbt_button) {
-        rv = QMessageBox::Save;
-    } else if (clicked_button == yesButton) {
-        rv = QMessageBox::Yes;
-    } else {
-        rv = QMessageBox::Cancel;
-    }
-
-    if (m_delete_on_close) delete this;
+}
 
-    return rv;
+int SendConfirmationDialog::exec()
+{
+    updateButtons();
+    countDownTimer.start(1s);
+    return QMessageBox::exec();
 }
 
 void SendConfirmationDialog::countDown()
diff --git a/src/qt/sendcoinsdialog.h b/src/qt/sendcoinsdialog.h
index 872e4eba2b..4e861e55bb 100644
--- a/src/qt/sendcoinsdialog.h
+++ b/src/qt/sendcoinsdialog.h
@@ -123,18 +123,12 @@ Q_SIGNALS:
 
 
 #define SEND_CONFIRM_DELAY   3
-#define ADDRESS_REUSE_OVERRIDE_DELAY   10
 
 class SendConfirmationDialog : public QMessageBox
 {
     Q_OBJECT
 
 public:
-    bool m_delete_on_close{false};
-    QString confirmButtonText{tr("Send")};
-    QMessageBox::StandardButton m_yes_button{QMessageBox::Yes};
-    QMessageBox::StandardButton m_cancel_button{QMessageBox::Cancel};
-
     SendConfirmationDialog(const QString& title, const QString& text, const QString& informative_text = "", const QString& detailed_text = "", int secDelay = SEND_CONFIRM_DELAY, bool enable_send = true, bool always_show_unsigned = true, QWidget* parent = nullptr);
     /* Returns QMessageBox::Cancel, QMessageBox::Yes when "Send" is
        clicked and QMessageBox::Save when "Create Unsigned" is clicked. */
@@ -149,7 +143,7 @@ private:
     QAbstractButton *m_psbt_button;
     QTimer countDownTimer;
     int secDelay;
-    bool m_enable_save;
+    QString confirmButtonText{tr("Send")};
     bool m_enable_send;
     QString m_psbt_button_text{tr("Create Unsigned")};
 };
diff --git a/src/qt/sendcoinsentry.cpp b/src/qt/sendcoinsentry.cpp
index a310f02765..d8102c1dca 100644
--- a/src/qt/sendcoinsentry.cpp
+++ b/src/qt/sendcoinsentry.cpp
@@ -71,12 +71,6 @@ void SendCoinsEntry::setModel(WalletModel *_model)
 {
     this->model = _model;
 
-    if (_model) {
-        ui->payTo->setWarningValidator(new BitcoinAddressUnusedInWalletValidator(*_model));
-    } else {
-        ui->payTo->setWarningValidator(nullptr);
-    }
-
     if (_model && _model->getOptionsModel())
         connect(_model->getOptionsModel(), &OptionsModel::displayUnitChanged, this, &SendCoinsEntry::updateDisplayUnit);
 
@@ -150,11 +144,6 @@ bool SendCoinsEntry::validate(interfaces::Node& node)
     return retval;
 }
 
-bool SendCoinsEntry::hasPaytoWarning() const
-{
-    return ui->payTo->hasWarning();
-}
-
 SendCoinsRecipient SendCoinsEntry::getValue()
 {
     recipient.address = ui->payTo->text();
diff --git a/src/qt/sendcoinsentry.h b/src/qt/sendcoinsentry.h
index ccb7d956a9..0edc0d1203 100644
--- a/src/qt/sendcoinsentry.h
+++ b/src/qt/sendcoinsentry.h
@@ -33,7 +33,6 @@ public:
 
     void setModel(WalletModel *model);
     bool validate(interfaces::Node& node);
-    bool hasPaytoWarning() const;
     SendCoinsRecipient getValue();
 
     /** Return whether the entry is still empty and unedited */
diff --git a/src/qt/signverifymessagedialog.cpp b/src/qt/signverifymessagedialog.cpp
index e98763c00e..012186ee4d 100644
--- a/src/qt/signverifymessagedialog.cpp
+++ b/src/qt/signverifymessagedialog.cpp
@@ -120,10 +120,12 @@ void SignVerifyMessageDialog::on_signMessageButton_SM_clicked()
         ui->statusLabel_SM->setText(tr("The entered address is invalid.") + QString(" ") + tr("Please check the address and try again."));
         return;
     }
-    MessageSignatureFormat sig_format{MessageSignatureFormat::LEGACY};
     const PKHash* pkhash = std::get_if<PKHash>(&destination);
     if (!pkhash) {
-        sig_format = MessageSignatureFormat::SIMPLE;
+        ui->addressIn_SM->setValid(false);
+        ui->statusLabel_SM->setStyleSheet("QLabel { color: red; }");
+        ui->statusLabel_SM->setText(tr("The entered address does not refer to a legacy (P2PKH) key. Message signing for SegWit and other non-P2PKH address types is not supported in this version of %1. Please check the address and try again.").arg(PACKAGE_NAME));
+        return;
     }
 
     WalletModel::UnlockContext ctx(model->requestUnlock());
@@ -136,7 +138,7 @@ void SignVerifyMessageDialog::on_signMessageButton_SM_clicked()
 
     const std::string& message = ui->messageIn_SM->document()->toPlainText().toStdString();
     std::string signature;
-    SigningResult res = model->wallet().signMessage(sig_format, message, destination, signature);
+    SigningResult res = model->wallet().signMessage(message, *pkhash, signature);
 
     QString error;
     switch (res) {
@@ -212,12 +214,6 @@ void SignVerifyMessageDialog::on_verifyMessageButton_VM_clicked()
             QString("<nobr>") + tr("Message verified.") + QString("</nobr>")
         );
         return;
-    case MessageVerificationResult::INCONCLUSIVE:
-    case MessageVerificationResult::ERR_POF:
-        ui->statusLabel_VM->setText(
-            QString("<nobr>") + tr("This version of %1 is unable to check this signature.").arg(PACKAGE_NAME) + QString("</nobr>")
-        );
-        return;
     case MessageVerificationResult::ERR_INVALID_ADDRESS:
         ui->statusLabel_VM->setText(
             tr("The entered address is invalid.") + QString(" ") +
@@ -225,6 +221,9 @@ void SignVerifyMessageDialog::on_verifyMessageButton_VM_clicked()
         );
         return;
     case MessageVerificationResult::ERR_ADDRESS_NO_KEY:
+        ui->addressIn_VM->setValid(false);
+        ui->statusLabel_VM->setText(tr("The entered address does not refer to a legacy (P2PKH) key. Message signing for SegWit and other non-P2PKH address types is not supported in this version of %1. Please check the address and try again.").arg(PACKAGE_NAME));
+        return;
     case MessageVerificationResult::ERR_MALFORMED_SIGNATURE:
         ui->signatureIn_VM->setValid(false);
         ui->statusLabel_VM->setText(
@@ -239,7 +238,6 @@ void SignVerifyMessageDialog::on_verifyMessageButton_VM_clicked()
             tr("Please check the signature and try again.")
         );
         return;
-    case MessageVerificationResult::ERR_INVALID:
     case MessageVerificationResult::ERR_NOT_SIGNED:
         ui->statusLabel_VM->setText(
             QString("<nobr>") + tr("Message verification failed.") + QString("</nobr>")
diff --git a/src/qt/test/addressbooktests.cpp b/src/qt/test/addressbooktests.cpp
index 832b5520f9..f7d66f316e 100644
--- a/src/qt/test/addressbooktests.cpp
+++ b/src/qt/test/addressbooktests.cpp
@@ -130,7 +130,7 @@ void TestAddAddressesToSendBook(interfaces::Node& node)
     OptionsModel optionsModel(node);
     bilingual_str error;
     QVERIFY(optionsModel.Init(error));
-    ClientModel clientModel(node, &optionsModel, *platformStyle);
+    ClientModel clientModel(node, &optionsModel);
     WalletContext& context = *node.walletLoader().context();
     AddWallet(context, wallet);
     WalletModel walletModel(interfaces::MakeWallet(context, wallet), clientModel, platformStyle.get());
diff --git a/src/qt/test/apptests.cpp b/src/qt/test/apptests.cpp
index d176ea5ae9..10abcb00eb 100644
--- a/src/qt/test/apptests.cpp
+++ b/src/qt/test/apptests.cpp
@@ -5,7 +5,6 @@
 #include <qt/test/apptests.h>
 
 #include <chainparams.h>
-#include <common/args.h>
 #include <key.h>
 #include <logging.h>
 #include <qt/bitcoin.h>
@@ -67,14 +66,6 @@ void AppTests::appTests()
     }
 #endif
 
-    {
-        // Need to ensure datadir is setup so resetting settings can delete the non-existent bitcoin_rw.conf
-        std::string error;
-        if (!gArgs.ReadConfigFiles(error, true)) {
-            QWARN("Error in readConfigFiles");
-        }
-    }
-
     qRegisterMetaType<interfaces::BlockAndHeaderTipInfo>("interfaces::BlockAndHeaderTipInfo");
     m_app.parameterSetup();
     QVERIFY(m_app.createOptionsModel(/*resetSettings=*/true));
diff --git a/src/qt/test/uritests.cpp b/src/qt/test/uritests.cpp
index 5a93871779..935f078e3d 100644
--- a/src/qt/test/uritests.cpp
+++ b/src/qt/test/uritests.cpp
@@ -46,16 +46,6 @@ void URITests::uriTests()
     QVERIFY(rv.amount == 10000000000LL);
     QVERIFY(rv.label == QString("Wikipedia Example"));
 
-    uri.setUrl(QString("bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?amount=x100x4"));
-    QVERIFY(GUIUtil::parseBitcoinURI(uri, &rv));
-    QVERIFY(rv.address == QString("175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W"));
-    QVERIFY(rv.amount == 16777216LL);
-
-    uri.setUrl(QString("bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?amount=100x2"));
-    QVERIFY(GUIUtil::parseBitcoinURI(uri, &rv));
-    QVERIFY(rv.address == QString("175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W"));
-    QVERIFY(rv.amount == 10000LL);
-
     uri.setUrl(QString("bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?message=Wikipedia Example Address"));
     QVERIFY(GUIUtil::parseBitcoinURI(uri, &rv));
     QVERIFY(rv.address == QString("175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W"));
@@ -72,9 +62,6 @@ void URITests::uriTests()
     uri.setUrl(QString("bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?amount=1,000&label=Wikipedia Example"));
     QVERIFY(!GUIUtil::parseBitcoinURI(uri, &rv));
 
-    uri.setUrl(QString("bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?amount=x1,0000&label=Wikipedia Example"));
-    QVERIFY(!GUIUtil::parseBitcoinURI(uri, &rv));
-
     uri.setUrl(QString("bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?amount=1,000.0&label=Wikipedia Example"));
     QVERIFY(!GUIUtil::parseBitcoinURI(uri, &rv));
 
diff --git a/src/qt/test/wallettests.cpp b/src/qt/test/wallettests.cpp
index be36eea2e0..603df0b15f 100644
--- a/src/qt/test/wallettests.cpp
+++ b/src/qt/test/wallettests.cpp
@@ -58,46 +58,19 @@ using wallet::WalletRescanReserver;
 
 namespace
 {
-void ConfirmSendAttempt(QString* text, QMessageBox::StandardButton confirm_type)
+//! Press "Yes" or "Cancel" buttons in modal send confirmation dialog.
+void ConfirmSend(QString* text = nullptr, QMessageBox::StandardButton confirm_type = QMessageBox::Yes)
 {
+    QTimer::singleShot(0, [text, confirm_type]() {
         for (QWidget* widget : QApplication::topLevelWidgets()) {
             if (widget->inherits("SendConfirmationDialog")) {
                 SendConfirmationDialog* dialog = qobject_cast<SendConfirmationDialog*>(widget);
                 if (text) *text = dialog->text();
                 QAbstractButton* button = dialog->button(confirm_type);
-                const QMessageBox::ButtonRole confirm_role = [confirm_type, button](){
-                    if (button) return QMessageBox::InvalidRole;
-                    switch (confirm_type) {
-                        case QMessageBox::Yes: return QMessageBox::YesRole;
-                        case QMessageBox::Cancel: return QMessageBox::NoRole;
-                        default: return QMessageBox::InvalidRole;
-                    }
-                }();
-                for (QAbstractButton* maybe_button : dialog->buttons()) {
-                    if (dialog->buttonRole(maybe_button) == confirm_role) {
-                        button = maybe_button;
-                    } else if (maybe_button->text().startsWith("Override")) {
-                        button = maybe_button;
-                        break;
-                    }
-                }
                 button->setEnabled(true);
                 button->click();
-                if (!button->text().startsWith("Override")) return;
             }
         }
-
-    // Try again
-    QTimer::singleShot(0, [text, confirm_type]{
-        ConfirmSendAttempt(text, confirm_type);
-    });
-}
-
-//! Press "Yes" or "Cancel" buttons in modal send confirmation dialog.
-void ConfirmSend(QString* text = nullptr, QMessageBox::StandardButton confirm_type = QMessageBox::Yes)
-{
-    QTimer::singleShot(0, [text, confirm_type]{
-        ConfirmSendAttempt(text, confirm_type);
     });
 }
 
@@ -268,7 +241,7 @@ public:
     MiniGUI(interfaces::Node& node, const PlatformStyle* platformStyle) : sendCoinsDialog(platformStyle), transactionView(platformStyle), optionsModel(node) {
         bilingual_str error;
         QVERIFY(optionsModel.Init(error));
-        clientModel = std::make_unique<ClientModel>(node, &optionsModel, *platformStyle);
+        clientModel = std::make_unique<ClientModel>(node, &optionsModel);
     }
 
     void initModelForWallet(interfaces::Node& node, const std::shared_ptr<CWallet>& wallet, const PlatformStyle* platformStyle)
diff --git a/src/qt/tonalutils.cpp b/src/qt/tonalutils.cpp
deleted file mode 100644
index 48bb87cddf..0000000000
--- a/src/qt/tonalutils.cpp
+++ /dev/null
@@ -1,83 +0,0 @@
-// Copyright (c) 2016 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#include <qt/tonalutils.h>
-
-#include <QFont>
-#include <QFontMetrics>
-#include <QRegExp>
-#include <QRegExpValidator>
-#include <QString>
-
-static const QList<QChar> tonal_digits{0xe8ef, 0xe8ee, 0xe8ed, 0xe8ec, 0xe8eb, 0xe8ea, 0xe8e9, '8', '7', '6', '5', '4', '3', '2', '1', '0'};
-
-namespace {
-
-bool font_supports_tonal(const QFont& font)
-{
-    const QFontMetrics fm(font);
-    QString s = "000";
-    const QSize sz = fm.size(0, s);
-    for (const auto& c : tonal_digits) {
-        if (!fm.inFont(c)) return false;
-        s[0] = s[1] = s[2] = c;
-        if (sz != fm.size(0, s)) return false;
-    }
-    return true;
-}
-
-} // anon namespace
-
-bool TonalUtils::Supported()
-{
-    QFont default_font;
-    if (font_supports_tonal(default_font)) return true;
-    // FIXME: This will fail if the default font has some non-Tonal glyphs but a fallback supports Tonal
-    // TODO: Check other fonts and ensure their usage when appropriate
-    return false;
-}
-
-#define RE_TONAL_DIGIT "[\\d\\xe8e0-\\xe8ef\\xe9d0-\\xe9df]"
-static QRegExpValidator tv(QRegExp("-?(?:" RE_TONAL_DIGIT "+\\.?|" RE_TONAL_DIGIT "*\\." RE_TONAL_DIGIT "+)"), nullptr);
-
-QValidator::State TonalUtils::validate(QString&input, int&pos)
-{
-    return tv.validate(input, pos);
-}
-
-void TonalUtils::ConvertFromHex(QString&str)
-{
-    for (int i = 0; i < str.size(); ++i)
-    {
-        ushort c = str[i].unicode();
-        if (c == '9')
-            str[i] = 0xe8e9;
-        else
-        if (c >= 'A' && c <= 'F')
-            str[i] = c + (0xe8ea - 'A');
-        else
-        if (c >= 'a' && c <= 'f')
-            str[i] = c + (0xe8ea - 'a');
-    }
-}
-
-void TonalUtils::ConvertToHex(QString&str)
-{
-    for (int i = 0; i < str.size(); ++i)
-    {
-        ushort c = str[i].unicode();
-        if (c == '9')
-            str[i] = 'a';
-        else
-        if (c >= 0xe8e0 && c <= 0xe8e9) {  // UCSUR 0-9
-            str[i] = c - (0xe8e0 - '0');
-        } else if (c >= 0xe8ea && c <= 0xe8ef) {  // UCSUR a-f
-            str[i] = c - (0xe8ea - 'a');
-        } else if (c >= 0xe9d0 && c <= 0xe9d9) {
-            str[i] = c - (0xe9d0 - '0');
-        } else
-        if (c >= 0xe9da && c <= 0xe9df)
-            str[i] = c - 0xe999;
-    }
-}
diff --git a/src/qt/tonalutils.h b/src/qt/tonalutils.h
deleted file mode 100644
index eb6786b765..0000000000
--- a/src/qt/tonalutils.h
+++ /dev/null
@@ -1,25 +0,0 @@
-// Copyright (c) 2016 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#ifndef BITCOIN_QT_TONALUTILS_H
-#define BITCOIN_QT_TONALUTILS_H
-
-#include <QValidator>
-
-QT_BEGIN_NAMESPACE
-class QString;
-QT_END_NAMESPACE
-
-class TonalUtils
-{
-public:
-    static bool Supported();
-
-    static QValidator::State validate(QString&input, int&pos);
-
-    static void ConvertFromHex(QString&);
-    static void ConvertToHex(QString&);
-};
-
-#endif // BITCOIN_QT_TONALUTILS_H
diff --git a/src/qt/trafficgraphwidget.cpp b/src/qt/trafficgraphwidget.cpp
index 8a52baebb3..fb6f2cb464 100644
--- a/src/qt/trafficgraphwidget.cpp
+++ b/src/qt/trafficgraphwidget.cpp
@@ -5,14 +5,11 @@
 #include <interfaces/node.h>
 #include <qt/trafficgraphwidget.h>
 #include <qt/clientmodel.h>
-#include <qt/guiutil.h>
 
-#include <QMouseEvent>
 #include <QPainter>
 #include <QPainterPath>
 #include <QColor>
 #include <QTimer>
-#include <QToolTip>
 
 #include <chrono>
 #include <cmath>
@@ -28,12 +25,7 @@ TrafficGraphWidget::TrafficGraphWidget(QWidget* parent)
       vSamplesOut()
 {
     timer = new QTimer(this);
-    tt_timer = new QTimer(this);
     connect(timer, &QTimer::timeout, this, &TrafficGraphWidget::updateRates);
-    connect(tt_timer, &QTimer::timeout, this, &TrafficGraphWidget::updateToolTip);
-    tt_timer->setInterval(500);
-    tt_timer->start();
-    setMouseTracking(true);
 }
 
 void TrafficGraphWidget::setClientModel(ClientModel *model)
@@ -47,12 +39,6 @@ void TrafficGraphWidget::setClientModel(ClientModel *model)
 
 std::chrono::minutes TrafficGraphWidget::getGraphRange() const { return m_range; }
 
-int TrafficGraphWidget::y_value(float value)
-{
-    int h = height() - YMARGIN * 2;
-    return YMARGIN + h - (h * 1.0 * (fToggle ? (pow(value, 0.30102) / pow(fMax, 0.30102)) : (value / fMax)));
-}
-
 void TrafficGraphWidget::paintPath(QPainterPath &path, QQueue<float> &samples)
 {
     int sampleCount = samples.size();
@@ -62,58 +48,13 @@ void TrafficGraphWidget::paintPath(QPainterPath &path, QQueue<float> &samples)
         path.moveTo(x, YMARGIN + h);
         for(int i = 0; i < sampleCount; ++i) {
             x = XMARGIN + w - w * i / DESIRED_SAMPLES;
-            int y = y_value(samples.at(i));
+            int y = YMARGIN + h - (int)(h * samples.at(i) / fMax);
             path.lineTo(x, y);
         }
         path.lineTo(x, YMARGIN + h);
     }
 }
 
-void TrafficGraphWidget::mousePressEvent(QMouseEvent *event)
-{
-    QWidget::mousePressEvent(event);
-    fToggle = !fToggle;
-    update();
-}
-
-float floatmax(float a, float b)
-{
-    if (a > b) return a;
-    else return b;
-}
-
-void TrafficGraphWidget::mouseMoveEvent(QMouseEvent *event)
-{
-    QWidget::mouseMoveEvent(event);
-    static int last_x = -1;
-    static int last_y = -1;
-    int x = event->x();
-    int y = event->y();
-    x_offset = event->globalX() - x;
-    y_offset = event->globalY() - y;
-    if (last_x == x && last_y == y) return; // Do nothing if mouse hasn't moved
-    int h = height() - YMARGIN * 2, w = width() - XMARGIN * 2;
-    int i = (w + XMARGIN - x) * DESIRED_SAMPLES / w;
-    unsigned int smallest_distance = 50; int closest_i = -1;
-    int sampleSize = vTimeStamp.size();
-    if (sampleSize && i >= -10 && i < sampleSize + 2 && y <= h + YMARGIN + 3) {
-        for (int test_i = std::max(i - 2, 0); test_i < std::min(i + 10, sampleSize); test_i++) {
-            float val = floatmax(vSamplesIn.at(test_i), vSamplesOut.at(test_i));
-            int y_data = y_value(val);
-            unsigned int distance = abs(y - y_data);
-            if (distance < smallest_distance) {
-                smallest_distance = distance;
-                closest_i = test_i;
-            }
-        }
-    }
-    if (ttpoint != closest_i) {
-        ttpoint = closest_i;
-        update(); // Calls paintEvent() to draw or delete the highlighted point
-    }
-    last_x = x; last_y = y;
-}
-
 void TrafficGraphWidget::paintEvent(QPaintEvent *)
 {
     QPainter painter(this);
@@ -133,33 +74,28 @@ void TrafficGraphWidget::paintEvent(QPaintEvent *)
     const QString units = tr("kB/s");
     const float yMarginText = 2.0;
 
-    // if we drew 10 or 3 fewer lines, break them up at the next lower order of magnitude
-    if(fMax / val <= (fToggle ? 10.0f : 3.0f)) {
-        float oldval = val;
+    // draw lines
+    painter.setPen(axisCol);
+    painter.drawText(XMARGIN, YMARGIN + h - h * val / fMax-yMarginText, QString("%1 %2").arg(val).arg(units));
+    for(float y = val; y < fMax; y += val) {
+        int yy = YMARGIN + h - h * y / fMax;
+        painter.drawLine(XMARGIN, yy, width() - XMARGIN, yy);
+    }
+    // if we drew 3 or fewer lines, break them up at the next lower order of magnitude
+    if(fMax / val <= 3.0f) {
+        axisCol = axisCol.darker();
         val = pow(10.0f, base - 1);
-        painter.setPen(axisCol.darker());
-        painter.drawText(XMARGIN, y_value(val)-yMarginText, QString("%1 %2").arg(val).arg(units));
-        if (fToggle) {
-            int yy = y_value(val*0.1);
-            painter.drawText(XMARGIN, yy-yMarginText, QString("%1 %2").arg(val*0.1).arg(units));
-            painter.drawLine(XMARGIN, yy, width() - XMARGIN, yy);
-        }
+        painter.setPen(axisCol);
+        painter.drawText(XMARGIN, YMARGIN + h - h * val / fMax-yMarginText, QString("%1 %2").arg(val).arg(units));
         int count = 1;
-        for(float y = val; y < (!fToggle || fMax / val < 20 ? fMax : oldval); y += val, count++) {
+        for(float y = val; y < fMax; y += val, count++) {
+            // don't overwrite lines drawn above
             if(count % 10 == 0)
                 continue;
-            int yy = y_value(y);
+            int yy = YMARGIN + h - h * y / fMax;
             painter.drawLine(XMARGIN, yy, width() - XMARGIN, yy);
         }
-        val = oldval;
     }
-    // draw lines
-    painter.setPen(axisCol);
-    for(float y = val; y < fMax; y += val) {
-        int yy = y_value(y);
-        painter.drawLine(XMARGIN, yy, width() - XMARGIN, yy);
-    }
-    painter.drawText(XMARGIN, y_value(val)-yMarginText, QString("%1 %2").arg(val).arg(units));
 
     painter.setRenderHint(QPainter::Antialiasing);
     if(!vSamplesIn.empty()) {
@@ -176,63 +112,18 @@ void TrafficGraphWidget::paintEvent(QPaintEvent *)
         painter.setPen(Qt::red);
         painter.drawPath(p);
     }
-    int sampleCount = vTimeStamp.size();
-    if (ttpoint >= 0 && ttpoint < sampleCount) {
-        painter.setPen(Qt::yellow);
-        int w = width() - XMARGIN * 2;
-        int x = XMARGIN + w - w * ttpoint / DESIRED_SAMPLES;
-        int y = y_value(floatmax(vSamplesIn.at(ttpoint), vSamplesOut.at(ttpoint)));
-        painter.drawEllipse(QPointF(x, y), 3, 3);
-        QString strTime;
-        int64_t sampleTime = vTimeStamp.at(ttpoint);
-        int age = GetTime() - sampleTime/1000;
-        if (age < 60*60*23)
-            strTime = QString::fromStdString(FormatISO8601Time(sampleTime/1000));
-        else
-            strTime = QString::fromStdString(FormatISO8601DateTime(sampleTime/1000));
-        int milliseconds_between_samples = 1000;
-        if (ttpoint > 0)
-            milliseconds_between_samples = std::min(milliseconds_between_samples, int(vTimeStamp.at(ttpoint-1) - sampleTime));
-        if (ttpoint + 1 < sampleCount)
-            milliseconds_between_samples = std::min(milliseconds_between_samples, int(sampleTime - vTimeStamp.at(ttpoint+1)));
-        if (milliseconds_between_samples < 1000)
-            strTime += QString::fromStdString(strprintf(".%03d", (sampleTime%1000)));
-        QString strData = tr("In") + " " + GUIUtil::formatBytesps(vSamplesIn.at(ttpoint)*1000) + "\n" + tr("Out") + " " + GUIUtil::formatBytesps(vSamplesOut.at(ttpoint)*1000);
-        // Line below allows ToolTip to move faster than once every 10 seconds.
-        QToolTip::showText(QPoint(x + x_offset, y + y_offset), strTime + "\n. " + strData);
-        QToolTip::showText(QPoint(x + x_offset, y + y_offset), strTime + "\n  " + strData);
-        tt_time = GetTime();
-    } else
-        QToolTip::hideText();
-}
-
-void TrafficGraphWidget::updateToolTip()
-{
-    if (!QToolTip::isVisible()) {
-        if (ttpoint >= 0) { // Remove the yellow circle if the ToolTip has gone due to mouse moving elsewhere.
-            ttpoint = -1;
-            update();
-        }
-    } else if (GetTime() >= tt_time + 9) { // ToolTip is about to expire so refresh it.
-        update();
-    }
 }
 
 void TrafficGraphWidget::updateRates()
 {
     if(!clientModel) return;
 
-    int64_t nTime = TicksSinceEpoch<std::chrono::milliseconds>(SystemClock::now());
-    static int64_t nLastTime = nTime - timer->interval();
-    int nRealInterval = nTime - nLastTime;
     quint64 bytesIn = clientModel->node().getTotalBytesRecv(),
             bytesOut = clientModel->node().getTotalBytesSent();
-    float in_rate_kilobytes_per_sec = static_cast<float>(bytesIn - nLastBytesIn) / nRealInterval;
-    float out_rate_kilobytes_per_sec = static_cast<float>(bytesOut - nLastBytesOut) / nRealInterval;
+    float in_rate_kilobytes_per_sec = static_cast<float>(bytesIn - nLastBytesIn) / timer->interval();
+    float out_rate_kilobytes_per_sec = static_cast<float>(bytesOut - nLastBytesOut) / timer->interval();
     vSamplesIn.push_front(in_rate_kilobytes_per_sec);
     vSamplesOut.push_front(out_rate_kilobytes_per_sec);
-    vTimeStamp.push_front(nLastTime);
-    nLastTime = nTime;
     nLastBytesIn = bytesIn;
     nLastBytesOut = bytesOut;
 
@@ -242,9 +133,6 @@ void TrafficGraphWidget::updateRates()
     while(vSamplesOut.size() > DESIRED_SAMPLES) {
         vSamplesOut.pop_back();
     }
-    while(vTimeStamp.size() > DESIRED_SAMPLES) {
-        vTimeStamp.pop_back();
-    }
 
     float tmax = 0.0f;
     for (const float f : vSamplesIn) {
@@ -254,7 +142,6 @@ void TrafficGraphWidget::updateRates()
         if(f > tmax) tmax = f;
     }
     fMax = tmax;
-    if (ttpoint >=0 && ttpoint < vTimeStamp.size()) ttpoint++; // Move the selected point to the left
     update();
 }
 
@@ -274,7 +161,6 @@ void TrafficGraphWidget::clear()
 
     vSamplesOut.clear();
     vSamplesIn.clear();
-    vTimeStamp.clear();
     fMax = 0.0f;
 
     if(clientModel) {
diff --git a/src/qt/trafficgraphwidget.h b/src/qt/trafficgraphwidget.h
index ab4eb3f259..5e5557ec82 100644
--- a/src/qt/trafficgraphwidget.h
+++ b/src/qt/trafficgraphwidget.h
@@ -28,18 +28,9 @@ public:
 
 protected:
     void paintEvent(QPaintEvent *) override;
-    int y_value(float value);
-    void mousePressEvent(QMouseEvent *event) override;
-    bool fToggle = true;
-    void mouseMoveEvent(QMouseEvent *event) override;
-    int ttpoint = -1;
-    int x_offset = 0;
-    int y_offset = 0;
-    int64_t tt_time = 0;
 
 public Q_SLOTS:
     void updateRates();
-    void updateToolTip();
     void setGraphRange(std::chrono::minutes new_range);
     void clear();
 
@@ -47,12 +38,10 @@ private:
     void paintPath(QPainterPath &path, QQueue<float> &samples);
 
     QTimer* timer{nullptr};
-    QTimer* tt_timer{nullptr};
     float fMax{0.0f};
     std::chrono::minutes m_range{0};
     QQueue<float> vSamplesIn;
     QQueue<float> vSamplesOut;
-    QQueue<int64_t> vTimeStamp;
     quint64 nLastBytesIn{0};
     quint64 nLastBytesOut{0};
     ClientModel* clientModel{nullptr};
diff --git a/src/qt/transactiondesc.cpp b/src/qt/transactiondesc.cpp
index a439acd6d6..b848b8fe94 100644
--- a/src/qt/transactiondesc.cpp
+++ b/src/qt/transactiondesc.cpp
@@ -58,7 +58,7 @@ QString TransactionDesc::FormatTxStatus(const interfaces::WalletTxStatus& status
             s += QLatin1String(", ") + tr("abandoned");
         }
         return s;
-    } else if (depth < TransactionRecord::RecommendedNumConfirmations || status.is_assumed) {
+    } else if (depth < 6) {
         /*: Text explaining the current status of a transaction, shown in the
             status field of the details window for this transaction. This
             status represents a transaction confirmed in at least one block,
diff --git a/src/qt/transactionrecord.cpp b/src/qt/transactionrecord.cpp
index 9332a9b92e..8a2ec4cd59 100644
--- a/src/qt/transactionrecord.cpp
+++ b/src/qt/transactionrecord.cpp
@@ -204,8 +204,6 @@ void TransactionRecord::updateStatus(const interfaces::WalletTxStatus& wtx, cons
             status.status = TransactionStatus::Unconfirmed;
             if (wtx.is_abandoned)
                 status.status = TransactionStatus::Abandoned;
-        } else if (wtx.is_assumed) {
-            status.status = TransactionStatus::AssumedConfirmed;
         }
         else if (status.depth < RecommendedNumConfirmations)
         {
diff --git a/src/qt/transactionrecord.h b/src/qt/transactionrecord.h
index 84683bfdab..21b1bc0e01 100644
--- a/src/qt/transactionrecord.h
+++ b/src/qt/transactionrecord.h
@@ -25,7 +25,6 @@ struct TransactionStatus {
         Confirmed,          /**< Have 6 or more confirmations (normal tx) or fully mature (mined tx) **/
         /// Normal (sent/received) transactions
         Unconfirmed,        /**< Not yet mined into a block **/
-        AssumedConfirmed,   /**< Confirmed, but background validation hasn't finished  */
         Confirming,         /**< Confirmed, but waiting for the recommended number of confirmations **/
         Conflicted,         /**< Conflicts with other transaction or mempool **/
         Abandoned,          /**< Abandoned from the wallet **/
@@ -73,7 +72,7 @@ public:
     };
 
     /** Number of confirmation recommended for accepting a transaction */
-    static const int RecommendedNumConfirmations = 16;
+    static const int RecommendedNumConfirmations = 6;
 
     TransactionRecord():
             hash(), time(0), type(Other), debit(0), credit(0), idx(0)
diff --git a/src/qt/transactiontablemodel.cpp b/src/qt/transactiontablemodel.cpp
index a71acf49a6..9214e7723d 100644
--- a/src/qt/transactiontablemodel.cpp
+++ b/src/qt/transactiontablemodel.cpp
@@ -320,9 +320,6 @@ QString TransactionTableModel::formatTxStatus(const TransactionRecord *wtx) cons
     case TransactionStatus::Abandoned:
         status = tr("Abandoned");
         break;
-    case TransactionStatus::AssumedConfirmed:
-        status = tr("Unconfirmed (%1 confirmations pending verification of historical blocks)").arg(wtx->status.depth);
-        break;
     case TransactionStatus::Confirming:
         status = tr("Confirming (%1 of %2 recommended confirmations)").arg(wtx->status.depth).arg(TransactionRecord::RecommendedNumConfirmations);
         break;
@@ -363,7 +360,7 @@ QString TransactionTableModel::lookupAddress(const std::string &address, bool to
     {
         description += label;
     }
-    if(label.isEmpty() || walletModel->getOptionsModel()->getDisplayAddresses() || tooltip)
+    if(label.isEmpty() || tooltip)
     {
         description += QString(" (") + QString::fromStdString(address) + QString(")");
     }
@@ -465,12 +462,11 @@ QVariant TransactionTableModel::txStatusDecoration(const TransactionRecord *wtx)
     switch(wtx->status.status)
     {
     case TransactionStatus::Unconfirmed:
-    case TransactionStatus::AssumedConfirmed:
         return QIcon(":/icons/transaction_0");
     case TransactionStatus::Abandoned:
         return QIcon(":/icons/transaction_abandoned");
     case TransactionStatus::Confirming:
-        switch (wtx->status.depth * 6 / TransactionRecord::RecommendedNumConfirmations)
+        switch(wtx->status.depth)
         {
         case 1: return QIcon(":/icons/transaction_1");
         case 2: return QIcon(":/icons/transaction_2");
diff --git a/src/qt/transactionview.cpp b/src/qt/transactionview.cpp
index 2341a19c6e..2aaa65c6f7 100644
--- a/src/qt/transactionview.cpp
+++ b/src/qt/transactionview.cpp
@@ -146,6 +146,22 @@ TransactionView::TransactionView(const PlatformStyle *platformStyle, QWidget *pa
     transactionView->setTabKeyNavigation(false);
     transactionView->setContextMenuPolicy(Qt::CustomContextMenu);
     transactionView->installEventFilter(this);
+    transactionView->setAlternatingRowColors(true);
+    transactionView->setSelectionBehavior(QAbstractItemView::SelectRows);
+    transactionView->setSelectionMode(QAbstractItemView::ExtendedSelection);
+    transactionView->setSortingEnabled(true);
+    transactionView->verticalHeader()->hide();
+
+    QSettings settings;
+    if (!transactionView->horizontalHeader()->restoreState(settings.value("TransactionViewHeaderState").toByteArray())) {
+        transactionView->setColumnWidth(TransactionTableModel::Status, STATUS_COLUMN_WIDTH);
+        transactionView->setColumnWidth(TransactionTableModel::Watchonly, WATCHONLY_COLUMN_WIDTH);
+        transactionView->setColumnWidth(TransactionTableModel::Date, DATE_COLUMN_WIDTH);
+        transactionView->setColumnWidth(TransactionTableModel::Type, TYPE_COLUMN_WIDTH);
+        transactionView->setColumnWidth(TransactionTableModel::Amount, AMOUNT_MINIMUM_COLUMN_WIDTH);
+        transactionView->horizontalHeader()->setMinimumSectionSize(MINIMUM_COLUMN_WIDTH);
+        transactionView->horizontalHeader()->setStretchLastSection(true);
+    }
 
     contextMenu = new QMenu(this);
     contextMenu->setObjectName("contextMenu");
@@ -199,26 +215,8 @@ void TransactionView::setModel(WalletModel *_model)
         transactionProxyModel->setSortCaseSensitivity(Qt::CaseInsensitive);
         transactionProxyModel->setFilterCaseSensitivity(Qt::CaseInsensitive);
         transactionProxyModel->setSortRole(Qt::EditRole);
-        transactionView->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
         transactionView->setModel(transactionProxyModel);
-
-        transactionView->setAlternatingRowColors(true);
-        transactionView->setSelectionBehavior(QAbstractItemView::SelectRows);
-        transactionView->setSelectionMode(QAbstractItemView::ExtendedSelection);
-        transactionView->horizontalHeader()->setSortIndicator(TransactionTableModel::Date, Qt::DescendingOrder);
-        transactionView->setSortingEnabled(true);
-        transactionView->verticalHeader()->hide();
-
-        columnResizingFixer = new GUIUtil::TableViewLastColumnResizingFixer(transactionView, AMOUNT_MINIMUM_COLUMN_WIDTH, MINIMUM_COLUMN_WIDTH, this);
-
-        QSettings settings;
-        if (!transactionView->horizontalHeader()->restoreState(settings.value("TransactionViewHeaderState").toByteArray())) {
-            transactionView->setColumnWidth(TransactionTableModel::Status, STATUS_COLUMN_WIDTH);
-            transactionView->setColumnWidth(TransactionTableModel::Watchonly, WATCHONLY_COLUMN_WIDTH);
-            transactionView->setColumnWidth(TransactionTableModel::Date, DATE_COLUMN_WIDTH);
-            transactionView->setColumnWidth(TransactionTableModel::Type, TYPE_COLUMN_WIDTH);
-            transactionView->setColumnWidth(TransactionTableModel::Amount, AMOUNT_MINIMUM_COLUMN_WIDTH);
-        }
+        transactionView->sortByColumn(TransactionTableModel::Date, Qt::DescendingOrder);
 
         if (_model->getOptionsModel())
         {
@@ -630,14 +628,6 @@ void TransactionView::focusTransaction(const uint256& txid)
     }
 }
 
-// We override the virtual resizeEvent of the QWidget to adjust tables column
-// sizes as the tables width is proportional to the dialogs width.
-void TransactionView::resizeEvent(QResizeEvent* event)
-{
-    QWidget::resizeEvent(event);
-    columnResizingFixer->stretchColumnWidth(TransactionTableModel::ToAddress);
-}
-
 // Need to override default Ctrl+C action for amount as default behaviour is just to copy DisplayRole text
 bool TransactionView::eventFilter(QObject *obj, QEvent *event)
 {
diff --git a/src/qt/transactionview.h b/src/qt/transactionview.h
index 34cc48c541..29fb722afe 100644
--- a/src/qt/transactionview.h
+++ b/src/qt/transactionview.h
@@ -87,10 +87,6 @@ private:
 
     QWidget *createDateRangeWidget();
 
-    GUIUtil::TableViewLastColumnResizingFixer *columnResizingFixer{nullptr};
-
-    virtual void resizeEvent(QResizeEvent* event) override;
-
     bool eventFilter(QObject *obj, QEvent *event) override;
 
     const PlatformStyle* m_platform_style;
diff --git a/src/qt/utilitydialog.cpp b/src/qt/utilitydialog.cpp
index 9c07211b05..f261c6409d 100644
--- a/src/qt/utilitydialog.cpp
+++ b/src/qt/utilitydialog.cpp
@@ -56,11 +56,8 @@ HelpMessageDialog::HelpMessageDialog(QWidget *parent, bool about) :
         ui->helpMessage->setVisible(false);
     } else {
         setWindowTitle(tr("Command-line options"));
-        QString header = "The bitcoin-qt application provides a graphical interface for interacting with " PACKAGE_NAME ".\n\n"
-                         "It combines the core functionalities of bitcoind with a user-friendly interface for wallet management, transaction history, and network statistics.\n\n"
-                         "It is suitable for users who prefer a graphical over a command-line interface.\n\n"
-                         "You can optionally specify a payment [URI], in e.g. the BIP20 or BIP21 URI formats.\n\n"
-                         "Usage: bitcoin-qt [options] [URI]\n\n";
+        QString header = "Usage: bitcoin-qt [command-line options] [URI]\n\n"
+                         "Optional URI is a Bitcoin address in BIP21 URI format.\n";
         QTextCursor cursor(ui->helpMessage->document());
         cursor.insertText(version);
         cursor.insertBlock();
diff --git a/src/qt/walletcontroller.cpp b/src/qt/walletcontroller.cpp
index b12387e96c..dd093e984a 100644
--- a/src/qt/walletcontroller.cpp
+++ b/src/qt/walletcontroller.cpp
@@ -254,15 +254,14 @@ void CreateWalletActivity::createWallet()
 
     std::string name = m_create_wallet_dialog->walletName().toStdString();
     uint64_t flags = 0;
+    // Enable descriptors by default.
+    flags |= WALLET_FLAG_DESCRIPTORS;
     if (m_create_wallet_dialog->isDisablePrivateKeysChecked()) {
         flags |= WALLET_FLAG_DISABLE_PRIVATE_KEYS;
     }
     if (m_create_wallet_dialog->isMakeBlankWalletChecked()) {
         flags |= WALLET_FLAG_BLANK_WALLET;
     }
-    if (m_create_wallet_dialog->isDescriptorWalletChecked()) {
-        flags |= WALLET_FLAG_DESCRIPTORS;
-    }
     if (m_create_wallet_dialog->isExternalSignerChecked()) {
         flags |= WALLET_FLAG_EXTERNAL_SIGNER;
     }
diff --git a/src/qt/walletframe.cpp b/src/qt/walletframe.cpp
index 406c6e2fd8..7a8a053900 100644
--- a/src/qt/walletframe.cpp
+++ b/src/qt/walletframe.cpp
@@ -2,7 +2,6 @@
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
-#include <qt/pairingpage.h>
 #include <qt/walletframe.h>
 
 #include <node/interface_ui.h>
@@ -36,10 +35,8 @@ WalletFrame::WalletFrame(const PlatformStyle* _platformStyle, QWidget* parent)
     QHBoxLayout *walletFrameLayout = new QHBoxLayout(this);
     setContentsMargins(0,0,0,0);
     walletStack = new QStackedWidget(this);
-    m_global_stack = new QStackedWidget(this);
-    m_global_stack->addWidget(walletStack);
     walletFrameLayout->setContentsMargins(0,0,0,0);
-    walletFrameLayout->addWidget(m_global_stack);
+    walletFrameLayout->addWidget(walletStack);
 
     // hbox for no wallet
     QGroupBox* no_wallet_group = new QGroupBox(walletStack);
@@ -56,9 +53,6 @@ WalletFrame::WalletFrame(const PlatformStyle* _platformStyle, QWidget* parent)
     no_wallet_group->setLayout(no_wallet_layout);
 
     walletStack->addWidget(no_wallet_group);
-
-    m_page_pairing = new PairingPage(this);
-    m_global_stack->addWidget(m_page_pairing);
 }
 
 WalletFrame::~WalletFrame() = default;
@@ -67,8 +61,6 @@ void WalletFrame::setClientModel(ClientModel *_clientModel)
 {
     this->clientModel = _clientModel;
 
-    m_page_pairing->setClientModel(_clientModel);
-
     for (auto i = mapWalletViews.constBegin(); i != mapWalletViews.constEnd(); ++i) {
         i.value()->setClientModel(_clientModel);
     }
@@ -161,12 +153,6 @@ void WalletFrame::gotoOverviewPage()
     QMap<WalletModel*, WalletView*>::const_iterator i;
     for (i = mapWalletViews.constBegin(); i != mapWalletViews.constEnd(); ++i)
         i.value()->gotoOverviewPage();
-    m_global_stack->setCurrentWidget(walletStack);
-}
-
-void WalletFrame::gotoPairingPage()
-{
-    m_global_stack->setCurrentWidget(m_page_pairing);
 }
 
 void WalletFrame::gotoHistoryPage()
@@ -174,7 +160,6 @@ void WalletFrame::gotoHistoryPage()
     QMap<WalletModel*, WalletView*>::const_iterator i;
     for (i = mapWalletViews.constBegin(); i != mapWalletViews.constEnd(); ++i)
         i.value()->gotoHistoryPage();
-    m_global_stack->setCurrentWidget(walletStack);
 }
 
 void WalletFrame::gotoReceiveCoinsPage()
@@ -182,7 +167,6 @@ void WalletFrame::gotoReceiveCoinsPage()
     QMap<WalletModel*, WalletView*>::const_iterator i;
     for (i = mapWalletViews.constBegin(); i != mapWalletViews.constEnd(); ++i)
         i.value()->gotoReceiveCoinsPage();
-    m_global_stack->setCurrentWidget(walletStack);
 }
 
 void WalletFrame::gotoSendCoinsPage(QString addr)
@@ -190,7 +174,6 @@ void WalletFrame::gotoSendCoinsPage(QString addr)
     QMap<WalletModel*, WalletView*>::const_iterator i;
     for (i = mapWalletViews.constBegin(); i != mapWalletViews.constEnd(); ++i)
         i.value()->gotoSendCoinsPage(addr);
-    m_global_stack->setCurrentWidget(walletStack);
 }
 
 void WalletFrame::gotoSignMessageTab(QString addr)
@@ -249,7 +232,7 @@ void WalletFrame::gotoLoadPSBT(bool from_clipboard)
 
     auto dlg = new PSBTOperationsDialog(this, currentWalletModel(), clientModel);
     dlg->openWithPSBT(psbtx);
-    GUIUtil::ShowModalDialogAsynchronously(dlg, Qt::NonModal);
+    GUIUtil::ShowModalDialogAsynchronously(dlg);
 }
 
 void WalletFrame::encryptWallet()
diff --git a/src/qt/walletframe.h b/src/qt/walletframe.h
index 2760714cd4..60c97ff76a 100644
--- a/src/qt/walletframe.h
+++ b/src/qt/walletframe.h
@@ -9,7 +9,6 @@
 #include <QMap>
 
 class ClientModel;
-class PairingPage;
 class PlatformStyle;
 class SendCoinsRecipient;
 class WalletModel;
@@ -53,13 +52,10 @@ Q_SIGNALS:
     void currentWalletSet();
 
 private:
-    QStackedWidget *m_global_stack;
     QStackedWidget *walletStack;
     ClientModel *clientModel;
     QMap<WalletModel*, WalletView*> mapWalletViews;
 
-    PairingPage *m_page_pairing;
-
     bool bOutOfSync;
 
     const PlatformStyle *platformStyle;
@@ -73,8 +69,6 @@ public:
 public Q_SLOTS:
     /** Switch to overview (home) page */
     void gotoOverviewPage();
-    /** Switch to pairing page */
-    void gotoPairingPage();
     /** Switch to history (transactions) page */
     void gotoHistoryPage();
     /** Switch to receive coins page */
diff --git a/src/qt/walletmodel.cpp b/src/qt/walletmodel.cpp
index ec0e999844..0a01c0a45b 100644
--- a/src/qt/walletmodel.cpp
+++ b/src/qt/walletmodel.cpp
@@ -152,22 +152,6 @@ bool WalletModel::validateAddress(const QString& address) const
     return IsValidDestinationString(address.toStdString());
 }
 
-bool WalletModel::checkAddressForUsage(const std::vector<std::string>& addresses) const
-{
-    return m_wallet->checkAddressForUsage(addresses);
-}
-
-bool WalletModel::findAddressUsage(const QStringList& addresses, std::function<void(const QString&, const interfaces::WalletTx&, uint32_t)> callback) const
-{
-    std::vector<std::string> std_addresses;
-    for (const auto& address : addresses) {
-        std_addresses.push_back(address.toStdString());
-    }
-    return m_wallet->findAddressUsage(std_addresses, [&callback](const std::string& address, const interfaces::WalletTx& wtx, uint32_t output_index){
-        callback(QString::fromStdString(address), wtx, output_index);
-    });
-}
-
 WalletModel::SendCoinsReturn WalletModel::prepareTransaction(WalletModelTransaction &transaction, const CCoinControl& coinControl)
 {
     CAmount total = 0;
@@ -537,7 +521,7 @@ bool WalletModel::bumpFee(uint256 hash, uint256& new_hash)
     const bool enable_send{!wallet().privateKeysDisabled() || wallet().hasExternalSigner()};
     const bool always_show_unsigned{getOptionsModel()->getEnablePSBTControls()};
     auto confirmationDialog = new SendConfirmationDialog(tr("Confirm fee bump"), questionString, "", "", SEND_CONFIRM_DELAY, enable_send, always_show_unsigned, nullptr);
-    confirmationDialog->m_delete_on_close = true;
+    confirmationDialog->setAttribute(Qt::WA_DeleteOnClose);
     // TODO: Replace QDialog::exec() with safer QDialog::show().
     const auto retval = static_cast<QMessageBox::StandardButton>(confirmationDialog->exec());
 
@@ -644,18 +628,3 @@ CAmount WalletModel::getAvailableBalance(const CCoinControl* control)
     // Fetch balance from the wallet, taking into account the selected coins
     return wallet().getAvailableBalance(*control);
 }
-
-BitcoinAddressUnusedInWalletValidator::BitcoinAddressUnusedInWalletValidator(const WalletModel& wallet_model, QObject *parent) :
-    QValidator(parent),
-    m_wallet_model(wallet_model)
-{
-}
-
-QValidator::State BitcoinAddressUnusedInWalletValidator::validate(QString &input, int &pos) const
-{
-    Q_UNUSED(pos);
-    if (m_wallet_model.checkAddressForUsage(std::vector<std::string>{input.toStdString()})) {
-        return QValidator::Invalid;
-    }
-    return QValidator::Acceptable;
-}
diff --git a/src/qt/walletmodel.h b/src/qt/walletmodel.h
index 2e58a19d12..ab2096c1fe 100644
--- a/src/qt/walletmodel.h
+++ b/src/qt/walletmodel.h
@@ -6,18 +6,15 @@
 #define BITCOIN_QT_WALLETMODEL_H
 
 #include <key.h>
-#include <primitives/transaction.h>
 
 #include <qt/walletmodeltransaction.h>
 
 #include <interfaces/wallet.h>
 #include <support/allocators/secure.h>
 
-#include <string>
 #include <vector>
 
 #include <QObject>
-#include <QValidator>
 
 enum class OutputType;
 
@@ -84,8 +81,6 @@ public:
 
     // Check address for validity
     bool validateAddress(const QString& address) const;
-    bool checkAddressForUsage(const std::vector<std::string>& addresses) const;
-    bool findAddressUsage(const QStringList& addresses, std::function<void(const QString&, const interfaces::WalletTx&, uint32_t)> callback) const;
 
     // Return status record for SendCoins, contains error id + information
     struct SendCoinsReturn
@@ -243,16 +238,4 @@ public Q_SLOTS:
     void pollBalanceChanged();
 };
 
-class BitcoinAddressUnusedInWalletValidator : public QValidator
-{
-    Q_OBJECT
-
-    const WalletModel& m_wallet_model;
-
-public:
-    explicit BitcoinAddressUnusedInWalletValidator(const WalletModel&, QObject *parent=nullptr);
-
-    State validate(QString &input, int &pos) const override;
-};
-
 #endif // BITCOIN_QT_WALLETMODEL_H
diff --git a/src/qt/walletview.cpp b/src/qt/walletview.cpp
index 03114986f7..4926d1e80b 100644
--- a/src/qt/walletview.cpp
+++ b/src/qt/walletview.cpp
@@ -210,36 +210,19 @@ void WalletView::encryptWallet()
 
 void WalletView::backupWallet()
 {
-    QString filetype_str;
-    //: Name of the wallet data file format.
-    QString supported_formats = tr("Wallet Data") + QLatin1String(" (*.dat)");
-    if (walletModel->wallet().canBackupToDbDump()) {
-        //: Name of the wallet data file format.
-        supported_formats += QLatin1String(";;") + tr("Wallet Database Dump File") + QLatin1String(" (*.walletdbdump)");
-    }
     QString filename = GUIUtil::getSaveFileName(this,
         tr("Backup Wallet"), QString(),
-        supported_formats,
-        &filetype_str);
+        //: Name of the wallet data file format.
+        tr("Wallet Data") + QLatin1String(" (*.dat)"), nullptr);
 
     if (filename.isEmpty())
         return;
 
-    WalletBackupFormat filetype;
-    if (filetype_str == "walletdbdump") {
-        filetype = WalletBackupFormat::DbDump;
-    } else {
-        filetype = WalletBackupFormat::Raw;
-    }
-
-    bilingual_str error;
-    if (!walletModel->wallet().backupWallet(filename.toLocal8Bit().data(), filetype, error)) {
-        if (error.empty()) {
-            Q_EMIT message(tr("Backup Failed"), tr("There was an error trying to save the wallet data to %1.").arg(filename), CClientUIInterface::MSG_ERROR);
-        } else {
-            Q_EMIT message(tr("Backup Failed"), tr("There was an error trying to save the wallet data to %1: %2").arg(filename).arg(QString::fromStdString(error.translated)), CClientUIInterface::MSG_ERROR);
+    if (!walletModel->wallet().backupWallet(filename.toLocal8Bit().data())) {
+        Q_EMIT message(tr("Backup Failed"), tr("There was an error trying to save the wallet data to %1.").arg(filename),
+            CClientUIInterface::MSG_ERROR);
         }
-    } else {
+    else {
         Q_EMIT message(tr("Backup Successful"), tr("The wallet data was successfully saved to %1.").arg(filename),
             CClientUIInterface::MSG_INFORMATION);
     }
diff --git a/src/random.cpp b/src/random.cpp
index f02057b47c..7cb6098d54 100644
--- a/src/random.cpp
+++ b/src/random.cpp
@@ -192,27 +192,11 @@ uint64_t GetRdSeed() noexcept
 #elif defined(__aarch64__) && defined(HWCAP2_RNG)
 
 bool g_rndr_supported = false;
-bool g_rndrrs_supported = false;
-
-bool VerifyRNDRRS()
-{
-    uint8_t ok;
-    uint64_t test;
-    int max_retries = 10;
-    do {
-        __asm__ volatile("mrs %0, s3_3_c2_c4_1; cset %w1, ne;"
-                         : "=r"(test), "=r"(ok)::"cc");
-        if (ok) return true;
-        __asm__ volatile("yield");
-    } while (--max_retries > 0);
-    return false;
-}
 
 void InitHardwareRand()
 {
     if (getauxval(AT_HWCAP2) & HWCAP2_RNG) {
         g_rndr_supported = true;
-        g_rndrrs_supported = VerifyRNDRRS();
     }
 }
 
@@ -220,10 +204,8 @@ void ReportHardwareRand()
 {
     // This must be done in a separate function, as InitHardwareRand() may be indirectly called
     // from global constructors, before logging is initialized.
-    if (g_rndr_supported && g_rndrrs_supported) {
+    if (g_rndr_supported) {
         LogPrintf("Using RNDR and RNDRRS as additional entropy sources\n");
-    } else if (g_rndr_supported) {
-        LogPrintf("Using RNDR as an additional entropy source\n");
     }
 }
 
@@ -313,7 +295,7 @@ void SeedHardwareSlow(CSHA512& hasher) noexcept {
         return;
     }
 #elif defined(__aarch64__) && defined(HWCAP2_RNG)
-    if (g_rndrrs_supported) {
+    if (g_rndr_supported) {
         for (int i = 0; i < 4; ++i) {
             uint64_t out = GetRNDRRS();
             hasher.Write((const unsigned char*)&out, sizeof(out));
@@ -640,7 +622,7 @@ void SeedStartup(CSHA512& hasher, RNGState& rng) noexcept
 
     // Static environment data
     RandAddStaticEnv(hasher);
-    LogInfo("Feeding %i bytes of environment data into RNG\n", hasher.Size() - old_size);
+    LogPrint(BCLog::RAND, "Feeding %i bytes of environment data into RNG\n", hasher.Size() - old_size);
 
     // Strengthen for 100 ms
     SeedStrengthen(hasher, rng, 100ms);
diff --git a/src/randomenv.cpp b/src/randomenv.cpp
index 132bb9eee0..4754b597c5 100644
--- a/src/randomenv.cpp
+++ b/src/randomenv.cpp
@@ -227,6 +227,7 @@ void AddAllCPUID(CSHA512& hasher)
 
 void RandAddDynamicEnv(CSHA512& hasher)
 {
+    RandAddSeedPerfmon(hasher);
 
     // Various clocks
 #ifdef WIN32
diff --git a/src/rest.cpp b/src/rest.cpp
index 9381f4ec2f..c42bc8e40c 100644
--- a/src/rest.cpp
+++ b/src/rest.cpp
@@ -10,7 +10,6 @@
 #include <blockfilter.h>
 #include <chain.h>
 #include <chainparams.h>
-#include <common/messages.h>
 #include <core_io.h>
 #include <flatfile.h>
 #include <httpserver.h>
@@ -32,10 +31,8 @@
 #include <util/check.h>
 #include <util/strencodings.h>
 #include <validation.h>
-#include <policy/fees.h>
 
 #include <any>
-#include <optional>
 #include <vector>
 
 #include <univalue.h>
@@ -646,45 +643,6 @@ static bool rest_deploymentinfo(const std::any& context, HTTPRequest* req, const
 
 }
 
-static bool rest_mempool_transactions(const std::any& context, HTTPRequest* req, const std::string& str_uri_part)
-{
-    if (!CheckWarmup(req))
-        return false;
-
-    std::string param;
-    const RESTResponseFormat rf = ParseDataFormat(param, str_uri_part);
-    if (param != "contents" && param != "info") {
-        return RESTERR(req, HTTP_BAD_REQUEST, "Invalid URI format. Expected /rest/mempool/transactions/<info|contents>.json");
-    }
-
-    const CTxMemPool* mempool = GetMemPool(context, req);
-    if (!mempool) return false;
-
-    switch (rf) {
-    case RESTResponseFormat::JSON: {
-        std::string str_json;
-        std::string raw_sequence_start;
-        const bool verbose = param == "contents";
-
-        try {
-            raw_sequence_start = req->GetQueryParameter("sequence_start").value_or("0");
-        } catch (const std::runtime_error& e) {
-            return RESTERR(req, HTTP_BAD_REQUEST, e.what());
-        }
-
-        const auto sequence_start{ToIntegral<uint64_t>(raw_sequence_start)};
-        str_json = MempoolTxsToJSON(*mempool, verbose, sequence_start.value()).write() + "\n";
-
-        req->WriteHeader("Content-Type", "application/json");
-        req->WriteReply(HTTP_OK, str_json);
-        return true;
-    }
-    default: {
-        return RESTERR(req, HTTP_NOT_FOUND, "output format not found (available: json)");
-    }
-    }
-}
-
 static bool rest_mempool(const std::any& context, HTTPRequest* req, const std::string& str_uri_part)
 {
     if (!CheckWarmup(req))
@@ -692,8 +650,8 @@ static bool rest_mempool(const std::any& context, HTTPRequest* req, const std::s
 
     std::string param;
     const RESTResponseFormat rf = ParseDataFormat(param, str_uri_part);
-    if (param != "contents" && param != "info" && param != "info/with_fee_histogram") {
-        return RESTERR(req, HTTP_BAD_REQUEST, "Invalid URI format. Expected /rest/mempool/<info|info/with_fee_histogram|contents>.json");
+    if (param != "contents" && param != "info") {
+        return RESTERR(req, HTTP_BAD_REQUEST, "Invalid URI format. Expected /rest/mempool/<info|contents>.json");
     }
 
     const CTxMemPool* mempool = GetMemPool(context, req);
@@ -726,14 +684,9 @@ static bool rest_mempool(const std::any& context, HTTPRequest* req, const std::s
             if (verbose && mempool_sequence) {
                 return RESTERR(req, HTTP_BAD_REQUEST, "Verbose results cannot contain mempool sequence values. (hint: set \"verbose=false\")");
             }
-            ChainstateManager* maybe_chainman = GetChainman(context, req);
-            if (!maybe_chainman) return false;
-            ChainstateManager& chainman = *maybe_chainman;
-            str_json = MempoolToJSON(chainman, *mempool, verbose, mempool_sequence).write() + "\n";
-        } else if (param == "info/with_fee_histogram") {
-            str_json = MempoolInfoToJSON(*mempool, MempoolInfoToJSON_const_histogram_floors).write() + "\n";
+            str_json = MempoolToJSON(*mempool, verbose, mempool_sequence).write() + "\n";
         } else {
-            str_json = MempoolInfoToJSON(*mempool, std::nullopt).write() + "\n";
+            str_json = MempoolInfoToJSON(*mempool).write() + "\n";
         }
 
         req->WriteHeader("Content-Type", "application/json");
@@ -1050,76 +1003,6 @@ static bool rest_blockhash_by_height(const std::any& context, HTTPRequest* req,
     }
 }
 
-static bool rest_getfee(const std::any& context, HTTPRequest* req, const std::string& strURIPart) {
-    if (!CheckWarmup(req)) {
-        return false;
-    }
-
-    const NodeContext* const node = GetNodeContext(context, req);
-    if (!node) return false;
-    const CBlockPolicyEstimator* const fee_estimator = node->fee_estimator.get();
-    if (!fee_estimator) return false;
-
-    std::string param;
-    const RESTResponseFormat rf = ParseDataFormat(param, strURIPart);
-    switch (rf) {
-    case RESTResponseFormat::JSON: {
-        std::vector<std::string> path = SplitString(param, '/');
-        path.erase(path.begin());
-        // check url scheme is correct
-        if (path.size() != 2) {
-            return RESTERR(req, HTTP_BAD_REQUEST, "Path must be /rest/fee/<MODE>/<TARGET>.json");
-        }
-        // check estimation mode is valid
-        const auto modestr = ToUpper(path[0]);
-        FeeEstimateMode mode;
-        if (!common::FeeModeFromString(modestr, mode)){
-            return RESTERR(req, HTTP_BAD_REQUEST, "<MODE> must be one of <unset|economical|conservative>");
-        }
-
-        // type conversions for estimateSmartFee
-        bool conservative = mode == FeeEstimateMode::CONSERVATIVE;
-        const auto parsed_conf_target{ToIntegral<unsigned int>(path[1])};
-        if (!parsed_conf_target.has_value()) {
-            return RESTERR(req, HTTP_BAD_REQUEST, strprintf("Unable to parse confirmation target to int"));
-        }
-        auto conf_target{*parsed_conf_target};
-        unsigned int max_target = fee_estimator->HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);
-        if (conf_target < 1 || conf_target > max_target) {
-            return RESTERR(req, HTTP_BAD_REQUEST, strprintf("Invalid confirmation target, must be in between %u - %u", 1, max_target));
-        }
-
-        // perform fee estimation
-        FeeCalculation feeCalc;
-        CFeeRate estimatedfee = fee_estimator->estimateSmartFee(conf_target, &feeCalc, conservative);
-
-        // create json for replying
-        UniValue feejson(UniValue::VOBJ);
-        if (estimatedfee != CFeeRate(0)) {
-            const CTxMemPool* mempool = GetMemPool(context, req);
-            if (mempool) {
-                CFeeRate min_mempool_feerate{mempool->GetMinFee()};
-                CFeeRate min_relay_feerate{mempool->m_opts.min_relay_feerate};
-                estimatedfee = std::max({estimatedfee, min_mempool_feerate, min_relay_feerate});
-            }
-            feejson.pushKV("feerate", ValueFromAmount(estimatedfee.GetFeePerK()));
-        } else {
-            return RESTERR(req, HTTP_SERVICE_UNAVAILABLE, "Insufficient data or no feerate found");
-        }
-        feejson.pushKV("blocks", feeCalc.returnedTarget);
-
-        // reply
-        std::string strJSON = feejson.write() + "\n";
-        req->WriteHeader("Content-Type", "application/json");
-        req->WriteReply(HTTP_OK, strJSON);
-        return true;
-    }
-    default: {
-        return RESTERR(req, HTTP_NOT_FOUND, "output format not found (available: json)");
-    }
-    }
-}
-
 static const struct {
     const char* prefix;
     bool (*handler)(const std::any& context, HTTPRequest* req, const std::string& strReq);
@@ -1131,13 +1014,11 @@ static const struct {
       {"/rest/blockfilterheaders/", rest_filter_header},
       {"/rest/chaininfo", rest_chaininfo},
       {"/rest/mempool/", rest_mempool},
-      {"/rest/mempool/transactions", rest_mempool_transactions},
       {"/rest/headers/", rest_headers},
       {"/rest/getutxos", rest_getutxos},
       {"/rest/deploymentinfo/", rest_deploymentinfo},
       {"/rest/deploymentinfo", rest_deploymentinfo},
       {"/rest/blockhashbyheight/", rest_blockhash_by_height},
-      {"/rest/fee", rest_getfee},
 };
 
 void StartREST(const std::any& context)
diff --git a/src/rpc/blockchain.cpp b/src/rpc/blockchain.cpp
index 414ebb913e..8b8576ab88 100644
--- a/src/rpc/blockchain.cpp
+++ b/src/rpc/blockchain.cpp
@@ -3,10 +3,6 @@
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
-#if defined(HAVE_CONFIG_H)
-#include <config/bitcoin-config.h>
-#endif
-
 #include <rpc/blockchain.h>
 
 #include <blockfilter.h>
@@ -27,7 +23,6 @@
 #include <index/blockfilterindex.h>
 #include <index/coinstatsindex.h>
 #include <kernel/coinstats.h>
-#include <key_io.h>
 #include <logging/timer.h>
 #include <net.h>
 #include <net_processing.h>
@@ -37,7 +32,6 @@
 #include <node/utxo_snapshot.h>
 #include <node/warnings.h>
 #include <primitives/transaction.h>
-#include <policy/settings.h>
 #include <rpc/server.h>
 #include <rpc/server_util.h>
 #include <rpc/util.h>
@@ -52,19 +46,6 @@
 #include <util/check.h>
 #include <util/fs.h>
 #include <util/strencodings.h>
-#include <util/string.h>
-#include <util/syserror.h>
-#include <validation.h>
-
-#ifdef ENABLE_WALLET
-#include <interfaces/wallet.h>
-#include <wallet/coincontrol.h>
-#include <wallet/fees.h>
-#include <wallet/rpc/util.h>
-#include <wallet/types.h>
-#include <wallet/wallet.h>
-#endif
-
 #include <util/translation.h>
 #include <validation.h>
 #include <validationinterface.h>
@@ -73,10 +54,8 @@
 #include <stdint.h>
 
 #include <condition_variable>
-#include <iterator>
 #include <memory>
 #include <mutex>
-#include <vector>
 
 using kernel::CCoinsStats;
 using kernel::CoinStatsHashType;
@@ -193,7 +172,6 @@ UniValue blockToJSON(BlockManager& blockman, const CBlock& block, const CBlockIn
     result.pushKV("size", (int)::GetSerializeSize(TX_WITH_WITNESS(block)));
     result.pushKV("weight", (int)::GetBlockWeight(block));
     UniValue txs(UniValue::VARR);
-    txs.reserve(block.vtx.size());
 
     switch (verbosity) {
         case TxVerbosity::SHOW_TXID:
@@ -453,6 +431,7 @@ static RPCHelpMan getblockfrompeer()
     return RPCHelpMan{
         "getblockfrompeer",
         "Attempt to fetch block from a given peer.\n\n"
+        "We must have the header for this block, e.g. using submitheader.\n"
         "The block will not have any undo data which can limit the usage of the block data in a context where the undo data is needed.\n"
         "Subsequent calls for the same block may cause the response from the previous peer to be ignored.\n"
         "Peers generally ignore requests for a stale block that they never fully verified, or one that is more than a month old.\n"
@@ -461,7 +440,7 @@ static RPCHelpMan getblockfrompeer()
         "Returns an empty JSON object if the request was successfully scheduled.",
         {
             {"blockhash", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "The block hash to try to fetch"},
-            {"peer_id|nodeid", RPCArg::Type::NUM, RPCArg::Optional::NO, "The peer to fetch it from (see getpeerinfo for peer IDs)"},
+            {"peer_id", RPCArg::Type::NUM, RPCArg::Optional::NO, "The peer to fetch it from (see getpeerinfo for peer IDs)"},
         },
         RPCResult{RPCResult::Type::OBJ, "", /*optional=*/false, "", {}},
         RPCExamples{
@@ -479,20 +458,22 @@ static RPCHelpMan getblockfrompeer()
 
     const CBlockIndex* const index = WITH_LOCK(cs_main, return chainman.m_blockman.LookupBlockIndex(block_hash););
 
-#if 0
+    if (!index) {
+        throw JSONRPCError(RPC_MISC_ERROR, "Block header missing");
+    }
+
     // Fetching blocks before the node has syncing past their height can prevent block files from
     // being pruned, so we avoid it if the node is in prune mode.
     if (chainman.m_blockman.IsPruneMode() && index->nHeight > WITH_LOCK(chainman.GetMutex(), return chainman.ActiveTip()->nHeight)) {
         throw JSONRPCError(RPC_MISC_ERROR, "In prune mode, only blocks that the node has already synced previously can be fetched from a peer");
     }
-#endif
 
-    const bool block_has_data = index && WITH_LOCK(::cs_main, return index->nStatus & BLOCK_HAVE_DATA);
+    const bool block_has_data = WITH_LOCK(::cs_main, return index->nStatus & BLOCK_HAVE_DATA);
     if (block_has_data) {
         throw JSONRPCError(RPC_MISC_ERROR, "Block already downloaded");
     }
 
-    if (const auto err{peerman.FetchBlock(peer_id, block_hash, index)}) {
+    if (const auto err{peerman.FetchBlock(peer_id, *index)}) {
         throw JSONRPCError(RPC_MISC_ERROR, err.value());
     }
     return UniValue::VOBJ;
@@ -529,171 +510,6 @@ static RPCHelpMan getblockhash()
     };
 }
 
-#ifdef ENABLE_WALLET
-bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results, std::function<void()>& interruption_point);
-
-static RPCHelpMan sweepprivkeys()
-{
-    return RPCHelpMan{"sweepprivkeys",
-        "\nSends bitcoins controlled by private key to specified destinations.\n",
-        {
-            {"options", RPCArg::Type::OBJ_NAMED_PARAMS, RPCArg::Optional::NO, "",
-                {
-                    {"privkeys", RPCArg::Type::ARR, RPCArg::Optional::NO, "An array of WIF private key(s)",
-                        {
-                            {"privkey", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, ""},
-                        },
-                        },
-
-                    {"label", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "Label for received bitcoins"},
-                },
-                RPCArgOptions{.oneline_description="options"}},
-        },
-        RPCResult{RPCResult::Type::STR_HEX, "", "The transaction id."},
-        RPCExamples{""},
-        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
-{
-    NodeContext& node = EnsureAnyNodeContext(request.context);
-
-    JSONRPCRequest wallet_req = request;
-    CHECK_NONFATAL(node.wallet_loader && node.wallet_loader->context());
-    node.wallet_loader->assignContextHACK(wallet_req.context);
-    std::shared_ptr<wallet::CWallet> const wallet = wallet::GetWalletForJSONRPCRequest(wallet_req);
-    if (!wallet) return NullUniValue;
-    wallet::CWallet* const pwallet = wallet.get();
-
-    // NOTE: It isn't safe to sweep-and-send in a single action, since this would leave the send missing from the transaction history
-
-    // Parse options
-    std::set<CScript> needles;
-    wallet::CCoinControl coin_control;
-    FillableSigningProvider temp_keystore;
-    CMutableTransaction tx;
-    std::string label;
-    CAmount total_in = 0;
-    for (const std::string& optname : request.params[0].getKeys()) {
-        const UniValue& optval = request.params[0][optname];
-        if (optname == "privkeys") {
-            const UniValue& privkeys_a = optval.get_array();
-            for (size_t privkey_i = 0; privkey_i < privkeys_a.size(); ++privkey_i) {
-                const UniValue& privkey_wif = privkeys_a[privkey_i];
-                std::string wif_secret = privkey_wif.get_str();
-                CKey key = DecodeSecret(wif_secret);
-                if (!key.IsValid()) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid private key encoding");
-                CPubKey pubkey = key.GetPubKey();
-                CHECK_NONFATAL(key.VerifyPubKey(pubkey));
-
-                temp_keystore.AddKey(key);
-                CKeyID address = pubkey.GetID();
-                CScript script = GetScriptForDestination(PKHash(address));
-                if (!script.empty()) {
-                    needles.insert(script);
-                }
-                script = GetScriptForRawPubKey(pubkey);
-                if (!script.empty()) {
-                    needles.insert(script);
-                }
-            }
-        } else if (optname == "label") {
-            label = wallet::LabelFromValue(optval.get_str());
-        } else {
-            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Unrecognised option '%s'", optname));
-        }
-    }
-
-    std::unique_ptr<wallet::ReserveDestination> reservedest;
-    CTxDestination dest;
-    {
-        LOCK(pwallet->cs_wallet);
-
-        // Reserve the key we will be using
-        reservedest.reset(new wallet::ReserveDestination(pwallet, pwallet->TransactionChangeType(pwallet->m_default_change_type, std::vector<wallet::CRecipient>())));
-        auto op_dest = reservedest->GetReservedDestination(false);
-        if (!op_dest) {
-            throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, util::ErrorString(op_dest).original);
-        }
-        dest = *op_dest;
-    }
-
-    // Scan UTXO set for inputs
-    std::vector<CTxOut> input_txos;
-    {
-        // Collect all possible inputs
-        std::map<COutPoint, Coin> coins;
-        {
-            std::unique_ptr<CCoinsViewCursor> pcursor;
-            {
-                ChainstateManager& chainman = EnsureAnyChainman(request.context);
-                LOCK(cs_main);
-                if (node.mempool) {
-                    node.mempool->FindScriptPubKey(needles, coins);
-                }
-                Chainstate& active_chainstate = chainman.ActiveChainstate();
-                active_chainstate.ForceFlushStateToDisk();
-                pcursor = std::unique_ptr<CCoinsViewCursor>(active_chainstate.CoinsDB().Cursor());
-                CHECK_NONFATAL(pcursor);
-            }
-            std::atomic<int> scan_progress;
-            const std::atomic<bool> should_abort{false};
-            int64_t count;
-            if (!FindScriptPubKey(scan_progress, should_abort, count, pcursor.get(), needles, coins, node.rpc_interruption_point)) {
-                throw JSONRPCError(RPC_MISC_ERROR, "UTXO FindScriptPubKey failed");
-            }
-        }
-
-        // Add them as inputs to the transaction, and count the total value
-        for (auto& it : coins) {
-            const COutPoint& outpoint = it.first;
-            const Coin& coin = it.second;
-            const CTxOut& txo = coin.out;
-            tx.vin.emplace_back(outpoint.hash, outpoint.n);
-            input_txos.push_back(txo);
-            total_in += txo.nValue;
-        }
-    }
-
-    if (total_in == 0) {
-        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, "No value to sweep");
-    }
-
-    tx.vout.emplace_back(total_in, GetScriptForDestination(dest));
-
-    while (true) {
-        if (IsDust(tx.vout[0], pwallet->chain().relayDustFee())) {
-            throw JSONRPCError(RPC_VERIFY_REJECTED, "Swept value would be dust");
-        }
-        for (size_t input_index = 0; input_index < tx.vin.size(); ++input_index) {
-            SignatureData empty;
-            if (!SignSignature(temp_keystore, input_txos[input_index].scriptPubKey, tx, input_index, input_txos[input_index].nValue, SIGHASH_ALL, empty)) {
-                throw JSONRPCError(RPC_MISC_ERROR, "Failed to sign");
-            }
-        }
-        int64_t tx_vsize = GetVirtualTransactionSize(CTransaction(tx));
-        CAmount fee_needed = GetMinimumFee(*wallet, tx_vsize, coin_control, nullptr /* FeeCalculation */);
-        const CAmount total_out = tx.vout[0].nValue;
-        if (fee_needed <= total_in - total_out) {
-            break;
-        }
-        tx.vout[0].nValue = total_in - fee_needed;
-    }
-
-    CTransactionRef final_tx(MakeTransactionRef(std::move(tx)));
-    pwallet->SetAddressBook(dest, label, wallet::AddressPurpose::RECEIVE);
-
-    std::string err_string;
-    const node::TransactionError err = BroadcastTransaction(node, final_tx, err_string, pwallet->m_default_max_tx_fee, true /* relay */, true /* wait_callback */);
-    if (node::TransactionError::OK != err) {
-        pwallet->DelAddressBook(dest);
-        throw JSONRPCTransactionError(err, err_string);
-    }
-    reservedest->KeepDestination();
-
-    return final_tx->GetHash().GetHex();
-},
-    };
-}
-#endif // ENABLE_WALLET
-
 static RPCHelpMan getblockheader()
 {
     return RPCHelpMan{"getblockheader",
@@ -996,167 +812,6 @@ std::optional<int> GetPruneHeight(const BlockManager& blockman, const CChain& ch
     return CHECK_NONFATAL(first_unpruned.pprev)->nHeight;
 }
 
-static RPCHelpMan listprunelocks()
-{
-    return RPCHelpMan{"listprunelocks",
-        "\nReturns a list of pruning locks.\n",
-        {},
-        RPCResult{
-            RPCResult::Type::OBJ, "", "",
-            {
-                {RPCResult::Type::ARR, "prune_locks", "",
-                {
-                    {RPCResult::Type::OBJ, "", "",
-                    {
-                        {RPCResult::Type::STR, "id", "A unique identifier for the lock"},
-                        {RPCResult::Type::STR, "desc", "A description of the lock's purpose"},
-                        {RPCResult::Type::ARR_FIXED, "height", "Range of blocks prevented from being pruned",
-                        {
-                            {RPCResult::Type::NUM, "height_first", "Height of first block that may not be pruned"},
-                            {RPCResult::Type::NUM, "height_last", "Height of last block that may not be pruned (omitted if unbounded)"},
-                        }},
-                        {RPCResult::Type::BOOL, "temporary", "Indicates the lock will not remain after a restart of the node"},
-                    }},
-                }},
-            }
-        },
-        RPCExamples{
-            HelpExampleCli("listprunelocks", "")
-          + HelpExampleRpc("listprunelocks", "")
-        },
-    [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
-{
-    NodeContext& node = EnsureAnyNodeContext(request.context);
-    ChainstateManager& chainman = EnsureChainman(node);
-    Chainstate& active_chainstate = chainman.ActiveChainstate();
-
-    UniValue locks_uv(UniValue::VARR);
-    {
-        LOCK(::cs_main);
-        BlockManager * const blockman = &active_chainstate.m_blockman;
-        for (const auto& prune_lock : blockman->m_prune_locks) {
-            UniValue prune_lock_uv(UniValue::VOBJ);
-            const auto& lock_info = prune_lock.second;
-            prune_lock_uv.pushKV("id", prune_lock.first);
-            prune_lock_uv.pushKV("desc", lock_info.desc);
-            UniValue heights_uv(UniValue::VARR);
-            heights_uv.push_back(lock_info.height_first);
-            if (lock_info.height_last < std::numeric_limits<uint64_t>::max()) {
-                heights_uv.push_back(lock_info.height_last);
-            }
-            prune_lock_uv.pushKV("height", heights_uv);
-            prune_lock_uv.pushKV("temporary", lock_info.temporary);
-            locks_uv.push_back(prune_lock_uv);
-        }
-    }
-
-    UniValue result(UniValue::VOBJ);
-    result.pushKV("prune_locks", locks_uv);
-    return result;
-},
-    };
-}
-
-static RPCHelpMan setprunelock()
-{
-    return RPCHelpMan{"setprunelock",
-        "\nManipulate pruning locks.\n",
-        {
-            {"id", RPCArg::Type::STR, RPCArg::Optional::NO, "The unique id of the manipulated prune lock (or \"*\" if deleting all)"},
-            {"lock_info", RPCArg::Type::OBJ, RPCArg::Optional::NO, "An object describing the desired lock",
-                {
-                    {"desc", RPCArg::Type::STR, RPCArg::Optional::NO, "Description of the lock"},
-                    {"height", RPCArg::Type::RANGE, RPCArg::DefaultHint("deletes the lock"), "The range of block heights to prevent pruning"},
-                    {"sync", RPCArg::Type::BOOL, RPCArg::Default(false), "If true, success indicates the lock change was stored to disk (if non-temporary). If false, it is possible for a subsequent node crash to lose the lock."},
-                    {"temporary", RPCArg::Type::BOOL, RPCArg::Default(false), "If true, the lock will not persist across node restart."},
-                },
-            },
-        },
-        RPCResult{
-            RPCResult::Type::OBJ, "", "",
-            {
-                {RPCResult::Type::BOOL, "success", "Whether the change was successful"},
-            }},
-        RPCExamples{
-            HelpExampleCli("setprunelock", "\"test\" \"{\\\"desc\\\": \\\"Just a test\\\", \\\"height\\\": [0,100]}\"")
-          + HelpExampleCli("setprunelock", "\"test-2\" \"{\\\"desc\\\": \\\"Second RPC-created prunelock test\\\", \\\"height\\\": [100]}\"")
-          + HelpExampleRpc("setprunelock", "\"test\", {\"desc\": \"Just a test\", \"height\": [0,100]}")
-        },
-    [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
-{
-    NodeContext& node = EnsureAnyNodeContext(request.context);
-    ChainstateManager& chainman = EnsureChainman(node);
-    Chainstate& active_chainstate = chainman.ActiveChainstate();
-
-    const auto& lock_info_json = request.params[1];
-    RPCTypeCheckObj(lock_info_json,
-        {
-            {"desc", UniValueType(UniValue::VSTR)},
-            {"height", UniValueType()}, // will be checked below
-            {"sync", UniValueType(UniValue::VBOOL)},
-            {"temporary", UniValueType(UniValue::VBOOL)},
-        },
-        /*fAllowNull=*/ true, /*fStrict=*/ true);
-
-    const auto& lockid = request.params[0].get_str();
-
-    node::PruneLockInfo lock_info;
-
-    auto height_param = lock_info_json["height"];
-    if (!height_param.isArray()) {
-        UniValue new_height_param(UniValue::VARR);
-        new_height_param.push_back(std::move(height_param));
-        height_param = std::move(new_height_param);
-    }
-    bool success;
-    if (height_param[0].isNull() && height_param[1].isNull()) {
-        // Delete
-        LOCK(::cs_main);
-        BlockManager * const blockman = &active_chainstate.m_blockman;
-        if (lockid == "*") {
-            // Delete all
-            success = true;
-            std::vector<std::string> all_ids;
-            all_ids.reserve(blockman->m_prune_locks.size());
-            for (const auto& prune_lock : blockman->m_prune_locks) {
-                all_ids.push_back(prune_lock.first);
-            }
-            for (auto& lockid : all_ids) {
-                success |= blockman->DeletePruneLock(lockid);
-            }
-        } else {
-            success = blockman->PruneLockExists(lockid) && blockman->DeletePruneLock(lockid);
-        }
-    } else {
-        if (lockid == "*") throw JSONRPCError(RPC_INVALID_PARAMETER, "id \"*\" only makes sense when deleting");
-        if (!height_param[0].isNum()) throw JSONRPCError(RPC_TYPE_ERROR, "Invalid start height");
-        lock_info.height_first = height_param[0].getInt<uint64_t>();
-        if (!height_param[1].isNull()) {
-            if (!height_param[1].isNum()) throw JSONRPCError(RPC_TYPE_ERROR, "Invalid end height");
-            lock_info.height_last = height_param[1].getInt<uint64_t>();
-        }
-        lock_info.desc = lock_info_json["desc"].get_str();
-        if (lock_info_json["temporary"].isNull()) {
-            lock_info.temporary = false;
-        } else {
-            lock_info.temporary = lock_info_json["temporary"].get_bool();
-        }
-        bool sync = false;
-        if (!lock_info_json["sync"].isNull()) {
-            sync = lock_info_json["sync"].get_bool();
-        }
-        LOCK(::cs_main);
-        BlockManager * const blockman = &active_chainstate.m_blockman;
-        success = blockman->UpdatePruneLock(lockid, lock_info, sync);
-    }
-
-    UniValue result(UniValue::VOBJ);
-    result.pushKV("success", success);
-    return result;
-},
-    };
-}
-
 static RPCHelpMan pruneblockchain()
 {
     return RPCHelpMan{"pruneblockchain", "",
@@ -1185,10 +840,6 @@ static RPCHelpMan pruneblockchain()
     if (heightParam < 0) {
         throw JSONRPCError(RPC_INVALID_PARAMETER, "Negative block height.");
     }
-    if (heightParam == 0) {
-        // Nothing to do here
-        return uint64_t(0);
-    }
 
     // Height value more than a billion is too high to be a block height, and
     // too low to be a block time (corresponds to timestamp from Sep 2001).
@@ -1430,13 +1081,12 @@ static RPCHelpMan gettxout()
             RPCResult{"Otherwise", RPCResult::Type::OBJ, "", "", {
                 {RPCResult::Type::STR_HEX, "bestblock", "The hash of the block at the tip of the chain"},
                 {RPCResult::Type::NUM, "confirmations", "The number of confirmations"},
-                {RPCResult::Type::NUM, "confirmations_assumed", /*optional=*/true, "The number of unverified confirmations (eg, in an assumed-valid UTXO set)"},
                 {RPCResult::Type::STR_AMOUNT, "value", "The transaction value in " + CURRENCY_UNIT},
                 {RPCResult::Type::OBJ, "scriptPubKey", "", {
                     {RPCResult::Type::STR, "asm", "Disassembly of the output script"},
                     {RPCResult::Type::STR, "desc", "Inferred descriptor for the output"},
                     {RPCResult::Type::STR_HEX, "hex", "The raw output script bytes, hex-encoded"},
-                    {RPCResult::Type::STR, "type", "The type (one of: " + GetAllOutputTypes() + ")"},
+                    {RPCResult::Type::STR, "type", "The type, eg pubkeyhash"},
                     {RPCResult::Type::STR, "address", /*optional=*/true, "The Bitcoin address (only if a well-defined address exists)"},
                 }},
                 {RPCResult::Type::BOOL, "coinbase", "Coinbase or not"},
@@ -1486,13 +1136,7 @@ static RPCHelpMan gettxout()
     if (coin.nHeight == MEMPOOL_HEIGHT) {
         ret.pushKV("confirmations", 0);
     } else {
-        const auto assumed_base_height = chainman.GetSnapshotBaseHeight();
-        if (assumed_base_height && coin.nHeight < *assumed_base_height) {
-            ret.pushKV("confirmations", 0);
-            ret.pushKV("confirmations_assumed", (int64_t)(pindex->nHeight - coin.nHeight + 1));
-        } else {
         ret.pushKV("confirmations", (int64_t)(pindex->nHeight - coin.nHeight + 1));
-        }
     }
     ret.pushKV("value", ValueFromAmount(coin.out.nValue));
     UniValue o(UniValue::VOBJ);
@@ -1535,69 +1179,6 @@ static RPCHelpMan verifychain()
     };
 }
 
-static RPCHelpMan scriptthreadsinfo()
-{
-    return RPCHelpMan{"scriptthreadsinfo",
-                "\nShow information about the script verification threads.\n",
-                {},
-                RPCResult{
-                    RPCResult::Type::OBJ, "", "",
-                    {
-                        {RPCResult::Type::BOOL, "enabled", "true if script verification threads are enabled (see setscriptthreadsenabled)."},
-                        {RPCResult::Type::NUM, "num_script_check_threads", "The total number of script verification threads, when enabled."},
-                    },
-                },
-                RPCExamples{
-                    HelpExampleCli("scriptthreadsinfo", "")
-            + HelpExampleRpc("scriptthreadsinfo", "")
-                },
-        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
-{
-    ChainstateManager& chainman = EnsureAnyChainman(request.context);
-    UniValue ret(UniValue::VOBJ);
-    size_t thread_count{chainman.m_script_check_queue_enabled ? chainman.GetCheckQueue().ThreadCount() : 0};
-    ret.pushKV("enabled", (bool)thread_count);
-    ret.pushKV("num_script_check_threads", (int64_t)thread_count + 1);
-    return ret;
-},
-    };
-}
-
-static RPCHelpMan setscriptthreadsenabled()
-{
-    return RPCHelpMan{"setscriptthreadsenabled",
-                "\nDisable/enable script verification threads, thereby reducing CPU usage on multicore systems on demand.\n"
-                "Disabling script verification threads may result in a significant slow-down during synchronisation.\n"
-                "Has no effect on single core machines or if started with -par=<-<numcores>\n",
-                {
-                    {"state", RPCArg::Type::BOOL, RPCArg::Optional::NO, "false if script verification threads should be disabled (true for re-enabling)"},
-                },
-                RPCResult{RPCResult::Type::NONE, "", ""},
-                RPCExamples{
-                    HelpExampleCli("setscriptthreadsenabled", "false")
-            + HelpExampleRpc("setscriptthreadsenabled", "false")
-                },
-        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
-{
-    ChainstateManager& chainman = EnsureAnyChainman(request.context);
-    LOCK(cs_main);
-
-    const bool parallel_script_checks{request.params[0].get_bool()};
-    if (parallel_script_checks) {
-        if (!chainman.GetCheckQueue().HasThreads()) {
-            throw JSONRPCError(RPC_MISC_ERROR, "Script verification threads are disabled (single core machine or -par=<-<numcores>)");
-        }
-
-        chainman.m_script_check_queue_enabled = true;
-    } else {
-        chainman.m_script_check_queue_enabled = false;
-    }
-
-    return NullUniValue;
-},
-    };
-}
-
 static void SoftForkDescPushBack(const CBlockIndex* blockindex, UniValue& softforks, const ChainstateManager& chainman, Consensus::BuriedDeployment dep)
 {
     // For buried deployments.
@@ -1657,7 +1238,6 @@ static void SoftForkDescPushBack(const CBlockIndex* blockindex, UniValue& softfo
         std::vector<bool> signals;
         BIP9Stats statsStruct = chainman.m_versionbitscache.Statistics(blockindex, chainman.GetConsensus(), id, &signals);
         statsUV.pushKV("period", statsStruct.period);
-        statsUV.pushKV("period_start", blockindex->nHeight + 1 - statsStruct.elapsed);
         statsUV.pushKV("elapsed", statsStruct.elapsed);
         statsUV.pushKV("count", statsStruct.count);
         if (ThresholdState::LOCKED_IN != current_state) {
@@ -1709,7 +1289,6 @@ RPCHelpMan getblockchaininfo()
                 {RPCResult::Type::NUM, "pruneheight", /*optional=*/true, "height of the last block pruned, plus one (only present if pruning is enabled)"},
                 {RPCResult::Type::BOOL, "automatic_pruning", /*optional=*/true, "whether automatic pruning is enabled (only present if pruning is enabled)"},
                 {RPCResult::Type::NUM, "prune_target_size", /*optional=*/true, "the target size used by pruning (only present if automatic pruning is enabled)"},
-                {RPCResult::Type::STR_HEX, "signet_challenge", /*optional=*/true, "the block challenge (aka. block script), in hexadecimal (only present if the current network is a signet)"},
                 (IsDeprecatedRPCEnabled("warnings") ?
                     RPCResult{RPCResult::Type::STR, "warnings", "any network and blockchain warnings (DEPRECATED)"} :
                     RPCResult{RPCResult::Type::ARR, "warnings", "any network and blockchain warnings (run with `-deprecatedrpc=warnings` to return the latest warning as a single string)",
@@ -1754,11 +1333,6 @@ RPCHelpMan getblockchaininfo()
             obj.pushKV("prune_target_size", chainman.m_blockman.GetPruneTarget());
         }
     }
-    if (chainman.GetParams().GetChainType() == ChainType::SIGNET) {
-        const std::vector<uint8_t>& signet_challenge =
-            chainman.GetParams().GetConsensus().signet_challenge;
-        obj.pushKV("signet_challenge", HexStr(signet_challenge));
-    }
 
     NodeContext& node = EnsureAnyNodeContext(request.context);
     obj.pushKV("warnings", node::GetWarningsForRpc(*CHECK_NONFATAL(node.warnings), IsDeprecatedRPCEnabled("warnings")));
@@ -1784,7 +1358,6 @@ const std::vector<RPCResult> RPCHelpForDeployment{
         {RPCResult::Type::OBJ, "statistics", /*optional=*/true, "numeric statistics about signalling for a softfork (only for \"started\" and \"locked_in\" status)",
         {
             {RPCResult::Type::NUM, "period", "the length in blocks of the signalling period"},
-            {RPCResult::Type::NUM, "period_start", "height of the first block of this signalling period"},
             {RPCResult::Type::NUM, "threshold", /*optional=*/true, "the number of blocks with the version bit set required to activate the feature (only for \"started\" status)"},
             {RPCResult::Type::NUM, "elapsed", "the number of blocks elapsed since the beginning of the current period"},
             {RPCResult::Type::NUM, "count", "the number of blocks with the version bit set in the current period"},
@@ -2491,6 +2064,7 @@ static RPCHelpMan getblockstats()
     };
 }
 
+namespace {
 //! Search for a given set of pubkey scripts
 bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results, std::function<void()>& interruption_point)
 {
@@ -2520,6 +2094,7 @@ bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>&
     scan_progress = 100;
     return true;
 }
+} // namespace
 
 /** RAII object to prevent concurrency issue when scanning the txout set */
 static std::atomic<int> g_scan_progress;
@@ -2766,17 +2341,9 @@ public:
         return true;
     }
 
-    void release() {
-        if (!m_could_reserve) {
-            throw std::runtime_error("Attempt to release unreserved BlockFiltersScanReserver");
-        }
-        g_scanfilter_in_progress = false;
-        m_could_reserve = false;
-    }
-
     ~BlockFiltersScanReserver() {
         if (m_could_reserve) {
-            release();
+            g_scanfilter_in_progress = false;
         }
     }
 };
@@ -2836,9 +2403,6 @@ static RPCHelpMan scanblocks()
             RPCResult{"when action=='status' and a scan is currently in progress", RPCResult::Type::OBJ, "", "", {
                     {RPCResult::Type::NUM, "progress", "Approximate percent complete"},
                     {RPCResult::Type::NUM, "current_height", "Height of the block currently being scanned"},
-                    {RPCResult::Type::ARR, "relevant_blocks", "Blocks that may have matched a scanobject.", {
-                        {RPCResult::Type::STR_HEX, "blockhash", "A relevant blockhash"},
-                    }},
                 },
             },
             scan_result_abort,
@@ -2853,20 +2417,15 @@ static RPCHelpMan scanblocks()
         },
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
 {
-    static GlobalMutex cs_relevant_blocks;
-    static UniValue relevant_blocks GUARDED_BY(cs_relevant_blocks);
-
     UniValue ret(UniValue::VOBJ);
     if (request.params[0].get_str() == "status") {
         BlockFiltersScanReserver reserver;
-        LOCK(cs_relevant_blocks);
         if (reserver.reserve()) {
             // no scan in progress
             return NullUniValue;
         }
         ret.pushKV("progress", g_scanfilter_progress.load());
         ret.pushKV("current_height", g_scanfilter_progress_height.load());
-        ret.pushKV("relevant_blocks", relevant_blocks);
         return ret;
     } else if (request.params[0].get_str() == "abort") {
         BlockFiltersScanReserver reserver;
@@ -2878,11 +2437,6 @@ static RPCHelpMan scanblocks()
         g_scanfilter_should_abort_scan = true;
         return true;
     } else if (request.params[0].get_str() == "start") {
-        {
-            LOCK(cs_relevant_blocks);
-            relevant_blocks = UniValue(UniValue::VARR);
-        }
-
         BlockFiltersScanReserver reserver;
         if (!reserver.reserve()) {
             throw JSONRPCError(RPC_INVALID_PARAMETER, "Scan already in progress, use action \"abort\" or \"status\"");
@@ -2938,7 +2492,7 @@ static RPCHelpMan scanblocks()
                 needle_set.emplace(script.begin(), script.end());
             }
         }
-
+        UniValue blocks(UniValue::VARR);
         const int amount_per_chunk = 10000;
         std::vector<BlockFilter> filters;
         int start_block_height = start_index->nHeight; // for progress reporting
@@ -2976,8 +2530,7 @@ static RPCHelpMan scanblocks()
                             }
                         }
 
-                        LOCK(cs_relevant_blocks);
-                        relevant_blocks.push_back(filter.GetBlockHash().GetHex());
+                        blocks.push_back(filter.GetBlockHash().GetHex());
                     }
                 }
             }
@@ -2997,10 +2550,8 @@ static RPCHelpMan scanblocks()
 
         ret.pushKV("from_height", start_block_height);
         ret.pushKV("to_height", start_index->nHeight); // start_index is always the last scanned block here
-        LOCK(cs_relevant_blocks);
-        ret.pushKV("relevant_blocks", std::move(relevant_blocks));
+        ret.pushKV("relevant_blocks", std::move(blocks));
         ret.pushKV("completed", completed);
-        reserver.release(); // ensure this is before cs_relevant_blocks is released, so status doesn't try to use moved relevant_blocks
     }
     else {
         throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Invalid action '%s'", request.params[0].get_str()));
@@ -3010,243 +2561,13 @@ static RPCHelpMan scanblocks()
     };
 }
 
-static RPCHelpMan getdescriptoractivity()
-{
-    return RPCHelpMan{"getdescriptoractivity",
-        "\nGet spend and receive activity associated with a set of descriptors for a set of blocks. "
-        "This command pairs well with the `relevant_blocks` output of `scanblocks()`.\n"
-        "This call may take several minutes. If you encounter timeouts, try specifying no RPC timeout (bitcoin-cli -rpcclienttimeout=0)",
-        {
-            RPCArg{"blockhashes", RPCArg::Type::ARR, RPCArg::Optional::OMITTED, "The list of blockhashes to examine for activity. Order doesn't matter. Must be along main chain or an error is thrown.\n", {
-                {"blockhash", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, "A valid blockhash"},
-            }},
-            scan_objects_arg_desc,
-            {"include_mempool", RPCArg::Type::BOOL, RPCArg::Default{true}, "Whether to include unconfirmed activity"},
-        },
-        RPCResult{
-            RPCResult::Type::OBJ, "", "", {
-                {RPCResult::Type::ARR, "activity", "events", {
-                    {RPCResult::Type::OBJ, "", "", {
-                        {RPCResult::Type::STR, "type", "always 'spend'"},
-                        {RPCResult::Type::STR_AMOUNT, "amount", "The total amount in " + CURRENCY_UNIT + " of the spent output"},
-                        {RPCResult::Type::STR_HEX, "blockhash", /*optional=*/true, "The blockhash this spend appears in (omitted if unconfirmed)"},
-                        {RPCResult::Type::NUM, "height", /*optional=*/true, "Height of the spend (omitted if unconfirmed)"},
-                        {RPCResult::Type::STR_HEX, "spend_txid", "The txid of the spending transaction"},
-                        {RPCResult::Type::NUM, "spend_vout", "The vout of the spend"},
-                        {RPCResult::Type::STR_HEX, "prevout_txid", "The txid of the prevout"},
-                        {RPCResult::Type::NUM, "prevout_vout", "The vout of the prevout"},
-                        {RPCResult::Type::OBJ, "prevout_spk", "", ScriptPubKeyDoc()},
-                    }},
-                    {RPCResult::Type::OBJ, "", "", {
-                        {RPCResult::Type::STR, "type", "always 'receive'"},
-                        {RPCResult::Type::STR_AMOUNT, "amount", "The total amount in " + CURRENCY_UNIT + " of the new output"},
-                        {RPCResult::Type::STR_HEX, "blockhash", /*optional=*/true, "The block that this receive is in (omitted if unconfirmed)"},
-                        {RPCResult::Type::NUM, "height", /*optional=*/true, "The height of the receive (omitted if unconfirmed)"},
-                        {RPCResult::Type::STR_HEX, "txid", "The txid of the receiving transaction"},
-                        {RPCResult::Type::NUM, "vout", "The vout of the receiving output"},
-                        {RPCResult::Type::OBJ, "output_spk", "", ScriptPubKeyDoc()},
-                    }},
-                    // TODO is the skip_type_check avoidable with a heterogeneous ARR?
-                }, /*skip_type_check=*/true},
-            },
-        },
-        RPCExamples{
-            HelpExampleCli("getdescriptoractivity", "'[\"000000000000000000001347062c12fded7c528943c8ce133987e2e2f5a840ee\"]' '[\"addr(bc1qzl6nsgqzu89a66l50cvwapnkw5shh23zarqkw9)\"]'")
-        },
-        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
-{
-    UniValue ret(UniValue::VOBJ);
-    UniValue activity(UniValue::VARR);
-    NodeContext& node = EnsureAnyNodeContext(request.context);
-    ChainstateManager& chainman = EnsureChainman(node);
-
-    struct CompareByHeightAscending {
-        bool operator()(const CBlockIndex* a, const CBlockIndex* b) const {
-            return a->nHeight < b->nHeight;
-        }
-    };
-
-    std::set<const CBlockIndex*, CompareByHeightAscending> blockindexes_sorted;
-
-    {
-        // Validate all given blockhashes, and ensure blocks are along a single chain.
-        LOCK(::cs_main);
-        for (const UniValue& blockhash : request.params[0].get_array().getValues()) {
-            uint256 bhash = ParseHashV(blockhash, "blockhash");
-            CBlockIndex* pindex = chainman.m_blockman.LookupBlockIndex(bhash);
-            if (!pindex) {
-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Block not found");
-            }
-            if (!chainman.ActiveChain().Contains(pindex)) {
-                throw JSONRPCError(RPC_INVALID_PARAMETER, "Block is not in main chain");
-            }
-            blockindexes_sorted.insert(pindex);
-        }
-    }
-
-    std::set<CScript> scripts_to_watch;
-
-    // Determine scripts to watch.
-    for (const UniValue& scanobject : request.params[1].get_array().getValues()) {
-        FlatSigningProvider provider;
-        std::vector<CScript> scripts = EvalDescriptorStringOrObject(scanobject, provider);
-
-        for (const CScript& script : scripts) {
-            scripts_to_watch.insert(script);
-        }
-    }
-
-    const auto AddSpend = [&](
-            const CScript& spk,
-            const CAmount val,
-            const CTransactionRef& tx,
-            int vin,
-            const CTxIn& txin,
-            const CBlockIndex* index
-            ) {
-        UniValue event(UniValue::VOBJ);
-        UniValue spkUv(UniValue::VOBJ);
-        ScriptToUniv(spk, /*out=*/spkUv, /*include_hex=*/true, /*include_address=*/true);
-
-        event.pushKV("type", "spend");
-        event.pushKV("amount", ValueFromAmount(val));
-        if (index) {
-            event.pushKV("blockhash", index->GetBlockHash().ToString());
-            event.pushKV("height", index->nHeight);
-        }
-        event.pushKV("spend_txid", tx->GetHash().ToString());
-        event.pushKV("spend_vin", vin);
-        event.pushKV("prevout_txid", txin.prevout.hash.ToString());
-        event.pushKV("prevout_vout", txin.prevout.n);
-        event.pushKV("prevout_spk", spkUv);
-
-        return event;
-    };
-
-    const auto AddReceive = [&](const CTxOut& txout, const CBlockIndex* index, int vout, const CTransactionRef& tx) {
-        UniValue event(UniValue::VOBJ);
-        UniValue spkUv(UniValue::VOBJ);
-        ScriptToUniv(txout.scriptPubKey, /*out=*/spkUv, /*include_hex=*/true, /*include_address=*/true);
-
-        event.pushKV("type", "receive");
-        event.pushKV("amount", ValueFromAmount(txout.nValue));
-        if (index) {
-            event.pushKV("blockhash", index->GetBlockHash().ToString());
-            event.pushKV("height", index->nHeight);
-        }
-        event.pushKV("txid", tx->GetHash().ToString());
-        event.pushKV("vout", vout);
-        event.pushKV("output_spk", spkUv);
-
-        return event;
-    };
-
-    BlockManager* blockman;
-    Chainstate& active_chainstate = chainman.ActiveChainstate();
-    {
-        LOCK(::cs_main);
-        blockman = CHECK_NONFATAL(&active_chainstate.m_blockman);
-    }
-
-    for (const CBlockIndex* blockindex : blockindexes_sorted) {
-        const CBlock block{GetBlockChecked(chainman.m_blockman, *blockindex)};
-        const CBlockUndo block_undo{GetUndoChecked(*blockman, *blockindex)};
-
-        for (size_t i = 0; i < block.vtx.size(); ++i) {
-            const auto& tx = block.vtx.at(i);
-
-            if (!tx->IsCoinBase()) {
-                // skip coinbase; spends can't happen there.
-                const auto& txundo = block_undo.vtxundo.at(i - 1);
-
-                for (size_t vin_idx = 0; vin_idx < tx->vin.size(); ++vin_idx) {
-                    const auto& coin = txundo.vprevout.at(vin_idx);
-                    const auto& txin = tx->vin.at(vin_idx);
-                    if (scripts_to_watch.contains(coin.out.scriptPubKey)) {
-                        activity.push_back(AddSpend(
-                                    coin.out.scriptPubKey, coin.out.nValue, tx, vin_idx, txin, blockindex));
-                    }
-                }
-            }
-
-            for (size_t vout_idx = 0; vout_idx < tx->vout.size(); ++vout_idx) {
-                const auto& vout = tx->vout.at(vout_idx);
-                if (scripts_to_watch.contains(vout.scriptPubKey)) {
-                    activity.push_back(AddReceive(vout, blockindex, vout_idx, tx));
-                }
-            }
-        }
-    }
-
-    bool search_mempool = true;
-    if (!request.params[2].isNull()) {
-        search_mempool = request.params[2].get_bool();
-    }
-
-    if (search_mempool) {
-        const CTxMemPool& mempool = EnsureMemPool(node);
-        LOCK(::cs_main);
-        LOCK(mempool.cs);
-        const CCoinsViewCache& coins_view = &active_chainstate.CoinsTip();
-
-        for (const CTxMemPoolEntry& e : mempool.entryAll()) {
-            const auto& tx = e.GetSharedTx();
-
-            for (size_t vin_idx = 0; vin_idx < tx->vin.size(); ++vin_idx) {
-                CScript scriptPubKey;
-                CAmount value;
-                const auto& txin = tx->vin.at(vin_idx);
-                Coin coin;
-                const bool have_coin = coins_view.GetCoin(txin.prevout, coin);
-
-                // Check if the previous output is in the chain
-                if (!have_coin) {
-                    // If not found in the chain, check the mempool. Likely, this is a
-                    // child transaction of another transaction in the mempool.
-                    CTransactionRef prev_tx = CHECK_NONFATAL(mempool.get(txin.prevout.hash));
-
-                    if (txin.prevout.n >= prev_tx->vout.size()) {
-                        throw std::runtime_error("Invalid output index");
-                    }
-                    const CTxOut& out = prev_tx->vout[txin.prevout.n];
-                    scriptPubKey = out.scriptPubKey;
-                    value = out.nValue;
-                } else {
-                    // Coin found in the chain
-                    const CTxOut& out = coin.out;
-                    scriptPubKey = out.scriptPubKey;
-                    value = out.nValue;
-                }
-
-                if (scripts_to_watch.contains(scriptPubKey)) {
-                    UniValue event(UniValue::VOBJ);
-                    activity.push_back(AddSpend(
-                                scriptPubKey, value, tx, vin_idx, txin, nullptr));
-                }
-            }
-
-            for (size_t vout_idx = 0; vout_idx < tx->vout.size(); ++vout_idx) {
-                const auto& vout = tx->vout.at(vout_idx);
-                if (scripts_to_watch.contains(vout.scriptPubKey)) {
-                    activity.push_back(AddReceive(vout, nullptr, vout_idx, tx));
-                }
-            }
-        }
-    }
-
-    ret.pushKV("activity", activity);
-    return ret;
-},
-    };
-}
-
 static RPCHelpMan getblockfilter()
 {
     return RPCHelpMan{"getblockfilter",
                 "\nRetrieve a BIP 157 content filter for a particular block.\n",
                 {
                     {"blockhash", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "The hash of the block"},
-                    {"filtertype", RPCArg::Type::STR, RPCArg::Default{BlockFilterTypeName(BlockFilterType::BASIC)}, "The type name of the filter, values: " + ListBlockFilterTypes()},
+                    {"filtertype", RPCArg::Type::STR, RPCArg::Default{BlockFilterTypeName(BlockFilterType::BASIC)}, "The type name of the filter"},
                 },
                 RPCResult{
                     RPCResult::Type::OBJ, "", "",
@@ -3326,32 +2647,11 @@ static RPCHelpMan getblockfilter()
  */
 static RPCHelpMan dumptxoutset()
 {
-    static const std::vector<std::pair<std::string, coinascii_cb_t>> ascii_types{
-        {"txid",         [](const COutPoint& k, const Coin& c) { return k.hash.GetHex(); }},
-        {"vout",         [](const COutPoint& k, const Coin& c) { return util::ToString(static_cast<int32_t>(k.n)); }},
-        {"value",        [](const COutPoint& k, const Coin& c) { return util::ToString(c.out.nValue); }},
-        {"coinbase",     [](const COutPoint& k, const Coin& c) { return util::ToString(c.fCoinBase); }},
-        {"height",       [](const COutPoint& k, const Coin& c) { return util::ToString(static_cast<uint32_t>(c.nHeight)); }},
-        {"scriptPubKey", [](const COutPoint& k, const Coin& c) { return HexStr(c.out.scriptPubKey); }},
-        // add any other desired items here
-    };
-
-    std::vector<RPCArg> ascii_args;
-    std::transform(std::begin(ascii_types), std::end(ascii_types), std::back_inserter(ascii_args),
-            [](const std::pair<std::string, coinascii_cb_t>& t) { return RPCArg{t.first, RPCArg::Type::STR, RPCArg::Optional::OMITTED, "Info to write for a given UTXO"}; });
-
     return RPCHelpMan{
         "dumptxoutset",
-        "Write the UTXO set to a file.",
+        "Write the serialized UTXO set to a file.",
         {
             {"path", RPCArg::Type::STR, RPCArg::Optional::NO, "Path to the output file. If relative, will be prefixed by datadir."},
-            {"format", RPCArg::Type::ARR, RPCArg::DefaultHint{"compact serialized format"},
-                                        "If no argument is provided, a compact binary serialized format is used; otherwise only requested items "
-                                        "available below are written in ASCII format (if an empty array is provided, all items are written in ASCII).",
-                                        ascii_args,
-                                        RPCArgOptions{.oneline_description="format"}},
-            {"show_header", RPCArg::Type::BOOL, RPCArg::Default{true}, "Whether to include the header line in non-serialized (ASCII) mode"},
-            {"separator", RPCArg::Type::STR, RPCArg::Default{","}, "Field separator to use in non-serialized (ASCII) mode"},
         },
         RPCResult{
             RPCResult::Type::OBJ, "", "",
@@ -3365,51 +2665,24 @@ static RPCHelpMan dumptxoutset()
                 }
         },
         RPCExamples{
-            HelpExampleCli("dumptxoutset", "utxo.dat") +
-            HelpExampleCli("dumptxoutset", "utxo.dat '[]'") +
-            HelpExampleCli("dumptxoutset", "utxo.dat '[\"txid\", \"vout\"]' false ':'")
+            HelpExampleCli("dumptxoutset", "utxo.dat")
         },
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
 {
-    EnsureNotWalletRestricted(request);
-
-    // handle optional ASCII parameters
-    const bool is_human_readable = !request.params[1].isNull();
-    const bool show_header = request.params[2].isNull() || request.params[2].get_bool();
-    const auto separator = request.params[3].isNull() ? MakeByteSpan(",").first(1) : MakeByteSpan(request.params[3].get_str());
-    std::vector<std::pair<std::string, coinascii_cb_t>> requested;
-    if (is_human_readable) {
-        const auto& arr = request.params[1].get_array();
-        const std::unordered_map<std::string, coinascii_cb_t> ascii_map(std::begin(ascii_types), std::end(ascii_types));
-        for (size_t i = 0; i < arr.size(); ++i) {
-            const auto it = ascii_map.find(arr[i].get_str());
-            if (it == std::end(ascii_map))
-                throw JSONRPCError(RPC_INVALID_PARAMETER, "unable to find item '"+arr[i].get_str()+"'");
-
-            requested.emplace_back(*it);
-        }
-
-        // if nothing was found, shows everything by default
-        if (requested.size() == 0)
-            requested = ascii_types;
-    }
-
     const ArgsManager& args{EnsureAnyArgsman(request.context)};
     const fs::path path = fsbridge::AbsPathJoin(args.GetDataDirNet(), fs::u8path(request.params[0].get_str()));
-    const auto path_info{fs::status(path)};
     // Write to a temporary path and then move into `path` on completion
     // to avoid confusion due to an interruption.
-    const fs::path temppath = fs::is_fifo(path_info) ? path : // If a named pipe is passed, write directly to it
-        fsbridge::AbsPathJoin(args.GetDataDirNet(), fs::u8path(request.params[0].get_str() + ".incomplete"));
+    const fs::path temppath = fsbridge::AbsPathJoin(args.GetDataDirNet(), fs::u8path(request.params[0].get_str() + ".incomplete"));
 
-    if (fs::exists(path_info) && !fs::is_fifo(path_info)) {
+    if (fs::exists(path)) {
         throw JSONRPCError(
             RPC_INVALID_PARAMETER,
             path.utf8string() + " already exists. If you are sure this is what you want, "
             "move it out of the way first");
     }
 
-    FILE* file{fsbridge::fopen(temppath, !is_human_readable ? "wb" : "w")};
+    FILE* file{fsbridge::fopen(temppath, "wb")};
     AutoFile afile{file};
     if (afile.IsNull()) {
         throw JSONRPCError(
@@ -3419,10 +2692,8 @@ static RPCHelpMan dumptxoutset()
 
     NodeContext& node = EnsureAnyNodeContext(request.context);
     UniValue result = CreateUTXOSnapshot(
-        is_human_readable,
-        show_header, separator, requested,
         node, node.chainman->ActiveChainstate(), afile, path, temppath);
-    if (!fs::is_fifo(path_info)) fs::rename(temppath, path);
+    fs::rename(temppath, path);
 
     result.pushKV("path", path.utf8string());
     return result;
@@ -3431,10 +2702,6 @@ static RPCHelpMan dumptxoutset()
 }
 
 UniValue CreateUTXOSnapshot(
-    const bool is_human_readable,
-    const bool show_header,
-    const Span<const std::byte>& separator,
-    const std::vector<std::pair<std::string, coinascii_cb_t>>& requested,
     NodeContext& node,
     Chainstate& chainstate,
     AutoFile& afile,
@@ -3445,9 +2712,6 @@ UniValue CreateUTXOSnapshot(
     std::optional<CCoinsStats> maybe_stats;
     const CBlockIndex* tip;
 
-    // used when human readable format is requested
-    const auto line_separator = MakeByteSpan("\n").first(1);
-
     {
         // We need to lock cs_main to ensure that the coinsdb isn't written to
         // between (i) flushing coins cache to disk (coinsdb), (ii) getting stats
@@ -3478,20 +2742,9 @@ UniValue CreateUTXOSnapshot(
         tip->nHeight, tip->GetBlockHash().ToString(),
         fs::PathToString(path), fs::PathToString(temppath)));
 
-    if (!is_human_readable) {
     SnapshotMetadata metadata{chainstate.m_chainman.GetParams().MessageStart(), tip->GetBlockHash(), maybe_stats->coins_count};
 
     afile << metadata;
-    } else if (show_header) {
-        afile.write(MakeByteSpan("#(blockhash " + tip->GetBlockHash().ToString() + " ) "));
-        for (auto it = std::begin(requested); it != std::end(requested); ++it) {
-            if (it != std::begin(requested)) {
-                afile.write(separator);
-            }
-            afile.write(MakeByteSpan(it->first));
-        }
-        afile.write(line_separator);
-    }
 
     COutPoint key;
     Txid last_hash;
@@ -3523,22 +2776,12 @@ UniValue CreateUTXOSnapshot(
         if (iter % 5000 == 0) node.rpc_interruption_point();
         ++iter;
         if (pcursor->GetKey(key) && pcursor->GetValue(coin)) {
-            if (!is_human_readable) {
             if (key.hash != last_hash) {
                 write_coins_to_file(afile, last_hash, coins, written_coins_count);
                 last_hash = key.hash;
                 coins.clear();
             }
             coins.emplace_back(key.n, coin);
-            } else {
-                for (auto it = std::begin(requested); it != std::end(requested); ++it) {
-                    if (it != std::begin(requested))
-                        afile.write(separator);
-                    afile.write(MakeByteSpan(it->second(key, coin)));
-                }
-                afile.write(line_separator);
-                ++written_coins_count;
-            }
         }
         pcursor->Next();
     }
@@ -3549,10 +2792,7 @@ UniValue CreateUTXOSnapshot(
 
     CHECK_NONFATAL(written_coins_count == maybe_stats->coins_count);
 
-    if (afile.fclose() != 0) {
-        throw std::ios_base::failure(
-            strprintf("Error closing %s: %s", fs::PathToString(temppath), SysErrorString(errno)));
-    }
+    afile.fclose();
 
     UniValue result(UniValue::VOBJ);
     result.pushKV("coins_written", written_coins_count);
@@ -3714,117 +2954,6 @@ return RPCHelpMan{
     };
 }
 
-static RPCHelpMan getblockfileinfo()
-{
-    return RPCHelpMan{
-            "getblockfileinfo",
-            "Retrieves information about a certain block file.",
-            {
-                {"file_number", RPCArg::Type::NUM, RPCArg::Optional::NO, "block file number"},
-            },
-            RPCResult{
-                    RPCResult::Type::OBJ, "", "",
-                    {
-                        {RPCResult::Type::NUM, "blocks_num", "the number of blocks stored in the file"},
-                        {RPCResult::Type::NUM, "lowest_block", "the height of the lowest block inside the file"},
-                        {RPCResult::Type::NUM, "highest_block", "the height of the highest block inside the file"},
-                        {RPCResult::Type::NUM, "data_size", "the number of used bytes in the block file"},
-                        {RPCResult::Type::NUM, "undo_size", "the number of used bytes in the undo file"},
-                    }
-            },
-            RPCExamples{ HelpExampleCli("getblockfileinfo", "0") },
-            [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue {
-                NodeContext& node = EnsureAnyNodeContext(request.context);
-
-                int block_num = request.params[0].getInt<int>();
-                if (block_num < 0) throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid block number");
-
-                CBlockFileInfo* info = node.chainman->m_blockman.GetBlockFileInfo(block_num);
-                if (!info) throw JSONRPCError(RPC_INVALID_PARAMETER, "block file not found");
-
-                UniValue result(UniValue::VOBJ);
-                result.pushKV("blocks_num", info->nBlocks);
-                result.pushKV("lowest_block", info->nHeightFirst);
-                result.pushKV("highest_block", info->nHeightLast);
-                result.pushKV("data_size", info->nSize);
-                result.pushKV("undo_size", info->nUndoSize);
-
-                return result;
-            }
-    };
-}
-
-static RPCHelpMan getblocklocations()
-{
-    return RPCHelpMan{"getblocklocations",
-                "\nEXPERIMENTAL warning: this call may be removed or changed in future releases.\n"
-                "\nReturns a JSON for the file system location of 'blockhash' block and undo data.\n"
-                "\nIt is possible to return also the locations of previous blocks, by specifying 'nblocks' > 1.\n",
-                {
-                    {"blockhash", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "The block hash"},
-                    {"nblocks", RPCArg::Type::NUM, RPCArg::Optional::NO, "Maximum number locations to return (up to genesis block)"},
-                },
-                {
-                    RPCResult{
-                        RPCResult::Type::ARR, "", "",
-                        {
-                            {RPCResult::Type::OBJ, "", "",
-                            {
-                                {RPCResult::Type::NUM, "file", "blk*.dat/rev*.dat file index"},
-                                {RPCResult::Type::NUM, "data", "block data file offset"},
-                                {RPCResult::Type::NUM, "undo", /*optional=*/true, "undo data file offset (if exists)"},
-                                {RPCResult::Type::STR_HEX, "prev", "previous block hash"},
-                            }},
-                        }
-                    },
-                },
-                RPCExamples{
-                    HelpExampleCli("getblocklocations", "\"00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09\" 10")
-                },
-                [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue {
-
-    ChainstateManager& chainman = EnsureAnyChainman(request.context);
-    if (chainman.m_blockman.IsPruneMode()) {
-        throw JSONRPCError(RPC_MISC_ERROR, "Block locations are not available in prune mode");
-    }
-
-    uint256 hash(ParseHashV(request.params[0], "blockhash"));
-    size_t nblocks = request.params[1].getInt<size_t>();
-
-    const CBlockIndex* pblockindex = WITH_LOCK(cs_main, return chainman.m_blockman.LookupBlockIndex(hash));
-    if (!pblockindex) {
-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Block not found");
-    }
-
-    UniValue result(UniValue::VARR);
-    do {
-        int64_t file_num;
-        uint64_t data_pos, undo_pos;
-        {
-            LOCK(::cs_main);
-            file_num = pblockindex->nFile;
-            data_pos = pblockindex->nDataPos;
-            undo_pos = pblockindex->nUndoPos;
-        }
-        UniValue location(UniValue::VOBJ);
-        location.pushKV("file", file_num);
-        location.pushKV("data", data_pos);
-        if (undo_pos) {
-            location.pushKV("undo", undo_pos);
-        }
-        if (pblockindex->pprev) {
-            location.pushKV("prev", pblockindex->pprev->GetBlockHash().GetHex());
-        } else {
-            location.pushKV("prev", uint256().GetHex());
-        }
-        result.push_back(location);
-        pblockindex = pblockindex->pprev;
-    } while (result.size() < nblocks && pblockindex);
-    return result;
-},
-    };
-}
-
 
 void RegisterBlockchainRPCCommands(CRPCTable& t)
 {
@@ -3843,32 +2972,21 @@ void RegisterBlockchainRPCCommands(CRPCTable& t)
         {"blockchain", &getdeploymentinfo},
         {"blockchain", &gettxout},
         {"blockchain", &gettxoutsetinfo},
-        {"blockchain", &listprunelocks},
-        {"blockchain", &setprunelock},
         {"blockchain", &pruneblockchain},
         {"blockchain", &verifychain},
-        {"blockchain", &scriptthreadsinfo},
-        {"blockchain", &setscriptthreadsenabled},
         {"blockchain", &preciousblock},
         {"blockchain", &scantxoutset},
         {"blockchain", &scanblocks},
-        {"blockchain", &getdescriptoractivity},
         {"blockchain", &getblockfilter},
         {"blockchain", &dumptxoutset},
         {"blockchain", &loadtxoutset},
         {"blockchain", &getchainstates},
-        {"hidden", &getblockfileinfo},
         {"hidden", &invalidateblock},
         {"hidden", &reconsiderblock},
         {"hidden", &waitfornewblock},
         {"hidden", &waitforblock},
         {"hidden", &waitforblockheight},
         {"hidden", &syncwithvalidationinterfacequeue},
-        {"hidden", &getblocklocations},
-
-#ifdef ENABLE_WALLET
-        {"wallet", &sweepprivkeys},
-#endif
     };
     for (const auto& c : commands) {
         t.appendCommand(c.name, &c);
diff --git a/src/rpc/blockchain.h b/src/rpc/blockchain.h
index 2ea02ed482..f6a7fe236c 100644
--- a/src/rpc/blockchain.h
+++ b/src/rpc/blockchain.h
@@ -5,10 +5,8 @@
 #ifndef BITCOIN_RPC_BLOCKCHAIN_H
 #define BITCOIN_RPC_BLOCKCHAIN_H
 
-#include <coins.h>
 #include <consensus/amount.h>
 #include <core_io.h>
-#include <span.h>
 #include <streams.h>
 #include <sync.h>
 #include <util/fs.h>
@@ -28,7 +26,6 @@ struct NodeContext;
 } // namespace node
 
 static constexpr int NUM_GETBLOCKSTATS_PERCENTILES = 5;
-using coinascii_cb_t = std::function<std::string(const COutPoint&, const Coin&)>;
 
 /**
  * Get the difficulty of the net wrt to the given block index.
@@ -55,10 +52,6 @@ void CalculatePercentilesByWeight(CAmount result[NUM_GETBLOCKSTATS_PERCENTILES],
  * @return a UniValue map containing metadata about the snapshot.
  */
 UniValue CreateUTXOSnapshot(
-    const bool is_human_readable,
-    const bool show_header,
-    const Span<const std::byte>& separator,
-    const std::vector<std::pair<std::string, coinascii_cb_t>>& requested,
     node::NodeContext& node,
     Chainstate& chainstate,
     AutoFile& afile,
diff --git a/src/rpc/client.cpp b/src/rpc/client.cpp
index 4fee4e6c4d..b866fa484b 100644
--- a/src/rpc/client.cpp
+++ b/src/rpc/client.cpp
@@ -32,7 +32,6 @@ static const CRPCConvertParam vRPCConvertParams[] =
     { "setmocktime", 0, "timestamp" },
     { "mockscheduler", 0, "delta_time" },
     { "utxoupdatepsbt", 1, "descriptors" },
-    { "utxoupdatepsbt", 2, "prevtxs" },
     { "generatetoaddress", 0, "nblocks" },
     { "generatetoaddress", 2, "maxtries" },
     { "generatetodescriptor", 0, "num_blocks" },
@@ -48,7 +47,6 @@ static const CRPCConvertParam vRPCConvertParams[] =
     { "sendtoaddress", 8, "avoid_reuse" },
     { "sendtoaddress", 9, "fee_rate"},
     { "sendtoaddress", 10, "verbose"},
-    { "setfeerate", 0, "amount" },
     { "settxfee", 0, "amount" },
     { "sethdseed", 0, "newkeypool" },
     { "getreceivedbyaddress", 1, "minconf" },
@@ -67,9 +65,7 @@ static const CRPCConvertParam vRPCConvertParams[] =
     { "getbalance", 2, "include_watchonly" },
     { "getbalance", 3, "avoid_reuse" },
     { "getblockfrompeer", 1, "peer_id" },
-    { "getblockfrompeer", 1, "nodeid" },
     { "getblockhash", 0, "height" },
-    { "maxmempool", 0, "megabytes" },
     { "waitforblockheight", 0, "height" },
     { "waitforblockheight", 1, "timeout" },
     { "waitforblock", 1, "timeout" },
@@ -91,29 +87,16 @@ static const CRPCConvertParam vRPCConvertParams[] =
     { "sendmany", 8, "fee_rate"},
     { "sendmany", 9, "verbose" },
     { "deriveaddresses", 1, "range" },
-    { "deriveaddresses", 2, "options" },
-    { "deriveaddresses", 2, "require_checksum" },
     { "scanblocks", 1, "scanobjects" },
     { "scanblocks", 2, "start_height" },
     { "scanblocks", 3, "stop_height" },
     { "scanblocks", 5, "options" },
     { "scanblocks", 5, "filter_false_positives" },
-    { "getdescriptoractivity", 0, "blockhashes" },
-    { "getdescriptoractivity", 1, "scanobjects" },
-    { "getdescriptoractivity", 2, "include_mempool" },
-    { "sweepprivkeys", 0, "options" },
-    { "sweepprivkeys", 0, "privkeys" },
     { "scantxoutset", 1, "scanobjects" },
-    { "dumptxoutset", 1, "format" },
-    { "dumptxoutset", 2, "show_header" },
     { "addmultisigaddress", 0, "nrequired" },
     { "addmultisigaddress", 1, "keys" },
-    { "addmultisigaddress", 2, "options" },
-    { "addmultisigaddress", 2, "sort" },
     { "createmultisig", 0, "nrequired" },
     { "createmultisig", 1, "keys" },
-    { "createmultisig", 2, "options" },
-    { "createmultisig", 2, "sort" },
     { "listunspent", 0, "minconf" },
     { "listunspent", 1, "maxconf" },
     { "listunspent", 2, "addresses" },
@@ -127,7 +110,6 @@ static const CRPCConvertParam vRPCConvertParams[] =
     { "getblock", 1, "verbosity" },
     { "getblock", 1, "verbose" },
     { "getblockheader", 1, "verbose" },
-    { "getblocklocations", 1, "nblocks" },
     { "getchaintxstats", 0, "nblocks" },
     { "gettransaction", 1, "include_watchonly" },
     { "gettransaction", 2, "verbose" },
@@ -143,10 +125,8 @@ static const CRPCConvertParam vRPCConvertParams[] =
     { "signrawtransactionwithwallet", 1, "prevtxs" },
     { "sendrawtransaction", 1, "maxfeerate" },
     { "sendrawtransaction", 2, "maxburnamount" },
-    { "sendrawtransaction", 3, "ignore_rejects" },
     { "testmempoolaccept", 0, "rawtxs" },
     { "testmempoolaccept", 1, "maxfeerate" },
-    { "testmempoolaccept", 2, "ignore_rejects" },
     { "submitpackage", 0, "package" },
     { "submitpackage", 1, "maxfeerate" },
     { "submitpackage", 2, "maxburnamount" },
@@ -161,7 +141,6 @@ static const CRPCConvertParam vRPCConvertParams[] =
     { "fundrawtransaction", 1, "lockUnspents"},
     { "fundrawtransaction", 1, "fee_rate"},
     { "fundrawtransaction", 1, "feeRate"},
-    { "fundrawtransaction", 1, "segwit_inputs_only"},
     { "fundrawtransaction", 1, "subtractFeeFromOutputs"},
     { "fundrawtransaction", 1, "input_weights"},
     { "fundrawtransaction", 1, "conf_target"},
@@ -188,17 +167,10 @@ static const CRPCConvertParam vRPCConvertParams[] =
     { "walletcreatefundedpsbt", 3, "solving_data"},
     { "walletcreatefundedpsbt", 3, "max_tx_weight"},
     { "walletcreatefundedpsbt", 4, "bip32derivs" },
-    { "walletprocesspsbt", 1, "options" },
     { "walletprocesspsbt", 1, "sign" },
-    { "walletprocesspsbt", 1, "bip32derivs" },
-    { "walletprocesspsbt", 1, "finalize" },
     { "walletprocesspsbt", 3, "bip32derivs" },
     { "walletprocesspsbt", 4, "finalize" },
     { "descriptorprocesspsbt", 1, "descriptors"},
-    { "descriptorprocesspsbt", 2, "options" },
-    { "descriptorprocesspsbt", 2, "bip32derivs" },
-    { "descriptorprocesspsbt", 2, "finalize" },
-    { "descriptorprocesspsbt", 2, "prevtxs" },
     { "descriptorprocesspsbt", 3, "bip32derivs" },
     { "descriptorprocesspsbt", 4, "finalize" },
     { "createpsbt", 0, "inputs" },
@@ -271,25 +243,19 @@ static const CRPCConvertParam vRPCConvertParams[] =
     { "importmulti", 1, "options" },
     { "importmulti", 1, "rescan" },
     { "importdescriptors", 0, "requests" },
-    { "importdescriptors", 1, "seeds" },
     { "listdescriptors", 0, "private" },
     { "verifychain", 0, "checklevel" },
     { "verifychain", 1, "nblocks" },
     { "getblockstats", 0, "hash_or_height" },
     { "getblockstats", 1, "stats" },
-    { "getblockfileinfo", 0, "file_number" },
-    { "setprunelock", 1, "lock_info" },
     { "pruneblockchain", 0, "height" },
     { "keypoolrefill", 0, "newsize" },
-    { "getmempoolinfo", 0, "fee_histogram" },
-    { "getmempoolinfo", 0, "with_fee_histogram" },
     { "getrawmempool", 0, "verbose" },
     { "getrawmempool", 1, "mempool_sequence" },
-    { "getorphantxs", 0, "verbosity" },
     { "estimatesmartfee", 0, "conf_target" },
     { "estimaterawfee", 0, "conf_target" },
     { "estimaterawfee", 1, "threshold" },
-    { "prioritisetransaction", 1, "priority_delta" },
+    { "prioritisetransaction", 1, "dummy" },
     { "prioritisetransaction", 2, "fee_delta" },
     { "setban", 2, "bantime" },
     { "setban", 3, "absolute" },
@@ -332,7 +298,6 @@ static const CRPCConvertParam vRPCConvertParams[] =
     { "echojson", 9, "arg9" },
     { "rescanblockchain", 0, "start_height"},
     { "rescanblockchain", 1, "stop_height"},
-    { "setscriptthreadsenabled", 0, "state"},
     { "createwallet", 1, "disable_private_keys"},
     { "createwallet", 2, "blank"},
     { "createwallet", 4, "avoid_reuse"},
@@ -349,8 +314,6 @@ static const CRPCConvertParam vRPCConvertParams[] =
     { "stop", 0, "wait" },
     { "addnode", 2, "v2transport" },
     { "addconnection", 2, "v2transport" },
-    { "listmempooltransactions", 0, "start_sequence"},
-    { "listmempooltransactions", 1, "verbose"},
 };
 // clang-format on
 
diff --git a/src/rpc/fees.cpp b/src/rpc/fees.cpp
index c218495223..10caa9ed2e 100644
--- a/src/rpc/fees.cpp
+++ b/src/rpc/fees.cpp
@@ -214,36 +214,10 @@ static RPCHelpMan estimaterawfee()
     };
 }
 
-static RPCHelpMan savefeeestimates()
-{
-    return RPCHelpMan{"savefeeestimates",
-                "\nDumps the fee estimates to disk. It will fail until the previous dump is fully loaded.\n",
-                {},
-                RPCResult{RPCResult::Type::NONE, "", ""},
-                RPCExamples{
-                    HelpExampleCli("savefeeestimates", "")
-            + HelpExampleRpc("savefeeestimates", "")
-                },
-        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
-{
-    static Mutex dump_mutex;
-    LOCK(dump_mutex);
-    CBlockPolicyEstimator& fee_estimator = EnsureAnyFeeEstimator(request.context);
-
-    if (!fee_estimator.FlushFeeEstimates()) {
-        throw JSONRPCError(RPC_MISC_ERROR, "Unable to dump fee estimates to disk");
-    }
-
-    return NullUniValue;
-},
-    };
-}
-
 void RegisterFeeRPCCommands(CRPCTable& t)
 {
     static const CRPCCommand commands[]{
         {"util", &estimatesmartfee},
-        {"util", &savefeeestimates},
         {"hidden", &estimaterawfee},
     };
     for (const auto& c : commands) {
diff --git a/src/rpc/mempool.cpp b/src/rpc/mempool.cpp
index e4360a0561..d61898260b 100644
--- a/src/rpc/mempool.cpp
+++ b/src/rpc/mempool.cpp
@@ -8,33 +8,23 @@
 #include <node/mempool_persist.h>
 
 #include <chainparams.h>
-#include <consensus/validation.h>
 #include <core_io.h>
 #include <kernel/mempool_entry.h>
-#include <net_processing.h>
-#include <node/context.h>
 #include <node/mempool_persist_args.h>
 #include <node/types.h>
 #include <policy/rbf.h>
 #include <policy/settings.h>
 #include <primitives/transaction.h>
-#include <rpc/mempool.h>
-#include <rpc/rawtransaction.h>
-#include <rpc/mempool.h>
 #include <rpc/server.h>
 #include <rpc/server_util.h>
 #include <rpc/util.h>
 #include <txmempool.h>
 #include <univalue.h>
-#include <util/any.h>
 #include <util/fs.h>
 #include <util/moneystr.h>
 #include <util/strencodings.h>
 #include <util/time.h>
-#include <util/vector.h>
-#include <validation.h>
 
-#include <optional>
 #include <utility>
 
 using node::DumpMempool;
@@ -59,20 +49,11 @@ static RPCHelpMan sendrawtransaction()
             {"hexstring", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "The hex string of the raw transaction"},
             {"maxfeerate", RPCArg::Type::AMOUNT, RPCArg::Default{FormatMoney(DEFAULT_MAX_RAW_TX_FEE_RATE.GetFeePerK())},
              "Reject transactions whose fee rate is higher than the specified value, expressed in " + CURRENCY_UNIT +
-                 "/kvB.\nFee rates larger than 1BTC/kvB are rejected.\nSet to 0 to accept any fee rate.",
-                RPCArgOptions{.skip_type_check = true}  // for ignore_rejects compatibility
-            },
+                 "/kvB.\nFee rates larger than 1BTC/kvB are rejected.\nSet to 0 to accept any fee rate."},
             {"maxburnamount", RPCArg::Type::AMOUNT, RPCArg::Default{FormatMoney(DEFAULT_MAX_BURN_AMOUNT)},
              "Reject transactions with provably unspendable outputs (e.g. 'datacarrier' outputs that use the OP_RETURN opcode) greater than the specified value, expressed in " + CURRENCY_UNIT + ".\n"
              "If burning funds through unspendable outputs is desired, increase this value.\n"
-             "This check is based on heuristics and does not guarantee spendability of outputs.\n",
-                RPCArgOptions{.skip_type_check = true}  // for ignore_rejects compatibility
-            },
-            {"ignore_rejects", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, "Rejection conditions to ignore, eg 'txn-mempool-conflict'",
-                {
-                    {"reject_reason", RPCArg::Type::STR, RPCArg::Optional::OMITTED, ""},
-                },
-            },
+             "This check is based on heuristics and does not guarantee spendability of outputs.\n"},
         },
         RPCResult{
             RPCResult::Type::STR_HEX, "", "The transaction hash in hex"
@@ -89,24 +70,7 @@ static RPCHelpMan sendrawtransaction()
                 },
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
         {
-            CFeeRate max_raw_tx_fee_rate{DEFAULT_MAX_RAW_TX_FEE_RATE};
-            CAmount max_burn_amount{0};
-            const UniValue* json_ign_rejs = &request.params[3];
-
-            if (request.params[1].isArray() && request.params[2].isNull() && request.params[3].isNull()) {
-                // ignore_rejects used to occupy this position (v0.12.0.knots20160226.rc1-v0.17.1.knots20181229)
-                json_ign_rejs = &request.params[1];
-            } else {
-                if (!request.params[1].isNull()) {
-                    max_raw_tx_fee_rate = ParseFeeRate(self.Arg<UniValue>("maxfeerate"));
-                }
-                if (request.params[2].isArray() && request.params[3].isNull()) {
-                    // ignore_rejects used to occupy this position (v0.18.0.knots20190502-v23.0.knots20220529)
-                    json_ign_rejs = &request.params[2];
-                } else if (!request.params[2].isNull()) {
-                    max_burn_amount = AmountFromValue(request.params[2]);
-                }
-            }
+            const CAmount max_burn_amount = request.params[2].isNull() ? 0 : AmountFromValue(request.params[2]);
 
             CMutableTransaction mtx;
             if (!DecodeHexTx(mtx, request.params[0].get_str())) {
@@ -121,18 +85,15 @@ static RPCHelpMan sendrawtransaction()
 
             CTransactionRef tx(MakeTransactionRef(std::move(mtx)));
 
-            ignore_rejects_type ignore_rejects;
-            if (!json_ign_rejs->isNull()) {
-                for (size_t i = 0; i < json_ign_rejs->size(); ++i) {
-                    const UniValue& json_ign_rej = (*json_ign_rejs)[i];
-                    ignore_rejects.insert(json_ign_rej.get_str());
-                }
-            }
+            const CFeeRate max_raw_tx_fee_rate{ParseFeeRate(self.Arg<UniValue>("maxfeerate"))};
+
+            int64_t virtual_size = GetVirtualTransactionSize(*tx);
+            CAmount max_raw_tx_fee = max_raw_tx_fee_rate.GetFee(virtual_size);
 
             std::string err_string;
             AssertLockNotHeld(cs_main);
             NodeContext& node = EnsureAnyNodeContext(request.context);
-            const TransactionError err = BroadcastTransaction(node, tx, err_string, max_raw_tx_fee_rate, /*relay=*/true, /*wait_callback=*/true, ignore_rejects);
+            const TransactionError err = BroadcastTransaction(node, tx, err_string, max_raw_tx_fee, /*relay=*/true, /*wait_callback=*/true);
             if (TransactionError::OK != err) {
                 throw JSONRPCTransactionError(err, err_string);
             }
@@ -160,11 +121,6 @@ static RPCHelpMan testmempoolaccept()
             {"maxfeerate", RPCArg::Type::AMOUNT, RPCArg::Default{FormatMoney(DEFAULT_MAX_RAW_TX_FEE_RATE.GetFeePerK())},
              "Reject transactions whose fee rate is higher than the specified value, expressed in " + CURRENCY_UNIT +
                  "/kvB.\nFee rates larger than 1BTC/kvB are rejected.\nSet to 0 to accept any fee rate."},
-            {"ignore_rejects", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, "Rejection conditions to ignore, eg 'txn-mempool-conflict'",
-                {
-                    {"reject_reason", RPCArg::Type::STR, RPCArg::Optional::OMITTED, ""},
-                },
-            },
         },
         RPCResult{
             RPCResult::Type::ARR, "", "The result of the mempool acceptance test for each raw transaction in the input array.\n"
@@ -211,16 +167,6 @@ static RPCHelpMan testmempoolaccept()
 
             const CFeeRate max_raw_tx_fee_rate{ParseFeeRate(self.Arg<UniValue>("maxfeerate"))};
 
-            const UniValue* json_ign_rejs = &request.params[2];
-            ignore_rejects_type ignore_rejects;
-            if (!json_ign_rejs->isNull()) {
-                for (size_t i = 0; i < json_ign_rejs->size(); ++i) {
-                    const UniValue& json_ign_rej = (*json_ign_rejs)[i];
-                    const std::string& ign_rej = json_ign_rej.get_str();
-                    ignore_rejects.insert(ign_rej);
-                }
-            }
-
             std::vector<CTransactionRef> txns;
             txns.reserve(raw_transactions.size());
             for (const auto& rawtx : raw_transactions.getValues()) {
@@ -238,9 +184,9 @@ static RPCHelpMan testmempoolaccept()
             Chainstate& chainstate = chainman.ActiveChainstate();
             const PackageMempoolAcceptResult package_result = [&] {
                 LOCK(::cs_main);
-                if (txns.size() > 1) return ProcessNewPackage(chainstate, mempool, txns, /*test_accept=*/true, /*client_maxfeerate=*/{}, ignore_rejects);
+                if (txns.size() > 1) return ProcessNewPackage(chainstate, mempool, txns, /*test_accept=*/true, /*client_maxfeerate=*/{});
                 return PackageMempoolAcceptResult(txns[0]->GetWitnessHash(),
-                                                  chainman.ProcessTransaction(txns[0], /*test_accept=*/true, ignore_rejects));
+                                                  chainman.ProcessTransaction(txns[0], /*test_accept=*/true));
             }();
 
             UniValue rpc_result(UniValue::VARR);
@@ -270,8 +216,7 @@ static RPCHelpMan testmempoolaccept()
                     // Check that fee does not exceed maximum fee
                     const int64_t virtual_size = tx_result.m_vsize.value();
                     const CAmount max_raw_tx_fee = max_raw_tx_fee_rate.GetFee(virtual_size);
-                    if (max_raw_tx_fee && fee > max_raw_tx_fee &&
-                        0 == (ignore_rejects.count("absurdly-high-fee") + ignore_rejects.count("max-fee-exceeded"))) {
+                    if (max_raw_tx_fee && fee > max_raw_tx_fee) {
                         result_inner.pushKV("allowed", false);
                         result_inner.pushKV("reject-reason", "max-fee-exceeded");
                         exit_early = true;
@@ -313,13 +258,10 @@ static std::vector<RPCResult> MempoolEntryDescription()
         RPCResult{RPCResult::Type::NUM, "weight", "transaction weight as defined in BIP 141."},
         RPCResult{RPCResult::Type::NUM_TIME, "time", "local time transaction entered pool in seconds since 1 Jan 1970 GMT"},
         RPCResult{RPCResult::Type::NUM, "height", "block height when transaction entered pool"},
-        RPCResult{RPCResult::Type::NUM, "startingpriority", "Priority when transaction entered pool"},
-        RPCResult{RPCResult::Type::NUM, "currentpriority", "Transaction priority now"},
         RPCResult{RPCResult::Type::NUM, "descendantcount", "number of in-mempool descendant transactions (including this one)"},
         RPCResult{RPCResult::Type::NUM, "descendantsize", "virtual transaction size of in-mempool descendants (including this one)"},
         RPCResult{RPCResult::Type::NUM, "ancestorcount", "number of in-mempool ancestor transactions (including this one)"},
         RPCResult{RPCResult::Type::NUM, "ancestorsize", "virtual transaction size of in-mempool ancestors (including this one)"},
-        RPCResult{RPCResult::Type::STR_HEX, "hash", "hash of entire serialized transaction"},
         RPCResult{RPCResult::Type::STR_HEX, "wtxid", "hash of serialized transaction, including witness data"},
         RPCResult{RPCResult::Type::OBJ, "fees", "",
             {
@@ -337,7 +279,7 @@ static std::vector<RPCResult> MempoolEntryDescription()
     };
 }
 
-static void entryToJSON(const CTxMemPool& pool, UniValue& info, const CTxMemPoolEntry& e, const int next_block_height) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)
+static void entryToJSON(const CTxMemPool& pool, UniValue& info, const CTxMemPoolEntry& e) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)
 {
     AssertLockHeld(pool.cs);
 
@@ -345,14 +287,11 @@ static void entryToJSON(const CTxMemPool& pool, UniValue& info, const CTxMemPool
     info.pushKV("weight", (int)e.GetTxWeight());
     info.pushKV("time", count_seconds(e.GetTime()));
     info.pushKV("height", (int)e.GetHeight());
-    info.pushKV("startingpriority", e.GetStartingPriority());
-    info.pushKV("currentpriority", e.GetPriority(next_block_height));
     info.pushKV("descendantcount", e.GetCountWithDescendants());
     info.pushKV("descendantsize", e.GetSizeWithDescendants());
     info.pushKV("ancestorcount", e.GetCountWithAncestors());
     info.pushKV("ancestorsize", e.GetSizeWithAncestors());
     info.pushKV("wtxid", e.GetTx().GetWitnessHash().ToString());
-    info.pushKV("hash", info["wtxid"]);
 
     UniValue fees(UniValue::VOBJ);
     fees.pushKV("base", ValueFromAmount(e.GetFee()));
@@ -397,22 +336,17 @@ static void entryToJSON(const CTxMemPool& pool, UniValue& info, const CTxMemPool
     info.pushKV("unbroadcast", pool.IsUnbroadcastTx(tx.GetHash()));
 }
 
-UniValue MempoolToJSON(ChainstateManager &chainman, const CTxMemPool& pool, bool verbose, bool include_mempool_sequence)
+UniValue MempoolToJSON(const CTxMemPool& pool, bool verbose, bool include_mempool_sequence)
 {
     if (verbose) {
         if (include_mempool_sequence) {
             throw JSONRPCError(RPC_INVALID_PARAMETER, "Verbose results cannot contain mempool sequence values.");
         }
-        LOCK(::cs_main);
-        const CChain& active_chain = chainman.ActiveChain();
-        const int next_block_height = active_chain.Height() + 1;
         LOCK(pool.cs);
-        // TODO: Release cs_main after mempool.cs acquired
-
         UniValue o(UniValue::VOBJ);
         for (const CTxMemPoolEntry& e : pool.entryAll()) {
             UniValue info(UniValue::VOBJ);
-            entryToJSON(pool, info, e, next_block_height);
+            entryToJSON(pool, info, e);
             // Mempool has unique entries so there is no advantage in using
             // UniValue::pushKV, which checks if the key already exists in O(N).
             // UniValue::pushKVEnd is used instead which currently is O(1).
@@ -440,136 +374,6 @@ UniValue MempoolToJSON(ChainstateManager &chainman, const CTxMemPool& pool, bool
     }
 }
 
-static RPCHelpMan maxmempool()
-{
-    return RPCHelpMan{"maxmempool",
-                "\nSets the allocated memory for the memory pool.\n",
-                {
-                    {"megabytes", RPCArg::Type::NUM, RPCArg::Optional::NO, "The memory allocated in MB"},
-                },
-                RPCResult{
-                    RPCResult::Type::NONE, "", ""},
-                RPCExamples{
-                    HelpExampleCli("maxmempool", "150") + HelpExampleRpc("maxmempool", "150")
-                },
-        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
-{
-    int64_t nSize = request.params[0].getInt<int32_t>();
-    int64_t nMempoolSizeMax = nSize * 1000000;
-
-    CTxMemPool& mempool = EnsureAnyMemPool(request.context);
-    LOCK2(cs_main, mempool.cs);
-
-    int64_t nMempoolSizeMin = maxmempoolMinimumBytes(mempool.m_opts.limits.descendant_size_vbytes);
-    if (nMempoolSizeMax < 0 || nMempoolSizeMax < nMempoolSizeMin)
-        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("MaxMempool size %d is too small", nSize));
-    mempool.m_opts.max_size_bytes = nMempoolSizeMax;
-
-    auto node_context = util::AnyPtr<NodeContext>(request.context);
-    if (node_context && node_context->chainman) {
-        Chainstate& active_chainstate = node_context->chainman->ActiveChainstate();
-        LimitMempoolSize(mempool, active_chainstate.CoinsTip());
-    }
-
-    return NullUniValue;
-}
-    };
-}
-
-static RPCHelpMan listmempooltransactions()
-{
-    return RPCHelpMan{"listmempooltransactions",
-        "\nReturns all transactions in the mempool. Can be filtered by mempool_sequence\n"
-        "\nAllows for syncing with current mempool entries via polling (not zmq).",
-        {
-            {"start_sequence", RPCArg::Type::NUM, RPCArg::Default{0}, "The mempool_sequence to start the results to. Defaults to 0 (zero, all transactions)."},
-            {"verbose", RPCArg::Type::BOOL, RPCArg::Default{false}, "True for a json object, false for array of transaction ids"},
-        },
-        {
-            RPCResult{"for verbose = false",
-                RPCResult::Type::OBJ, "", "",
-                {
-                    {RPCResult::Type::NUM, "mempool_sequence", "The current max mempool sequence value."},
-                    {RPCResult::Type::ARR, "txs", "",
-                    {
-                        {RPCResult::Type::OBJ, "", "",
-                        {
-                            {RPCResult::Type::NUM, "entry_sequence", "The mempool sequence value for this transaction entry."},
-                            {RPCResult::Type::STR_HEX, "txid", "The transaction id"},
-                        }},
-                    }},
-                }},
-            RPCResult{"for verbose = true",
-                RPCResult::Type::OBJ, "", "",
-                {
-                    {RPCResult::Type::NUM, "mempool_sequence", "The current max mempool sequence value."},
-                    {RPCResult::Type::ARR, "txs", "",
-                    {
-                        {RPCResult::Type::OBJ, "", "",
-                        {
-                         Cat<std::vector<RPCResult>>(
-                            {
-                                {RPCResult::Type::NUM, "entry_sequence", "The mempool sequence value for this transaction entry."},
-                            },
-                            DecodeTxDoc(/*txid_field_doc=*/"The transaction id of the mempool transaction")),
-                        }},
-                    }},
-                }},
-        },
-        RPCExamples{
-            HelpExampleCli("listmempooltransactions", "true")
-            + HelpExampleRpc("listmempooltransactions", "true")
-        },
-        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
-        {
-            uint64_t start_mempool_sequence = 0;
-            if (!request.params[0].isNull()) {
-                start_mempool_sequence = request.params[0].getInt<uint64_t>();
-            }
-
-            bool fVerbose = false;
-            if (!request.params[1].isNull())
-                fVerbose = request.params[1].get_bool();
-
-            return MempoolTxsToJSON(EnsureAnyMemPool(request.context), fVerbose, start_mempool_sequence);
-        },
-    };
-}
-
-UniValue MempoolTxsToJSON(const CTxMemPool& pool, bool verbose, uint64_t sequence_start)
-{
-    uint64_t mempool_sequence;
-
-    LOCK(pool.cs);
-    mempool_sequence = pool.GetSequence();
-
-    UniValue o(UniValue::VOBJ);
-    o.pushKV("mempool_sequence", mempool_sequence);
-
-    UniValue a(UniValue::VARR);
-    for (const CTxMemPoolEntry& e : pool.mapTx) {
-        UniValue txentry(UniValue::VOBJ);
-
-        // We skip anything not requested.
-        if (e.GetSequence() < sequence_start)
-            continue;
-
-        txentry.pushKV("entry_sequence", e.GetSequence());
-
-        if (verbose) {
-            // We could also calculate fees etc for this transaction, but yolo.
-            TxToUniv(e.GetTx(), /*block_hash=*/uint256::ZERO, /*entry=*/txentry, /*include_hex=*/false);
-        } else {
-            txentry.pushKV("txid", e.GetTx().GetHash().ToString());
-        }
-
-        a.push_back(txentry);
-    }
-
-    o.pushKV("txs", a);
-    return o;
-}
-
 static RPCHelpMan getrawmempool()
 {
     return RPCHelpMan{"getrawmempool",
@@ -615,9 +419,7 @@ static RPCHelpMan getrawmempool()
         include_mempool_sequence = request.params[1].get_bool();
     }
 
-    NodeContext& node = EnsureAnyNodeContext(request.context);
-    ChainstateManager& chainman = EnsureChainman(node);
-    return MempoolToJSON(chainman, EnsureAnyMemPool(request.context), fVerbose, include_mempool_sequence);
+    return MempoolToJSON(EnsureAnyMemPool(request.context), fVerbose, include_mempool_sequence);
 },
     };
 }
@@ -653,12 +455,7 @@ static RPCHelpMan getmempoolancestors()
     uint256 hash = ParseHashV(request.params[0], "parameter 1");
 
     const CTxMemPool& mempool = EnsureAnyMemPool(request.context);
-    ChainstateManager& chainman = EnsureAnyChainman(request.context);
-    LOCK(::cs_main);
-    const CChain& active_chain = chainman.ActiveChain();
-    const int next_block_height = active_chain.Height() + 1;
     LOCK(mempool.cs);
-    // TODO: Release cs_main after mempool.cs acquired
 
     const auto entry{mempool.GetEntry(Txid::FromUint256(hash))};
     if (entry == nullptr) {
@@ -679,7 +476,7 @@ static RPCHelpMan getmempoolancestors()
             const CTxMemPoolEntry &e = *ancestorIt;
             const uint256& _hash = e.GetTx().GetHash();
             UniValue info(UniValue::VOBJ);
-            entryToJSON(mempool, info, e, next_block_height);
+            entryToJSON(mempool, info, e);
             o.pushKV(_hash.ToString(), std::move(info));
         }
         return o;
@@ -719,12 +516,7 @@ static RPCHelpMan getmempooldescendants()
     uint256 hash = ParseHashV(request.params[0], "parameter 1");
 
     const CTxMemPool& mempool = EnsureAnyMemPool(request.context);
-    ChainstateManager& chainman = EnsureAnyChainman(request.context);
-    LOCK(::cs_main);
-    const CChain& active_chain = chainman.ActiveChain();
-    const int next_block_height = active_chain.Height() + 1;
     LOCK(mempool.cs);
-    // TODO: Release cs_main after mempool.cs acquired
 
     const auto it{mempool.GetIter(hash)};
     if (!it) {
@@ -749,7 +541,7 @@ static RPCHelpMan getmempooldescendants()
             const CTxMemPoolEntry &e = *descendantIt;
             const uint256& _hash = e.GetTx().GetHash();
             UniValue info(UniValue::VOBJ);
-            entryToJSON(mempool, info, e, next_block_height);
+            entryToJSON(mempool, info, e);
             o.pushKV(_hash.ToString(), std::move(info));
         }
         return o;
@@ -776,12 +568,7 @@ static RPCHelpMan getmempoolentry()
     uint256 hash = ParseHashV(request.params[0], "parameter 1");
 
     const CTxMemPool& mempool = EnsureAnyMemPool(request.context);
-    ChainstateManager& chainman = EnsureAnyChainman(request.context);
-    LOCK(::cs_main);
-    const CChain& active_chain = chainman.ActiveChain();
-    const int next_block_height = active_chain.Height() + 1;
     LOCK(mempool.cs);
-    // TODO: Release cs_main after mempool.cs acquired
 
     const auto entry{mempool.GetEntry(Txid::FromUint256(hash))};
     if (entry == nullptr) {
@@ -789,7 +576,7 @@ static RPCHelpMan getmempoolentry()
     }
 
     UniValue info(UniValue::VOBJ);
-    entryToJSON(mempool, info, *entry, next_block_height);
+    entryToJSON(mempool, info, *entry);
     return info;
 },
     };
@@ -824,7 +611,7 @@ static RPCHelpMan gettxspendingprevout()
         },
         RPCExamples{
             HelpExampleCli("gettxspendingprevout", "\"[{\\\"txid\\\":\\\"a08e6907dbbd3d809776dbfc5d82e371b764ed838b5655e72f463568df1aadf0\\\",\\\"vout\\\":3}]\"")
-            + HelpExampleRpc("gettxspendingprevout", "[{\"txid\":\"a08e6907dbbd3d809776dbfc5d82e371b764ed838b5655e72f463568df1aadf0\",\"vout\":3}]")
+            + HelpExampleRpc("gettxspendingprevout", "\"[{\\\"txid\\\":\\\"a08e6907dbbd3d809776dbfc5d82e371b764ed838b5655e72f463568df1aadf0\\\",\\\"vout\\\":3}]\"")
         },
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
         {
@@ -877,7 +664,7 @@ static RPCHelpMan gettxspendingprevout()
     };
 }
 
-UniValue MempoolInfoToJSON(const CTxMemPool& pool, const std::optional<MempoolHistogramFeeRates>& histogram_floors)
+UniValue MempoolInfoToJSON(const CTxMemPool& pool)
 {
     // Make sure this call is atomic in the pool.
     LOCK(pool.cs);
@@ -891,103 +678,16 @@ UniValue MempoolInfoToJSON(const CTxMemPool& pool, const std::optional<MempoolHi
     ret.pushKV("mempoolminfee", ValueFromAmount(std::max(pool.GetMinFee(), pool.m_opts.min_relay_feerate).GetFeePerK()));
     ret.pushKV("minrelaytxfee", ValueFromAmount(pool.m_opts.min_relay_feerate.GetFeePerK()));
     ret.pushKV("incrementalrelayfee", ValueFromAmount(pool.m_opts.incremental_relay_feerate.GetFeePerK()));
-    ret.pushKV("dustrelayfee", ValueFromAmount(pool.m_opts.dust_relay_feerate.GetFeePerK()));
-    ret.pushKV("dustrelayfeefloor", ValueFromAmount(pool.m_opts.dust_relay_feerate_floor.GetFeePerK()));
-    if (pool.m_opts.dust_relay_target == 0) {
-        ret.pushKV("dustdynamic", "off");
-    } else {
-        std::string multiplier_str = strprintf("%u", pool.m_opts.dust_relay_multiplier / 1000);
-        if (pool.m_opts.dust_relay_multiplier % 1000) {
-            multiplier_str += strprintf(".%03u", pool.m_opts.dust_relay_multiplier % 1000);
-            while (multiplier_str.back() == '0') multiplier_str.pop_back();
-        }
-        if (pool.m_opts.dust_relay_target < 0) {
-            ret.pushKV("dustdynamic", strprintf("%s*target:%u", multiplier_str, -pool.m_opts.dust_relay_target));
-        } else { // pool.m_opts.dust_relay_target > 0
-            ret.pushKV("dustdynamic", strprintf("%s*mempool:%u", multiplier_str, pool.m_opts.dust_relay_target));
-        }
-    }
     ret.pushKV("unbroadcastcount", uint64_t{pool.GetUnbroadcastTxs().size()});
-    ret.pushKV("fullrbf", (pool.m_opts.rbf_policy == RBFPolicy::Always));
-    switch (pool.m_opts.rbf_policy) {
-    case RBFPolicy::Never : ret.pushKV("rbf_policy", "never"); break;
-    case RBFPolicy::OptIn : ret.pushKV("rbf_policy", "optin"); break;
-    case RBFPolicy::Always: ret.pushKV("rbf_policy", "always"); break;
-    }
-    switch (pool.m_opts.truc_policy) {
-    case TRUCPolicy::Reject : ret.pushKV("truc_policy", "reject"); break;
-    case TRUCPolicy::Accept : ret.pushKV("truc_policy", "accept"); break;
-    case TRUCPolicy::Enforce: ret.pushKV("truc_policy", "enforce"); break;
-    }
-
-    if (histogram_floors) {
-        const MempoolHistogramFeeRates& floors{histogram_floors.value()};
-
-        std::vector<uint64_t> sizes(floors.size(), 0);
-        std::vector<uint64_t> count(floors.size(), 0);
-        std::vector<CAmount> fees(floors.size(), 0);
-
-        for (const CTxMemPoolEntry& e : pool.mapTx) {
-            const CAmount fee{e.GetFee()};
-            const uint32_t size{uint32_t(e.GetTxSize())};
-
-            const CAmount afees{e.GetModFeesWithAncestors()}, dfees{e.GetModFeesWithDescendants()};
-            const uint32_t asize{uint32_t(e.GetSizeWithAncestors())}, dsize{uint32_t(e.GetSizeWithDescendants())};
-
-            // Do not use CFeeRate here, since it rounds up, and this should be rounding down
-            const CAmount fpb{fee / size};     // Fee rate per byte
-            const CAmount afpb{afees / asize}; // Fee rate per byte including ancestors
-            const CAmount dfpb{dfees / dsize}; // Fee rate per byte including descendants
-
-            // Fee rate per byte including ancestors & descendants
-            // (fee/size are included in both, so subtracted to avoid double-counting)
-            const CAmount tfpb{(afees + dfees - fee) / (asize + dsize - size)};
-
-            const CAmount fee_rate{std::max(std::min(dfpb, tfpb), std::min(fpb, afpb))};
-
-            // Distribute fee rates
-            for (size_t i = floors.size(); i > 0;) {
-                --i;
-                if (fee_rate >= floors[i]) {
-                    sizes[i] += size;
-                    ++count[i];
-                    fees[i] += fee;
-                    break;
-                }
-            }
-        }
-
-        // Track total amount of available fees in fee rate groups
-        CAmount total_fees = 0;
-        UniValue info(UniValue::VOBJ);
-        for (size_t i = 0; i < floors.size(); ++i) {
-            UniValue info_sub(UniValue::VOBJ);
-            info_sub.pushKV("sizes", sizes[i]);
-            info_sub.pushKV("count", count.at(i));
-            info_sub.pushKV("fees", fees.at(i));
-            info_sub.pushKV("from_feerate", floors[i]);
-            info_sub.pushKV("to_feerate", i == floors.size() - 1 ? std::numeric_limits<int64_t>::max() : floors[i + 1]);
-            total_fees += fees.at(i);
-            info.pushKV(ToString(floors[i]), info_sub);
-        }
-        info.pushKV("total_fees", total_fees);
-        ret.pushKV("fee_histogram", info);
-    }
-
+    ret.pushKV("fullrbf", pool.m_opts.full_rbf);
     return ret;
 }
 
 static RPCHelpMan getmempoolinfo()
 {
     return RPCHelpMan{"getmempoolinfo",
-        "Returns details on the active state of the TX memory pool.\n",
-        {
-            {"fee_histogram|with_fee_histogram", {RPCArg::Type::ARR, RPCArg::Type::BOOL}, RPCArg::Optional::OMITTED, "Fee statistics grouped by fee rate ranges",
-                {
-                    {"fee_rate", RPCArg::Type::NUM, RPCArg::Optional::NO, "Fee rate (in " + CURRENCY_ATOM + "/vB) to group the fees by"},
-                },
-            },
-        },
+        "Returns details on the active state of the TX memory pool.",
+        {},
         RPCResult{
             RPCResult::Type::OBJ, "", "",
             {
@@ -1000,64 +700,16 @@ static RPCHelpMan getmempoolinfo()
                 {RPCResult::Type::STR_AMOUNT, "mempoolminfee", "Minimum fee rate in " + CURRENCY_UNIT + "/kvB for tx to be accepted. Is the maximum of minrelaytxfee and minimum mempool fee"},
                 {RPCResult::Type::STR_AMOUNT, "minrelaytxfee", "Current minimum relay fee for transactions"},
                 {RPCResult::Type::NUM, "incrementalrelayfee", "minimum fee rate increment for mempool limiting or replacement in " + CURRENCY_UNIT + "/kvB"},
-                {RPCResult::Type::NUM, "dustrelayfee", "Current fee rate used to define dust, the value of an output so small it will cost more to spend than its value, in " + CURRENCY_UNIT + "/kvB"},
-                {RPCResult::Type::NUM, "dustrelayfeefloor", "Minimum fee rate used to define dust in " + CURRENCY_UNIT + "/kvB"},
-                {RPCResult::Type::STR, "dustdynamic", "Method for automatic adjustments to dustrelayfee (one of: off, target:<blocks>, or mempool:<kB>)"},
                 {RPCResult::Type::NUM, "unbroadcastcount", "Current number of transactions that haven't passed initial broadcast yet"},
                 {RPCResult::Type::BOOL, "fullrbf", "True if the mempool accepts RBF without replaceability signaling inspection"},
-                {RPCResult::Type::STR, "rbf_policy", "Policy used for replacing conflicting transactions by fee (one of: never, optin, always)"},
-                {RPCResult::Type::STR, "truc_policy", "Behaviour for transactions requesting limits (one of: reject, accept, enforce)"},
-                {RPCResult::Type::OBJ_DYN, "fee_histogram", /*optional=*/true, "",
-                    {
-                        {RPCResult::Type::OBJ, "<fee_rate_group>", "Fee rate group named by its lower bound (in " + CURRENCY_ATOM + "/vB), identical to the \"from_feerate\" field below",
-                            {
-                                {RPCResult::Type::NUM, "sizes", "Cumulative size of all transactions in the fee rate group (in vBytes)"},
-                                {RPCResult::Type::NUM, "count", "Number of transactions in the fee rate group"},
-                                {RPCResult::Type::NUM, "fees", "Cumulative fees of all transactions in the fee rate group (in " + CURRENCY_ATOM + ")"},
-                                {RPCResult::Type::NUM, "from_feerate", "Group contains transactions with fee rates equal or greater than this value (in " + CURRENCY_ATOM + "/vB)"},
-                                {RPCResult::Type::NUM, "to_feerate", /*optional=*/true, "Group contains transactions with fee rates equal or less than this value (in " + CURRENCY_ATOM + "/vB)"},
-                            }},
-                        {RPCResult::Type::ELISION, "", ""},
-                        {RPCResult::Type::NUM, "total_fees", "Total available fees in mempool (in " + CURRENCY_ATOM + ")"},
-                    }, /*skip_type_check=*/ true},
             }},
         RPCExamples{
-            HelpExampleCli("getmempoolinfo", "") +
-            HelpExampleCli("getmempoolinfo", R"("[0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 17, 20, 25, 30, 40, 50, 60, 70, 80, 100, 120, 140, 170, 200]")") +
-            HelpExampleRpc("getmempoolinfo", "") +
-            HelpExampleRpc("getmempoolinfo", R"([0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 17, 20, 25, 30, 40, 50, 60, 70, 80, 100, 120, 140, 170, 200])")
+            HelpExampleCli("getmempoolinfo", "")
+            + HelpExampleRpc("getmempoolinfo", "")
         },
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
 {
-    MempoolHistogramFeeRates histogram_floors;
-    std::optional<MempoolHistogramFeeRates> histogram_floors_opt = std::nullopt;
-
-    if (request.params[0].isBool()) {
-        if (request.params[0].isTrue()) {
-            histogram_floors_opt = MempoolInfoToJSON_const_histogram_floors;
-        }
-    } else if (!request.params[0].isNull()) {
-        const UniValue histogram_floors_univalue = request.params[0].get_array();
-
-        if (histogram_floors_univalue.empty()) {
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid number of parameters");
-        }
-
-        for (size_t i = 0; i < histogram_floors_univalue.size(); ++i) {
-            int64_t value = histogram_floors_univalue[i].getInt<int64_t>();
-
-            if (value < 0) {
-                throw JSONRPCError(RPC_INVALID_PARAMETER, "Non-negative values are expected");
-            } else if (i > 0 && histogram_floors.back() >= value) {
-                throw JSONRPCError(RPC_INVALID_PARAMETER, "Strictly increasing values are expected");
-            }
-
-            histogram_floors.push_back(value);
-        }
-        histogram_floors_opt = std::optional<MempoolHistogramFeeRates>(std::move(histogram_floors));
-    }
-
-    return MempoolInfoToJSON(EnsureAnyMemPool(request.context), histogram_floors_opt);
+    return MempoolInfoToJSON(EnsureAnyMemPool(request.context));
 },
     };
 }
@@ -1160,107 +812,6 @@ static RPCHelpMan savemempool()
     };
 }
 
-static std::vector<RPCResult> OrphanDescription()
-{
-    return {
-        RPCResult{RPCResult::Type::STR_HEX, "txid", "The transaction hash in hex"},
-        RPCResult{RPCResult::Type::STR_HEX, "wtxid", "The transaction witness hash in hex"},
-        RPCResult{RPCResult::Type::NUM, "bytes", "The serialized transaction size in bytes"},
-        RPCResult{RPCResult::Type::NUM, "vsize", "The virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted. CAUTION: Since orphan transactions are missing input data, this can be incorrect!"},
-        RPCResult{RPCResult::Type::NUM, "weight", "The transaction weight as defined in BIP 141."},
-        RPCResult{RPCResult::Type::NUM_TIME, "entry", "The entry time into the orphanage expressed in " + UNIX_EPOCH_TIME},
-        RPCResult{RPCResult::Type::NUM_TIME, "expiration", "The orphan expiration time expressed in " + UNIX_EPOCH_TIME},
-        RPCResult{RPCResult::Type::ARR, "from", "",
-        {
-            RPCResult{RPCResult::Type::NUM, "peer_id", "Peer ID"},
-        }},
-    };
-}
-
-static UniValue OrphanToJSON(const TxOrphanage::OrphanTxBase& orphan)
-{
-    UniValue o(UniValue::VOBJ);
-    o.pushKV("txid", orphan.tx->GetHash().ToString());
-    o.pushKV("wtxid", orphan.tx->GetWitnessHash().ToString());
-    o.pushKV("bytes", orphan.tx->GetTotalSize());
-    o.pushKV("vsize", GetVirtualTransactionSize(*orphan.tx));
-    o.pushKV("weight", GetTransactionWeight(*orphan.tx));
-    o.pushKV("entry", int64_t{TicksSinceEpoch<std::chrono::seconds>(orphan.nTimeExpire - ORPHAN_TX_EXPIRE_TIME)});
-    o.pushKV("expiration", int64_t{TicksSinceEpoch<std::chrono::seconds>(orphan.nTimeExpire)});
-    UniValue from(UniValue::VARR);
-    from.push_back(orphan.fromPeer); // only one fromPeer for now
-    o.pushKV("from", from);
-    return o;
-}
-
-static RPCHelpMan getorphantxs()
-{
-    return RPCHelpMan{"getorphantxs",
-        "\nShows transactions in the tx orphanage.\n"
-        "\nEXPERIMENTAL warning: this call may be changed in future releases.\n",
-        {
-            {"verbosity", RPCArg::Type::NUM, RPCArg::Default{0}, "0 for an array of txids (may contain duplicates), 1 for an array of objects with tx details, and 2 for details from (1) and tx hex",
-             RPCArgOptions{.skip_type_check = true}},
-        },
-        {
-            RPCResult{"for verbose = 0",
-                RPCResult::Type::ARR, "", "",
-                {
-                    {RPCResult::Type::STR_HEX, "txid", "The transaction hash in hex"},
-                }},
-            RPCResult{"for verbose = 1",
-                RPCResult::Type::ARR, "", "",
-                {
-                    {RPCResult::Type::OBJ, "", "", OrphanDescription()},
-                }},
-            RPCResult{"for verbose = 2",
-                RPCResult::Type::ARR, "", "",
-                {
-                    {RPCResult::Type::OBJ, "", "",
-                        Cat<std::vector<RPCResult>>(
-                            OrphanDescription(),
-                            {{RPCResult::Type::STR_HEX, "hex", "The serialized, hex-encoded transaction data"}}
-                        )
-                    },
-                }},
-        },
-        RPCExamples{
-            HelpExampleCli("getorphantxs", "2")
-            + HelpExampleRpc("getorphantxs", "2")
-        },
-        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
-        {
-            const NodeContext& node = EnsureAnyNodeContext(request.context);
-            PeerManager& peerman = EnsurePeerman(node);
-            std::vector<TxOrphanage::OrphanTxBase> orphanage = peerman.GetOrphanTransactions();
-
-            int verbosity{ParseVerbosity(request.params[0], /*default_verbosity=*/0, /*allow_bool*/false)};
-
-            UniValue ret(UniValue::VARR);
-
-            if (verbosity == 0) {
-                for (auto const& orphan : orphanage) {
-                    ret.push_back(orphan.tx->GetHash().ToString());
-                }
-            } else if (verbosity == 1) {
-                for (auto const& orphan : orphanage) {
-                    ret.push_back(OrphanToJSON(orphan));
-                }
-            } else if (verbosity == 2) {
-                for (auto const& orphan : orphanage) {
-                    UniValue o{OrphanToJSON(orphan)};
-                    o.pushKV("hex", EncodeHexTx(*orphan.tx));
-                    ret.push_back(o);
-                }
-            } else {
-                throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid verbosity value " + ToString(verbosity));
-            }
-
-            return ret;
-        },
-    };
-}
-
 static RPCHelpMan submitpackage()
 {
     return RPCHelpMan{"submitpackage",
@@ -1476,10 +1027,7 @@ void RegisterMempoolRPCCommands(CRPCTable& t)
         {"blockchain", &getrawmempool},
         {"blockchain", &importmempool},
         {"blockchain", &savemempool},
-        {"blockchain", &maxmempool},
-        {"hidden", &getorphantxs},
         {"rawtransactions", &submitpackage},
-        {"rawtransactions", &listmempooltransactions},
     };
     for (const auto& c : commands) {
         t.appendCommand(c.name, &c);
diff --git a/src/rpc/mempool.h b/src/rpc/mempool.h
index 894999614e..229d7d52dd 100644
--- a/src/rpc/mempool.h
+++ b/src/rpc/mempool.h
@@ -5,33 +5,13 @@
 #ifndef BITCOIN_RPC_MEMPOOL_H
 #define BITCOIN_RPC_MEMPOOL_H
 
-#include <consensus/amount.h>
-
-#include <optional>
-#include <vector>
-
-class ChainstateManager;
 class CTxMemPool;
 class UniValue;
 
-typedef std::vector<CAmount> MempoolHistogramFeeRates;
-
-/* TODO: define log scale formular for dynamically creating the
- * feelimits but with the property of not constantly changing
- * (and thus screw up client implementations) */
-static const MempoolHistogramFeeRates MempoolInfoToJSON_const_histogram_floors{
-    1, 2, 3, 4, 5, 6, 7, 8, 10,
-    12, 14, 17, 20, 25, 30, 40, 50, 60, 70, 80, 100,
-    120, 140, 170, 200, 250, 300, 400, 500, 600, 700, 800, 1000,
-    1200, 1400, 1700, 2000, 2500, 3000, 4000, 5000, 6000, 7000, 8000, 10000};
-
 /** Mempool information to JSON */
-UniValue MempoolInfoToJSON(const CTxMemPool& pool, const std::optional<MempoolHistogramFeeRates>& histogram_floors);
+UniValue MempoolInfoToJSON(const CTxMemPool& pool);
 
 /** Mempool to JSON */
-UniValue MempoolToJSON(ChainstateManager& chainman, const CTxMemPool& pool, bool verbose = false, bool include_mempool_sequence = false);
-
-/** Mempool Txs to JSON */
-UniValue MempoolTxsToJSON(const CTxMemPool& pool, bool verbose = false, uint64_t sequence_start = 0);
+UniValue MempoolToJSON(const CTxMemPool& pool, bool verbose = false, bool include_mempool_sequence = false);
 
 #endif // BITCOIN_RPC_MEMPOOL_H
diff --git a/src/rpc/mining.cpp b/src/rpc/mining.cpp
index f4d28b438c..445fd8c344 100644
--- a/src/rpc/mining.cpp
+++ b/src/rpc/mining.cpp
@@ -34,7 +34,6 @@
 #include <script/signingprovider.h>
 #include <txmempool.h>
 #include <univalue.h>
-#include <util/check.h>
 #include <util/signalinterrupt.h>
 #include <util/strencodings.h>
 #include <util/string.h>
@@ -162,7 +161,7 @@ static UniValue generateBlocks(ChainstateManager& chainman, Mining& miner, const
 {
     UniValue blockHashes(UniValue::VARR);
     while (nGenerate > 0 && !chainman.m_interrupt) {
-        auto pblocktemplate = miner.createNewBlock(coinbase_script);
+        std::unique_ptr<CBlockTemplate> pblocktemplate(miner.createNewBlock(coinbase_script));
         if (!pblocktemplate.get())
             throw JSONRPCError(RPC_INTERNAL_ERROR, "Couldn't create new block");
 
@@ -373,7 +372,7 @@ static RPCHelpMan generateblock()
     {
         LOCK(chainman.GetMutex());
         {
-            auto blocktemplate = miner.createNewBlock(coinbase_script, {.use_mempool = false});
+            std::unique_ptr<CBlockTemplate> blocktemplate{miner.createNewBlock(coinbase_script, {.use_mempool = false})};
             if (!blocktemplate) {
                 throw JSONRPCError(RPC_INTERNAL_ERROR, "Couldn't create new block");
             }
@@ -420,14 +419,12 @@ static RPCHelpMan getmininginfo()
                     RPCResult::Type::OBJ, "", "",
                     {
                         {RPCResult::Type::NUM, "blocks", "The current block"},
-                        {RPCResult::Type::NUM, "currentblocksize", /*optional=*/true, "The block size of the last assembled block (only present if a block was ever assembled, and blockmaxsize is configured)"},
                         {RPCResult::Type::NUM, "currentblockweight", /*optional=*/true, "The block weight of the last assembled block (only present if a block was ever assembled)"},
                         {RPCResult::Type::NUM, "currentblocktx", /*optional=*/true, "The number of block transactions of the last assembled block (only present if a block was ever assembled)"},
                         {RPCResult::Type::NUM, "difficulty", "The current difficulty"},
                         {RPCResult::Type::NUM, "networkhashps", "The network hashes per second"},
                         {RPCResult::Type::NUM, "pooledtx", "The size of the mempool"},
                         {RPCResult::Type::STR, "chain", "current network name (" LIST_CHAIN_NAMES ")"},
-                        {RPCResult::Type::STR_HEX, "signet_challenge", /*optional=*/true, "The block challenge (aka. block script), in hexadecimal (only present if the current network is a signet)"},
                         (IsDeprecatedRPCEnabled("warnings") ?
                             RPCResult{RPCResult::Type::STR, "warnings", "any network and blockchain warnings (DEPRECATED)"} :
                             RPCResult{RPCResult::Type::ARR, "warnings", "any network and blockchain warnings (run with `-deprecatedrpc=warnings` to return the latest warning as a single string)",
@@ -451,18 +448,12 @@ static RPCHelpMan getmininginfo()
 
     UniValue obj(UniValue::VOBJ);
     obj.pushKV("blocks",           active_chain.Height());
-    if (BlockAssembler::m_last_block_size) obj.pushKV("currentblocksize", *BlockAssembler::m_last_block_size);
     if (BlockAssembler::m_last_block_weight) obj.pushKV("currentblockweight", *BlockAssembler::m_last_block_weight);
     if (BlockAssembler::m_last_block_num_txs) obj.pushKV("currentblocktx", *BlockAssembler::m_last_block_num_txs);
     obj.pushKV("difficulty", GetDifficulty(*CHECK_NONFATAL(active_chain.Tip())));
     obj.pushKV("networkhashps",    getnetworkhashps().HandleRequest(request));
     obj.pushKV("pooledtx",         (uint64_t)mempool.size());
     obj.pushKV("chain", chainman.GetParams().GetChainTypeString());
-    if (chainman.GetParams().GetChainType() == ChainType::SIGNET) {
-        const std::vector<uint8_t>& signet_challenge =
-            chainman.GetParams().GetConsensus().signet_challenge;
-        obj.pushKV("signet_challenge", HexStr(signet_challenge));
-    }
     obj.pushKV("warnings", node::GetWarningsForRpc(*CHECK_NONFATAL(node.warnings), IsDeprecatedRPCEnabled("warnings")));
     return obj;
 },
@@ -477,10 +468,9 @@ static RPCHelpMan prioritisetransaction()
                 "Accepts the transaction into mined blocks at a higher (or lower) priority\n",
                 {
                     {"txid", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "The transaction id."},
-                    {"priority_delta", RPCArg::Type::NUM, RPCArg::Optional::OMITTED, "The priority to add or subtract.\n"
-            "                  The transaction selection algorithm considers the tx as it would have a higher priority.\n"
-            "                  (priority of a transaction is calculated: coinage * value_in_satoshis / txsize)\n"},
-                    {"fee_delta", RPCArg::Type::NUM, RPCArg::Optional::OMITTED, "The fee value (in satoshis) to add (or subtract, if negative).\n"
+                    {"dummy", RPCArg::Type::NUM, RPCArg::Optional::OMITTED, "API-Compatibility for previous API. Must be zero or null.\n"
+            "                  DEPRECATED. For forward compatibility use named arguments and omit this parameter."},
+                    {"fee_delta", RPCArg::Type::NUM, RPCArg::Optional::NO, "The fee value (in satoshis) to add (or subtract, if negative).\n"
             "                  Note, that this value is not a fee rate. It is a value to modify absolute fee of the TX.\n"
             "                  The fee is not actually paid, only the algorithm for selecting transactions into a block\n"
             "                  considers the transaction as it would have paid a higher (or lower) fee."},
@@ -496,17 +486,14 @@ static RPCHelpMan prioritisetransaction()
     LOCK(cs_main);
 
     uint256 hash(ParseHashV(request.params[0], "txid"));
-    double priority_delta = 0;
-    CAmount nAmount = 0;
+    const auto dummy{self.MaybeArg<double>("dummy")};
+    CAmount nAmount = request.params[2].getInt<int64_t>();
 
-    if (!request.params[1].isNull()) {
-        priority_delta = request.params[1].get_real();
-    }
-    if (!request.params[2].isNull()) {
-        nAmount = request.params[2].getInt<int64_t>();
+    if (dummy && *dummy != 0) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Priority is no longer supported, dummy argument to prioritisetransaction must be 0.");
     }
 
-    EnsureAnyMemPool(request.context).PrioritiseTransaction(hash, priority_delta, nAmount);
+    EnsureAnyMemPool(request.context).PrioritiseTransaction(hash, nAmount);
     return true;
 },
     };
@@ -524,7 +511,6 @@ static RPCHelpMan getprioritisedtransactions()
                     {RPCResult::Type::NUM, "fee_delta", "transaction fee delta in satoshis"},
                     {RPCResult::Type::BOOL, "in_mempool", "whether this transaction is currently in mempool"},
                     {RPCResult::Type::NUM, "modified_fee", /*optional=*/true, "modified fee in satoshis. Only returned if in_mempool=true"},
-                    {RPCResult::Type::NUM, "priority_delta", /*optional=*/true, "transaction coin-age priority delta"},
                 }}
             },
         },
@@ -544,7 +530,6 @@ static RPCHelpMan getprioritisedtransactions()
                 if (delta_info.in_mempool) {
                     result_inner.pushKV("modified_fee", *delta_info.modified_fee);
                 }
-                result_inner.pushKV("priority_delta", delta_info.priority_delta);
                 rpc_result.pushKV(delta_info.txid.GetHex(), std::move(result_inner));
             }
             return rpc_result;
@@ -581,8 +566,6 @@ static std::string gbt_vb_name(const Consensus::DeploymentPos pos) {
     return s;
 }
 
-static UniValue TemplateToJSON(const Consensus::Params&, const ChainstateManager&, const CBlockTemplate*, const CBlockIndex*, const std::set<std::string>& setClientRules, unsigned int nTransactionsUpdatedLast);
-
 static RPCHelpMan getblocktemplate()
 {
     return RPCHelpMan{"getblocktemplate",
@@ -597,14 +580,9 @@ static RPCHelpMan getblocktemplate()
             {"template_request", RPCArg::Type::OBJ, RPCArg::Optional::NO, "Format of the template",
             {
                 {"mode", RPCArg::Type::STR, /* treat as named arg */ RPCArg::Optional::OMITTED, "This must be set to \"template\", \"proposal\" (see BIP 23), or omitted"},
-                {"blockmaxsize", RPCArg::Type::NUM, RPCArg::DefaultHint{"set by -blockmaxsize"}, "limit returned block to specified size (disables template cache)"},
-                {"blockmaxweight", RPCArg::Type::NUM, RPCArg::DefaultHint{"set by -blockmaxweight"}, "limit returned block to specified weight (disables template cache)"},
-                {"blockreservedsigops", RPCArg::Type::NUM, RPCArg::Default{node::BlockCreateOptions{}.coinbase_output_max_additional_sigops}, "reserve specified number of sigops in returned block for generation transaction (disables template cache)"},
-                {"blockreservedsize", RPCArg::Type::NUM, RPCArg::Default{node::BlockCreateOptions{}.coinbase_max_additional_size}, "reserve specified size in returned block for generation transaction (disables template cache)"},
-                {"blockreservedweight", RPCArg::Type::NUM, RPCArg::Default{node::BlockCreateOptions{}.coinbase_max_additional_weight}, "reserve specified weight in returned block for generation transaction (disables template cache)"},
                 {"capabilities", RPCArg::Type::ARR, /* treat as named arg */ RPCArg::Optional::OMITTED, "A list of strings",
                 {
-                    {"str", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "client side supported feature, 'longpoll', 'coinbasevalue', 'proposal', 'skip_validity_test', 'serverlist', 'workid'"},
+                    {"str", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "client side supported feature, 'longpoll', 'coinbasevalue', 'proposal', 'serverlist', 'workid'"},
                 }},
                 {"rules", RPCArg::Type::ARR, RPCArg::Optional::NO, "A list of strings",
                 {
@@ -612,7 +590,6 @@ static RPCHelpMan getblocktemplate()
                     {"str", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "other client side supported softfork deployment"},
                 }},
                 {"longpollid", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "delay processing request until the result would vary significantly from the \"longpollid\" of a prior template"},
-                {"minfeerate", RPCArg::Type::NUM, RPCArg::DefaultHint{"set by -blockmintxfee"}, "only include transactions with a minimum sats/vbyte (disables template cache)"},
                 {"data", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, "proposed block data to check, encoded in hexadecimal; valid only for mode=\"proposal\""},
             },
             },
@@ -649,7 +626,6 @@ static RPCHelpMan getblocktemplate()
                             {RPCResult::Type::NUM, "", "transactions before this one (by 1-based index in 'transactions' list) that must be present in the final block if this one is"},
                         }},
                         {RPCResult::Type::NUM, "fee", "difference in value between transaction inputs and outputs (in satoshis); for coinbase transactions, this is a negative Number of the total collected block fees (ie, not including the block subsidy); if key is not present, fee is unknown and clients MUST NOT assume there isn't one"},
-                        {RPCResult::Type::NUM, "priority", /*optional=*/true, "transaction coin-age priority (non-standard)"},
                         {RPCResult::Type::NUM, "sigops", "total SigOps cost, as counted for purposes of block limits; if key is not present, sigop cost is unknown and clients MUST NOT assume it is zero"},
                         {RPCResult::Type::NUM, "weight", "total transaction weight, as counted for purposes of block limits"},
                     }},
@@ -689,14 +665,6 @@ static RPCHelpMan getblocktemplate()
     LOCK(cs_main);
     uint256 tip{CHECK_NONFATAL(miner.getTipHash()).value()};
 
-    BlockAssembler::Options options;
-    {
-        const ArgsManager& args{EnsureAnyArgsman(request.context)};
-        ApplyArgsManOptions(args, options);
-    }
-    const BlockAssembler::Options options_def{options.Clamped()};
-    bool bypass_cache{false};
-
     std::string strMode = "template";
     UniValue lpval = NullUniValue;
     std::set<std::string> setClientRules;
@@ -750,39 +718,6 @@ static RPCHelpMan getblocktemplate()
                 setClientRules.insert(v.get_str());
             }
         }
-
-        if (!oparam["blockmaxsize"].isNull()) {
-            options.nBlockMaxSize = oparam["blockmaxsize"].getInt<size_t>();
-        }
-        if (!oparam["blockmaxweight"].isNull()) {
-            options.nBlockMaxWeight = oparam["blockmaxweight"].getInt<size_t>();
-        }
-        if (!oparam["blockreservedsize"].isNull()) {
-            options.coinbase_max_additional_size = oparam["blockreservedsize"].getInt<size_t>();
-        }
-        if (!oparam["blockreservedweight"].isNull()) {
-            options.coinbase_max_additional_weight = oparam["blockreservedweight"].getInt<size_t>();
-        }
-        if (!oparam["blockreservedsigops"].isNull()) {
-            options.coinbase_output_max_additional_sigops = oparam["blockreservedsigops"].getInt<size_t>();
-        }
-        if (!oparam["minfeerate"].isNull()) {
-            options.blockMinFeeRate = CFeeRate{AmountFromValue(oparam["minfeerate"]), COIN /* sat/vB */};
-        }
-        options = options.Clamped();
-        bypass_cache |= !(options == options_def);
-
-        // NOTE: Intentionally not setting bypass_cache for skip_validity_test since _using_ the cache is fine
-        const UniValue& client_caps = oparam.find_value("capabilities");
-        if (client_caps.isArray()) {
-            for (unsigned int i = 0; i < client_caps.size(); ++i) {
-                const UniValue& v = client_caps[i];
-                if (!v.isStr()) continue;
-                if (v.get_str() == "skip_validity_test") {
-                    options.test_block_validity = false;
-                }
-            }
-        }
     }
 
     if (strMode != "template")
@@ -865,22 +800,10 @@ static RPCHelpMan getblocktemplate()
     // Update block
     static CBlockIndex* pindexPrev;
     static int64_t time_start;
-    static std::shared_ptr<CBlockTemplate> pblocktemplate;
+    static std::unique_ptr<CBlockTemplate> pblocktemplate;
     if (!pindexPrev || pindexPrev->GetBlockHash() != tip ||
-        bypass_cache ||
         (miner.getTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - time_start > 5))
     {
-        if (bypass_cache || !options.test_block_validity) {
-            // Create one-off template unrelated to cache
-            const auto tx_update_counter = miner.getTransactionsUpdated();
-            CBlockIndex* const local_pindexPrev = chainman.m_blockman.LookupBlockIndex(tip);
-            const CScript dummy_script{CScript() << OP_TRUE};
-            auto tmpl = miner.createNewBlock2(dummy_script, options);
-            if (!tmpl) throw JSONRPCError(RPC_OUT_OF_MEMORY, "Out of memory");
-            return TemplateToJSON(consensusParams, chainman, &*tmpl, local_pindexPrev, setClientRules, tx_update_counter);
-        }
-        CHECK_NONFATAL(options == options_def);
-
         // Clear pindexPrev so future calls make a new block, despite any failures from here on
         pindexPrev = nullptr;
 
@@ -906,14 +829,6 @@ static RPCHelpMan getblocktemplate()
     UpdateTime(pblock, consensusParams, pindexPrev);
     pblock->nNonce = 0;
 
-    return TemplateToJSON(consensusParams, chainman, &*pblocktemplate, pindexPrev, setClientRules, nTransactionsUpdatedLast);
-},
-    };
-}
-
-static UniValue TemplateToJSON(const Consensus::Params& consensusParams, const ChainstateManager& chainman, const CBlockTemplate* const pblocktemplate, const CBlockIndex* const pindexPrev, const std::set<std::string>& setClientRules, const unsigned int nTransactionsUpdatedLast) {
-    const CBlock* const pblock = &pblocktemplate->block;
-
     // NOTE: If at some point we support pre-segwit miners post-segwit-activation, this needs to take segwit support into consideration
     const bool fPreSegWit = !DeploymentActiveAfter(pindexPrev, chainman, Consensus::DEPLOYMENT_SEGWIT);
 
@@ -953,9 +868,6 @@ static UniValue TemplateToJSON(const Consensus::Params& consensusParams, const C
         }
         entry.pushKV("sigops", nTxSigOps);
         entry.pushKV("weight", GetTransactionWeight(tx));
-        if (index_in_template && !pblocktemplate->vTxPriorities.empty()) {
-            entry.pushKV("priority", pblocktemplate->vTxPriorities[index_in_template]);
-        }
 
         transactions.push_back(std::move(entry));
     }
@@ -981,7 +893,6 @@ static UniValue TemplateToJSON(const Consensus::Params& consensusParams, const C
         aRules.push_back("!signet");
     }
 
-    auto block_version = pblock->nVersion;
     UniValue vbavailable(UniValue::VOBJ);
     for (int j = 0; j < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j) {
         Consensus::DeploymentPos pos = Consensus::DeploymentPos(j);
@@ -993,7 +904,7 @@ static UniValue TemplateToJSON(const Consensus::Params& consensusParams, const C
                 break;
             case ThresholdState::LOCKED_IN:
                 // Ensure bit is set in block version
-                block_version |= chainman.m_versionbitscache.Mask(consensusParams, pos);
+                pblock->nVersion |= chainman.m_versionbitscache.Mask(consensusParams, pos);
                 [[fallthrough]];
             case ThresholdState::STARTED:
             {
@@ -1002,7 +913,7 @@ static UniValue TemplateToJSON(const Consensus::Params& consensusParams, const C
                 if (setClientRules.find(vbinfo.name) == setClientRules.end()) {
                     if (!vbinfo.gbt_force) {
                         // If the client doesn't support this, don't indicate it in the [default] version
-                        block_version &= ~chainman.m_versionbitscache.Mask(consensusParams, pos);
+                        pblock->nVersion &= ~chainman.m_versionbitscache.Mask(consensusParams, pos);
                     }
                 }
                 break;
@@ -1022,7 +933,7 @@ static UniValue TemplateToJSON(const Consensus::Params& consensusParams, const C
             }
         }
     }
-    result.pushKV("version", block_version);
+    result.pushKV("version", pblock->nVersion);
     result.pushKV("rules", std::move(aRules));
     result.pushKV("vbavailable", std::move(vbavailable));
     result.pushKV("vbrequired", int(0));
@@ -1031,7 +942,7 @@ static UniValue TemplateToJSON(const Consensus::Params& consensusParams, const C
     result.pushKV("transactions", std::move(transactions));
     result.pushKV("coinbaseaux", std::move(aux));
     result.pushKV("coinbasevalue", (int64_t)pblock->vtx[0]->vout[0].nValue);
-    result.pushKV("longpollid", pindexPrev->GetBlockHash().GetHex() + ToString(nTransactionsUpdatedLast));
+    result.pushKV("longpollid", tip.GetHex() + ToString(nTransactionsUpdatedLast));
     result.pushKV("target", hashTarget.GetHex());
     result.pushKV("mintime", (int64_t)pindexPrev->GetMedianTimePast()+1);
     result.pushKV("mutable", std::move(aMutable));
@@ -1062,6 +973,8 @@ static UniValue TemplateToJSON(const Consensus::Params& consensusParams, const C
     }
 
     return result;
+},
+    };
 }
 
 class submitblock_StateCatcher final : public CValidationInterface
diff --git a/src/rpc/net.cpp b/src/rpc/net.cpp
index 9d055b4762..1119a3e668 100644
--- a/src/rpc/net.cpp
+++ b/src/rpc/net.cpp
@@ -43,31 +43,11 @@ const std::vector<std::string> CONNECTION_TYPE_DOC{
         "outbound-full-relay (default automatic connections)",
         "block-relay-only (does not relay transactions or addresses)",
         "inbound (initiated by the peer)",
-        "manual (added via addnode RPC or -addnode/-connect configuration options; protected from DoS disconnection and not required to be full nodes as other outbound peers are)",
+        "manual (added via addnode RPC or -addnode/-connect configuration options)",
         "addr-fetch (short-lived automatic connection for soliciting addresses)",
         "feeler (short-lived automatic connection for testing addresses)"
 };
 
-ConnectionType ConnectionTypeFromValue(const UniValue& uv)
-{
-    const std::string& s{uv.get_str()};
-    if (s == "inbound") {
-        return ConnectionType::INBOUND;
-    } else if (s == "manual") {
-        return ConnectionType::MANUAL;
-    } else if (s == "feeler") {
-        return ConnectionType::FEELER;
-    } else if (s == "outbound-full-relay") {
-        return ConnectionType::OUTBOUND_FULL_RELAY;
-    } else if (s == "block-relay-only") {
-        return ConnectionType::BLOCK_RELAY;
-    } else if (s == "addr-fetch") {
-        return ConnectionType::ADDR_FETCH;
-    }
-
-    throw JSONRPCError(RPC_INVALID_PARAMETER, "Unknown connection type " + s);
-}
-
 const std::vector<std::string> TRANSPORT_TYPE_DOC{
     "detecting (peer could be v1 or v2)",
     "v1 (plaintext transport protocol)",
@@ -149,8 +129,8 @@ static RPCHelpMan getpeerinfo()
                     {RPCResult::Type::STR, "addrbind", /*optional=*/true, "(ip:port) Bind address of the connection to the peer"},
                     {RPCResult::Type::STR, "addrlocal", /*optional=*/true, "(ip:port) Local address as reported by the peer"},
                     {RPCResult::Type::STR, "network", "Network (" + Join(GetNetworkNames(/*append_unroutable=*/true), ", ") + ")"},
-                    {RPCResult::Type::NUM, "mapped_as", /*optional=*/true, "Mapped AS (Autonomous System) number at the end of the BGP route to the peer, used for diversifying\n"
-                                                        "peer selection (only displayed if the -asmap config option is set)"},
+                    {RPCResult::Type::NUM, "mapped_as", /*optional=*/true, "The AS in the BGP route to the peer used for diversifying\n"
+                                                        "peer selection (only available if the asmap config flag is set)"},
                     {RPCResult::Type::STR_HEX, "services", "The services offered"},
                     {RPCResult::Type::ARR, "servicesnames", "the services offered, in human-readable form",
                     {
@@ -163,11 +143,6 @@ static RPCHelpMan getpeerinfo()
                     {RPCResult::Type::NUM_TIME, "last_block", "The " + UNIX_EPOCH_TIME + " of the last block received from this peer"},
                     {RPCResult::Type::NUM, "bytessent", "The total bytes sent"},
                     {RPCResult::Type::NUM, "bytesrecv", "The total bytes received"},
-                    {RPCResult::Type::NUM, "cpu_load", /*optional=*/true,
-                        "The CPU time (user + system) spent processing messages from this peer "
-                        "and crafting messages for it expressed in per milles (‰) of the "
-                        "duration of the connection. Will be omitted on platforms that do not "
-                        "support this or if still not measured."},
                     {RPCResult::Type::NUM_TIME, "conntime", "The " + UNIX_EPOCH_TIME + " of the connection"},
                     {RPCResult::Type::NUM, "timeoffset", "The time offset in seconds"},
                     {RPCResult::Type::NUM, "pingtime", /*optional=*/true, "The last ping time in milliseconds (ms), if any"},
@@ -193,7 +168,6 @@ static RPCHelpMan getpeerinfo()
                     {
                         {RPCResult::Type::STR, "permission_type", Join(NET_PERMISSIONS_DOC, ",\n") + ".\n"},
                     }},
-                    {RPCResult::Type::BOOL, "forced_inbound", "Whether this peer forced a connection by evicting another."},
                     {RPCResult::Type::NUM, "minfeefilter", "The minimum fee rate for transactions this peer accepts"},
                     {RPCResult::Type::OBJ_DYN, "bytessent_per_msg", "",
                     {
@@ -213,7 +187,6 @@ static RPCHelpMan getpeerinfo()
                                                               "best capture connection behaviors."},
                     {RPCResult::Type::STR, "transport_protocol_type", "Type of transport protocol: \n" + Join(TRANSPORT_TYPE_DOC, ",\n") + ".\n"},
                     {RPCResult::Type::STR, "session_id", "The session ID for this connection, or \"\" if there is none (\"v2\" transport protocol only).\n"},
-                    {RPCResult::Type::NUM, "misbehavior_score", "The misbehavior score for this peer. Always 0, but may be 100 if the peer is about to be disconnected. (DEPRECATED)\n"},
                 }},
             }},
         },
@@ -232,8 +205,6 @@ static RPCHelpMan getpeerinfo()
 
     UniValue ret(UniValue::VARR);
 
-    const auto now{GetTime<std::chrono::seconds>()};
-
     for (const CNodeStats& stats : vstats) {
         UniValue obj(UniValue::VOBJ);
         CNodeStateStats statestats;
@@ -268,9 +239,6 @@ static RPCHelpMan getpeerinfo()
         obj.pushKV("last_block", count_seconds(stats.m_last_block_time));
         obj.pushKV("bytessent", stats.nSendBytes);
         obj.pushKV("bytesrecv", stats.nRecvBytes);
-        if (stats.m_cpu_time > 0s && now > stats.m_connected) {
-            obj.pushKV("cpu_load", /* ‰ */1000.0 * stats.m_cpu_time / (now - stats.m_connected));
-        }
         obj.pushKV("conntime", count_seconds(stats.m_connected));
         obj.pushKV("timeoffset", Ticks<std::chrono::seconds>(statestats.time_offset));
         if (stats.m_last_ping_time > 0us) {
@@ -307,7 +275,6 @@ static RPCHelpMan getpeerinfo()
             permissions.push_back(permission);
         }
         obj.pushKV("permissions", std::move(permissions));
-        obj.pushKV("forced_inbound", stats.m_forced_inbound);
         obj.pushKV("minfeefilter", ValueFromAmount(statestats.m_fee_filter_received));
 
         UniValue sendPerMsgType(UniValue::VOBJ);
@@ -326,7 +293,6 @@ static RPCHelpMan getpeerinfo()
         obj.pushKV("connection_type", ConnectionTypeAsString(stats.m_conn_type));
         obj.pushKV("transport_protocol_type", TransportTypeAsString(stats.m_transport_type));
         obj.pushKV("session_id", stats.m_session_id);
-        obj.pushKV("misbehavior_score", statestats.m_misbehavior_score);
 
         ret.push_back(std::move(obj));
     }
@@ -341,14 +307,14 @@ static RPCHelpMan addnode()
     return RPCHelpMan{"addnode",
                 "\nAttempts to add or remove a node from the addnode list.\n"
                 "Or try a connection to a node once.\n"
-                +
+                "Nodes added using addnode (or -connect) are protected from DoS disconnection and are not required to be\n"
+                "full nodes/support SegWit as other outbound peers are (though such peers will not be synced from).\n" +
                 strprintf("Addnode connections are limited to %u at a time", MAX_ADDNODE_CONNECTIONS) +
                 " and are counted separately from the -maxconnections limit.\n",
                 {
                     {"node", RPCArg::Type::STR, RPCArg::Optional::NO, "The address of the peer to connect to"},
                     {"command", RPCArg::Type::STR, RPCArg::Optional::NO, "'add' to add a node to the list, 'remove' to remove a node from the list, 'onetry' to try a connection to the node once"},
-                    {"v2transport|connection_type_compat", {RPCArg::Type::BOOL, RPCArg::Type::STR}, RPCArg::DefaultHint{"set by -v2transport"}, "Attempt to connect using BIP324 v2 transport protocol (ignored for 'remove' command)"},
-                    {"connection_type", RPCArg::Type::STR, RPCArg::Default{"manual"}, "Type of connection: \n" + Join(CONNECTION_TYPE_DOC, ",\n") + "\nOnly supported for command \"onetry\" for now."},
+                    {"v2transport", RPCArg::Type::BOOL, RPCArg::DefaultHint{"set by -v2transport"}, "Attempt to connect using BIP324 v2 transport protocol (ignored for 'remove' command)"},
                 },
                 RPCResult{RPCResult::Type::NONE, "", ""},
                 RPCExamples{
@@ -368,25 +334,7 @@ static RPCHelpMan addnode()
 
     const auto node_arg{self.Arg<std::string>("node")};
     bool node_v2transport = connman.GetLocalServices() & NODE_P2P_V2;
-    bool use_v2transport{node_v2transport};
-    ConnectionType connection_type = ConnectionType::MANUAL;
-    std::string connection_type_arg;
-    if (request.params[2].isStr()) {
-        // connection_type used to occupy this position (v0.21.0.knots20210130-v25.1.knots20231115)
-        if (command == "remove" || request.params.size() > 3) {
-            // Same behaviour as too many args passed normally
-            throw std::runtime_error(self.ToString());
-        }
-        connection_type = ConnectionTypeFromValue(request.params[2]);
-    } else {
-        use_v2transport = self.MaybeArg<bool>("v2transport").value_or(node_v2transport);
-        if (!request.params[3].isNull()) {
-            if (command == "remove") {
-                throw std::runtime_error(self.ToString());
-            }
-            connection_type = ConnectionTypeFromValue(request.params[3]);
-        }
-    }
+    bool use_v2transport = self.MaybeArg<bool>("v2transport").value_or(node_v2transport);
 
     if (use_v2transport && !node_v2transport) {
         throw JSONRPCError(RPC_INVALID_PARAMETER, "Error: v2transport requested but not enabled (see -v2transport)");
@@ -395,16 +343,12 @@ static RPCHelpMan addnode()
     if (command == "onetry")
     {
         CAddress addr;
-        connman.OpenNetworkConnection(addr, /*fCountFailure=*/false, /*grant_outbound=*/{}, node_arg.c_str(), connection_type, use_v2transport);
+        connman.OpenNetworkConnection(addr, /*fCountFailure=*/false, /*grant_outbound=*/{}, node_arg.c_str(), ConnectionType::MANUAL, use_v2transport);
         return UniValue::VNULL;
     }
 
     if (command == "add")
     {
-        if (connection_type != ConnectionType::MANUAL) {
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "connection_type != manual is only supported for the \"onetry\" command for now");
-        }
-
         if (!connman.AddNode({node_arg, use_v2transport})) {
             throw JSONRPCError(RPC_CLIENT_NODE_ALREADY_ADDED, "Error: Node already added");
         }
@@ -442,6 +386,10 @@ static RPCHelpMan addconnection()
         },
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
 {
+    if (Params().GetChainType() != ChainType::REGTEST) {
+        throw std::runtime_error("addconnection is for regression testing (-regtest mode) only.");
+    }
+
     const std::string address = request.params[0].get_str();
     const std::string conn_type_in{TrimString(request.params[1].get_str())};
     ConnectionType conn_type{};
@@ -486,7 +434,7 @@ static RPCHelpMan disconnectnode()
                 "\nStrictly one out of 'address' and 'nodeid' can be provided to identify the node.\n"
                 "\nTo disconnect by nodeid, either set 'address' to the empty string, or call using the named 'nodeid' argument only.\n",
                 {
-                    {"address", RPCArg::Type::STR, RPCArg::DefaultHint{"fallback to nodeid"}, "The IP address/port of the node or subnet"},
+                    {"address", RPCArg::Type::STR, RPCArg::DefaultHint{"fallback to nodeid"}, "The IP address/port of the node"},
                     {"nodeid", RPCArg::Type::NUM, RPCArg::DefaultHint{"fallback to address"}, "The node ID (see getpeerinfo for node IDs)"},
                 },
                 RPCResult{RPCResult::Type::NONE, "", ""},
@@ -507,20 +455,7 @@ static RPCHelpMan disconnectnode()
 
     if (!address_arg.isNull() && id_arg.isNull()) {
         /* handle disconnect-by-address */
-        const bool only_subnet{address_arg.get_str().find('/') != std::string::npos};
-        if (only_subnet) {
-            success = false;
-        } else {
-            success = connman.DisconnectNode(address_arg.get_str());
-        }
-        if (!success) {
-            const CSubNet subnet = LookupSubNet(address_arg.get_str());
-            if (subnet.IsValid()) {
-                success = connman.DisconnectNode(subnet);
-            } else if (only_subnet) {
-                throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid subnet");
-            }
-        }
+        success = connman.DisconnectNode(address_arg.get_str());
     } else if (!id_arg.isNull() && (address_arg.isNull() || (address_arg.isStr() && address_arg.get_str().empty()))) {
         /* handle disconnect-by-id */
         NodeId nodeid = (NodeId) id_arg.getInt<int64_t>();
@@ -1167,12 +1102,12 @@ static RPCHelpMan getaddrmaninfo()
     };
 }
 
-UniValue AddrmanEntryToJSON(const AddrInfo& info, const CConnman& connman)
+UniValue AddrmanEntryToJSON(const AddrInfo& info, CConnman& connman)
 {
     UniValue ret(UniValue::VOBJ);
     ret.pushKV("address", info.ToStringAddr());
-    const uint32_t mapped_as{connman.GetMappedAS(info)};
-    if (mapped_as) {
+    const auto mapped_as{connman.GetMappedAS(info)};
+    if (mapped_as != 0) {
         ret.pushKV("mapped_as", mapped_as);
     }
     ret.pushKV("port", info.GetPort());
@@ -1181,14 +1116,14 @@ UniValue AddrmanEntryToJSON(const AddrInfo& info, const CConnman& connman)
     ret.pushKV("network", GetNetworkName(info.GetNetClass()));
     ret.pushKV("source", info.source.ToStringAddr());
     ret.pushKV("source_network", GetNetworkName(info.source.GetNetClass()));
-    const uint32_t source_mapped_as{connman.GetMappedAS(info.source)};
-    if (source_mapped_as) {
+    const auto source_mapped_as{connman.GetMappedAS(info.source)};
+    if (source_mapped_as != 0) {
         ret.pushKV("source_mapped_as", source_mapped_as);
     }
     return ret;
 }
 
-UniValue AddrmanTableToJSON(const std::vector<std::pair<AddrInfo, AddressPosition>>& tableInfos, const CConnman& connman)
+UniValue AddrmanTableToJSON(const std::vector<std::pair<AddrInfo, AddressPosition>>& tableInfos, CConnman& connman)
 {
     UniValue table(UniValue::VOBJ);
     for (const auto& e : tableInfos) {
@@ -1215,14 +1150,14 @@ static RPCHelpMan getrawaddrman()
                 {RPCResult::Type::OBJ_DYN, "table", "buckets with addresses in the address manager table ( new, tried )", {
                     {RPCResult::Type::OBJ, "bucket/position", "the location in the address manager table (<bucket>/<position>)", {
                         {RPCResult::Type::STR, "address", "The address of the node"},
-                        {RPCResult::Type::NUM, "mapped_as", /*optional=*/true, "Mapped AS (Autonomous System) number at the end of the BGP route to the peer, used for diversifying peer selection (only displayed if the -asmap config option is set)"},
+                        {RPCResult::Type::NUM, "mapped_as", /*optional=*/true, "The ASN mapped to the IP of this peer per our current ASMap"},
                         {RPCResult::Type::NUM, "port", "The port number of the node"},
                         {RPCResult::Type::STR, "network", "The network (" + Join(GetNetworkNames(), ", ") + ") of the address"},
                         {RPCResult::Type::NUM, "services", "The services offered by the node"},
                         {RPCResult::Type::NUM_TIME, "time", "The " + UNIX_EPOCH_TIME + " when the node was last seen"},
                         {RPCResult::Type::STR, "source", "The address that relayed the address to us"},
                         {RPCResult::Type::STR, "source_network", "The network (" + Join(GetNetworkNames(), ", ") + ") of the source address"},
-                        {RPCResult::Type::NUM, "source_mapped_as", /*optional=*/true, "Mapped AS (Autonomous System) number at the end of the BGP route to the source, used for diversifying peer selection (only displayed if the -asmap config option is set)"}
+                        {RPCResult::Type::NUM, "source_mapped_as", /*optional=*/true, "The ASN mapped to the IP of this peer's source per our current ASMap"}
                     }}
                 }}
             }
diff --git a/src/rpc/node.cpp b/src/rpc/node.cpp
index 4601e39ec1..54e2c8e226 100644
--- a/src/rpc/node.cpp
+++ b/src/rpc/node.cpp
@@ -6,9 +6,6 @@
 #include <config/bitcoin-config.h> // IWYU pragma: keep
 
 #include <chainparams.h>
-#include <clientversion.h>
-#include <common/args.h>
-#include <common/system.h>
 #include <httpserver.h>
 #include <index/blockfilterindex.h>
 #include <index/coinstatsindex.h>
@@ -19,7 +16,6 @@
 #include <interfaces/ipc.h>
 #include <kernel/cs_main.h>
 #include <logging.h>
-#include <net.h>
 #include <node/context.h>
 #include <rpc/server.h>
 #include <rpc/server_util.h>
@@ -196,40 +192,6 @@ static RPCHelpMan getmemoryinfo()
     };
 }
 
-static RPCHelpMan getgeneralinfo()
-{
-    return RPCHelpMan{"getgeneralinfo",
-                "Returns data about the bitcoin daemon.\n",
-                {},
-                RPCResult{
-                    RPCResult::Type::OBJ, "", "",
-                    {
-                        {RPCResult::Type::STR, "clientversion", "Client version"},
-                        {RPCResult::Type::STR, "useragent", "Client name"},
-                        {RPCResult::Type::STR, "datadir", "Data directory path"},
-                        {RPCResult::Type::STR, "blocksdir", "Blocks directory path"},
-                        {RPCResult::Type::NUM, "startuptime", "Startup time"},
-                    }
-                },
-                RPCExamples{
-                    HelpExampleCli("getgeneralinfo", "")
-            + HelpExampleRpc("getgeneralinfo", "")
-                },
-        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
-{
-        const ArgsManager& args{EnsureAnyArgsman(request.context)};
-
-        UniValue obj(UniValue::VOBJ);
-        obj.pushKV("clientversion", FormatFullVersion());
-        obj.pushKV("useragent", strSubVersion);
-        obj.pushKV("datadir", fs::PathToString(args.GetDataDirNet()));
-        obj.pushKV("blocksdir", fs::PathToString(args.GetBlocksDirPath()));
-        obj.pushKV("startuptime", GetStartupTime());
-        return obj;
-},
-    };
-}
-
 static void EnableOrDisableLogCategories(UniValue cats, bool enable) {
     cats = cats.get_array();
     for (unsigned int i = 0; i < cats.size(); ++i) {
@@ -307,32 +269,6 @@ static RPCHelpMan logging()
     };
 }
 
-static RPCHelpMan format()
-{
-    return RPCHelpMan{"format",
-        "\nFormat data we have about an RPC command in the format specified\n",
-        {
-            {"command", RPCArg::Type::STR, RPCArg::Optional::NO, "Command to query"},
-            {"output", RPCArg::Type::STR, RPCArg::Optional::NO, "Output format. Accepted values: args_cli"},
-        },
-        RPCResult{RPCResult::Type::STR, "data", "Formated data about command"},
-        RPCExamples{""},
-        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
-{
-    const std::string command = request.params[0].get_str();
-    JSONRPCRequest jreq(request);
-    jreq.mode = JSONRPCRequest::GET_HELP;
-
-    try {
-        tableRPC.execute(command, jreq);
-    } catch(const UniValue& e) {
-        return e["message"];
-    }
-    return NullUniValue;
-},
-    };
-}
-
 static RPCHelpMan echo(const std::string& name)
 {
     return RPCHelpMan{name,
@@ -468,12 +404,10 @@ void RegisterNodeRPCCommands(CRPCTable& t)
 {
     static const CRPCCommand commands[]{
         {"control", &getmemoryinfo},
-        {"control", &getgeneralinfo},
         {"control", &logging},
         {"util", &getindexinfo},
         {"hidden", &setmocktime},
         {"hidden", &mockscheduler},
-        {"hidden", &format},
         {"hidden", &echo},
         {"hidden", &echojson},
         {"hidden", &echoipc},
diff --git a/src/rpc/output_script.cpp b/src/rpc/output_script.cpp
index 3ffa342ef1..01a9e59284 100644
--- a/src/rpc/output_script.cpp
+++ b/src/rpc/output_script.cpp
@@ -32,7 +32,6 @@ static RPCHelpMan validateaddress()
         "\nReturn information about the given bitcoin address.\n",
         {
             {"address", RPCArg::Type::STR, RPCArg::Optional::NO, "The bitcoin address to validate"},
-            {"address_type", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "DEPRECATED", RPCArgOptions{.hidden=true}},
         },
         RPCResult{
             RPCResult::Type::OBJ, "", "",
@@ -45,7 +44,6 @@ static RPCHelpMan validateaddress()
                 {RPCResult::Type::NUM, "witness_version", /*optional=*/true, "The version number of the witness program"},
                 {RPCResult::Type::STR_HEX, "witness_program", /*optional=*/true, "The hex value of the witness program"},
                 {RPCResult::Type::STR, "error", /*optional=*/true, "Error message, if any"},
-                {RPCResult::Type::NUM, "error_index", /*optional=*/true, "DEPRECATED. The index of the first likely error location, if known"},
                 {RPCResult::Type::ARR, "error_locations", /*optional=*/true, "Indices of likely error locations in address, if known (e.g. Bech32 errors)",
                     {
                         {RPCResult::Type::NUM, "index", "index of a potential error"},
@@ -61,14 +59,6 @@ static RPCHelpMan validateaddress()
             std::string error_msg;
             std::vector<int> error_locations;
             CTxDestination dest = DecodeDestination(request.params[0].get_str(), error_msg, &error_locations);
-
-            // Merely validate address_type is an actual address type, so we don't silently ignore potential future parameters
-            if (!request.params[1].isNull()) {
-                if (!ParseOutputType(request.params[1].get_str())) {
-                    throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Unknown address type '%s'", request.params[1].get_str()));
-                }
-            }
-
             const bool isValid = IsValidDestination(dest);
             CHECK_NONFATAL(isValid == error_msg.empty());
 
@@ -84,9 +74,6 @@ static RPCHelpMan validateaddress()
                 UniValue detail = DescribeAddress(dest);
                 ret.pushKVs(std::move(detail));
             } else {
-                if (!error_locations.empty()) {
-                    ret.pushKV("error_index", error_locations.at(0));
-                }
                 UniValue error_indices(UniValue::VARR);
                 for (int i : error_locations) error_indices.push_back(i);
                 ret.pushKV("error_locations", std::move(error_indices));
@@ -102,20 +89,14 @@ static RPCHelpMan createmultisig()
 {
     return RPCHelpMan{"createmultisig",
         "\nCreates a multi-signature address with n signature of m keys required.\n"
-        "It returns a json object with the address and redeemScript.\n"
-        "Public keys can be sorted according to BIP67 during the request if required.\n",
+        "It returns a json object with the address and redeemScript.\n",
         {
             {"nrequired", RPCArg::Type::NUM, RPCArg::Optional::NO, "The number of required signatures out of the n keys."},
             {"keys", RPCArg::Type::ARR, RPCArg::Optional::NO, "The hex-encoded public keys.",
                 {
                     {"key", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, "The hex-encoded public key"},
                 }},
-            {"options|address_type", {RPCArg::Type::OBJ_NAMED_PARAMS, RPCArg::Type::STR}, RPCArg::Optional::OMITTED, "",
-                {
-                    {"address_type", RPCArg::Type::STR, RPCArg::Default{"legacy"}, "The address type to use. Options are \"legacy\", \"p2sh-segwit\", and \"bech32\".", RPCArgOptions{.also_positional = true}},
-                    {"sort", RPCArg::Type::BOOL, RPCArg::Default{false}, "Whether to sort public keys according to BIP67."},
-                },
-                RPCArgOptions{.oneline_description="options"}},
+            {"address_type", RPCArg::Type::STR, RPCArg::Default{"legacy"}, "The address type to use. Options are \"legacy\", \"p2sh-segwit\", and \"bech32\"."},
         },
         RPCResult{
             RPCResult::Type::OBJ, "", "",
@@ -139,54 +120,28 @@ static RPCHelpMan createmultisig()
         {
             int required = request.params[0].getInt<int>();
 
-            bool sort = false;
-            OutputType output_type = OutputType::LEGACY;
-
-            if (request.params[2].isStr()) {
-                // backward compatibility
-                std::optional<OutputType> parsed = ParseOutputType(request.params[2].get_str());
-                if (!parsed) {
-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf("Unknown address type '%s'", request.params[2].get_str()));
-                }
-                output_type = parsed.value();
-            } else if (!request.params[2].isNull()) {
-                const UniValue& options = request.params[2].get_obj();
-                RPCTypeCheckObj(options,
-                    {
-                        {"address_type", UniValueType(UniValue::VSTR)},
-                        {"sort", UniValueType(UniValue::VBOOL)},
-                    },
-                    true, true);
-
-                if (options.exists("address_type")) {
-                    std::optional<OutputType> parsed = ParseOutputType(options["address_type"].get_str());
-                    if (!parsed) {
-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf("Unknown address type '%s'", options["address_type"].get_str()));
-                    }
-                    output_type = parsed.value();
-                }
-
-                if (options.exists("sort")) {
-                    sort = options["sort"].get_bool();
-                }
-            }
-            if (output_type == OutputType::BECH32M) {
-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "createmultisig cannot create bech32m multisig addresses");
-            }
-
             // Get the public keys
             const UniValue& keys = request.params[1].get_array();
             std::vector<CPubKey> pubkeys;
             for (unsigned int i = 0; i < keys.size(); ++i) {
                 pubkeys.push_back(HexToPubKey(keys[i].get_str()));
-                if (sort && !pubkeys.back().IsCompressed()) {
-                    throw std::runtime_error(strprintf("Compressed key required for BIP67: %s", keys[i].get_str()));
+            }
+
+            // Get the output type
+            OutputType output_type = OutputType::LEGACY;
+            if (!request.params[2].isNull()) {
+                std::optional<OutputType> parsed = ParseOutputType(request.params[2].get_str());
+                if (!parsed) {
+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf("Unknown address type '%s'", request.params[2].get_str()));
+                } else if (parsed.value() == OutputType::BECH32M) {
+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "createmultisig cannot create bech32m multisig addresses");
                 }
+                output_type = parsed.value();
             }
 
             FlatSigningProvider keystore;
             CScript inner;
-            const CTxDestination dest = AddAndGetMultisigDestination(required, pubkeys, output_type, keystore, inner, sort);
+            const CTxDestination dest = AddAndGetMultisigDestination(required, pubkeys, output_type, keystore, inner);
 
             // Make the descriptor
             std::unique_ptr<Descriptor> descriptor = InferDescriptor(GetScriptForDestination(dest), keystore);
@@ -270,12 +225,6 @@ static RPCHelpMan deriveaddresses()
         {
             {"descriptor", RPCArg::Type::STR, RPCArg::Optional::NO, "The descriptor."},
             {"range", RPCArg::Type::RANGE, RPCArg::Optional::OMITTED, "If a ranged descriptor is used, this specifies the end or the range (in [begin,end] notation) to derive."},
-            {"options", RPCArg::Type::OBJ_NAMED_PARAMS, RPCArg::Optional::OMITTED, "",
-                {
-                    {"require_checksum", RPCArg::Type::BOOL, RPCArg::Default{true}, "Require a checksum. If a checksum is provided it will be verified regardless of this parameter."},
-                },
-                RPCArgOptions{.oneline_description="options"}
-            },
         },
         RPCResult{
             RPCResult::Type::ARR, "", "",
@@ -284,29 +233,13 @@ static RPCHelpMan deriveaddresses()
             }
         },
         RPCExamples{
-            "First three native segwit receive addresses:\n" +
+            "First three native segwit receive addresses\n" +
             HelpExampleCli("deriveaddresses", "\"" + EXAMPLE_DESCRIPTOR + "\" \"[0,2]\"") +
-            HelpExampleRpc("deriveaddresses", "\"" + EXAMPLE_DESCRIPTOR + "\", \"[0,2]\"") +
-            "Derive the PKH address from a WIF, which has a built-in checksum:\n" +
-            HelpExampleCli("deriveaddresses", "\"pkh(cPsQTSmMZ8e3AEUWGjS73f5R364yJxH6RxcgnwbHjbKbFPUP2Dtu)\" null '{\"require_checksum\": false}'")
+            HelpExampleRpc("deriveaddresses", "\"" + EXAMPLE_DESCRIPTOR + "\", \"[0,2]\"")
         },
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
         {
             const std::string desc_str = request.params[0].get_str();
-            bool require_checksum = true;
-
-            if (!request.params[2].isNull()) {
-                const UniValue& options = request.params[2];
-                RPCTypeCheckObj(options,
-                    {
-                        {"require_checksum", UniValueType(UniValue::VBOOL)},
-                    },
-                    true, true);
-
-                if (options.exists("require_checksum")) {
-                    require_checksum = options["require_checksum"].get_bool();
-                }
-            }
 
             int64_t range_begin = 0;
             int64_t range_end = 0;
@@ -317,16 +250,16 @@ static RPCHelpMan deriveaddresses()
 
             FlatSigningProvider key_provider;
             std::string error;
-            auto desc = Parse(desc_str, key_provider, error, require_checksum);
+            auto desc = Parse(desc_str, key_provider, error, /* require_checksum = */ true);
             if (!desc) {
                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, error);
             }
 
-            if (!desc->IsRange() && !request.params[1].isNull()) {
+            if (!desc->IsRange() && request.params.size() > 1) {
                 throw JSONRPCError(RPC_INVALID_PARAMETER, "Range should not be specified for an un-ranged descriptor");
             }
 
-            if (desc->IsRange() && request.params[1].isNull()) {
+            if (desc->IsRange() && request.params.size() == 1) {
                 throw JSONRPCError(RPC_INVALID_PARAMETER, "Range must be specified for a ranged descriptor");
             }
 
diff --git a/src/rpc/rawtransaction.cpp b/src/rpc/rawtransaction.cpp
index 5beacdd8cd..21bc0e52f1 100644
--- a/src/rpc/rawtransaction.cpp
+++ b/src/rpc/rawtransaction.cpp
@@ -24,7 +24,6 @@
 #include <psbt.h>
 #include <random.h>
 #include <rpc/blockchain.h>
-#include <rpc/rawtransaction.h>
 #include <rpc/rawtransaction_util.h>
 #include <rpc/server.h>
 #include <rpc/server_util.h>
@@ -73,13 +72,7 @@ static void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue&
         const CBlockIndex* pindex = active_chainstate.m_blockman.LookupBlockIndex(hashBlock);
         if (pindex) {
             if (active_chainstate.m_chain.Contains(pindex)) {
-                const auto assumed_base = active_chainstate.SnapshotBase();
-                if (assumed_base && pindex->nHeight < assumed_base->nHeight) {
-                    entry.pushKV("confirmations", 0);
-                    entry.pushKV("confirmations_assumed", 1 + active_chainstate.m_chain.Height() - pindex->nHeight);
-                } else {
                 entry.pushKV("confirmations", 1 + active_chainstate.m_chain.Height() - pindex->nHeight);
-                }
                 entry.pushKV("time", pindex->GetBlockTime());
                 entry.pushKV("blocktime", pindex->GetBlockTime());
             }
@@ -89,7 +82,7 @@ static void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue&
     }
 }
 
-std::vector<RPCResult> ScriptPubKeyDoc() {
+static std::vector<RPCResult> ScriptPubKeyDoc() {
     return
          {
              {RPCResult::Type::STR, "asm", "Disassembly of the output script"},
@@ -100,7 +93,7 @@ std::vector<RPCResult> ScriptPubKeyDoc() {
          };
 }
 
-std::vector<RPCResult> DecodeTxDoc(const std::string& txid_field_doc)
+static std::vector<RPCResult> DecodeTxDoc(const std::string& txid_field_doc)
 {
     return {
         {RPCResult::Type::STR_HEX, "txid", txid_field_doc},
@@ -181,7 +174,7 @@ static std::vector<RPCArg> CreateTxDoc()
 
 // Update PSBT with information from the mempool, the UTXO set, the txindex, and the provided descriptors.
 // Optionally, sign the inputs that we can using information from the descriptors.
-PartiallySignedTransaction ProcessPSBT(const std::string& psbt_string, const std::any& context, const HidingSigningProvider& provider, int sighash_type, const std::optional<std::vector<CTransactionRef>>& prev_txs, bool finalize)
+PartiallySignedTransaction ProcessPSBT(const std::string& psbt_string, const std::any& context, const HidingSigningProvider& provider, int sighash_type, bool finalize)
 {
     // Unserialize the transactions
     PartiallySignedTransaction psbtx;
@@ -198,20 +191,8 @@ PartiallySignedTransaction ProcessPSBT(const std::string& psbt_string, const std
     // the full transaction isn't found
     std::map<COutPoint, Coin> coins;
 
-    // Filter prev_txs to unique txids and create lookup
-    std::map<Txid, CTransactionRef> prev_tx_map;
-    if (prev_txs.has_value()) {
-        for (const auto& tx : prev_txs.value()) {
-            const auto txid = tx->GetHash();
-            if (prev_tx_map.count(txid)) {
-                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf("Duplicate txids in prev_txs %s", txid.GetHex()));
-            }
-            prev_tx_map[txid] = tx;
-        }
-    }
-
     // Fetch previous transactions:
-    // First, look in prev_txs, the txindex, and the mempool
+    // First, look in the txindex and the mempool
     for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {
         PSBTInput& psbt_input = psbtx.inputs.at(i);
         const CTxIn& tx_in = psbtx.tx->vin.at(i);
@@ -221,17 +202,8 @@ PartiallySignedTransaction ProcessPSBT(const std::string& psbt_string, const std
 
         CTransactionRef tx;
 
-        // First look in provided dependant transactions
-        if (prev_tx_map.contains(tx_in.prevout.hash)) {
-            tx = prev_tx_map[tx_in.prevout.hash];
-            // Sanity check it has an output
-            // at the right index
-            if (tx_in.prevout.n >= tx->vout.size()) {
-                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf("Previous tx has too few outputs for PSBT input %s", tx->GetHash().GetHex()));
-            }
-        }
-        // Then look in the txindex
-        if (!tx && g_txindex) {
+        // Look in the txindex
+        if (g_txindex) {
             uint256 block_hash;
             g_txindex->FindTx(tx_in.prevout.hash, block_hash, tx);
         }
@@ -318,7 +290,6 @@ static RPCHelpMan getrawtransaction()
                              {RPCResult::Type::BOOL, "in_active_chain", /*optional=*/true, "Whether specified block is in the active chain or not (only present with explicit \"blockhash\" argument)"},
                              {RPCResult::Type::STR_HEX, "blockhash", /*optional=*/true, "the block hash"},
                              {RPCResult::Type::NUM, "confirmations", /*optional=*/true, "The confirmations"},
-                             {RPCResult::Type::NUM, "confirmations_assumed", /*optional=*/true, "The number of unverified confirmations (eg, in an assumed-valid UTXO set)"},
                              {RPCResult::Type::NUM_TIME, "blocktime", /*optional=*/true, "The block time expressed in " + UNIX_EPOCH_TIME},
                              {RPCResult::Type::NUM, "time", /*optional=*/true, "Same as \"blocktime\""},
                              {RPCResult::Type::STR_HEX, "hex", "The serialized, hex-encoded data for 'txid'"},
@@ -467,8 +438,8 @@ static RPCHelpMan createrawtransaction()
                 RPCExamples{
                     HelpExampleCli("createrawtransaction", "\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":0}]\" \"[{\\\"address\\\":0.01}]\"")
             + HelpExampleCli("createrawtransaction", "\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":0}]\" \"[{\\\"data\\\":\\\"00010203\\\"}]\"")
-            + HelpExampleRpc("createrawtransaction", "[{\"txid\":\"myid\",\"vout\":0}], [{\"address\":0.01}]")
-            + HelpExampleRpc("createrawtransaction", "[{\"txid\":\"myid\",\"vout\":0}], [{\"data\":\"00010203\"}]")
+            + HelpExampleRpc("createrawtransaction", "\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":0}]\", \"[{\\\"address\\\":0.01}]\"")
+            + HelpExampleRpc("createrawtransaction", "\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":0}]\", \"[{\\\"data\\\":\\\"00010203\\\"}]\"")
                 },
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
 {
@@ -546,9 +517,9 @@ static RPCHelpMan decodescript()
                  {
                      {RPCResult::Type::STR, "asm", "Disassembly of the output script"},
                      {RPCResult::Type::STR_HEX, "hex", "The raw output script bytes, hex-encoded"},
+                     {RPCResult::Type::STR, "type", "The type of the output script (e.g. witness_v0_keyhash or witness_v0_scripthash)"},
                      {RPCResult::Type::STR, "address", /*optional=*/true, "The Bitcoin address (only if a well-defined address exists)"},
                      {RPCResult::Type::STR, "desc", "Inferred descriptor for the script"},
-                     {RPCResult::Type::STR, "type", "The type of the output script (one of: " + GetAllOutputTypes() + ")"},
                      {RPCResult::Type::STR, "p2sh-segwit", "address of the P2SH script wrapping this witness redeem script"},
                  }},
             },
@@ -789,8 +760,6 @@ static RPCHelpMan signrawtransactionwithkey()
                     {
                         {RPCResult::Type::STR_HEX, "hex", "The hex-encoded raw transaction with signature(s)"},
                         {RPCResult::Type::BOOL, "complete", "If the transaction has a complete set of signatures"},
-                        {RPCResult::Type::STR_AMOUNT, "fee", /*optional=*/true, "The fee (input amounts minus output amounts), if known"},
-                        {RPCResult::Type::STR_AMOUNT, "feerate", /*optional=*/true, "The fee rate (in " + CURRENCY_UNIT + "/kB), if fee is known"},
                         {RPCResult::Type::ARR, "errors", /*optional=*/true, "Script verification errors (if there are any)",
                         {
                             {RPCResult::Type::OBJ, "", "",
@@ -810,7 +779,7 @@ static RPCHelpMan signrawtransactionwithkey()
                 },
                 RPCExamples{
                     HelpExampleCli("signrawtransactionwithkey", "\"myhex\" \"[\\\"key1\\\",\\\"key2\\\"]\"")
-            + HelpExampleRpc("signrawtransactionwithkey", "\"myhex\", [\"key1\",\"key2\"]")
+            + HelpExampleRpc("signrawtransactionwithkey", "\"myhex\", \"[\\\"key1\\\",\\\"key2\\\"]\"")
                 },
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
 {
@@ -867,10 +836,10 @@ const RPCResult decodepsbt_inputs{
                 {RPCResult::Type::OBJ, "scriptPubKey", "",
                 {
                     {RPCResult::Type::STR, "asm", "Disassembly of the output script"},
-                    {RPCResult::Type::STR, "desc", "Inferred descriptor for the script"},
+                    {RPCResult::Type::STR, "desc", "Inferred descriptor for the output"},
                     {RPCResult::Type::STR_HEX, "hex", "The raw output script bytes, hex-encoded"},
+                    {RPCResult::Type::STR, "type", "The type, eg 'pubkeyhash'"},
                     {RPCResult::Type::STR, "address", /*optional=*/true, "The Bitcoin address (only if a well-defined address exists)"},
-                    {RPCResult::Type::STR, "type", "The type (one of: " + GetAllOutputTypes() + ")"},
                 }},
             }},
             {RPCResult::Type::OBJ_DYN, "partial_signatures", /*optional=*/true, "",
@@ -882,13 +851,13 @@ const RPCResult decodepsbt_inputs{
             {
                 {RPCResult::Type::STR, "asm", "Disassembly of the redeem script"},
                 {RPCResult::Type::STR_HEX, "hex", "The raw redeem script bytes, hex-encoded"},
-                {RPCResult::Type::STR, "type", "The type (one of: " + GetAllOutputTypes() + ")"},
+                {RPCResult::Type::STR, "type", "The type, eg 'pubkeyhash'"},
             }},
             {RPCResult::Type::OBJ, "witness_script", /*optional=*/true, "",
             {
                 {RPCResult::Type::STR, "asm", "Disassembly of the witness script"},
                 {RPCResult::Type::STR_HEX, "hex", "The raw witness script bytes, hex-encoded"},
-                {RPCResult::Type::STR, "type", "The type (one of: " + GetAllOutputTypes() + ")"},
+                {RPCResult::Type::STR, "type", "The type, eg 'pubkeyhash'"},
             }},
             {RPCResult::Type::ARR, "bip32_derivs", /*optional=*/true, "",
             {
@@ -988,13 +957,13 @@ const RPCResult decodepsbt_outputs{
             {
                 {RPCResult::Type::STR, "asm", "Disassembly of the redeem script"},
                 {RPCResult::Type::STR_HEX, "hex", "The raw redeem script bytes, hex-encoded"},
-                {RPCResult::Type::STR, "type", "The type (one of: " + GetAllOutputTypes() + ")"},
+                {RPCResult::Type::STR, "type", "The type, eg 'pubkeyhash'"},
             }},
             {RPCResult::Type::OBJ, "witness_script", /*optional=*/true, "",
             {
                 {RPCResult::Type::STR, "asm", "Disassembly of the witness script"},
                 {RPCResult::Type::STR_HEX, "hex", "The raw witness script bytes, hex-encoded"},
-                {RPCResult::Type::STR, "type", "The type (one of: " + GetAllOutputTypes() + ")"},
+                {RPCResult::Type::STR, "type", "The type, eg 'pubkeyhash'"},
             }},
             {RPCResult::Type::ARR, "bip32_derivs", /*optional=*/true, "",
             {
@@ -1701,7 +1670,7 @@ static RPCHelpMan converttopsbt()
 static RPCHelpMan utxoupdatepsbt()
 {
     return RPCHelpMan{"utxoupdatepsbt",
-            "\nUpdates all segwit inputs and outputs in a PSBT with data from output descriptors, provided dependant transactions, the UTXO set, txindex, or the mempool.\n",
+            "\nUpdates all segwit inputs and outputs in a PSBT with data from output descriptors, the UTXO set, txindex, or the mempool.\n",
             {
                 {"psbt", RPCArg::Type::STR, RPCArg::Optional::NO, "A base64 string of a PSBT"},
                 {"descriptors", RPCArg::Type::ARR, RPCArg::Optional::OMITTED, "An array of either strings or objects", {
@@ -1711,9 +1680,6 @@ static RPCHelpMan utxoupdatepsbt()
                          {"range", RPCArg::Type::RANGE, RPCArg::Default{1000}, "Up to what index HD chains should be explored (either end or [begin,end])"},
                     }},
                 }},
-                {"prevtxs", RPCArg::Type::ARR, RPCArg::Optional::OMITTED, "An array of dependant serialized transactions as hex", {
-                    {"", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "A serialized previous transaction in hex"},
-                }},
             },
             RPCResult {
                     RPCResult::Type::STR, "", "The base64-encoded partially signed transaction with inputs updated"
@@ -1732,18 +1698,12 @@ static RPCHelpMan utxoupdatepsbt()
         }
     }
 
-    std::vector<CTransactionRef> prev_txns;
-    if (!request.params[2].isNull()) {
-        prev_txns = ParseTransactionVector(request.params[2]);
-    }
-
     // We don't actually need private keys further on; hide them as a precaution.
     const PartiallySignedTransaction& psbtx = ProcessPSBT(
         request.params[0].get_str(),
         request.context,
         HidingSigningProvider(&provider, /*hide_secret=*/true, /*hide_origin=*/false),
         /*sighash_type=*/SIGHASH_ALL,
-        /*prev_txs=*/prev_txns,
         /*finalize=*/false);
 
     DataStream ssTx{};
@@ -1977,8 +1937,6 @@ RPCHelpMan descriptorprocesspsbt()
                              {"range", RPCArg::Type::RANGE, RPCArg::Default{1000}, "Up to what index HD chains should be explored (either end or [begin,end])"},
                         }},
                     }},
-                    {"options|sighashtype", {RPCArg::Type::OBJ_NAMED_PARAMS, RPCArg::Type::STR}, RPCArg::Optional::OMITTED, "",
-                        {
                     {"sighashtype", RPCArg::Type::STR, RPCArg::Default{"DEFAULT for Taproot, ALL otherwise"}, "The signature hash type to sign with if not specified by the PSBT. Must be one of\n"
             "       \"DEFAULT\"\n"
             "       \"ALL\"\n"
@@ -1986,17 +1944,9 @@ RPCHelpMan descriptorprocesspsbt()
             "       \"SINGLE\"\n"
             "       \"ALL|ANYONECANPAY\"\n"
             "       \"NONE|ANYONECANPAY\"\n"
-                    "       \"SINGLE|ANYONECANPAY\"",
-                                RPCArgOptions{.also_positional = true}},
-                            {"bip32derivs", RPCArg::Type::BOOL, RPCArg::Default{true}, "Include BIP 32 derivation paths for public keys if we know them", RPCArgOptions{.also_positional = true}},
-                            {"finalize", RPCArg::Type::BOOL, RPCArg::Default{true}, "Also finalize inputs if possible", RPCArgOptions{.also_positional = true}},
-                            {"prevtxs", RPCArg::Type::ARR, RPCArg::Optional::OMITTED, "An array of dependant serialized transactions as hex", {
-                                {"", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "A serialized previous transaction in hex"},
-                            }},
-                        },
-                    RPCArgOptions{.oneline_description="options"}},
-                    {"bip32derivs", RPCArg::Type::BOOL, RPCArg::Default{true}, "for backwards compatibility", RPCArgOptions{.hidden=true}},
-                    {"finalize", RPCArg::Type::BOOL, RPCArg::Default{true}, "for backwards compatibility", RPCArgOptions{.hidden=true}},
+            "       \"SINGLE|ANYONECANPAY\""},
+                    {"bip32derivs", RPCArg::Type::BOOL, RPCArg::Default{true}, "Include BIP 32 derivation paths for public keys if we know them"},
+                    {"finalize", RPCArg::Type::BOOL, RPCArg::Default{true}, "Also finalize inputs if possible"},
                 },
                 RPCResult{
                     RPCResult::Type::OBJ, "", "",
@@ -2020,51 +1970,15 @@ RPCHelpMan descriptorprocesspsbt()
         EvalDescriptorStringOrObject(descs[i], provider, /*expand_priv=*/true);
     }
 
-    // Get options
-    bool bip32derivs = true;
-    bool finalize = true;
-    int sighash_type = ParseSighashString(NullUniValue); // Use ParseSighashString default
-    std::vector<CTransactionRef> prev_txns;
-    if (request.params[2].isStr() || request.params[2].isNull()) {
-        // Old style positional parameters
-        sighash_type = ParseSighashString(request.params[2]);
-        bip32derivs = request.params[3].isNull() ? true : request.params[3].get_bool();
-        finalize = request.params[4].isNull() ? true : request.params[4].get_bool();
-    } else {
-        // New style options are in an object
-        UniValue options = request.params[2];
-        RPCTypeCheckObj(options,
-            {
-                {"bip32derivs", UniValueType(UniValue::VBOOL)},
-                {"finalize", UniValueType(UniValue::VBOOL)},
-                {"prevtxs", UniValueType(UniValue::VARR)},
-                {"sighashtype", UniValueType(UniValue::VSTR)},
-            },
-            true, true);
-        if (options.exists("bip32derivs")) {
-            bip32derivs = options["bip32derivs"].get_bool();
-        }
-        if (options.exists("finalize")) {
-            finalize = options["finalize"].get_bool();
-        }
-        if (options.exists("prevtxs")) {
-            prev_txns = ParseTransactionVector(options["prevtxs"]);
-        }
-        if (options.exists("sighashtype")) {
-            sighash_type = ParseSighashString(options["sighashtype"]);
-        }
-        if (request.params.size() > 3) {
-            // Same behaviour as too many args passed normally
-            throw std::runtime_error(self.ToString());
-        }
-    }
+    int sighash_type = ParseSighashString(request.params[2]);
+    bool bip32derivs = request.params[3].isNull() ? true : request.params[3].get_bool();
+    bool finalize = request.params[4].isNull() ? true : request.params[4].get_bool();
 
     const PartiallySignedTransaction& psbtx = ProcessPSBT(
         request.params[0].get_str(),
         request.context,
         HidingSigningProvider(&provider, /*hide_secret=*/false, !bip32derivs),
         sighash_type,
-        /*prev_txs=*/prev_txns,
         finalize);
 
     // Check whether or not all of the inputs are now signed
diff --git a/src/rpc/rawtransaction.h b/src/rpc/rawtransaction.h
deleted file mode 100644
index 9b5f746223..0000000000
--- a/src/rpc/rawtransaction.h
+++ /dev/null
@@ -1,14 +0,0 @@
-// Copyright (c) 2017-2022 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#ifndef BITCOIN_RPC_RAWTRANSACTION_H
-#define BITCOIN_RPC_RAWTRANSACTION_H
-
-#include <string>
-
-struct RPCResult;
-
-std::vector<RPCResult> DecodeTxDoc(const std::string& txid_field_doc);
-
-#endif // BITCOIN_RPC_RAWTRANSACTION_H
diff --git a/src/rpc/rawtransaction_util.cpp b/src/rpc/rawtransaction_util.cpp
index 28201f8732..53f943bb9e 100644
--- a/src/rpc/rawtransaction_util.cpp
+++ b/src/rpc/rawtransaction_util.cpp
@@ -21,8 +21,6 @@
 #include <util/strencodings.h>
 #include <util/translation.h>
 
-#include <optional>
-
 void AddInputs(CMutableTransaction& rawTx, const UniValue& inputs_in, std::optional<bool> rbf)
 {
     UniValue inputs;
@@ -310,13 +308,12 @@ void SignTransaction(CMutableTransaction& mtx, const SigningProvider* keystore,
 
     // Script verification errors
     std::map<int, bilingual_str> input_errors;
-    std::optional<CAmount> inputs_amount_sum;
 
-    bool complete = SignTransaction(mtx, keystore, coins, nHashType, input_errors, &inputs_amount_sum);
-    SignTransactionResultToJSON(mtx, complete, coins, input_errors, result, inputs_amount_sum);
+    bool complete = SignTransaction(mtx, keystore, coins, nHashType, input_errors);
+    SignTransactionResultToJSON(mtx, complete, coins, input_errors, result);
 }
 
-void SignTransactionResultToJSON(CMutableTransaction& mtx, bool complete, const std::map<COutPoint, Coin>& coins, const std::map<int, bilingual_str>& input_errors, UniValue& result, const std::optional<CAmount>& inputs_amount_sum)
+void SignTransactionResultToJSON(CMutableTransaction& mtx, bool complete, const std::map<COutPoint, Coin>& coins, const std::map<int, bilingual_str>& input_errors, UniValue& result)
 {
     // Make errors UniValue
     UniValue vErrors(UniValue::VARR);
@@ -328,21 +325,8 @@ void SignTransactionResultToJSON(CMutableTransaction& mtx, bool complete, const
         TxInErrorToJSON(mtx.vin.at(err_pair.first), vErrors, err_pair.second.original);
     }
 
-    CTransaction tx(mtx);
-    result.pushKV("hex", EncodeHexTx(tx));
+    result.pushKV("hex", EncodeHexTx(CTransaction(mtx)));
     result.pushKV("complete", complete);
-    if (inputs_amount_sum) {
-        CAmount inout_amount = *inputs_amount_sum;
-        for (const CTxOut& txout : mtx.vout) {
-            inout_amount -= txout.nValue;
-        }
-        result.pushKV("fee", ValueFromAmount(inout_amount));
-        result.pushKV("feerate",
-            ValueFromAmount(
-                CFeeRate(inout_amount, GetVirtualTransactionSize(tx)).GetFeePerK()
-            )
-        );
-    }
     if (!vErrors.empty()) {
         if (result.exists("errors")) {
             vErrors.push_backV(result["errors"].getValues());
diff --git a/src/rpc/rawtransaction_util.h b/src/rpc/rawtransaction_util.h
index 499aeeb2a0..40d6bbba87 100644
--- a/src/rpc/rawtransaction_util.h
+++ b/src/rpc/rawtransaction_util.h
@@ -8,7 +8,6 @@
 #include <addresstype.h>
 #include <consensus/amount.h>
 #include <map>
-#include <optional>
 #include <string>
 #include <optional>
 
@@ -30,7 +29,7 @@ class SigningProvider;
  * @param result         JSON object where signed transaction results accumulate
  */
 void SignTransaction(CMutableTransaction& mtx, const SigningProvider* keystore, const std::map<COutPoint, Coin>& coins, const UniValue& hashType, UniValue& result);
-void SignTransactionResultToJSON(CMutableTransaction& mtx, bool complete, const std::map<COutPoint, Coin>& coins, const std::map<int, bilingual_str>& input_errors, UniValue& result, const std::optional<CAmount>& inputs_amount_sum);
+void SignTransactionResultToJSON(CMutableTransaction& mtx, bool complete, const std::map<COutPoint, Coin>& coins, const std::map<int, bilingual_str>& input_errors, UniValue& result);
 
 /**
   * Parse a prevtxs UniValue array and get the map of coins from it
diff --git a/src/rpc/register.h b/src/rpc/register.h
index b75831b739..65fd29ff08 100644
--- a/src/rpc/register.h
+++ b/src/rpc/register.h
@@ -22,7 +22,6 @@ void RegisterRawTransactionRPCCommands(CRPCTable &tableRPC);
 void RegisterSignMessageRPCCommands(CRPCTable&);
 void RegisterSignerRPCCommands(CRPCTable &tableRPC);
 void RegisterTxoutProofRPCCommands(CRPCTable&);
-void RegisterStatsRPCCommands(CRPCTable&);
 
 static inline void RegisterAllCoreRPCCommands(CRPCTable &t)
 {
@@ -39,7 +38,6 @@ static inline void RegisterAllCoreRPCCommands(CRPCTable &t)
     RegisterSignerRPCCommands(t);
 #endif // ENABLE_EXTERNAL_SIGNER
     RegisterTxoutProofRPCCommands(t);
-    RegisterStatsRPCCommands(t);
 }
 
 #endif // BITCOIN_RPC_REGISTER_H
diff --git a/src/rpc/request.cpp b/src/rpc/request.cpp
index 8cc57cb536..083d1be44f 100644
--- a/src/rpc/request.cpp
+++ b/src/rpc/request.cpp
@@ -16,7 +16,6 @@
 #include <fstream>
 #include <stdexcept>
 #include <string>
-#include <utility>
 #include <vector>
 
 /**
@@ -87,18 +86,15 @@ static const char* const COOKIEAUTH_FILE = ".cookie";
 static fs::path GetAuthCookieFile(bool temp=false)
 {
     fs::path arg = gArgs.GetPathArg("-rpccookiefile", COOKIEAUTH_FILE);
-    if (arg.empty()) {
-        return {}; // -norpccookiefile was specified
-    }
     if (temp) {
         arg += ".tmp";
     }
     return AbsPathForConfigVal(gArgs, arg);
 }
 
-static std::optional<std::string> g_generated_cookie;
+static bool g_generated_cookie = false;
 
-bool GenerateAuthCookie(std::string* cookie_out, const std::pair<std::optional<fs::perms>, bool>& cookie_perms)
+bool GenerateAuthCookie(std::string* cookie_out, std::optional<fs::perms> cookie_perms)
 {
     const size_t COOKIE_SIZE = 32;
     unsigned char rand_pwd[COOKIE_SIZE];
@@ -110,48 +106,31 @@ bool GenerateAuthCookie(std::string* cookie_out, const std::pair<std::optional<f
      */
     std::ofstream file;
     fs::path filepath_tmp = GetAuthCookieFile(true);
-    if (filepath_tmp.empty()) {
-        return true; // -norpccookiefile
-    }
-    try {
-        fs::remove(filepath_tmp);
-    } catch (const fs::filesystem_error& e) {
-        // ignore
-    }
     file.open(filepath_tmp);
     if (!file.is_open()) {
-        LogWarning("Unable to open cookie authentication file %s for writing", fs::PathToString(filepath_tmp));
+        LogInfo("Unable to open cookie authentication file %s for writing\n", fs::PathToString(filepath_tmp));
         return false;
     }
-
-    if (cookie_perms.first) {
-        std::error_code code;
-        fs::permissions(filepath_tmp, cookie_perms.first.value(), fs::perm_options::replace, code);
-        if (code) {
-            LogWarning("Unable to set permissions on cookie authentication file %s", fs::PathToString(filepath_tmp));
-            return false;
-        }
-    }
-
     file << cookie;
     file.close();
 
     fs::path filepath = GetAuthCookieFile(false);
-    try {
-        fs::remove(filepath);
-    } catch (const fs::filesystem_error& e) {
-        // ignore
-    }
     if (!RenameOver(filepath_tmp, filepath)) {
-        LogWarning("Unable to rename cookie authentication file %s to %s", fs::PathToString(filepath_tmp), fs::PathToString(filepath));
+        LogInfo("Unable to rename cookie authentication file %s to %s\n", fs::PathToString(filepath_tmp), fs::PathToString(filepath));
         return false;
     }
+    if (cookie_perms) {
+        std::error_code code;
+        fs::permissions(filepath, cookie_perms.value(), fs::perm_options::replace, code);
+        if (code) {
+            LogInfo("Unable to set permissions on cookie authentication file %s\n", fs::PathToString(filepath_tmp));
+            return false;
+        }
+    }
 
-    g_generated_cookie = cookie;
+    g_generated_cookie = true;
     LogInfo("Generated RPC authentication cookie %s\n", fs::PathToString(filepath));
-    LogInfo("Permissions used for cookie%s: %s\n",
-              (cookie_perms.first && cookie_perms.second) ? " (set by -rpccookieperms)" : "",
-              PermsToSymbolicString(fs::status(filepath).permissions()));
+    LogInfo("Permissions used for cookie: %s\n", PermsToSymbolicString(fs::status(filepath).permissions()));
 
     if (cookie_out)
         *cookie_out = cookie;
@@ -163,9 +142,6 @@ bool GetAuthCookie(std::string *cookie_out)
     std::ifstream file;
     std::string cookie;
     fs::path filepath = GetAuthCookieFile();
-    if (filepath.empty()) {
-        return true; // -norpccookiefile
-    }
     file.open(filepath);
     if (!file.is_open())
         return false;
@@ -180,9 +156,8 @@ bool GetAuthCookie(std::string *cookie_out)
 void DeleteAuthCookie()
 {
     try {
-        std::string existing_cookie;
-        if (GetAuthCookie(&existing_cookie) && g_generated_cookie == existing_cookie) {
-            // Delete the cookie file if it exists and was generated by this process
+        if (g_generated_cookie) {
+            // Delete the cookie file if it was generated by this process
             fs::remove(GetAuthCookieFile());
         }
     } catch (const fs::filesystem_error& e) {
@@ -228,8 +203,18 @@ void JSONRPCRequest::parse(const UniValue& valRequest)
     m_json_version = JSONRPCVersion::V1_LEGACY;
     const UniValue& jsonrpc_version = request.find_value("jsonrpc");
     if (!jsonrpc_version.isNull()) {
-        if (jsonrpc_version.isStr() && jsonrpc_version.get_str() == "2.0") {
+        if (!jsonrpc_version.isStr()) {
+            throw JSONRPCError(RPC_INVALID_REQUEST, "jsonrpc field must be a string");
+        }
+        // The "jsonrpc" key was added in the 2.0 spec, but some older documentation
+        // incorrectly included {"jsonrpc":"1.0"} in a request object, so we
+        // maintain that for backwards compatibility.
+        if (jsonrpc_version.get_str() == "1.0") {
+            m_json_version = JSONRPCVersion::V1_LEGACY;
+        } else if (jsonrpc_version.get_str() == "2.0") {
             m_json_version = JSONRPCVersion::V2;
+        } else {
+            throw JSONRPCError(RPC_INVALID_REQUEST, "JSON-RPC version not supported");
         }
     }
 
diff --git a/src/rpc/request.h b/src/rpc/request.h
index 8d80b7a44e..24887e8691 100644
--- a/src/rpc/request.h
+++ b/src/rpc/request.h
@@ -9,7 +9,6 @@
 #include <any>
 #include <optional>
 #include <string>
-#include <utility>
 
 #include <univalue.h>
 #include <util/fs.h>
@@ -25,7 +24,7 @@ UniValue JSONRPCReplyObj(UniValue result, UniValue error, std::optional<UniValue
 UniValue JSONRPCError(int code, const std::string& message);
 
 /** Generate a new RPC authentication cookie and write it to disk */
-bool GenerateAuthCookie(std::string* cookie_out, const std::pair<std::optional<fs::perms>, bool>& cookie_perms);
+bool GenerateAuthCookie(std::string* cookie_out, std::optional<fs::perms> cookie_perms=std::nullopt);
 /** Read the RPC authentication cookie from disk */
 bool GetAuthCookie(std::string *cookie_out);
 /** Delete RPC authentication cookie from disk */
@@ -42,7 +41,6 @@ public:
     enum Mode { EXECUTE, GET_HELP, GET_ARGS } mode = EXECUTE;
     std::string URI;
     std::string authUser;
-    std::string m_wallet_restriction{"-"};
     std::string peerAddr;
     std::any context;
     JSONRPCVersion m_json_version = JSONRPCVersion::V1_LEGACY;
diff --git a/src/rpc/server.cpp b/src/rpc/server.cpp
index 51142c47e9..19063fa5be 100644
--- a/src/rpc/server.cpp
+++ b/src/rpc/server.cpp
@@ -9,24 +9,16 @@
 
 #include <common/args.h>
 #include <common/system.h>
-#include <httprpc.h>
 #include <logging.h>
 #include <node/context.h>
-#include <rpc/request.h>
 #include <rpc/server_util.h>
 #include <rpc/util.h>
 #include <sync.h>
-#include <util/any.h>
 #include <util/signalinterrupt.h>
 #include <util/strencodings.h>
 #include <util/string.h>
 #include <util/time.h>
 
-#ifdef ENABLE_WALLET
-#include <interfaces/wallet.h>
-#include <wallet/wallet.h>
-#endif
-
 #include <boost/signals2/signal.hpp>
 
 #include <cassert>
@@ -266,70 +258,9 @@ static RPCHelpMan getrpcinfo()
     };
 }
 
-static RPCHelpMan getrpcwhitelist()
-{
-    return RPCHelpMan{"getrpcwhitelist",
-                "\nReturns whitelisted RPCs for the current user.\n",
-                {},
-                RPCResult{
-                    RPCResult::Type::OBJ, "", "",
-                    {
-                        {RPCResult::Type::OBJ_DYN, "methods", "List of RPCs that the user is allowed to call",
-                        {
-                            {RPCResult::Type::NONE, "rpc", "Key is name of RPC method, value is null"},
-                        }},
-                        {RPCResult::Type::OBJ_DYN, "wallets", "List of wallets that the user is allowed to access",
-                        {
-                            {RPCResult::Type::NONE, "wallet_name", "Key is name of wallet, value is null"},
-                        }},
-                    }
-                },
-                RPCExamples{
-                    HelpExampleCli("getrpcwhitelist", "")
-                + HelpExampleRpc("getrpcwhitelist", "")},
-        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
-{
-    UniValue whitelisted_rpcs(UniValue::VOBJ);
-    const std::set<std::string>& whitelist = GetWhitelistedRpcs(request.authUser);
-    for (const auto& rpc : whitelist) {
-        whitelisted_rpcs.pushKV(rpc, NullUniValue);
-    }
-
-    UniValue whitelisted_wallets(UniValue::VOBJ);
-#ifdef ENABLE_WALLET
-    std::string authorized_wallet_name;
-    const bool have_wallet_restriction = GetWalletRestrictionFromJSONRPCRequest(request, authorized_wallet_name);
-    if (have_wallet_restriction) {
-        if (authorized_wallet_name != "-") {
-            whitelisted_wallets.pushKV(authorized_wallet_name, NullUniValue);
-        }
-    } else {
-        // All wallets are allowed
-        auto node_context = util::AnyPtr<node::NodeContext>(request.context);
-        if (node_context && node_context->wallet_loader && node_context->wallet_loader->context()) {
-            for (const std::shared_ptr<wallet::CWallet>& wallet : wallet::GetWallets(*node_context->wallet_loader->context())) {
-                if (!wallet.get()) continue;
-
-                LOCK(wallet->cs_wallet);
-                whitelisted_wallets.pushKV(wallet->GetName(), NullUniValue);
-            }
-        }
-    }
-#endif
-
-    UniValue result(UniValue::VOBJ);
-    result.pushKV("methods", whitelisted_rpcs);
-    result.pushKV("wallets", whitelisted_wallets);
-
-    return result;
-}
-    };
-}
-
 static const CRPCCommand vRPCCommands[]{
     /* Overall control/query calls */
     {"control", &getrpcinfo},
-    {"control", &getrpcwhitelist},
     {"control", &help},
     {"control", &stop},
     {"control", &uptime},
@@ -567,7 +498,7 @@ static bool ExecuteCommands(const std::vector<const CRPCCommand*>& commands, con
     return false;
 }
 
-UniValue CRPCTable::execute(const std::string method, const JSONRPCRequest &request) const
+UniValue CRPCTable::execute(const JSONRPCRequest &request) const
 {
     // Return immediately if in warmup
     {
@@ -577,7 +508,7 @@ UniValue CRPCTable::execute(const std::string method, const JSONRPCRequest &requ
     }
 
     // Find method
-    auto it = mapCommands.find(method);
+    auto it = mapCommands.find(request.strMethod);
     if (it != mapCommands.end()) {
         UniValue result;
         if (ExecuteCommands(it->second, request, result)) {
@@ -587,11 +518,6 @@ UniValue CRPCTable::execute(const std::string method, const JSONRPCRequest &requ
     throw JSONRPCError(RPC_METHOD_NOT_FOUND, "Method not found");
 }
 
-UniValue CRPCTable::execute(const JSONRPCRequest &request) const
-{
-    return this->execute(request.strMethod, request);
-}
-
 static bool ExecuteCommand(const CRPCCommand& command, const JSONRPCRequest& request, UniValue& result, bool last_handler)
 {
     try {
diff --git a/src/rpc/server.h b/src/rpc/server.h
index 1789a5e422..56e8a63088 100644
--- a/src/rpc/server.h
+++ b/src/rpc/server.h
@@ -137,22 +137,13 @@ public:
     CRPCTable();
     std::string help(const std::string& name, const JSONRPCRequest& helpreq) const;
 
-    /**
-     * Execute the request.strMethod.
-     * @param request The JSONRPCRequest to execute
-     * @returns Result of the call.
-     * @throws an exception (UniValue) when an error happens.
-     */
-    UniValue execute(const JSONRPCRequest &request) const;
-
     /**
      * Execute a method.
-     * @param method The method to execute
      * @param request The JSONRPCRequest to execute
      * @returns Result of the call.
      * @throws an exception (UniValue) when an error happens.
      */
-    UniValue execute(const std::string method, const JSONRPCRequest &request) const;
+    UniValue execute(const JSONRPCRequest &request) const;
 
     /**
     * Returns a list of registered commands
diff --git a/src/rpc/signmessage.cpp b/src/rpc/signmessage.cpp
index ca8a430bd8..83462738c5 100644
--- a/src/rpc/signmessage.cpp
+++ b/src/rpc/signmessage.cpp
@@ -49,10 +49,6 @@ static RPCHelpMan verifymessage()
                 throw JSONRPCError(RPC_TYPE_ERROR, "Address does not refer to key");
             case MessageVerificationResult::ERR_MALFORMED_SIGNATURE:
                 throw JSONRPCError(RPC_TYPE_ERROR, "Malformed base64 encoding");
-            case MessageVerificationResult::ERR_POF:
-            case MessageVerificationResult::INCONCLUSIVE:
-                throw JSONRPCError(RPC_TYPE_ERROR, "This signature is not yet supported");
-            case MessageVerificationResult::ERR_INVALID:
             case MessageVerificationResult::ERR_PUBKEY_NOT_RECOVERED:
             case MessageVerificationResult::ERR_NOT_SIGNED:
                 return false;
diff --git a/src/rpc/util.cpp b/src/rpc/util.cpp
index 0c6fe04811..cc49670198 100644
--- a/src/rpc/util.cpp
+++ b/src/rpc/util.cpp
@@ -80,21 +80,6 @@ void RPCTypeCheckObj(const UniValue& o,
     }
 }
 
-int ParseVerbosity(const UniValue& arg, int default_verbosity, bool allow_bool)
-{
-    if (!arg.isNull()) {
-        if (arg.isBool()) {
-            if (!allow_bool) {
-                throw JSONRPCError(RPC_TYPE_ERROR, "Verbosity was boolean but only integer allowed");
-            }
-            return arg.get_bool(); // true = 1
-        } else {
-            return arg.getInt<int>();
-        }
-    }
-    return default_verbosity;
-}
-
 CAmount AmountFromValue(const UniValue& value, int decimals)
 {
     if (!value.isNum() && !value.isStr())
@@ -253,7 +238,7 @@ CPubKey AddrToPubKey(const FillableSigningProvider& keystore, const std::string&
 }
 
 // Creates a multisig address from a given list of public keys, number of signatures required, and the address type
-CTxDestination AddAndGetMultisigDestination(const int required, const std::vector<CPubKey>& pubkeys, OutputType type, FlatSigningProvider& keystore, CScript& script_out, bool sort)
+CTxDestination AddAndGetMultisigDestination(const int required, const std::vector<CPubKey>& pubkeys, OutputType type, FlatSigningProvider& keystore, CScript& script_out)
 {
     // Gather public keys
     if (required < 1) {
@@ -266,7 +251,7 @@ CTxDestination AddAndGetMultisigDestination(const int required, const std::vecto
         throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Number of keys involved in the multisignature address creation > %d\nReduce the number", MAX_PUBKEYS_PER_MULTISIG));
     }
 
-    script_out = GetScriptForMultisig(required, pubkeys, sort);
+    script_out = GetScriptForMultisig(required, pubkeys);
 
     // Check if any keys are uncompressed. If so, the type is legacy
     for (const CPubKey& pk : pubkeys) {
@@ -663,11 +648,7 @@ UniValue RPCHelpMan::HandleRequest(const JSONRPCRequest& request) const
      * the user is asking for help information, and throw help when appropriate.
      */
     if (request.mode == JSONRPCRequest::GET_HELP || !IsValidNumArgs(request.params.size())) {
-        std::string help_format = "default";
-        if (request.strMethod == "format") {
-            help_format = request.params[1].get_str();
-        }
-        throw std::runtime_error(ToString(help_format));
+        throw std::runtime_error(ToString());
     }
     UniValue arg_mismatch{UniValue::VOBJ};
     for (size_t i{0}; i < m_args.size(); ++i) {
@@ -785,7 +766,7 @@ std::vector<std::pair<std::string, bool>> RPCHelpMan::GetArgNames() const
 size_t RPCHelpMan::GetParamIndex(std::string_view key) const
 {
     auto it{std::find_if(
-        m_args.begin(), m_args.end(), [&key](const auto& arg) { return arg.GetFirstName() == key;}
+        m_args.begin(), m_args.end(), [&key](const auto& arg) { return arg.GetName() == key;}
     )};
 
     CHECK_NONFATAL(it != m_args.end());  // TODO: ideally this is checked at compile time
@@ -854,34 +835,6 @@ std::string RPCHelpMan::ToString() const
     return ret;
 }
 
-std::string RPCHelpMan::ToStringArgsCli() const
-{
-    std::string res;
-    for (const auto& arg : m_args) {
-        const bool is_file = ToLower(arg.m_description).find("file") != std::string::npos;
-        res += arg.m_names + ":" + (is_file ? "file" : arg.ToTypeString()) + ",";
-    }
-
-    if (res.size() > 0) {
-        res.pop_back();
-    }
-
-    return res;
-}
-
-std::string RPCHelpMan::ToString(const std::string& format) const
-{
-    if (format == "default") {
-        return this->ToString();
-    }
-
-    if (format == "args_cli") {
-        return this->ToStringArgsCli();
-    }
-
-    throw std::runtime_error("unrecogonized help format");
-}
-
 UniValue RPCHelpMan::GetArgMap() const
 {
     UniValue arr{UniValue::VARR};
@@ -899,15 +852,9 @@ UniValue RPCHelpMan::GetArgMap() const
     for (int i{0}; i < int(m_args.size()); ++i) {
         const auto& arg = m_args.at(i);
         std::vector<std::string> arg_names = SplitString(arg.m_names, '|');
-        RPCArg::Type argtype = arg.m_type;
-        size_t arg_num = 0;
         for (const auto& arg_name : arg_names) {
-            if (!arg.m_type_per_name.empty()) {
-                argtype = arg.m_type_per_name.at(arg_num++);
-            }
-
-            push_back_arg_info(m_name, i, arg_name, argtype);
-            if (argtype == RPCArg::Type::OBJ_NAMED_PARAMS) {
+            push_back_arg_info(m_name, i, arg_name, arg.m_type);
+            if (arg.m_type == RPCArg::Type::OBJ_NAMED_PARAMS) {
                 for (const auto& inner : arg.m_inner) {
                     std::vector<std::string> inner_names = SplitString(inner.m_names, '|');
                     for (const std::string& inner_name : inner_names) {
@@ -958,15 +905,13 @@ UniValue RPCArg::MatchesType(const UniValue& request) const
 {
     if (m_opts.skip_type_check) return true;
     if (IsOptional() && request.isNull()) return true;
-    for (auto type : m_type_per_name.empty() ? std::vector<RPCArg::Type>{m_type} : m_type_per_name) {
-        const auto exp_type{ExpectedType(type)};
-        if (!exp_type) return true; // nothing to check
+    const auto exp_type{ExpectedType(m_type)};
+    if (!exp_type) return true; // nothing to check
 
-        if (*exp_type == request.getType()) {
-            return true;
-        }
+    if (*exp_type != request.getType()) {
+        return strprintf("JSON value of type %s is not of expected type %s", uvTypeName(request.getType()), uvTypeName(*exp_type));
     }
-    return strprintf("JSON value of type %s is not of expected type %s", uvTypeName(request.getType()), uvTypeName(*ExpectedType(m_type)));
+    return true;
 }
 
 std::string RPCArg::GetFirstName() const
@@ -989,32 +934,6 @@ bool RPCArg::IsOptional() const
     }
 }
 
-std::string RPCArg::ToTypeString() const
-{
-    switch (m_type) {
-    case Type::STR_HEX:
-    case Type::STR:
-        return "string";
-    case Type::NUM:
-        return "numeric";
-    case Type::AMOUNT:
-        return "numeric or string";
-    case Type::RANGE:
-        return "numeric or array";
-    case Type::BOOL:
-        return "boolean";
-    case Type::OBJ:
-    case Type::OBJ_NAMED_PARAMS:
-    case Type::OBJ_USER_KEYS:
-        return "json object";
-    case Type::ARR:
-        return"json array";
-    } // no default case, so the compiler can warn about missing cases
-
-    //gcc and msvc might complain we don't return anything even if we handle all cases
-    throw std::runtime_error("unknown argument type");
-}
-
 std::string RPCArg::ToDescriptionString(bool is_named_arg) const
 {
     std::string ret;
@@ -1022,7 +941,39 @@ std::string RPCArg::ToDescriptionString(bool is_named_arg) const
     if (m_opts.type_str.size() != 0) {
         ret += m_opts.type_str.at(1);
     } else {
-        ret += this->ToTypeString();
+        switch (m_type) {
+        case Type::STR_HEX:
+        case Type::STR: {
+            ret += "string";
+            break;
+        }
+        case Type::NUM: {
+            ret += "numeric";
+            break;
+        }
+        case Type::AMOUNT: {
+            ret += "numeric or string";
+            break;
+        }
+        case Type::RANGE: {
+            ret += "numeric or array";
+            break;
+        }
+        case Type::BOOL: {
+            ret += "boolean";
+            break;
+        }
+        case Type::OBJ:
+        case Type::OBJ_NAMED_PARAMS:
+        case Type::OBJ_USER_KEYS: {
+            ret += "json object";
+            break;
+        }
+        case Type::ARR: {
+            ret += "json array";
+            break;
+        }
+        } // no default case, so the compiler can warn about missing cases
     }
     if (m_fallback.index() == 1) {
         ret += ", optional, default=" + std::get<RPCArg::DefaultHint>(m_fallback);
@@ -1416,23 +1367,6 @@ std::vector<CScript> EvalDescriptorStringOrObject(const UniValue& scanobject, Fl
     return ret;
 }
 
-std::vector<CTransactionRef> ParseTransactionVector(const UniValue txns_param)
-{
-    std::vector<CTransactionRef> txns;
-    const UniValue& raw_transactions = txns_param.get_array();
-    txns.reserve(raw_transactions.size());
-
-    for (const auto& rawtx : raw_transactions.getValues()) {
-        CMutableTransaction mtx;
-        if (!DecodeHexTx(mtx, rawtx.get_str())) {
-            throw JSONRPCError(RPC_DESERIALIZATION_ERROR,
-                               "TX decode failed: " + rawtx.get_str() + " Make sure the prev tx has at least one input.");
-        }
-        txns.emplace_back(MakeTransactionRef(std::move(mtx)));
-    }
-    return txns;
-}
-
 /** Convert a vector of bilingual strings to a UniValue::VARR containing their original untranslated values. */
 [[nodiscard]] static UniValue BilingualStringsToUniValue(const std::vector<bilingual_str>& bilingual_strings)
 {
@@ -1455,19 +1389,3 @@ void PushWarnings(const std::vector<bilingual_str>& warnings, UniValue& obj)
     if (warnings.empty()) return;
     obj.pushKV("warnings", BilingualStringsToUniValue(warnings));
 }
-
-bool GetWalletRestrictionFromJSONRPCRequest(const JSONRPCRequest& request, std::string& out_wallet_allowed)
-{
-    if (request.m_wallet_restriction.empty()) return false;
-    out_wallet_allowed = request.m_wallet_restriction;
-    return true;
-}
-
-void EnsureNotWalletRestricted(const JSONRPCRequest& request)
-{
-    std::string authorized_wallet_name;
-    const bool have_wallet_restriction = GetWalletRestrictionFromJSONRPCRequest(request, authorized_wallet_name);
-    if (have_wallet_restriction) {
-        throw JSONRPCError(RPC_METHOD_NOT_FOUND, "Method not available for wallet-restricted RPC users");
-    }
-}
diff --git a/src/rpc/util.h b/src/rpc/util.h
index 4e1be5ceed..23024376e0 100644
--- a/src/rpc/util.h
+++ b/src/rpc/util.h
@@ -18,7 +18,6 @@
 #include <univalue.h>
 #include <util/check.h>
 
-#include <algorithm>
 #include <cstddef>
 #include <cstdint>
 #include <functional>
@@ -101,17 +100,6 @@ uint256 ParseHashO(const UniValue& o, std::string_view strKey);
 std::vector<unsigned char> ParseHexV(const UniValue& v, std::string_view name);
 std::vector<unsigned char> ParseHexO(const UniValue& o, std::string_view strKey);
 
-/**
- * Parses verbosity from provided UniValue.
- *
- * @param[in] arg The verbosity argument as an int (0, 1, 2,...) or bool if allow_bool is set to true
- * @param[in] default_verbosity The value to return if verbosity argument is null
- * @param[in] allow_bool If true, allows arg to be a bool and parses it
- * @returns An integer describing the verbosity level (e.g. 0, 1, 2, etc.)
- * @throws JSONRPCError if allow_bool is false but arg provided is boolean
- */
-int ParseVerbosity(const UniValue& arg, int default_verbosity, bool allow_bool);
-
 /**
  * Validate and return a CAmount from a UniValue number or string.
  *
@@ -134,7 +122,7 @@ std::string HelpExampleRpcNamed(const std::string& methodname, const RPCArgList&
 
 CPubKey HexToPubKey(const std::string& hex_in);
 CPubKey AddrToPubKey(const FillableSigningProvider& keystore, const std::string& addr_in);
-CTxDestination AddAndGetMultisigDestination(const int required, const std::vector<CPubKey>& pubkeys, OutputType type, FlatSigningProvider& keystore, CScript& script_out, bool sort);
+CTxDestination AddAndGetMultisigDestination(const int required, const std::vector<CPubKey>& pubkeys, OutputType type, FlatSigningProvider& keystore, CScript& script_out);
 
 UniValue DescribeAddress(const CTxDestination& dest);
 
@@ -154,9 +142,6 @@ std::pair<int64_t, int64_t> ParseDescriptorRange(const UniValue& value);
 /** Evaluate a descriptor given as a string, or as a {"desc":...,"range":...} object, with default range of 1000. */
 std::vector<CScript> EvalDescriptorStringOrObject(const UniValue& scanobject, FlatSigningProvider& provider, const bool expand_priv = false);
 
-/** Parses a vector of transactions from a univalue array. */
-std::vector<CTransactionRef> ParseTransactionVector(const UniValue txns_param);
-
 /**
  * Serializing JSON objects depends on the outer type. Only arrays and
  * dictionaries can be nested in json. The top-level outer type is "NONE".
@@ -225,7 +210,6 @@ struct RPCArg {
 
     const std::string m_names; //!< The name of the arg (can be empty for inner args, can contain multiple aliases separated by | for named request arguments)
     const Type m_type;
-    const std::vector<Type> m_type_per_name;
     const std::vector<RPCArg> m_inner; //!< Only used for arrays or dicts
     const Fallback m_fallback;
     const std::string m_description;
@@ -246,24 +230,6 @@ struct RPCArg {
         CHECK_NONFATAL(type != Type::ARR && type != Type::OBJ && type != Type::OBJ_NAMED_PARAMS && type != Type::OBJ_USER_KEYS);
     }
 
-    RPCArg(
-        std::string name,
-        std::vector<Type> types,
-        Fallback fallback,
-        std::string description,
-        std::vector<RPCArg> inner = {},
-        RPCArgOptions opts = {})
-        : m_names{std::move(name)},
-          m_type{types.at(0)},
-          m_type_per_name{std::move(types)},
-          m_inner{std::move(inner)},
-          m_fallback{std::move(fallback)},
-          m_description{std::move(description)},
-          m_opts{std::move(opts)}
-    {
-        CHECK_NONFATAL(m_type_per_name.size() == size_t(std::count(m_names.begin(), m_names.end(), '|')) + 1);
-    }
-
     RPCArg(
         std::string name,
         Type type,
@@ -305,10 +271,6 @@ struct RPCArg {
      * Set oneline to get the oneline representation (less whitespace)
      */
     std::string ToStringObj(bool oneline) const;
-    /**
-     * Return the type as a string
-     */
-    std::string ToTypeString() const;
     /**
      * Return the description string, including the argument type and whether
      * the argument is required.
@@ -510,8 +472,6 @@ public:
         }
     }
     std::string ToString() const;
-    std::string ToStringArgsCli() const;
-    std::string ToString(const std::string& format) const;
     /** Return the named args that need to be converted from string to another JSON type */
     UniValue GetArgMap() const;
     /** If the supplied number of args is neither too small nor too high */
@@ -534,8 +494,6 @@ private:
     size_t GetParamIndex(std::string_view key) const;
 };
 
-std::vector<RPCResult> ScriptPubKeyDoc();
-
 /**
  * Push warning messages to an RPC "warnings" field as a JSON array of strings.
  *
@@ -545,7 +503,4 @@ std::vector<RPCResult> ScriptPubKeyDoc();
 void PushWarnings(const UniValue& warnings, UniValue& obj);
 void PushWarnings(const std::vector<bilingual_str>& warnings, UniValue& obj);
 
-bool GetWalletRestrictionFromJSONRPCRequest(const JSONRPCRequest& request, std::string& out_wallet_allowed);
-void EnsureNotWalletRestricted(const JSONRPCRequest& request);
-
 #endif // BITCOIN_RPC_UTIL_H
diff --git a/src/script/bitcoinconsensus.cpp b/src/script/bitcoinconsensus.cpp
deleted file mode 100644
index c4eccacf41..0000000000
--- a/src/script/bitcoinconsensus.cpp
+++ /dev/null
@@ -1,157 +0,0 @@
-// Copyright (c) 2009-2010 Satoshi Nakamoto
-// Copyright (c) 2009-2022 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#include <script/bitcoinconsensus.h>
-
-#include <primitives/transaction.h>
-#include <pubkey.h>
-#include <script/interpreter.h>
-
-namespace {
-
-/** A class that deserializes a single CTransaction one time. */
-class TxInputStream
-{
-public:
-    TxInputStream(const unsigned char *txTo, size_t txToLen) :
-    m_data(txTo),
-    m_remaining(txToLen)
-    {}
-
-    void read(Span<std::byte> dst)
-    {
-        if (dst.size() > m_remaining) {
-            throw std::ios_base::failure(std::string(__func__) + ": end of data");
-        }
-
-        if (dst.data() == nullptr) {
-            throw std::ios_base::failure(std::string(__func__) + ": bad destination buffer");
-        }
-
-        if (m_data == nullptr) {
-            throw std::ios_base::failure(std::string(__func__) + ": bad source buffer");
-        }
-
-        memcpy(dst.data(), m_data, dst.size());
-        m_remaining -= dst.size();
-        m_data += dst.size();
-    }
-
-    template<typename T>
-    TxInputStream& operator>>(T&& obj)
-    {
-        ::Unserialize(*this, obj);
-        return *this;
-    }
-
-private:
-    const unsigned char* m_data;
-    size_t m_remaining;
-};
-
-inline int set_error(bitcoinconsensus_error* ret, bitcoinconsensus_error serror)
-{
-    if (ret)
-        *ret = serror;
-    return 0;
-}
-
-} // namespace
-
-/** Check that all specified flags are part of the libconsensus interface. */
-static bool verify_flags(unsigned int flags)
-{
-    return (flags & ~(bitcoinconsensus_SCRIPT_FLAGS_VERIFY_ALL)) == 0;
-}
-
-static int verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen, CAmount amount,
-                                    const unsigned char *txTo        , unsigned int txToLen,
-                                    const UTXO *spentOutputs, unsigned int spentOutputsLen,
-                                    unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err)
-{
-    if (!verify_flags(flags)) {
-        return set_error(err, bitcoinconsensus_ERR_INVALID_FLAGS);
-    }
-
-    if (flags & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_TAPROOT && spentOutputs == nullptr) {
-        return set_error(err, bitcoinconsensus_ERR_SPENT_OUTPUTS_REQUIRED);
-    }
-
-    try {
-        TxInputStream stream(txTo, txToLen);
-        CTransaction tx(deserialize, TX_WITH_WITNESS, stream);
-
-        std::vector<CTxOut> spent_outputs;
-        if (spentOutputs != nullptr) {
-            if (spentOutputsLen != tx.vin.size()) {
-                return set_error(err, bitcoinconsensus_ERR_SPENT_OUTPUTS_MISMATCH);
-            }
-            for (size_t i = 0; i < spentOutputsLen; i++) {
-                CScript spk = CScript(spentOutputs[i].scriptPubKey, spentOutputs[i].scriptPubKey + spentOutputs[i].scriptPubKeySize);
-                const CAmount& value = spentOutputs[i].value;
-                CTxOut tx_out = CTxOut(value, spk);
-                spent_outputs.push_back(tx_out);
-            }
-        }
-
-        if (nIn >= tx.vin.size())
-            return set_error(err, bitcoinconsensus_ERR_TX_INDEX);
-        if (GetSerializeSize(TX_WITH_WITNESS(tx)) != txToLen)
-            return set_error(err, bitcoinconsensus_ERR_TX_SIZE_MISMATCH);
-
-        // Regardless of the verification result, the tx did not error.
-        set_error(err, bitcoinconsensus_ERR_OK);
-
-        PrecomputedTransactionData txdata(tx);
-
-        if (spentOutputs != nullptr && flags & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_TAPROOT) {
-            txdata.Init(tx, std::move(spent_outputs));
-        }
-
-        return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), &tx.vin[nIn].scriptWitness, flags, TransactionSignatureChecker(&tx, nIn, amount, txdata, MissingDataBehavior::FAIL), nullptr);
-    } catch (const std::exception&) {
-        return set_error(err, bitcoinconsensus_ERR_TX_DESERIALIZE); // Error deserializing
-    }
-}
-
-int bitcoinconsensus_verify_script_with_spent_outputs(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen, int64_t amount,
-                                    const unsigned char *txTo        , unsigned int txToLen,
-                                    const UTXO *spentOutputs, unsigned int spentOutputsLen,
-                                    unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err)
-{
-    CAmount am(amount);
-    return ::verify_script(scriptPubKey, scriptPubKeyLen, am, txTo, txToLen, spentOutputs, spentOutputsLen, nIn, flags, err);
-}
-
-int bitcoinconsensus_verify_script_with_amount(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen, int64_t amount,
-                                    const unsigned char *txTo        , unsigned int txToLen,
-                                    unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err)
-{
-    CAmount am(amount);
-    UTXO *spentOutputs = nullptr;
-    unsigned int spentOutputsLen = 0;
-    return ::verify_script(scriptPubKey, scriptPubKeyLen, am, txTo, txToLen, spentOutputs, spentOutputsLen, nIn, flags, err);
-}
-
-
-int bitcoinconsensus_verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen,
-                                   const unsigned char *txTo        , unsigned int txToLen,
-                                   unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err)
-{
-    if (flags & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS) {
-        return set_error(err, bitcoinconsensus_ERR_AMOUNT_REQUIRED);
-    }
-
-    CAmount am(0);
-    UTXO *spentOutputs = nullptr;
-    unsigned int spentOutputsLen = 0;
-    return ::verify_script(scriptPubKey, scriptPubKeyLen, am, txTo, txToLen, spentOutputs, spentOutputsLen, nIn, flags, err);
-}
-
-unsigned int bitcoinconsensus_version()
-{
-    // Just use the API version for now
-    return BITCOINCONSENSUS_API_VER;
-}
diff --git a/src/script/bitcoinconsensus.h b/src/script/bitcoinconsensus.h
deleted file mode 100644
index a202b5ba06..0000000000
--- a/src/script/bitcoinconsensus.h
+++ /dev/null
@@ -1,96 +0,0 @@
-// Copyright (c) 2009-2010 Satoshi Nakamoto
-// Copyright (c) 2009-2021 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#ifndef BITCOIN_SCRIPT_BITCOINCONSENSUS_H
-#define BITCOIN_SCRIPT_BITCOINCONSENSUS_H
-
-#include <stdint.h>
-
-#if defined(BUILD_BITCOIN_INTERNAL) && defined(HAVE_CONFIG_H)
-#include <config/bitcoin-config.h>
-  #if defined(_WIN32)
-    #if defined(HAVE_DLLEXPORT_ATTRIBUTE)
-      #define EXPORT_SYMBOL __declspec(dllexport)
-    #else
-      #define EXPORT_SYMBOL
-    #endif
-  #elif defined(HAVE_DEFAULT_VISIBILITY_ATTRIBUTE)
-    #define EXPORT_SYMBOL __attribute__ ((visibility ("default")))
-  #endif
-#elif defined(MSC_VER) && !defined(STATIC_LIBBITCOINCONSENSUS)
-  #define EXPORT_SYMBOL __declspec(dllimport)
-#endif
-
-#ifndef EXPORT_SYMBOL
-  #define EXPORT_SYMBOL
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define BITCOINCONSENSUS_API_VER 2
-
-typedef enum bitcoinconsensus_error_t
-{
-    bitcoinconsensus_ERR_OK = 0,
-    bitcoinconsensus_ERR_TX_INDEX,
-    bitcoinconsensus_ERR_TX_SIZE_MISMATCH,
-    bitcoinconsensus_ERR_TX_DESERIALIZE,
-    bitcoinconsensus_ERR_AMOUNT_REQUIRED,
-    bitcoinconsensus_ERR_INVALID_FLAGS,
-    bitcoinconsensus_ERR_SPENT_OUTPUTS_REQUIRED,
-    bitcoinconsensus_ERR_SPENT_OUTPUTS_MISMATCH
-} bitcoinconsensus_error;
-
-/** Script verification flags */
-enum
-{
-    bitcoinconsensus_SCRIPT_FLAGS_VERIFY_NONE                = 0,
-    bitcoinconsensus_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), // evaluate P2SH (BIP16) subscripts
-    bitcoinconsensus_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), // enforce strict DER (BIP66) compliance
-    bitcoinconsensus_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), // enforce NULLDUMMY (BIP147)
-    bitcoinconsensus_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), // enable CHECKLOCKTIMEVERIFY (BIP65)
-    bitcoinconsensus_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), // enable CHECKSEQUENCEVERIFY (BIP112)
-    bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), // enable WITNESS (BIP141)
-    bitcoinconsensus_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), // enable TAPROOT (BIPs 341 & 342)
-    bitcoinconsensus_SCRIPT_FLAGS_VERIFY_ALL                 = bitcoinconsensus_SCRIPT_FLAGS_VERIFY_P2SH | bitcoinconsensus_SCRIPT_FLAGS_VERIFY_DERSIG |
-                                                               bitcoinconsensus_SCRIPT_FLAGS_VERIFY_NULLDUMMY | bitcoinconsensus_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |
-                                                               bitcoinconsensus_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY | bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS |
-                                                               bitcoinconsensus_SCRIPT_FLAGS_VERIFY_TAPROOT
-};
-
-typedef struct {
-    const unsigned char *scriptPubKey;
-    unsigned int scriptPubKeySize;
-    int64_t value;
-} UTXO;
-
-/// Returns 1 if the input nIn of the serialized transaction pointed to by
-/// txTo correctly spends the scriptPubKey pointed to by scriptPubKey under
-/// the additional constraints specified by flags.
-/// If not nullptr, err will contain an error/success code for the operation
-EXPORT_SYMBOL int bitcoinconsensus_verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen,
-                                                 const unsigned char *txTo        , unsigned int txToLen,
-                                                 unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err);
-
-EXPORT_SYMBOL int bitcoinconsensus_verify_script_with_amount(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen, int64_t amount,
-                                    const unsigned char *txTo        , unsigned int txToLen,
-                                    unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err);
-
-EXPORT_SYMBOL int bitcoinconsensus_verify_script_with_spent_outputs(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen, int64_t amount,
-                                    const unsigned char *txTo        , unsigned int txToLen,
-                                    const UTXO *spentOutputs, unsigned int spentOutputsLen,
-                                    unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err);
-
-EXPORT_SYMBOL unsigned int bitcoinconsensus_version();
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
-
-#undef EXPORT_SYMBOL
-
-#endif // BITCOIN_SCRIPT_BITCOINCONSENSUS_H
diff --git a/src/script/descriptor.cpp b/src/script/descriptor.cpp
index 685ed583c7..ae9dba6a50 100644
--- a/src/script/descriptor.cpp
+++ b/src/script/descriptor.cpp
@@ -148,6 +148,8 @@ std::string DescriptorChecksum(const Span<const char>& span)
     return ret;
 }
 
+std::string AddChecksum(const std::string& str) { return str + "#" + DescriptorChecksum(str); }
+
 ////////////////////////////////////////////////////////////////////////////
 // Internal representation                                                //
 ////////////////////////////////////////////////////////////////////////////
@@ -821,11 +823,8 @@ class PKDescriptor final : public DescriptorImpl
 private:
     const bool m_xonly;
 protected:
-    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, Span<const CScript>, FlatSigningProvider& out) const override
+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, Span<const CScript>, FlatSigningProvider&) const override
     {
-        CKeyID id = keys[0].GetID();
-        out.pubkeys.emplace(id, keys[0]);
-
         if (m_xonly) {
             CScript script = CScript() << ToByteVector(XOnlyPubKey(keys[0])) << OP_CHECKSIG;
             return Vector(std::move(script));
@@ -2087,8 +2086,6 @@ std::string GetDescriptorChecksum(const std::string& descriptor)
     return ret;
 }
 
-std::string AddChecksum(const std::string& str) { return str + "#" + DescriptorChecksum(str); }
-
 std::unique_ptr<Descriptor> InferDescriptor(const CScript& script, const SigningProvider& provider)
 {
     return InferScript(script, ParseScriptContext::TOP, provider);
diff --git a/src/script/descriptor.h b/src/script/descriptor.h
index 6674de91f9..e78a775330 100644
--- a/src/script/descriptor.h
+++ b/src/script/descriptor.h
@@ -185,11 +185,6 @@ std::unique_ptr<Descriptor> Parse(const std::string& descriptor, FlatSigningProv
  */
 std::string GetDescriptorChecksum(const std::string& descriptor);
 
-/**
- * Simple wrapper to add the checksum at the end of the descriptor
- */
-std::string AddChecksum(const std::string& str);
-
 /** Find a descriptor for the specified `script`, using information from `provider` where possible.
  *
  * A non-ranged descriptor which only generates the specified script will be returned in all
diff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp
index 6cf1830d6d..9d0e9b5e3c 100644
--- a/src/script/interpreter.cpp
+++ b/src/script/interpreter.cpp
@@ -1303,7 +1303,7 @@ public:
         // Serialize the nSequence
         if (nInput != nIn && (fHashSingle || fHashNone))
             // let the others update at will
-            ::Serialize(s, int32_t{0});
+            ::Serialize(s, int{0});
         else
             ::Serialize(s, txTo.vin[nInput].nSequence);
     }
@@ -1565,7 +1565,7 @@ bool SignatureHashSchnorr(uint256& hash_out, ScriptExecutionData& execdata, cons
 }
 
 template <class T>
-uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn, int32_t nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache)
+uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache)
 {
     assert(nIn < txTo.vin.size());
 
@@ -1658,10 +1658,6 @@ bool GenericTransactionSignatureChecker<T>::CheckECDSASignature(const std::vecto
     int nHashType = vchSig.back();
     vchSig.pop_back();
 
-    if (m_require_sighash_all && nHashType != SIGHASH_ALL) {
-        return false;
-    }
-
     // Witness sighashes need the amount.
     if (sigversion == SigVersion::WITNESS_V0 && amount < 0) return HandleMissingData(m_mdb);
 
@@ -1690,9 +1686,6 @@ bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(Span<const uns
     uint8_t hashtype = SIGHASH_DEFAULT;
     if (sig.size() == 65) {
         hashtype = SpanPopBack(sig);
-        if (m_require_sighash_all && hashtype != SIGHASH_ALL) {
-            return set_error(serror, SCRIPT_ERR_SIG_HASHTYPE);
-        }
         if (hashtype == SIGHASH_DEFAULT) return set_error(serror, SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);
     }
     uint256 sighash;
diff --git a/src/script/interpreter.h b/src/script/interpreter.h
index 5b20a78d98..8ba0018c23 100644
--- a/src/script/interpreter.h
+++ b/src/script/interpreter.h
@@ -240,7 +240,7 @@ extern const HashWriter HASHER_TAPLEAF;    //!< Hasher with tag "TapLeaf" pre-fe
 extern const HashWriter HASHER_TAPBRANCH;  //!< Hasher with tag "TapBranch" pre-fed to it.
 
 template <class T>
-uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn, int32_t nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache = nullptr);
+uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache = nullptr);
 
 class BaseSignatureChecker
 {
@@ -301,8 +301,6 @@ public:
     bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion, ScriptExecutionData& execdata, ScriptError* serror = nullptr) const override;
     bool CheckLockTime(const CScriptNum& nLockTime) const override;
     bool CheckSequence(const CScriptNum& nSequence) const override;
-
-    bool m_require_sighash_all{false};
 };
 
 using TransactionSignatureChecker = GenericTransactionSignatureChecker<CTransaction>;
diff --git a/src/script/script.cpp b/src/script/script.cpp
index 368ca4b66f..d650db9a0d 100644
--- a/src/script/script.cpp
+++ b/src/script/script.cpp
@@ -303,56 +303,6 @@ bool CScript::HasValidOps() const
     return true;
 }
 
-std::pair<size_t, size_t> CScript::DatacarrierBytes() const
-{
-    size_t counted{0};
-    opcodetype opcode, last_opcode{OP_INVALIDOPCODE};
-    std::vector<unsigned char> push_data;
-    unsigned int inside_noop{0}, inside_conditional{0};
-    CScript::const_iterator opcode_it = begin(), data_began = begin();
-    for (CScript::const_iterator it = begin(); it < end(); last_opcode = opcode) {
-        opcode_it = it;
-        if (!GetOp(it, opcode, push_data)) {
-            // Invalid scripts are necessarily all data
-            return {0, size()};
-        }
-
-        if (opcode == OP_IF || opcode == OP_NOTIF) {
-            ++inside_conditional;
-        } else if (opcode == OP_ENDIF) {
-            if (!inside_conditional) return {0, size()};  // invalid
-            --inside_conditional;
-        } else if (opcode == OP_RETURN && !inside_conditional) {
-            // unconditional OP_RETURN is unspendable
-            return {size(), 0};
-        }
-
-        // Match OP_FALSE OP_IF
-        if (inside_noop) {
-            switch (opcode) {
-            case OP_IF: case OP_NOTIF:
-                ++inside_noop;
-                break;
-            case OP_ENDIF:
-                if (0 == --inside_noop) {
-                    counted += it - data_began + 1;
-                }
-                break;
-            default: /* do nothing */;
-            }
-        } else if (opcode == OP_IF && last_opcode == OP_FALSE) {
-            inside_noop = 1;
-            data_began = opcode_it;
-        // Match <data> OP_DROP
-        } else if (opcode <= OP_PUSHDATA4) {
-            data_began = opcode_it;
-        } else if (opcode == OP_DROP && last_opcode <= OP_PUSHDATA4) {
-            counted += it - data_began;
-        }
-    }
-    return {0, counted};
-}
-
 bool GetScriptOp(CScriptBase::const_iterator& pc, CScriptBase::const_iterator end, opcodetype& opcodeRet, std::vector<unsigned char>* pvchRet)
 {
     opcodeRet = OP_INVALIDOPCODE;
diff --git a/src/script/script.h b/src/script/script.h
index 7362724e46..323411251c 100644
--- a/src/script/script.h
+++ b/src/script/script.h
@@ -562,8 +562,6 @@ public:
         return (size() > 0 && *begin() == OP_RETURN) || (size() > MAX_SCRIPT_SIZE);
     }
 
-    std::pair<size_t, size_t> DatacarrierBytes() const;
-
     void clear()
     {
         // The default prevector::clear() does not release memory
diff --git a/src/script/sign.cpp b/src/script/sign.cpp
index f493a6b8c9..9568348bf6 100644
--- a/src/script/sign.cpp
+++ b/src/script/sign.cpp
@@ -18,8 +18,6 @@
 #include <util/translation.h>
 #include <util/vector.h>
 
-#include <optional>
-
 typedef std::vector<unsigned char> valtype;
 
 MutableTransactionSignatureCreator::MutableTransactionSignatureCreator(const CMutableTransaction& tx, unsigned int input_idx, const CAmount& amount, int hash_type)
@@ -786,7 +784,7 @@ bool IsSegWitOutput(const SigningProvider& provider, const CScript& script)
     return false;
 }
 
-bool SignTransaction(CMutableTransaction& mtx, const SigningProvider* keystore, const std::map<COutPoint, Coin>& coins, int nHashType, std::map<int, bilingual_str>& input_errors, std::optional<CAmount>* inputs_amount_sum)
+bool SignTransaction(CMutableTransaction& mtx, const SigningProvider* keystore, const std::map<COutPoint, Coin>& coins, int nHashType, std::map<int, bilingual_str>& input_errors)
 {
     bool fHashSingle = ((nHashType & ~SIGHASH_ANYONECANPAY) == SIGHASH_SINGLE);
 
@@ -811,37 +809,20 @@ bool SignTransaction(CMutableTransaction& mtx, const SigningProvider* keystore,
     }
 
     // Sign what we can:
-    if (inputs_amount_sum) *inputs_amount_sum = 0;
     for (unsigned int i = 0; i < mtx.vin.size(); ++i) {
         CTxIn& txin = mtx.vin[i];
         auto coin = coins.find(txin.prevout);
         if (coin == coins.end() || coin->second.IsSpent()) {
-            if (inputs_amount_sum) {
-                inputs_amount_sum->reset();
-                inputs_amount_sum = nullptr;
-            }
             input_errors[i] = _("Input not found or already spent");
             continue;
         }
         const CScript& prevPubKey = coin->second.out.scriptPubKey;
         const CAmount& amount = coin->second.out.nValue;
-        if (inputs_amount_sum && *inputs_amount_sum) {
-            if (amount > 0) {
-                **inputs_amount_sum += amount;
-            } else {
-                inputs_amount_sum->reset();
-                inputs_amount_sum = nullptr;
-            }
-        }
 
         SignatureData sigdata = DataFromTransaction(mtx, i, coin->second.out);
         // Only sign SIGHASH_SINGLE if there's a corresponding output:
         if (!fHashSingle || (i < mtx.vout.size())) {
             ProduceSignature(*keystore, MutableTransactionSignatureCreator(mtx, i, amount, &txdata, nHashType), prevPubKey, sigdata);
-            if ((!sigdata.witness) && inputs_amount_sum && *inputs_amount_sum) {
-                inputs_amount_sum->reset();
-                inputs_amount_sum = nullptr;
-            }
         }
 
         UpdateInput(txin, sigdata);
diff --git a/src/script/sign.h b/src/script/sign.h
index 95da0330da..4edd5bf326 100644
--- a/src/script/sign.h
+++ b/src/script/sign.h
@@ -15,8 +15,6 @@
 #include <script/signingprovider.h>
 #include <uint256.h>
 
-#include <optional>
-
 class CKey;
 class CKeyID;
 class CScript;
@@ -126,6 +124,6 @@ void UpdateInput(CTxIn& input, const SignatureData& data);
 bool IsSegWitOutput(const SigningProvider& provider, const CScript& script);
 
 /** Sign the CMutableTransaction */
-bool SignTransaction(CMutableTransaction& mtx, const SigningProvider* provider, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, bilingual_str>& input_errors, std::optional<CAmount>* inputs_amount_sum = nullptr);
+bool SignTransaction(CMutableTransaction& mtx, const SigningProvider* provider, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, bilingual_str>& input_errors);
 
 #endif // BITCOIN_SCRIPT_SIGN_H
diff --git a/src/script/signingprovider.cpp b/src/script/signingprovider.cpp
index e52f47cc35..baabd4d5b5 100644
--- a/src/script/signingprovider.cpp
+++ b/src/script/signingprovider.cpp
@@ -9,8 +9,6 @@
 
 #include <logging.h>
 
-bool g_implicit_segwit = true;
-
 const SigningProvider& DUMMY_SIGNING_PROVIDER = SigningProvider();
 
 template<typename M, typename K, typename V>
@@ -79,16 +77,6 @@ bool FlatSigningProvider::GetTaprootBuilder(const XOnlyPubKey& output_key, Tapro
     return LookupHelper(tr_trees, output_key, builder);
 }
 
-void FlatSigningProvider::AddMasterKey(const CExtKey& key)
-{
-    CPubKey pubkey = key.Neuter().pubkey;
-    const auto id = pubkey.GetID();
-    KeyOriginInfo origin;
-    std::copy(key.vchFingerprint, key.vchFingerprint + sizeof(key.vchFingerprint), origin.fingerprint);
-    origins[id] = std::make_pair(pubkey, origin);
-    keys[id] = key.key;
-}
-
 FlatSigningProvider& FlatSigningProvider::Merge(FlatSigningProvider&& b)
 {
     scripts.merge(b.scripts);
@@ -114,7 +102,7 @@ void FillableSigningProvider::ImplicitlyLearnRelatedKeyScripts(const CPubKey& pu
     // "Implicitly" refers to fact that scripts are derived automatically from
     // existing keys, and are present in memory, even without being explicitly
     // loaded (e.g. from a file).
-    if (pubkey.IsCompressed() && g_implicit_segwit) {
+    if (pubkey.IsCompressed()) {
         CScript script = GetScriptForDestination(WitnessV0KeyHash(key_id));
         // This does not use AddCScript, as it may be overridden.
         CScriptID id(script);
diff --git a/src/script/signingprovider.h b/src/script/signingprovider.h
index 3b8513688e..efdfd9ee56 100644
--- a/src/script/signingprovider.h
+++ b/src/script/signingprovider.h
@@ -14,10 +14,6 @@
 #include <script/script.h>
 #include <sync.h>
 
-static const bool DEFAULT_WALLET_IMPLICIT_SEGWIT = false;
-
-extern bool g_implicit_segwit;
-
 struct ShortestVectorFirstComparator
 {
     bool operator()(const std::vector<unsigned char>& a, const std::vector<unsigned char>& b) const
@@ -223,7 +219,6 @@ struct FlatSigningProvider final : public SigningProvider
     bool GetTaprootSpendData(const XOnlyPubKey& output_key, TaprootSpendData& spenddata) const override;
     bool GetTaprootBuilder(const XOnlyPubKey& output_key, TaprootBuilder& builder) const override;
 
-    void AddMasterKey(const CExtKey& key);
     FlatSigningProvider& Merge(FlatSigningProvider&& b) LIFETIMEBOUND;
 };
 
diff --git a/src/script/solver.cpp b/src/script/solver.cpp
index 43af6c4bee..bd3c5cdf72 100644
--- a/src/script/solver.cpp
+++ b/src/script/solver.cpp
@@ -215,23 +215,13 @@ CScript GetScriptForRawPubKey(const CPubKey& pubKey)
     return CScript() << std::vector<unsigned char>(pubKey.begin(), pubKey.end()) << OP_CHECKSIG;
 }
 
-CScript GetScriptForMultisig(int nRequired, const std::vector<CPubKey>& keys, bool fSorted)
+CScript GetScriptForMultisig(int nRequired, const std::vector<CPubKey>& keys)
 {
-    std::vector<std::vector<unsigned char>> vEncoded;
-    vEncoded.reserve(keys.size());
-    for (const CPubKey& key : keys) {
-        vEncoded.emplace_back(ToByteVector(key));
-    }
-
-    if (fSorted) {
-        std::sort(vEncoded.begin(), vEncoded.end());
-    }
-
     CScript script;
+
     script << nRequired;
-    for (const std::vector<unsigned char>& bytes : vEncoded) {
-        script << bytes;
-    }
+    for (const CPubKey& key : keys)
+        script << ToByteVector(key);
     script << keys.size() << OP_CHECKMULTISIG;
 
     return script;
diff --git a/src/script/solver.h b/src/script/solver.h
index 0f8647b9f9..5a7b685a6f 100644
--- a/src/script/solver.h
+++ b/src/script/solver.h
@@ -62,6 +62,6 @@ CScript GetScriptForRawPubKey(const CPubKey& pubkey);
 std::optional<std::pair<int, std::vector<Span<const unsigned char>>>> MatchMultiA(const CScript& script LIFETIMEBOUND);
 
 /** Generate a multisig script. */
-CScript GetScriptForMultisig(int nRequired, const std::vector<CPubKey>& keys, bool fSorted=false);
+CScript GetScriptForMultisig(int nRequired, const std::vector<CPubKey>& keys);
 
 #endif // BITCOIN_SCRIPT_SOLVER_H
diff --git a/src/stats/rpc_stats.cpp b/src/stats/rpc_stats.cpp
deleted file mode 100644
index 08c1926726..0000000000
--- a/src/stats/rpc_stats.cpp
+++ /dev/null
@@ -1,79 +0,0 @@
-// Copyright (c) 2016 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#include <rpc/server.h>
-#include <rpc/util.h>
-#include <stats/stats.h>
-#include <util/strencodings.h>
-
-#include <stdint.h>
-
-#include <univalue.h>
-
-static RPCHelpMan getmempoolstats()
-{
-    return RPCHelpMan{"getmempoolstats",
-                "\nReturns the collected mempool statistics (non-linear non-interpolated samples).\n",
-                {},
-                RPCResult{
-                    RPCResult::Type::OBJ, "", "",
-                    {
-                        {RPCResult::Type::NUM_TIME, "time_from", "Timestamp, first sample"},
-                        {RPCResult::Type::NUM_TIME, "time_to", "Timestamp, last sample"},
-                        {RPCResult::Type::ARR, "samples", "",
-                        {
-                            {RPCResult::Type::ARR_FIXED, "", "",
-                            {
-                                {RPCResult::Type::NUM, "", "Sample time in seconds (relative to other sample times only)"},
-                                {RPCResult::Type::NUM, "", "Number of transactions in the memory pool"},
-                                {RPCResult::Type::NUM, "", "Memory usage by memory pool"},
-                                {RPCResult::Type::NUM, "", "Minimum fee per kB"},
-                            }},
-                        }},
-                    }},
-                RPCExamples{
-                    HelpExampleCli("getmempoolstats", "")
-            + HelpExampleRpc("getmempoolstats", "")
-                },
-        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
-{
-    // get stats from the core stats model
-    uint64_t timeFrom = 0;
-    uint64_t timeTo = 0;
-    mempoolSamples_t samples = CStats::DefaultStats()->mempoolGetValuesInRange(timeFrom, timeTo);
-
-    // use "flat" json encoding for performance reasons
-    UniValue samplesObj(UniValue::VARR);
-    for (struct CStatsMempoolSample& sample : samples) {
-        UniValue singleSample(UniValue::VARR);
-        singleSample.push_back(UniValue((uint64_t)sample.m_time_delta));
-        singleSample.push_back(UniValue(sample.m_tx_count));
-        singleSample.push_back(UniValue(sample.m_dyn_mem_usage));
-        singleSample.push_back(UniValue(sample.m_min_fee_per_k));
-        samplesObj.push_back(singleSample);
-    }
-
-    UniValue result(UniValue::VOBJ);
-    result.pushKV("time_from", timeFrom);
-    result.pushKV("time_to", timeTo);
-    result.pushKV("samples", samplesObj);
-
-    return result;
-},
-    };
-}
-
-void RegisterStatsRPCCommands(CRPCTable& t)
-{
-// clang-format off
-static const CRPCCommand commands[] =
-{ //  category              actor (function)
-  //  --------------------- ------------------------
-    { "stats",              &getmempoolstats,                    },
-};
-// clang-format on
-    for (const auto& c : commands) {
-        t.appendCommand(c.name, &c);
-    }
-}
diff --git a/src/stats/stats.cpp b/src/stats/stats.cpp
deleted file mode 100644
index 3077bfc6b8..0000000000
--- a/src/stats/stats.cpp
+++ /dev/null
@@ -1,144 +0,0 @@
-// Copyright (c) 2016 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#include <stats/stats.h>
-
-#include <common/args.h>
-#include <memusage.h>
-#include <util/time.h>
-
-#include <cmath>
-
-static const uint32_t SAMPLE_MIN_DELTA_IN_SEC = 2;
-static const int CLEANUP_SAMPLES_THRESHOLD = 100;
-size_t CStats::maxStatsMemory = 0;
-const size_t CStats::DEFAULT_MAX_STATS_MEMORY = 10 * 1024 * 1024; //10 MB
-const bool CStats::DEFAULT_STATISTICS_ENABLED = false;
-std::atomic<bool> CStats::m_stats_enabled(false); //disable stats by default
-
-CStats* CStats::m_shared_instance{nullptr};
-
-CStats* CStats::DefaultStats()
-{
-    if (!m_shared_instance)
-        m_shared_instance = new CStats();
-
-    return m_shared_instance;
-}
-
-void CStats::addMempoolSample(int64_t txcount, int64_t dynUsage, int64_t currentMinRelayFee)
-{
-    if (!m_stats_enabled)
-        return;
-
-    uint64_t now = GetTime();
-    {
-        LOCK(cs_stats);
-
-        // set the mempool stats start time if this is the first sample
-        if (m_mempool_stats.m_start_time == 0)
-            m_mempool_stats.m_start_time = now;
-
-        // ensure the minimum time delta between samples
-        if (m_mempool_stats.m_samples.size() && m_mempool_stats.m_start_time + m_mempool_stats.m_samples.back().m_time_delta + SAMPLE_MIN_DELTA_IN_SEC >= now) {
-            return;
-        }
-
-        // calculate the current time delta and add a sample
-        uint32_t timeDelta = now - m_mempool_stats.m_start_time; //truncate to uint32_t should be sufficient
-        m_mempool_stats.m_samples.push_back({timeDelta, txcount, dynUsage, currentMinRelayFee});
-        m_mempool_stats.m_cleanup_counter++;
-
-        // check if we should cleanup the container
-        if (m_mempool_stats.m_cleanup_counter >= CLEANUP_SAMPLES_THRESHOLD) {
-            //check memory usage
-            if (memusage::DynamicUsage(m_mempool_stats.m_samples) > maxStatsMemory && m_mempool_stats.m_samples.size() > 1) {
-                // only shrink if the vector.capacity() is > the target for performance reasons
-                m_mempool_stats.m_samples.shrink_to_fit();
-                const size_t memUsage = memusage::DynamicUsage(m_mempool_stats.m_samples);
-                // calculate the amount of samples we need to remove
-                size_t itemsToRemove = (memUsage - maxStatsMemory + sizeof(m_mempool_stats.m_samples[0]) - 1) / sizeof(m_mempool_stats.m_samples[0]);
-
-                // sanity check; always keep the most recent sample we just added
-                if (m_mempool_stats.m_samples.size() <= itemsToRemove) {
-                    itemsToRemove = m_mempool_stats.m_samples.size() - 1;
-                }
-                m_mempool_stats.m_samples.erase(m_mempool_stats.m_samples.begin(), m_mempool_stats.m_samples.begin() + itemsToRemove);
-            }
-            // shrink vector
-            m_mempool_stats.m_samples.shrink_to_fit();
-            m_mempool_stats.m_cleanup_counter = 0;
-        }
-
-        // fire signal
-        MempoolStatsDidChange();
-    }
-}
-
-mempoolSamples_t CStats::mempoolGetValuesInRange(uint64_t& fromTime, uint64_t& toTime)
-{
-    if (!m_stats_enabled)
-        return mempoolSamples_t();
-
-    LOCK(cs_stats);
-
-    // if empty, return directly
-    if (!m_mempool_stats.m_samples.size())
-        return m_mempool_stats.m_samples;
-
-
-    if (!(fromTime == 0 && toTime == 0) && (fromTime > m_mempool_stats.m_start_time + m_mempool_stats.m_samples.front().m_time_delta || toTime < m_mempool_stats.m_start_time + m_mempool_stats.m_samples.back().m_time_delta)) {
-        mempoolSamples_t::iterator fromSample = m_mempool_stats.m_samples.begin();
-        mempoolSamples_t::iterator toSample = std::prev(m_mempool_stats.m_samples.end());
-
-        // create subset of samples
-        bool fromSet = false;
-        for (mempoolSamples_t::iterator it = m_mempool_stats.m_samples.begin(); it != m_mempool_stats.m_samples.end(); ++it) {
-            if (m_mempool_stats.m_start_time + (*it).m_time_delta >= fromTime && !fromSet) {
-                fromSample = it;
-                fromSet = true;
-            }
-            else if (m_mempool_stats.m_start_time + (*it).m_time_delta > toTime) {
-                toSample = std::prev(it);
-                break;
-            }
-        }
-
-        mempoolSamples_t subset(fromSample, toSample + 1);
-
-        // set the fromTime and toTime pass-by-ref parameters
-        fromTime = m_mempool_stats.m_start_time + (*fromSample).m_time_delta;
-        toTime = m_mempool_stats.m_start_time + (*toSample).m_time_delta;
-
-        // return subset
-        return subset;
-    }
-
-    // return all available samples
-    fromTime = m_mempool_stats.m_start_time + m_mempool_stats.m_samples.front().m_time_delta;
-    toTime = m_mempool_stats.m_start_time + m_mempool_stats.m_samples.back().m_time_delta;
-    return m_mempool_stats.m_samples;
-}
-
-void CStats::setMaxMemoryUsageTarget(size_t maxMem)
-{
-    m_stats_enabled = (maxMem > 0);
-
-    LOCK(cs_stats);
-    maxStatsMemory = maxMem;
-}
-
-void CStats::AddStatsOptions()
-{
-    gArgs.AddArg("-statsenable", strprintf("Enable statistics (default: %u)", DEFAULT_STATISTICS_ENABLED), ArgsManager::ALLOW_ANY, OptionsCategory::STATS);
-    gArgs.AddArg("-statsmaxmemorytarget=<n>", strprintf("Set the memory limit target for statistics in bytes (default: %u)", DEFAULT_MAX_STATS_MEMORY), ArgsManager::ALLOW_ANY, OptionsCategory::STATS);
-}
-
-bool CStats::parameterInteraction()
-{
-    if (gArgs.GetBoolArg("-statsenable", DEFAULT_STATISTICS_ENABLED))
-        DefaultStats()->setMaxMemoryUsageTarget(gArgs.GetIntArg("-statsmaxmemorytarget", DEFAULT_MAX_STATS_MEMORY));
-
-    return true;
-}
diff --git a/src/stats/stats.h b/src/stats/stats.h
deleted file mode 100644
index 7444da59f3..0000000000
--- a/src/stats/stats.h
+++ /dev/null
@@ -1,77 +0,0 @@
-// Copyright (c) 2016 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#ifndef BITCOIN_STATS_STATS_H
-#define BITCOIN_STATS_STATS_H
-
-#include <sync.h>
-
-#include <atomic>
-#include <stdlib.h>
-#include <vector>
-
-#include <boost/signals2/signal.hpp>
-
-struct CStatsMempoolSample {
-    uint32_t m_time_delta;    //use 32bit time delta to save memory
-    int64_t m_tx_count;       //transaction count
-    int64_t m_dyn_mem_usage;  //dynamic mempool usage
-    int64_t m_min_fee_per_k;  //min fee per Kb
-};
-
-typedef std::vector<struct CStatsMempoolSample> mempoolSamples_t;
-
-// simple mempool stats container
-class CStatsMempool
-{
-public:
-    uint64_t m_start_time;      //start time of the container
-    mempoolSamples_t m_samples;
-    uint64_t m_cleanup_counter; //internal counter to trogger cleanups
-
-    CStatsMempool()
-    {
-        m_start_time = 0;
-        m_cleanup_counter = 0;
-    }
-};
-
-// Class that manages various types of statistics and its memory consumption
-class CStats
-{
-private:
-    static size_t maxStatsMemory;                  //maximum amount of memory to use for the stats
-
-    static CStats* m_shared_instance;
-    mutable RecursiveMutex cs_stats;
-
-    CStatsMempool m_mempool_stats; //mempool stats container
-
-public:
-    static const size_t DEFAULT_MAX_STATS_MEMORY; //default maximum of memory to use
-    static const bool DEFAULT_STATISTICS_ENABLED; //default value for enabling statistics
-
-    static std::atomic<bool> m_stats_enabled; //if enabled, stats will be collected
-    static CStats* DefaultStats(); //shared instance
-
-    /* signals */
-    boost::signals2::signal<void(void)> MempoolStatsDidChange; //mempool stats update signal
-
-    /* add a mempool stats sample */
-    void addMempoolSample(int64_t txcount, int64_t dynUsage, int64_t currentMinRelayFee);
-
-    /* get all mempool samples in range */
-    mempoolSamples_t mempoolGetValuesInRange(uint64_t& fromTime, uint64_t& toTime);
-
-    /* set the target for the maximum memory consumption (in bytes) */
-    void setMaxMemoryUsageTarget(size_t maxMem);
-
-    /* register the statistics module help strings */
-    static void AddStatsOptions();
-
-    /* access the parameters and map it to the internal model */
-    static bool parameterInteraction();
-};
-
-#endif // BITCOIN_STATS_STATS_H
diff --git a/src/stats/test/stats_tests.cpp b/src/stats/test/stats_tests.cpp
deleted file mode 100644
index 77c21d595c..0000000000
--- a/src/stats/test/stats_tests.cpp
+++ /dev/null
@@ -1,76 +0,0 @@
-// Copyright (c) 2016 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#include <stats/stats.h>
-
-#include <test/util/setup_common.h>
-#include <util/time.h>
-
-#include <boost/test/unit_test.hpp>
-
-BOOST_FIXTURE_TEST_SUITE(stats_tests, BasicTestingSetup)
-
-BOOST_AUTO_TEST_CASE(stats)
-{
-    CStats::DefaultStats()->setMaxMemoryUsageTarget(CStats::DEFAULT_MAX_STATS_MEMORY);
-
-    uint64_t start = GetTime();
-    SetMockTime(start);
-
-    CStats::DefaultStats()->addMempoolSample(0, 1, 1);
-    SetMockTime(start + 1);
-    CStats::DefaultStats()->addMempoolSample(0, 2, 2); //1second should be to short
-    SetMockTime(start + 5);
-    CStats::DefaultStats()->addMempoolSample(3, 4, 3);
-
-    uint64_t queryFromTime = start;
-    uint64_t queryToTime = start + 3600;
-    mempoolSamples_t samples = CStats::DefaultStats()->mempoolGetValuesInRange(queryFromTime, queryToTime);
-
-    BOOST_CHECK_EQUAL(samples[0].m_time_delta, 0U);
-    BOOST_CHECK_EQUAL(samples[1].m_time_delta, 5U);
-    BOOST_CHECK_EQUAL(samples[1].m_tx_count, 3);
-    BOOST_CHECK_EQUAL(samples[1].m_dyn_mem_usage, 4);
-
-    // check retrieving a subset of the available samples
-    queryFromTime = start;
-    queryToTime = start;
-    samples = CStats::DefaultStats()->mempoolGetValuesInRange(queryFromTime, queryToTime);
-    BOOST_CHECK_EQUAL(samples.size(), 1U);
-
-    // add some samples
-    for (int i = 0; i < 10000; i++) {
-        SetMockTime(start + 10 + i * 5);
-        CStats::DefaultStats()->addMempoolSample(i, i + 1, i + 2);
-    }
-
-    queryFromTime = start + 3600;
-    queryToTime = start + 3600;
-    samples = CStats::DefaultStats()->mempoolGetValuesInRange(queryFromTime, queryToTime);
-    BOOST_CHECK_EQUAL(samples.size(), 1U); //get a single sample
-
-    queryFromTime = start;
-    queryToTime = start + 3600;
-    samples = CStats::DefaultStats()->mempoolGetValuesInRange(queryFromTime, queryToTime);
-    BOOST_CHECK(samples.size() >= 3600 / 5);
-
-    // reduce max memory and add 100 samples to ensure it triggers the cleanup
-    CStats::DefaultStats()->setMaxMemoryUsageTarget(10 * 1024);
-    for (int i = 10000; i < 10100; i++) {
-        SetMockTime(start + 10 + i * 5);
-        CStats::DefaultStats()->addMempoolSample(i, i + 1, i + 2);
-    }
-
-    queryFromTime = start;
-    queryToTime = start + 100;
-    samples = CStats::DefaultStats()->mempoolGetValuesInRange(queryFromTime, queryToTime);
-    BOOST_CHECK_EQUAL(samples.size(), 1U);
-
-    queryFromTime = 0; // no range limits
-    queryToTime = 0;   // no range  limits
-    samples = CStats::DefaultStats()->mempoolGetValuesInRange(queryFromTime, queryToTime);
-    BOOST_CHECK_EQUAL(samples.size() < 1000U, true);
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff --git a/src/streams.cpp b/src/streams.cpp
index 8e06ab205c..5f7baf92b9 100644
--- a/src/streams.cpp
+++ b/src/streams.cpp
@@ -5,7 +5,6 @@
 #include <span.h>
 #include <streams.h>
 #include <util/fs_helpers.h>
-#include <util/ioprio.h>
 
 #include <array>
 
@@ -100,7 +99,6 @@ void AutoFile::write(Span<const std::byte> src)
             *m_position += buf_now.size();
         }
     }
-    m_was_written = true;
 }
 
 bool AutoFile::Commit()
@@ -108,11 +106,6 @@ bool AutoFile::Commit()
     return ::FileCommit(m_file);
 }
 
-void AutoFile::SetIdlePriority()
-{
-    ioprio_set_file_idle(m_file);
-}
-
 bool AutoFile::IsError()
 {
     return ferror(m_file);
diff --git a/src/streams.h b/src/streams.h
index 8b36aba2b9..431a4d77c6 100644
--- a/src/streams.h
+++ b/src/streams.h
@@ -6,14 +6,10 @@
 #ifndef BITCOIN_STREAMS_H
 #define BITCOIN_STREAMS_H
 
-#include <logging.h>
 #include <serialize.h>
 #include <span.h>
 #include <support/allocators/zeroafterfree.h>
-#include <util/check.h>
-#include <util/fs_helpers.h>
 #include <util/overflow.h>
-#include <util/syserror.h>
 
 #include <algorithm>
 #include <assert.h>
@@ -395,26 +391,11 @@ protected:
     std::FILE* m_file;
     std::vector<std::byte> m_xor;
     std::optional<int64_t> m_position;
-    bool m_was_written{false};
 
 public:
     explicit AutoFile(std::FILE* file, std::vector<std::byte> data_xor={});
 
-    ~AutoFile()
-    {
-        if (m_was_written) {
-            // Callers that wrote to the file must have closed it explicitly
-            // with the fclose() method and checked that the close succeeded.
-            // This is because here from the destructor we have no way to signal
-            // error due to close which, after write, could mean the file is
-            // corrupted and must be handled properly at the call site.
-            Assume(IsNull());
-        }
-
-        if (fclose() != 0) {
-            LogPrintLevel(BCLog::ALL, BCLog::Level::Error, "Failed to close file: %s\n", SysErrorString(errno));
-        }
-    }
+    ~AutoFile() { fclose(); }
 
     // Disallow copies
     AutoFile(const AutoFile&) = delete;
@@ -474,13 +455,8 @@ public:
     }
 
     bool Commit();
-    void SetIdlePriority();
     bool IsError();
     bool Truncate(unsigned size);
-    void AdviseSequential()
-    {
-        ::AdviseSequential(m_file);
-    }
 };
 
 /** Wrapper around an AutoFile& that implements a ring buffer to
@@ -544,17 +520,6 @@ public:
     {
         if (nRewindIn >= nBufSize)
             throw std::ios_base::failure("Rewind limit must be less than buffer size");
-        m_src.AdviseSequential();
-    }
-
-    ~BufferedFile() { fclose(); }
-
-    int fclose()
-    {
-        if (auto rel{m_src.release()}) {
-            return CloseAndUncache(rel);
-        }
-        return m_src.fclose();
     }
 
     //! check whether we're at the end of the source file
diff --git a/src/test/amount_tests.cpp b/src/test/amount_tests.cpp
index 21d8b708ae..e5ab1cfb90 100644
--- a/src/test/amount_tests.cpp
+++ b/src/test/amount_tests.cpp
@@ -139,12 +139,4 @@ BOOST_AUTO_TEST_CASE(ToStringTest)
     BOOST_CHECK_EQUAL(feeRate.ToString(FeeEstimateMode::SAT_VB), "0.001 sat/vB");
 }
 
-BOOST_AUTO_TEST_CASE(SatsToStringTest)
-{
-    BOOST_CHECK_EQUAL(CFeeRate(1).SatsToString(), "0.001");
-    BOOST_CHECK_EQUAL(CFeeRate(70).SatsToString(), "0.070");
-    BOOST_CHECK_EQUAL(CFeeRate(3141).SatsToString(), "3.141");
-    BOOST_CHECK_EQUAL(CFeeRate(10002).SatsToString(), "10.002");
-}
-
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/src/test/blockfilter_index_tests.cpp b/src/test/blockfilter_index_tests.cpp
index 8e2ccc2721..067a32d6a4 100644
--- a/src/test/blockfilter_index_tests.cpp
+++ b/src/test/blockfilter_index_tests.cpp
@@ -68,7 +68,7 @@ CBlock BuildChainTestingSetup::CreateBlock(const CBlockIndex* prev,
     const CScript& scriptPubKey)
 {
      BlockAssembler::Options options;
-    std::shared_ptr<CBlockTemplate> pblocktemplate = BlockAssembler{m_node.chainman->ActiveChainstate(), m_node.mempool.get(), options, m_node}.CreateNewBlock(scriptPubKey);
+    std::unique_ptr<CBlockTemplate> pblocktemplate = BlockAssembler{m_node.chainman->ActiveChainstate(), m_node.mempool.get(), options}.CreateNewBlock(scriptPubKey);
     CBlock& block = pblocktemplate->block;
     block.hashPrevBlock = prev->GetBlockHash();
     block.nTime = prev->nTime + 1;
diff --git a/src/test/blockfilter_tests.cpp b/src/test/blockfilter_tests.cpp
index 75cb9ec959..470fdde30a 100644
--- a/src/test/blockfilter_tests.cpp
+++ b/src/test/blockfilter_tests.cpp
@@ -5,7 +5,6 @@
 #include <test/data/blockfilters.json.h>
 #include <test/util/setup_common.h>
 
-#include <addresstype.h>
 #include <blockfilter.h>
 #include <core_io.h>
 #include <primitives/block.h>
@@ -128,74 +127,6 @@ BOOST_AUTO_TEST_CASE(blockfilter_basic_test)
     BOOST_CHECK(default_ctor_block_filter_1.GetEncodedFilter() == default_ctor_block_filter_2.GetEncodedFilter());
 }
 
-BOOST_AUTO_TEST_CASE(blockfilter_v0_test)
-{
-    CScript included_scripts[4], excluded_scripts[8];
-
-    included_scripts[0] = GetScriptForDestination(WitnessV0KeyHash());  // p2wpkh
-    included_scripts[1] = GetScriptForDestination(WitnessV0KeyHash()); // p2wpkh
-    included_scripts[2] = GetScriptForDestination(WitnessV0ScriptHash()); // p2wsh
-    included_scripts[3] = GetScriptForDestination(WitnessV0ScriptHash()); // p2wsh
-
-    excluded_scripts[0] << std::vector<unsigned char>(0, 65) << OP_CHECKSIG; // p2pk
-    excluded_scripts[1] << OP_0 << OP_HASH160 << std::vector<unsigned char>(1, 20) << OP_EQUALVERIFY << OP_CHECKSIG; // p2pkh
-    excluded_scripts[2] << OP_1 << std::vector<unsigned char>(2, 33) << OP_1 << OP_CHECKMULTISIG; // multisig
-    excluded_scripts[3] << OP_0 << std::vector<unsigned char>(3, 32); // push data
-    excluded_scripts[4] << OP_4 << OP_ADD << OP_8 << OP_EQUAL; // random script
-    excluded_scripts[5] << OP_RETURN << std::vector<unsigned char>(4, 40); // opreturn
-    excluded_scripts[6] << OP_RETURN << OP_4 << OP_ADD << OP_8 << OP_EQUAL; // none standard opreturn
-
-    CMutableTransaction tx_1;
-    tx_1.vout.emplace_back(100, included_scripts[0]);
-    tx_1.vout.emplace_back(100, included_scripts[2]);
-    tx_1.vout.emplace_back(200, excluded_scripts[0]);
-    tx_1.vout.emplace_back(300, excluded_scripts[1]);
-    tx_1.vout.emplace_back(400, excluded_scripts[2]);
-
-    CMutableTransaction tx_2;
-    tx_2.vout.emplace_back(100, included_scripts[3]);
-    tx_2.vout.emplace_back(100, excluded_scripts[3]);
-    tx_2.vout.emplace_back(0, excluded_scripts[4]);
-    tx_2.vout.emplace_back(400, excluded_scripts[7]); // Script is empty
-
-    CBlock block;
-    block.vtx.push_back(MakeTransactionRef(tx_1));
-    block.vtx.push_back(MakeTransactionRef(tx_2));
-
-    CBlockUndo block_undo;
-    block_undo.vtxundo.emplace_back();
-    block_undo.vtxundo.back().vprevout.emplace_back(CTxOut(500, included_scripts[1]), 1000, true);
-    block_undo.vtxundo.back().vprevout.emplace_back(CTxOut(600, excluded_scripts[5]), 10000, false);
-    block_undo.vtxundo.back().vprevout.emplace_back(CTxOut(700, excluded_scripts[6]), 100000, false);
-
-    BlockFilter block_filter(BlockFilterType::V0, block, block_undo);
-    const GCSFilter& filter = block_filter.GetFilter();
-
-    for (const CScript& script : included_scripts) {
-        BOOST_CHECK(filter.Match(GCSFilter::Element(script.begin(), script.end())));
-    }
-    for (const CScript& script : excluded_scripts) {
-        BOOST_CHECK(!filter.Match(GCSFilter::Element(script.begin(), script.end())));
-    }
-
-    // Test serialization/unserialization.
-    BlockFilter block_filter2;
-
-    DataStream stream;
-    stream << block_filter;
-    stream >> block_filter2;
-
-    BOOST_CHECK_EQUAL(block_filter.GetFilterType(), block_filter2.GetFilterType());
-    BOOST_CHECK_EQUAL(block_filter.GetBlockHash(), block_filter2.GetBlockHash());
-    BOOST_CHECK(block_filter.GetEncodedFilter() == block_filter2.GetEncodedFilter());
-
-    BlockFilter default_ctor_block_filter_1;
-    BlockFilter default_ctor_block_filter_2;
-    BOOST_CHECK_EQUAL(default_ctor_block_filter_1.GetFilterType(), default_ctor_block_filter_2.GetFilterType());
-    BOOST_CHECK_EQUAL(default_ctor_block_filter_1.GetBlockHash(), default_ctor_block_filter_2.GetBlockHash());
-    BOOST_CHECK(default_ctor_block_filter_1.GetEncodedFilter() == default_ctor_block_filter_2.GetEncodedFilter());
-}
-
 BOOST_AUTO_TEST_CASE(blockfilters_json_test)
 {
     UniValue json;
@@ -248,17 +179,12 @@ BOOST_AUTO_TEST_CASE(blockfilters_json_test)
 BOOST_AUTO_TEST_CASE(blockfilter_type_names)
 {
     BOOST_CHECK_EQUAL(BlockFilterTypeName(BlockFilterType::BASIC), "basic");
-    BOOST_CHECK_EQUAL(BlockFilterTypeName(BlockFilterType::V0), "v0");
     BOOST_CHECK_EQUAL(BlockFilterTypeName(static_cast<BlockFilterType>(255)), "");
 
     BlockFilterType filter_type;
     BOOST_CHECK(BlockFilterTypeByName("basic", filter_type));
     BOOST_CHECK_EQUAL(filter_type, BlockFilterType::BASIC);
 
-    BlockFilterType filter_type_v0;
-    BOOST_CHECK(BlockFilterTypeByName("v0", filter_type_v0));
-    BOOST_CHECK_EQUAL(filter_type_v0, BlockFilterType::V0);
-
     BOOST_CHECK(!BlockFilterTypeByName("unknown", filter_type));
 }
 
diff --git a/src/test/codex32_tests.cpp b/src/test/codex32_tests.cpp
deleted file mode 100644
index 17427add89..0000000000
--- a/src/test/codex32_tests.cpp
+++ /dev/null
@@ -1,377 +0,0 @@
-// Copyright (c) 2023 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#include <bech32.h>
-#include <codex32.h>
-#include <test/util/str.h>
-
-#include <boost/test/unit_test.hpp>
-
-#include <array>
-#include <string>
-
-BOOST_AUTO_TEST_SUITE(codex32_tests)
-
-BOOST_AUTO_TEST_CASE(codex32_bip93_misc_invalid)
-{
-    // This example uses a "0" threshold with a non-"s" index
-    const std::string input1 = "ms10fauxxxxxxxxxxxxxxxxxxxxxxxxxxxx0z26tfn0ulw3p";
-    const auto dec1 = codex32::Result{input1};
-    BOOST_CHECK_EQUAL(dec1.error(), codex32::INVALID_SHARE_IDX);
-
-    // This example has a threshold that is not a digit.
-    const std::string input2 = "ms1fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxda3kr3s0s2swg";
-    const auto dec2 = codex32::Result{input2};
-    BOOST_CHECK_EQUAL(dec2.error(), codex32::INVALID_K);
-}
-
-BOOST_AUTO_TEST_CASE(codex32_bip93_vector_1)
-{
-    const std::string input = "ms10testsxxxxxxxxxxxxxxxxxxxxxxxxxx4nzvca9cmczlw";
-
-    const auto dec = codex32::Result{input};
-    BOOST_CHECK(dec.IsValid());
-    BOOST_CHECK_EQUAL(dec.error(), codex32::OK);
-    BOOST_CHECK_EQUAL(dec.GetHrp(), "ms");
-    BOOST_CHECK_EQUAL(dec.GetK(), 0);
-    BOOST_CHECK_EQUAL(dec.GetIdString(), "test");
-    BOOST_CHECK_EQUAL(dec.GetShareIndex(), 's');
-
-    const auto payload = dec.GetPayload();
-    BOOST_CHECK_EQUAL(payload.size(), 16);
-    BOOST_CHECK_EQUAL(HexStr(payload), "318c6318c6318c6318c6318c6318c631");
-
-    // Try re-encoding
-    BOOST_CHECK_EQUAL(input, dec.Encode());
-
-    // Try directly constructing the share
-    const auto direct = codex32::Result("ms", 0, "test", 's', payload);
-    BOOST_CHECK(direct.IsValid());
-    BOOST_CHECK_EQUAL(direct.error(), codex32::OK);
-    BOOST_CHECK_EQUAL(direct.GetIdString(), "test");
-    BOOST_CHECK_EQUAL(direct.GetShareIndex(), 's');
-
-    // We cannot check that the codex32 string is exactly the same as the
-    // input, since it will not be -- the test vector has nonzero trailing
-    // bits while our code will always choose zero trailing bits. But we
-    // can at least check that the payloads are identical.
-    const auto payload_direct = direct.GetPayload();
-    BOOST_CHECK_EQUAL(HexStr(payload), HexStr(payload_direct));
-}
-
-BOOST_AUTO_TEST_CASE(codex32_bip93_vector_2)
-{
-    const std::string input_a = "MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM";
-    const auto dec_a = codex32::Result{input_a};
-    BOOST_CHECK(dec_a.IsValid());
-    BOOST_CHECK_EQUAL(dec_a.GetHrp(), "ms");
-    BOOST_CHECK_EQUAL(dec_a.GetK(), 2);
-    BOOST_CHECK_EQUAL(dec_a.GetIdString(), "name");
-    BOOST_CHECK_EQUAL(dec_a.GetShareIndex(), 'a');
-    BOOST_CHECK(CaseInsensitiveEqual(input_a, dec_a.Encode()));
-
-    const std::string input_c = "MS12NAMECACDEFGHJKLMNPQRSTUVWXYZ023FTR2GDZMPY6PN";
-    const auto dec_c = codex32::Result{input_c};
-    BOOST_CHECK(dec_c.IsValid());
-    BOOST_CHECK_EQUAL(dec_c.GetHrp(), "ms");
-    BOOST_CHECK_EQUAL(dec_c.GetK(), 2);
-    BOOST_CHECK_EQUAL(dec_c.GetIdString(), "name");
-    BOOST_CHECK_EQUAL(dec_c.GetShareIndex(), 'c');
-    BOOST_CHECK(CaseInsensitiveEqual(input_c, dec_c.Encode()));
-
-    const auto d = codex32::Result{{input_a, input_c}, 'd'};
-    BOOST_CHECK(d.IsValid());
-    BOOST_CHECK_EQUAL(d.GetHrp(), "ms");
-    BOOST_CHECK_EQUAL(d.GetK(), 2);
-    BOOST_CHECK_EQUAL(d.GetIdString(), "name");
-    BOOST_CHECK_EQUAL(d.GetShareIndex(), 'd');
-    BOOST_CHECK(CaseInsensitiveEqual("MS12NAMEDLL4F8JLH4E5VDVULDLFXU2JHDNLSM97XVENRXEG", d.Encode()));
-
-    const auto err1 = codex32::Result{{}, 's'};
-    BOOST_CHECK_EQUAL(err1.error(), codex32::TOO_FEW_SHARES);
-    const auto err2 = codex32::Result{{input_c}, 's'};
-    BOOST_CHECK_EQUAL(err2.error(), codex32::TOO_FEW_SHARES);
-    const auto err3 = codex32::Result{{input_a, input_c}, 'b'};
-    BOOST_CHECK_EQUAL(err3.error(), codex32::INVALID_SHARE_IDX);
-
-    const auto s = codex32::Result{{input_a, input_c}, 's'};
-    BOOST_CHECK(s.IsValid());
-    BOOST_CHECK_EQUAL(s.GetHrp(), "ms");
-    BOOST_CHECK_EQUAL(s.GetK(), 2);
-    BOOST_CHECK_EQUAL(s.GetIdString(), "name");
-    BOOST_CHECK_EQUAL(s.GetShareIndex(), 's');
-    BOOST_CHECK(CaseInsensitiveEqual("MS12NAMES6XQGUZTTXKEQNJSJZV4JV3NZ5K3KWGSPHUH6EVW", s.Encode()));
-
-    const auto seed = s.GetPayload();
-    BOOST_CHECK_EQUAL(seed.size(), 16);
-    BOOST_CHECK_EQUAL(HexStr(seed), "d1808e096b35b209ca12132b264662a5");
-}
-
-BOOST_AUTO_TEST_CASE(codex32_bip93_vector_3)
-{
-    const auto s = codex32::Result("ms", 3, "Cash", 's', ParseHex("ffeeddccbbaa99887766554433221100"));
-    BOOST_CHECK(s.IsValid());
-    BOOST_CHECK_EQUAL(s.GetIdString(), "cash");
-    BOOST_CHECK_EQUAL(s.GetShareIndex(), 's');
-    BOOST_CHECK_EQUAL(s.GetK(), 3);
-    BOOST_CHECK_EQUAL(s.Encode(), "ms13cashsllhdmn9m42vcsamx24zrxgs3qqjzqud4m0d6nln");
-
-    const auto a = codex32::Result{"ms13casha320zyxwvutsrqpnmlkjhgfedca2a8d0zehn8a0t"};
-    BOOST_CHECK(a.IsValid());
-    BOOST_CHECK_EQUAL(a.GetIdString(), "cash");
-    BOOST_CHECK_EQUAL(a.GetShareIndex(), 'a');
-    BOOST_CHECK_EQUAL(a.GetK(), 3);
-
-    const auto c = codex32::Result{"ms13cashcacdefghjklmnpqrstuvwxyz023949xq35my48dr"};
-    BOOST_CHECK(c.IsValid());
-    BOOST_CHECK_EQUAL(c.GetIdString(), "cash");
-    BOOST_CHECK_EQUAL(c.GetShareIndex(), 'c');
-    BOOST_CHECK_EQUAL(c.GetK(), 3);
-
-    const auto err1 = codex32::Result{{}, 'd'};
-    BOOST_CHECK_EQUAL(err1.error(), codex32::TOO_FEW_SHARES);
-    const auto err2 = codex32::Result{{a, c}, 'd'};
-    BOOST_CHECK_EQUAL(err2.error(), codex32::TOO_FEW_SHARES);
-    const auto err3 = codex32::Result{{s, a}, 'd'};
-    BOOST_CHECK_EQUAL(err3.error(), codex32::TOO_FEW_SHARES);
-    const auto err4 = codex32::Result{{s, s, a}, 'd'};
-    BOOST_CHECK_EQUAL(err4.error(), codex32::DUPLICATE_SHARE);
-
-    const auto d = codex32::Result{{s, a, c}, 'd'};
-    BOOST_CHECK(d.IsValid());
-    BOOST_CHECK_EQUAL(d.GetIdString(), "cash");
-    BOOST_CHECK_EQUAL(d.GetShareIndex(), 'd');
-    BOOST_CHECK_EQUAL(d.GetK(), 3);
-    BOOST_CHECK_EQUAL(d.Encode(), "ms13cashd0wsedstcdcts64cd7wvy4m90lm28w4ffupqs7rm");
-
-    const auto e = codex32::Result{{a, c, d}, 'e'};
-    BOOST_CHECK(e.IsValid());
-    BOOST_CHECK_EQUAL(e.GetIdString(), "cash");
-    BOOST_CHECK_EQUAL(e.GetShareIndex(), 'e');
-    BOOST_CHECK_EQUAL(e.GetK(), 3);
-    BOOST_CHECK_EQUAL(e.Encode(), "ms13casheekgpemxzshcrmqhaydlp6yhms3ws7320xyxsar9");
-
-    const auto f = codex32::Result{{a, s, d}, 'f'};
-    BOOST_CHECK(f.IsValid());
-    BOOST_CHECK_EQUAL(f.GetIdString(), "cash");
-    BOOST_CHECK_EQUAL(f.GetShareIndex(), 'f');
-    BOOST_CHECK_EQUAL(f.GetK(), 3);
-    BOOST_CHECK_EQUAL(f.Encode(), "ms13cashf8jh6sdrkpyrsp5ut94pj8ktehhw2hfvyrj48704");
-
-    // Mismatched data
-    const auto g1 = codex32::Result{"ms", 2, "cash", 'g', ParseHex("ffeeddccbbaa99887766554433221100")};
-    BOOST_CHECK(g1.IsValid());
-    const auto err_s1 = codex32::Result{{a, c, g1}, 's'};
-    BOOST_CHECK_EQUAL(err_s1.error(), codex32::MISMATCH_K);
-
-    const auto g2 = codex32::Result{"ms", 3, "leet", 'g', ParseHex("ffeeddccbbaa99887766554433221100")};
-    BOOST_CHECK(g2.IsValid());
-    const auto err_s2 = codex32::Result{{a, c, g2}, 's'};
-    BOOST_CHECK_EQUAL(err_s2.error(), codex32::MISMATCH_ID);
-
-    const auto g3 = codex32::Result{"ms", 3, "cash", 'g', ParseHex("ffeeddccbbaa99887766554433221100ab")};
-    BOOST_CHECK(g3.IsValid());
-    const auto err_s3 = codex32::Result{{a, c, g3}, 's'};
-    BOOST_CHECK_EQUAL(err_s3.error(), codex32::MISMATCH_LENGTH);
-}
-
-BOOST_AUTO_TEST_CASE(codex32_bip93_vector_4)
-{
-    const std::string seed = "ffeeddccbbaa99887766554433221100ffeeddccbbaa99887766554433221100";
-    const auto s = codex32::Result{"ms", 0, "leet", 's', ParseHex(seed)};
-    BOOST_CHECK(s.IsValid());
-    BOOST_CHECK_EQUAL(s.GetIdString(), "leet");
-    BOOST_CHECK_EQUAL(s.GetShareIndex(), 's');
-    BOOST_CHECK_EQUAL(s.GetK(), 0);
-    BOOST_CHECK_EQUAL(HexStr(s.GetPayload()), seed);
-    BOOST_CHECK_EQUAL(s.Encode(), "ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqqtum9pgv99ycma");
-
-    std::vector<std::string> alternates = {
-        "ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqqtum9pgv99ycma",
-        "ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqpj82dp34u6lqtd",
-        "ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqzsrs4pnh7jmpj5",
-        "ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqrfcpap2w8dqezy",
-        "ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqy5tdvphn6znrf0",
-        "ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq9dsuypw2ragmel",
-        "ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqx05xupvgp4v6qx",
-        "ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq8k0h5p43c2hzsk",
-        "ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqgum7hplmjtr8ks",
-        "ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqf9q0lpxzt5clxq",
-        "ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq28y48pyqfuu7le",
-        "ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqt7ly0paesr8x0f",
-        "ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqvrvg7pqydv5uyz",
-        "ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqd6hekpea5n0y5j",
-        "ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqwcnrwpmlkmt9dt",
-        "ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq0pgjxpzx0ysaam",
-    };
-    for (const auto& alt : alternates) {
-        const auto s_alt = codex32::Result{alt};
-        BOOST_CHECK(s_alt.IsValid());
-        BOOST_CHECK_EQUAL(HexStr(s_alt.GetPayload()), seed);
-    }
-}
-
-BOOST_AUTO_TEST_CASE(codex32_bip93_vector_5)
-{
-    const auto s = codex32::Result{"MS100C8VSM32ZXFGUHPCHTLUPZRY9X8GF2TVDW0S3JN54KHCE6MUA7LQPZYGSFJD6AN074RXVCEMLH8WU3TK925ACDEFGHJKLMNPQRSTUVWXY06FHPV80UNDVARHRAK"};
-    BOOST_CHECK(s.IsValid());
-    BOOST_CHECK_EQUAL(s.error(), codex32::OK);
-    BOOST_CHECK_EQUAL(s.GetIdString(), "0c8v");
-    BOOST_CHECK_EQUAL(s.GetShareIndex(), 's');
-    BOOST_CHECK_EQUAL(s.GetK(), 0);
-    BOOST_CHECK_EQUAL(HexStr(s.GetPayload()), "dc5423251cb87175ff8110c8531d0952d8d73e1194e95b5f19d6f9df7c01111104c9baecdfea8cccc677fb9ddc8aec5553b86e528bcadfdcc201c17c638c47e9");
-}
-
-BOOST_AUTO_TEST_CASE(codex32_errors)
-{
-    const std::vector<codex32::Result> errs = {
-        codex32::Result("ms", 3, "cash", 's', ParseHex("ffeeddccbbaa99887766554433221100")),
-        // bad hrp
-        codex32::Result("bc", 3, "cash", 's', ParseHex("ffeeddccbbaa99887766554433221100")),
-        // bad ID len
-        codex32::Result("ms", 3, "cas", 's', ParseHex("ffeeddccbbaa99887766554433221100")),
-        codex32::Result("ms", 3, "cashcashcash", 's', ParseHex("ffeeddccbbaa99887766554433221100")),
-        codex32::Result("ms", 3, "", 's', ParseHex("ffeeddccbbaa99887766554433221100")),
-        // bad id char
-        codex32::Result("ms", 3, "bash", 's', ParseHex("ffeeddccbbaa99887766554433221100")),
-        // bad k
-        codex32::Result("ms", 1, "cash", 's', ParseHex("ffeeddccbbaa99887766554433221100")),
-        codex32::Result("ms", 10, "cash", 's', ParseHex("ffeeddccbbaa99887766554433221100")),
-        codex32::Result("ms", 100000, "cash", 's', ParseHex("ffeeddccbbaa99887766554433221100")),
-        // bad share idx
-        codex32::Result("ms", 100000, "cash", 'b', ParseHex("ffeeddccbbaa99887766554433221100")),
-        codex32::Result("ms", 100000, "cash", 'i', ParseHex("ffeeddccbbaa99887766554433221100")),
-        codex32::Result("ms", 100000, "cash", '1', ParseHex("ffeeddccbbaa99887766554433221100")),
-        codex32::Result("ms", 100000, "cash", 'o', ParseHex("ffeeddccbbaa99887766554433221100")),
-        codex32::Result("ms", 100000, "cash", ' ', ParseHex("ffeeddccbbaa99887766554433221100")),
-    };
-
-    BOOST_CHECK_EQUAL(errs[0].error(), codex32::OK);
-    BOOST_CHECK_EQUAL(errs[1].error(), codex32::INVALID_HRP);
-    BOOST_CHECK_EQUAL(errs[2].error(), codex32::INVALID_ID_LEN);
-    BOOST_CHECK_EQUAL(errs[3].error(), codex32::INVALID_ID_LEN);
-    BOOST_CHECK_EQUAL(errs[4].error(), codex32::INVALID_ID_LEN);
-    BOOST_CHECK_EQUAL(errs[5].error(), codex32::INVALID_ID_CHAR);
-    BOOST_CHECK_EQUAL(errs[6].error(), codex32::INVALID_K);
-    BOOST_CHECK_EQUAL(errs[7].error(), codex32::INVALID_K);
-    BOOST_CHECK_EQUAL(errs[8].error(), codex32::INVALID_K);
-    BOOST_CHECK_EQUAL(errs[9].error(), codex32::INVALID_SHARE_IDX);
-    BOOST_CHECK_EQUAL(errs[10].error(), codex32::INVALID_SHARE_IDX);
-    BOOST_CHECK_EQUAL(errs[11].error(), codex32::INVALID_SHARE_IDX);
-    BOOST_CHECK_EQUAL(errs[12].error(), codex32::INVALID_SHARE_IDX);
-    BOOST_CHECK_EQUAL(errs[13].error(), codex32::INVALID_SHARE_IDX);
-
-}
-
-BOOST_AUTO_TEST_CASE(codex32_bip93_invalid_1)
-{
-    std::vector<std::string> bad_checksum = {
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxve740yyge2ghq",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxve740yyge2ghp",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxlk3yepcstwr",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxx6pgnv7jnpcsp",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxx0cpvr7n4geq",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxm5252y7d3lr",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxrd9sukzl05ej",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxc55srw5jrm0",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxgc7rwhtudwc",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxx4gy22afwghvs",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxme084q0vpht7pe0",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxme084q0vpht7pew",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxqyadsp3nywm8a",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxzvg7ar4hgaejk",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxcznau0advgxqe",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxch3jrc6j5040j",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx52gxl6ppv40mcv",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx7g4g2nhhle8fk",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx63m45uj8ss4x8",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy4r708q7kg65x",
-    };
-    for (const auto& bad : bad_checksum) {
-        auto res = codex32::Result{bad};
-        BOOST_CHECK_EQUAL(res.error(), codex32::BAD_CHECKSUM);
-    }
-}
-
-BOOST_AUTO_TEST_CASE(codex32_bip93_invalid_2)
-{
-    std::vector<std::string> bad_checksum = {
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxurfvwmdcmymdufv",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxcsyppjkd8lz4hx3",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxu6hwvl5p0l9xf3c",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxwqey9rfs6smenxa",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxv70wkzrjr4ntqet",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx3hmlrmpa4zl0v",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxrfggf88znkaup",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxpt7l4aycv9qzj",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxus27z9xtyxyw3",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxcwm4re8fs78vn",
-    };
-    for (const auto& bad : bad_checksum) {
-        auto res = codex32::Result{bad};
-        BOOST_CHECK(res.error() == codex32::BAD_CHECKSUM || res.error() == codex32::INVALID_LENGTH);
-    }
-}
-
-BOOST_AUTO_TEST_CASE(codex32_bip93_invalid_3)
-{
-    std::vector<std::string> bad_checksum = {
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxw0a4c70rfefn4",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxk4pavy5n46nea",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxx9lrwar5zwng4w",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxr335l5tv88js3",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxvu7q9nz8p7dj68v",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxpq6k542scdxndq3",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxkmfw6jm270mz6ej",
-        "ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxzhddxw99w7xws",
-        "ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxx42cux6um92rz",
-        "ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxarja5kqukdhy9",
-        "ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxky0ua3ha84qk8",
-        "ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx9eheesxadh2n2n9",
-        "ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx9llwmgesfulcj2z",
-        "ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx02ev7caq6n9fgkf",
-    };
-    for (const auto& bad : bad_checksum) {
-        auto res = codex32::Result{bad};
-        BOOST_CHECK_EQUAL(res.error(), codex32::INVALID_LENGTH);
-    }
-}
-
-BOOST_AUTO_TEST_CASE(codex32_bip93_invalid_hrp)
-{
-    std::vector<std::string> bad_checksum = {
-        "0fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2",
-        "10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2",
-        "ms0fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2",
-        "m10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2",
-        "s10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2",
-        "0fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxhkd4f70m8lgws",
-        "10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxhkd4f70m8lgws",
-        "m10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxx8t28z74x8hs4l",
-        "s10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxh9d0fhnvfyx3x",
-    };
-    for (const auto& bad : bad_checksum) {
-        auto res = codex32::Result{bad};
-        BOOST_CHECK(res.error() == codex32::INVALID_HRP || res.error() == codex32::BECH32_DECODE);
-    }
-}
-
-BOOST_AUTO_TEST_CASE(codex32_bip93_invalid_case)
-{
-    std::vector<std::string> bad_checksum = {
-        "Ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2",
-        "mS10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2",
-        "MS10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2",
-        "ms10FAUXsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2",
-        "ms10fauxSxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2",
-        "ms10fauxsXXXXXXXXXXXXXXXXXXXXXXXXXXuqxkk05lyf3x2",
-        "ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxUQXKK05LYF3X2",
-    };
-    for (const auto& bad : bad_checksum) {
-        auto res = codex32::Result{bad};
-        BOOST_CHECK_EQUAL(res.error(), codex32::BECH32_DECODE);
-    }
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff --git a/src/test/flatfile_tests.cpp b/src/test/flatfile_tests.cpp
index d94cab640b..21a36d9d43 100644
--- a/src/test/flatfile_tests.cpp
+++ b/src/test/flatfile_tests.cpp
@@ -46,7 +46,6 @@ BOOST_AUTO_TEST_CASE(flatfile_open)
     {
         AutoFile file{seq.Open(FlatFilePos(0, pos1))};
         file << LIMITED_STRING(line1, 256);
-        BOOST_REQUIRE_EQUAL(file.fclose(), 0);
     }
 
     // Attempt to append to file opened in read-only mode.
@@ -59,7 +58,6 @@ BOOST_AUTO_TEST_CASE(flatfile_open)
     {
         AutoFile file{seq.Open(FlatFilePos(0, pos2))};
         file << LIMITED_STRING(line2, 256);
-        BOOST_REQUIRE_EQUAL(file.fclose(), 0);
     }
 
     // Read text from file in read-only mode.
@@ -81,7 +79,6 @@ BOOST_AUTO_TEST_CASE(flatfile_open)
 
         file >> LIMITED_STRING(text, 256);
         BOOST_CHECK_EQUAL(text, line2);
-        BOOST_REQUIRE_EQUAL(file.fclose(), 0);
     }
 
     // Ensure another file in the sequence has no data.
@@ -89,7 +86,6 @@ BOOST_AUTO_TEST_CASE(flatfile_open)
         std::string text;
         AutoFile file{seq.Open(FlatFilePos(1, pos2))};
         BOOST_CHECK_THROW(file >> LIMITED_STRING(text, 256), std::ios_base::failure);
-        BOOST_REQUIRE_EQUAL(file.fclose(), 0);
     }
 }
 
diff --git a/src/test/fuzz/autofile.cpp b/src/test/fuzz/autofile.cpp
index b1c868d19d..81761c7bf9 100644
--- a/src/test/fuzz/autofile.cpp
+++ b/src/test/fuzz/autofile.cpp
@@ -62,10 +62,5 @@ FUZZ_TARGET(autofile)
         if (f != nullptr) {
             fclose(f);
         }
-    } else {
-        // FuzzedFileProvider::close() is expected to fail sometimes. Don't let
-        // the destructor of AutoFile be upset by a failing fclose(). Close it
-        // explicitly (and ignore any errors) so that the destructor is a noop.
-        (void)auto_file.fclose();
     }
 }
diff --git a/src/test/fuzz/block_index.cpp b/src/test/fuzz/block_index.cpp
index e47e3084a7..eef8c2efc8 100644
--- a/src/test/fuzz/block_index.cpp
+++ b/src/test/fuzz/block_index.cpp
@@ -89,8 +89,7 @@ FUZZ_TARGET(block_index, .init = init_block_index)
     }
 
     // Store these files and blocks in the block index. It should not fail.
-    const std::unordered_map<std::string, node::PruneLockInfo> prune_locks;
-    assert(block_index.WriteBatchSync(files_info, files_count - 1, blocks_info, prune_locks));
+    assert(block_index.WriteBatchSync(files_info, files_count - 1, blocks_info));
 
     // We should be able to read every block file info we stored. Its value should correspond to
     // what we stored above.
diff --git a/src/test/fuzz/buffered_file.cpp b/src/test/fuzz/buffered_file.cpp
index c4edceddaa..e30c19b265 100644
--- a/src/test/fuzz/buffered_file.cpp
+++ b/src/test/fuzz/buffered_file.cpp
@@ -65,8 +65,4 @@ FUZZ_TARGET(buffered_file)
         }
         opt_buffered_file->GetPos();
     }
-    if (opt_buffered_file) {
-        opt_buffered_file->fclose();
-        opt_buffered_file.reset();
-    }
 }
diff --git a/src/test/fuzz/coins_view.cpp b/src/test/fuzz/coins_view.cpp
index ff842997eb..368c69819a 100644
--- a/src/test/fuzz/coins_view.cpp
+++ b/src/test/fuzz/coins_view.cpp
@@ -284,8 +284,7 @@ FUZZ_TARGET(coins_view, .init = initialize_coins_view)
                 (void)GetTransactionSigOpCost(transaction, coins_view_cache, flags);
             },
             [&] {
-                std::string reason;
-                (void)IsWitnessStandard(CTransaction{random_mutable_transaction}, coins_view_cache, "bad-witness-", reason);
+                (void)IsWitnessStandard(CTransaction{random_mutable_transaction}, coins_view_cache);
             });
     }
 }
diff --git a/src/test/fuzz/message.cpp b/src/test/fuzz/message.cpp
index 05837ea9bd..6763206f72 100644
--- a/src/test/fuzz/message.cpp
+++ b/src/test/fuzz/message.cpp
@@ -38,7 +38,7 @@ FUZZ_TARGET(message, .init = initialize_message)
         }
     }
     {
-        (void)MessageHash(random_message, MessageSignatureFormat::LEGACY);
+        (void)MessageHash(random_message);
         (void)MessageVerify(fuzzed_data_provider.ConsumeRandomLengthString(1024), fuzzed_data_provider.ConsumeRandomLengthString(1024), random_message);
         (void)SigningResultString(fuzzed_data_provider.PickValueInArray({SigningResult::OK, SigningResult::PRIVATE_KEY_NOT_AVAILABLE, SigningResult::SIGNING_FAILED}));
     }
diff --git a/src/test/fuzz/mini_miner.cpp b/src/test/fuzz/mini_miner.cpp
index e6115e54a3..51de4d0166 100644
--- a/src/test/fuzz/mini_miner.cpp
+++ b/src/test/fuzz/mini_miner.cpp
@@ -26,11 +26,9 @@ void initialize_miner()
 {
     static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();
     g_setup = testing_setup.get();
-    MineBlock(g_setup->m_node, CScript() << OP_FALSE);
     for (uint32_t i = 0; i < uint32_t{100}; ++i) {
         g_available_coins.emplace_back(Txid::FromUint256(uint256::ZERO), i);
     }
-    g_setup->m_node.args->ForceSetArg("-blockprioritysize", "0");
 }
 
 // Test that the MiniMiner can run with various outpoints and feerates.
@@ -177,7 +175,7 @@ FUZZ_TARGET(mini_miner_selection, .init = initialize_miner)
     miner_options.nBlockMaxWeight = DEFAULT_BLOCK_MAX_WEIGHT;
     miner_options.test_block_validity = false;
 
-    node::BlockAssembler miner{g_setup->m_node.chainman->ActiveChainstate(), &pool, miner_options, g_setup->m_node};
+    node::BlockAssembler miner{g_setup->m_node.chainman->ActiveChainstate(), &pool, miner_options};
     node::MiniMiner mini_miner{pool, outpoints};
     assert(mini_miner.IsReadyToCalculate());
 
diff --git a/src/test/fuzz/node_eviction.cpp b/src/test/fuzz/node_eviction.cpp
index 1887217219..e47432600c 100644
--- a/src/test/fuzz/node_eviction.cpp
+++ b/src/test/fuzz/node_eviction.cpp
@@ -40,7 +40,7 @@ FUZZ_TARGET(node_eviction)
     // Make a copy since eviction_candidates may be in some valid but otherwise
     // indeterminate state after the SelectNodeToEvict(&&) call.
     const std::vector<NodeEvictionCandidate> eviction_candidates_copy = eviction_candidates;
-    const std::optional<NodeId> node_to_evict = SelectNodeToEvict(std::move(eviction_candidates), /*force=*/fuzzed_data_provider.ConsumeBool());
+    const std::optional<NodeId> node_to_evict = SelectNodeToEvict(std::move(eviction_candidates));
     if (node_to_evict) {
         assert(std::any_of(eviction_candidates_copy.begin(), eviction_candidates_copy.end(), [&node_to_evict](const NodeEvictionCandidate& eviction_candidate) { return *node_to_evict == eviction_candidate.id; }));
     }
diff --git a/src/test/fuzz/partially_downloaded_block.cpp b/src/test/fuzz/partially_downloaded_block.cpp
index c7e9915744..77952cab9e 100644
--- a/src/test/fuzz/partially_downloaded_block.cpp
+++ b/src/test/fuzz/partially_downloaded_block.cpp
@@ -76,7 +76,7 @@ FUZZ_TARGET(partially_downloaded_block, .init = initialize_pdb)
             available.insert(i);
         }
 
-        if (add_to_mempool && (!pool.exists(GenTxid::Txid(tx->GetHash()))) && SanityCheckForConsumeTxMemPoolEntry(*tx)) {
+        if (add_to_mempool && !pool.exists(GenTxid::Txid(tx->GetHash()))) {
             LOCK2(cs_main, pool.cs);
             pool.addUnchecked(ConsumeTxMemPoolEntry(fuzzed_data_provider, *tx));
             available.insert(i);
diff --git a/src/test/fuzz/policy_estimator.cpp b/src/test/fuzz/policy_estimator.cpp
index 2201e4a559..a4e1947b9f 100644
--- a/src/test/fuzz/policy_estimator.cpp
+++ b/src/test/fuzz/policy_estimator.cpp
@@ -44,13 +44,12 @@ FUZZ_TARGET(policy_estimator, .init = initialize_policy_estimator)
                     return;
                 }
                 const CTransaction tx{*mtx};
-                if (!SanityCheckForConsumeTxMemPoolEntry(tx)) return;
                 const CTxMemPoolEntry& entry = ConsumeTxMemPoolEntry(fuzzed_data_provider, tx);
                 const auto tx_submitted_in_package = fuzzed_data_provider.ConsumeBool();
                 const auto tx_has_mempool_parents = fuzzed_data_provider.ConsumeBool();
                 const auto tx_info = NewMempoolTransactionInfo(entry.GetSharedTx(), entry.GetFee(),
                                                                entry.GetTxSize(), entry.GetHeight(),
-                                                               empty_ignore_rejects,
+                                                               /*mempool_limit_bypassed=*/false,
                                                                tx_submitted_in_package,
                                                                /*chainstate_is_current=*/true,
                                                                tx_has_mempool_parents);
@@ -69,7 +68,6 @@ FUZZ_TARGET(policy_estimator, .init = initialize_policy_estimator)
                         break;
                     }
                     const CTransaction tx{*mtx};
-                    if (!SanityCheckForConsumeTxMemPoolEntry(tx)) return;
                     mempool_entries.emplace_back(CTxMemPoolEntry::ExplicitCopy, ConsumeTxMemPoolEntry(fuzzed_data_provider, tx));
                 }
                 std::vector<RemovedMempoolTransactionInfo> txs;
@@ -97,6 +95,5 @@ FUZZ_TARGET(policy_estimator, .init = initialize_policy_estimator)
         AutoFile fuzzed_auto_file{fuzzed_file_provider.open()};
         block_policy_estimator.Write(fuzzed_auto_file);
         block_policy_estimator.Read(fuzzed_auto_file);
-        (void)fuzzed_auto_file.fclose();
     }
 }
diff --git a/src/test/fuzz/policy_estimator_io.cpp b/src/test/fuzz/policy_estimator_io.cpp
index 813674e25c..3e7d093343 100644
--- a/src/test/fuzz/policy_estimator_io.cpp
+++ b/src/test/fuzz/policy_estimator_io.cpp
@@ -32,5 +32,4 @@ FUZZ_TARGET(policy_estimator_io, .init = initialize_policy_estimator_io)
     if (block_policy_estimator.Read(fuzzed_auto_file)) {
         block_policy_estimator.Write(fuzzed_auto_file);
     }
-    (void)fuzzed_auto_file.fclose();
 }
diff --git a/src/test/fuzz/rbf.cpp b/src/test/fuzz/rbf.cpp
index 64d2d1ca0c..eb981352ec 100644
--- a/src/test/fuzz/rbf.cpp
+++ b/src/test/fuzz/rbf.cpp
@@ -57,8 +57,6 @@ FUZZ_TARGET(rbf, .init = initialize_rbf)
     if (!mtx) {
         return;
     }
-    const CTransaction tx{*mtx};
-    if (!SanityCheckForConsumeTxMemPoolEntry(tx)) return;
 
     bilingual_str error;
     CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};
@@ -71,13 +69,13 @@ FUZZ_TARGET(rbf, .init = initialize_rbf)
             break;
         }
         const CTransaction another_tx{*another_mtx};
-        if (!SanityCheckForConsumeTxMemPoolEntry(another_tx)) break;
         if (fuzzed_data_provider.ConsumeBool() && !mtx->vin.empty()) {
             mtx->vin[0].prevout = COutPoint{another_tx.GetHash(), 0};
         }
         LOCK2(cs_main, pool.cs);
         pool.addUnchecked(ConsumeTxMemPoolEntry(fuzzed_data_provider, another_tx));
     }
+    const CTransaction tx{*mtx};
     if (fuzzed_data_provider.ConsumeBool()) {
         LOCK2(cs_main, pool.cs);
         pool.addUnchecked(ConsumeTxMemPoolEntry(fuzzed_data_provider, tx));
diff --git a/src/test/fuzz/rpc.cpp b/src/test/fuzz/rpc.cpp
index 77ebd7333c..9122617e46 100644
--- a/src/test/fuzz/rpc.cpp
+++ b/src/test/fuzz/rpc.cpp
@@ -85,7 +85,6 @@ const std::vector<std::string> RPC_COMMANDS_NOT_SAFE_FOR_FUZZING{
     "importwallet", // avoid reading from disk
     "loadtxoutset",   // avoid reading from disk
     "loadwallet",   // avoid reading from disk
-    "savefeeestimates",      // disabled as a precautionary measure: may take a file path argument in the future
     "savemempool",           // disabled as a precautionary measure: may take a file path argument in the future
     "setban",                // avoid DNS lookups
     "stop",                  // avoid shutdown state
@@ -112,7 +111,6 @@ const std::vector<std::string> RPC_COMMANDS_SAFE_FOR_FUZZING{
     "estimaterawfee",
     "estimatesmartfee",
     "finalizepsbt",
-    "format",
     "generate",
     "generateblock",
     "getaddednodeinfo",
@@ -125,8 +123,6 @@ const std::vector<std::string> RPC_COMMANDS_SAFE_FOR_FUZZING{
     "getblockfrompeer", // when no peers are connected, no p2p message is sent
     "getblockhash",
     "getblockheader",
-    "getblockfileinfo",
-    "getblocklocations",
     "getblockstats",
     "getblocktemplate",
     "getchaintips",
@@ -134,30 +130,25 @@ const std::vector<std::string> RPC_COMMANDS_SAFE_FOR_FUZZING{
     "getchaintxstats",
     "getconnectioncount",
     "getdeploymentinfo",
-    "getdescriptoractivity",
     "getdescriptorinfo",
     "getdifficulty",
-    "getgeneralinfo",
     "getindexinfo",
     "getmemoryinfo",
     "getmempoolancestors",
     "getmempooldescendants",
     "getmempoolentry",
-    "getmempoolstats",
     "getmempoolinfo",
     "getmininginfo",
     "getnettotals",
     "getnetworkhashps",
     "getnetworkinfo",
     "getnodeaddresses",
-    "getorphantxs",
     "getpeerinfo",
     "getprioritisedtransactions",
     "getrawaddrman",
     "getrawmempool",
     "getrawtransaction",
     "getrpcinfo",
-    "getrpcwhitelist",
     "gettxout",
     "gettxoutsetinfo",
     "gettxspendingprevout",
@@ -165,10 +156,7 @@ const std::vector<std::string> RPC_COMMANDS_SAFE_FOR_FUZZING{
     "invalidateblock",
     "joinpsbts",
     "listbanned",
-    "listmempooltransactions",
-    "listprunelocks",
     "logging",
-    "maxmempool",
     "mockscheduler",
     "ping",
     "preciousblock",
@@ -177,19 +165,15 @@ const std::vector<std::string> RPC_COMMANDS_SAFE_FOR_FUZZING{
     "reconsiderblock",
     "scanblocks",
     "scantxoutset",
-    "scriptthreadsinfo",
     "sendmsgtopeer", // when no peers are connected, no p2p message is sent
     "sendrawtransaction",
     "setmocktime",
     "setnetworkactive",
-    "setprunelock",
-    "setscriptthreadsenabled",
     "signmessagewithprivkey",
     "signrawtransactionwithkey",
     "submitblock",
     "submitheader",
     "submitpackage",
-    "sweepprivkeys",
     "syncwithvalidationinterfacequeue",
     "testmempoolaccept",
     "uptime",
diff --git a/src/test/fuzz/script_bitcoin_consensus.cpp b/src/test/fuzz/script_bitcoin_consensus.cpp
deleted file mode 100644
index 846389863d..0000000000
--- a/src/test/fuzz/script_bitcoin_consensus.cpp
+++ /dev/null
@@ -1,50 +0,0 @@
-// Copyright (c) 2020 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#include <script/bitcoinconsensus.h>
-#include <script/interpreter.h>
-#include <test/fuzz/FuzzedDataProvider.h>
-#include <test/fuzz/fuzz.h>
-#include <test/fuzz/util.h>
-
-#include <cstdint>
-#include <string>
-#include <vector>
-
-FUZZ_TARGET(script_bitcoin_consensus)
-{
-    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());
-    const std::vector<uint8_t> random_bytes_1 = ConsumeRandomLengthByteVector(fuzzed_data_provider);
-    const std::vector<uint8_t> random_bytes_2 = ConsumeRandomLengthByteVector(fuzzed_data_provider);
-    const CAmount money = ConsumeMoney(fuzzed_data_provider);
-    bitcoinconsensus_error err;
-    bitcoinconsensus_error* err_p = fuzzed_data_provider.ConsumeBool() ? &err : nullptr;
-    const unsigned int n_in = fuzzed_data_provider.ConsumeIntegral<unsigned int>();
-    const unsigned int flags = fuzzed_data_provider.ConsumeIntegral<unsigned int>();
-    assert(bitcoinconsensus_version() == BITCOINCONSENSUS_API_VER);
-    if ((flags & SCRIPT_VERIFY_WITNESS) != 0 && (flags & SCRIPT_VERIFY_P2SH) == 0) {
-        return;
-    }
-    (void)bitcoinconsensus_verify_script(random_bytes_1.data(), random_bytes_1.size(), random_bytes_2.data(), random_bytes_2.size(), n_in, flags, err_p);
-    (void)bitcoinconsensus_verify_script_with_amount(random_bytes_1.data(), random_bytes_1.size(), money, random_bytes_2.data(), random_bytes_2.size(), n_in, flags, err_p);
-
-    std::vector<UTXO> spent_outputs;
-    std::vector<std::vector<unsigned char>> spent_spks;
-    if (n_in <= 24386) {
-        spent_outputs.reserve(n_in);
-        spent_spks.reserve(n_in);
-        for (size_t i = 0; i < n_in; ++i) {
-            spent_spks.push_back(ConsumeRandomLengthByteVector(fuzzed_data_provider));
-            const CAmount value{ConsumeMoney(fuzzed_data_provider)};
-            const auto spk_size{static_cast<unsigned>(spent_spks.back().size())};
-            spent_outputs.push_back({.scriptPubKey = spent_spks.back().data(), .scriptPubKeySize = spk_size, .value = value});
-        }
-    }
-
-    const auto spent_outs_size{static_cast<unsigned>(spent_outputs.size())};
-
-    (void)bitcoinconsensus_verify_script_with_spent_outputs(
-            random_bytes_1.data(), random_bytes_1.size(), money, random_bytes_2.data(), random_bytes_2.size(),
-            spent_outputs.data(), spent_outs_size, n_in, flags, err_p);
-}
diff --git a/src/test/fuzz/transaction.cpp b/src/test/fuzz/transaction.cpp
index b94ce7a301..2a043f7458 100644
--- a/src/test/fuzz/transaction.cpp
+++ b/src/test/fuzz/transaction.cpp
@@ -9,7 +9,6 @@
 #include <consensus/validation.h>
 #include <core_io.h>
 #include <core_memusage.h>
-#include <kernel/mempool_options.h>
 #include <policy/policy.h>
 #include <policy/settings.h>
 #include <primitives/transaction.h>
@@ -58,9 +57,10 @@ FUZZ_TARGET(transaction, .init = initialize_transaction)
         Assert(res == state_with_dupe_check.IsValid());
     }
 
+    const CFeeRate dust_relay_fee{DUST_RELAY_TX_FEE};
     std::string reason;
-    const bool is_standard_with_permit_bare_multisig = IsStandardTx(tx, kernel::MemPoolOptions{.permit_bare_pubkey = true, .permit_bare_multisig = true}, reason);
-    const bool is_standard_without_permit_bare_multisig = IsStandardTx(tx, kernel::MemPoolOptions{.permit_bare_pubkey = true, .permit_bare_multisig = false}, reason);
+    const bool is_standard_with_permit_bare_multisig = IsStandardTx(tx, std::nullopt, /* permit_bare_multisig= */ true, dust_relay_fee, reason);
+    const bool is_standard_without_permit_bare_multisig = IsStandardTx(tx, std::nullopt, /* permit_bare_multisig= */ false, dust_relay_fee, reason);
     if (is_standard_without_permit_bare_multisig) {
         assert(is_standard_with_permit_bare_multisig);
     }
@@ -88,8 +88,7 @@ FUZZ_TARGET(transaction, .init = initialize_transaction)
     CCoinsView coins_view;
     const CCoinsViewCache coins_view_cache(&coins_view);
     (void)AreInputsStandard(tx, coins_view_cache);
-    std::string reject_reason;
-    (void)IsWitnessStandard(tx, coins_view_cache, "fuzz", reject_reason);
+    (void)IsWitnessStandard(tx, coins_view_cache);
 
     if (tx.GetTotalSize() < 250'000) { // Avoid high memory usage (with msan) due to json encoding
         {
diff --git a/src/test/fuzz/tx_pool.cpp b/src/test/fuzz/tx_pool.cpp
index 1cd229f94d..64861311db 100644
--- a/src/test/fuzz/tx_pool.cpp
+++ b/src/test/fuzz/tx_pool.cpp
@@ -2,7 +2,6 @@
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
-#include <clientversion.h>
 #include <consensus/validation.h>
 #include <node/context.h>
 #include <node/mempool_args.h>
@@ -98,7 +97,7 @@ void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Cha
         BlockAssembler::Options options;
         options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);
         options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};
-        auto assembler = BlockAssembler{chainstate, &tx_pool, options, g_setup->m_node};
+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};
         auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);
         Assert(block_template->block.vtx.size() >= 1);
     }
@@ -116,7 +115,7 @@ void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chains
 {
     const auto time = ConsumeTime(fuzzed_data_provider,
                                   chainstate.m_chain.Tip()->GetMedianTimePast() + 1,
-                                  DEFAULT_SOFTWARE_EXPIRY - 1);
+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());
     SetMockTime(time);
 }
 
diff --git a/src/test/fuzz/util/mempool.cpp b/src/test/fuzz/util/mempool.cpp
index 3dfa3d6e94..8e7499a860 100644
--- a/src/test/fuzz/util/mempool.cpp
+++ b/src/test/fuzz/util/mempool.cpp
@@ -14,17 +14,6 @@
 #include <cstdint>
 #include <limits>
 
-bool SanityCheckForConsumeTxMemPoolEntry(const CTransaction& tx) noexcept
-{
-    try {
-        (void)tx.GetValueOut();
-        return true;
-    } catch (const std::runtime_error&) {
-        return false;
-    }
-}
-
-// NOTE: Transaction must pass SanityCheckForConsumeTxMemPoolEntry first
 CTxMemPoolEntry ConsumeTxMemPoolEntry(FuzzedDataProvider& fuzzed_data_provider, const CTransaction& tx) noexcept
 {
     // Avoid:
@@ -35,10 +24,8 @@ CTxMemPoolEntry ConsumeTxMemPoolEntry(FuzzedDataProvider& fuzzed_data_provider,
     assert(MoneyRange(fee));
     const int64_t time = fuzzed_data_provider.ConsumeIntegral<int64_t>();
     const uint64_t entry_sequence{fuzzed_data_provider.ConsumeIntegral<uint64_t>()};
-    const double coin_age = fuzzed_data_provider.ConsumeFloatingPoint<double>();
-    const unsigned int entry_height = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, std::numeric_limits<unsigned int>::max() - 1);
+    const unsigned int entry_height = fuzzed_data_provider.ConsumeIntegral<unsigned int>();
     const bool spends_coinbase = fuzzed_data_provider.ConsumeBool();
-    const int32_t extra_weight = fuzzed_data_provider.ConsumeIntegralInRange<int32_t>(0, GetTransactionWeight(tx) * 3);
     const unsigned int sig_op_cost = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, MAX_BLOCK_SIGOPS_COST);
-    return CTxMemPoolEntry{MakeTransactionRef(tx), fee, time, entry_height, entry_sequence, /*entry_tx_inputs_coin_age=*/coin_age, tx.GetValueOut(), spends_coinbase, extra_weight, sig_op_cost, {}};
+    return CTxMemPoolEntry{MakeTransactionRef(tx), fee, time, entry_height, entry_sequence, spends_coinbase, sig_op_cost, {}};
 }
diff --git a/src/test/fuzz/util/mempool.h b/src/test/fuzz/util/mempool.h
index 740225a0ee..31b578dc4b 100644
--- a/src/test/fuzz/util/mempool.h
+++ b/src/test/fuzz/util/mempool.h
@@ -21,7 +21,6 @@ public:
     }
 };
 
-[[nodiscard]] bool SanityCheckForConsumeTxMemPoolEntry(const CTransaction& tx) noexcept;
 [[nodiscard]] CTxMemPoolEntry ConsumeTxMemPoolEntry(FuzzedDataProvider& fuzzed_data_provider, const CTransaction& tx) noexcept;
 
 #endif // BITCOIN_TEST_FUZZ_UTIL_MEMPOOL_H
diff --git a/src/test/fuzz/utxo_snapshot.cpp b/src/test/fuzz/utxo_snapshot.cpp
index 7ee15af146..21c305e222 100644
--- a/src/test/fuzz/utxo_snapshot.cpp
+++ b/src/test/fuzz/utxo_snapshot.cpp
@@ -118,7 +118,6 @@ void utxo_snapshot_fuzz(FuzzBufferType buffer)
             WriteCompactSize(outfile, 999); // index of coin
             outfile << Coin{coinbase->vout[0], /*nHeightIn=*/999, /*fCoinBaseIn=*/0};
         }
-        assert(outfile.fclose() == 0);
     }
 
     const auto ActivateFuzzedSnapshot{[&] {
diff --git a/src/test/fuzz/validation_load_mempool.cpp b/src/test/fuzz/validation_load_mempool.cpp
index f6543ba912..c70d9ddf1e 100644
--- a/src/test/fuzz/validation_load_mempool.cpp
+++ b/src/test/fuzz/validation_load_mempool.cpp
@@ -55,7 +55,6 @@ FUZZ_TARGET(validation_load_mempool, .init = initialize_validation_load_mempool)
     (void)LoadMempool(pool, MempoolPath(g_setup->m_args), chainstate,
                       {
                           .mockable_fopen_function = fuzzed_fopen,
-                          .load_knots_data = true,
                       });
     pool.SetLoadTried(true);
     (void)DumpMempool(pool, MempoolPath(g_setup->m_args), fuzzed_fopen, true);
diff --git a/src/test/getarg_tests.cpp b/src/test/getarg_tests.cpp
index adfef3cfb1..8734735fd5 100644
--- a/src/test/getarg_tests.cpp
+++ b/src/test/getarg_tests.cpp
@@ -104,22 +104,22 @@ BOOST_AUTO_TEST_CASE(setting_args)
     BOOST_CHECK_EQUAL(args.GetSetting("foo").write(), "99");
     BOOST_CHECK_EQUAL(args.GetArg("foo", "default"), "99");
     BOOST_CHECK_EQUAL(args.GetIntArg("foo", 100), 99);
-    BOOST_CHECK_EQUAL(args.GetBoolArg("foo", true), true);
-    BOOST_CHECK_EQUAL(args.GetBoolArg("foo", false), true);
+    BOOST_CHECK_THROW(args.GetBoolArg("foo", true), std::runtime_error);
+    BOOST_CHECK_THROW(args.GetBoolArg("foo", false), std::runtime_error);
 
     set_foo(3.25);
     BOOST_CHECK_EQUAL(args.GetSetting("foo").write(), "3.25");
     BOOST_CHECK_EQUAL(args.GetArg("foo", "default"), "3.25");
     BOOST_CHECK_THROW(args.GetIntArg("foo", 100), std::runtime_error);
-    BOOST_CHECK_EQUAL(args.GetBoolArg("foo", true), true);
-    BOOST_CHECK_EQUAL(args.GetBoolArg("foo", false), true);
+    BOOST_CHECK_THROW(args.GetBoolArg("foo", true), std::runtime_error);
+    BOOST_CHECK_THROW(args.GetBoolArg("foo", false), std::runtime_error);
 
     set_foo(0);
     BOOST_CHECK_EQUAL(args.GetSetting("foo").write(), "0");
     BOOST_CHECK_EQUAL(args.GetArg("foo", "default"), "0");
     BOOST_CHECK_EQUAL(args.GetIntArg("foo", 100), 0);
-    BOOST_CHECK_EQUAL(args.GetBoolArg("foo", true), false);
-    BOOST_CHECK_EQUAL(args.GetBoolArg("foo", false), false);
+    BOOST_CHECK_THROW(args.GetBoolArg("foo", true), std::runtime_error);
+    BOOST_CHECK_THROW(args.GetBoolArg("foo", false), std::runtime_error);
 
     set_foo(true);
     BOOST_CHECK_EQUAL(args.GetSetting("foo").write(), "true");
diff --git a/src/test/miner_tests.cpp b/src/test/miner_tests.cpp
index 801d49bdba..c4cf6f8a40 100644
--- a/src/test/miner_tests.cpp
+++ b/src/test/miner_tests.cpp
@@ -66,9 +66,8 @@ BlockAssembler MinerTestingSetup::AssemblerForTest(CTxMemPool& tx_mempool)
     BlockAssembler::Options options;
 
     options.nBlockMaxWeight = MAX_BLOCK_WEIGHT;
-    options.nBlockMaxSize = MAX_BLOCK_SERIALIZED_SIZE;
     options.blockMinFeeRate = blockMinFeeRate;
-    return BlockAssembler{m_node.chainman->ActiveChainstate(), &tx_mempool, options, m_node};
+    return BlockAssembler{m_node.chainman->ActiveChainstate(), &tx_mempool, options};
 }
 
 constexpr static struct {
@@ -137,7 +136,7 @@ void MinerTestingSetup::TestPackageSelection(const CScript& scriptPubKey, const
     Txid hashHighFeeTx = tx.GetHash();
     tx_mempool.addUnchecked(entry.Fee(50000).Time(Now<NodeSeconds>()).SpendsCoinbase(false).FromTx(tx));
 
-    auto pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey);
+    std::unique_ptr<CBlockTemplate> pblocktemplate = AssemblerForTest(tx_mempool).CreateNewBlock(scriptPubKey);
     BOOST_REQUIRE_EQUAL(pblocktemplate->block.vtx.size(), 4U);
     BOOST_CHECK(pblocktemplate->block.vtx[1]->GetHash() == hashParentTx);
     BOOST_CHECK(pblocktemplate->block.vtx[2]->GetHash() == hashHighFeeTx);
@@ -607,11 +606,9 @@ void MinerTestingSetup::TestPrioritisedMining(const CScript& scriptPubKey, const
 // NOTE: These tests rely on CreateNewBlock doing its own self-validation!
 BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)
 {
-    gArgs.ForceSetArg("-blockprioritysize", "0");
-
     // Note that by default, these tests run with size accounting enabled.
     CScript scriptPubKey = CScript() << ParseHex("04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f") << OP_CHECKSIG;
-    std::shared_ptr<CBlockTemplate> pblocktemplate;
+    std::unique_ptr<CBlockTemplate> pblocktemplate;
 
     CTxMemPool& tx_mempool{*m_node.mempool};
     // Simple block creation, nothing special yet:
diff --git a/src/test/net_peer_connection_tests.cpp b/src/test/net_peer_connection_tests.cpp
index 3001fa9c78..2dde6daee5 100644
--- a/src/test/net_peer_connection_tests.cpp
+++ b/src/test/net_peer_connection_tests.cpp
@@ -127,15 +127,6 @@ BOOST_AUTO_TEST_CASE(test_addnode_getaddednodeinfo_and_connection_detection)
     BOOST_CHECK(!connman->AddNode({/*m_added_node=*/"127.1", /*m_use_v2transport=*/true}));
 #endif
 
-    BOOST_TEST_MESSAGE("\nCall AddNode() with a CJDNS service equal to an existing addnode entry; it should not be added");
-    BOOST_CHECK(!connman->AddNode({/*m_added_node=*/"[fc00:3344:5566:7788:9900:aabb:ccdd:eeff]:1234", /*m_use_v2transport=*/false}));
-
-    BOOST_TEST_MESSAGE("\nCall AddNode() with a CJDNS addr equal to an existing inbound one but with a different port specified; it should not be added");
-    BOOST_CHECK(!connman->AddNode({/*m_added_node=*/"[fc00:3344:5566:7788:9900:aabb:ccdd:eeff]:8333", /*m_use_v2transport=*/false}));
-
-    BOOST_TEST_MESSAGE("\nCall AddNode() with a CJDNS addr equal to an existing inbound one but resolving to a different port; it should not be added");
-    BOOST_CHECK(!connman->AddNode({/*m_added_node=*/"fc00:3344:5566:7788:9900:aabb:ccdd:eeff", /*m_use_v2transport=*/false}));
-
     BOOST_TEST_MESSAGE("\nExpect GetAddedNodeInfo to return expected number of peers with `include_connected` true/false");
     BOOST_CHECK_EQUAL(connman->GetAddedNodeInfo(/*include_connected=*/true).size(), nodes.size());
     BOOST_CHECK(connman->GetAddedNodeInfo(/*include_connected=*/false).empty());
diff --git a/src/test/net_peer_eviction_tests.cpp b/src/test/net_peer_eviction_tests.cpp
index 70c3340a04..d9e1c2332e 100644
--- a/src/test/net_peer_eviction_tests.cpp
+++ b/src/test/net_peer_eviction_tests.cpp
@@ -573,7 +573,7 @@ BOOST_AUTO_TEST_CASE(peer_protection_test)
 bool IsEvicted(std::vector<NodeEvictionCandidate> candidates, const std::unordered_set<NodeId>& node_ids, FastRandomContext& random_context)
 {
     std::shuffle(candidates.begin(), candidates.end(), random_context);
-    const std::optional<NodeId> evicted_node_id = SelectNodeToEvict(std::move(candidates), /*force=*/false);
+    const std::optional<NodeId> evicted_node_id = SelectNodeToEvict(std::move(candidates));
     if (!evicted_node_id) {
         return false;
     }
@@ -666,14 +666,14 @@ BOOST_AUTO_TEST_CASE(peer_eviction_test)
         // four peers by net group, eight by lowest ping time, four by last time of novel tx, up to eight non-tx-relay
         // peers by last novel block time, and four more peers by last novel block time.
         if (number_of_nodes >= 29) {
-            BOOST_CHECK(SelectNodeToEvict(GetRandomNodeEvictionCandidates(number_of_nodes, random_context), /*force=*/false));
+            BOOST_CHECK(SelectNodeToEvict(GetRandomNodeEvictionCandidates(number_of_nodes, random_context)));
         }
 
         // No eviction is expected given <= 20 random eviction candidates. The eviction logic protects at least
         // four peers by net group, eight by lowest ping time, four by last time of novel tx and four peers by last
         // novel block time.
         if (number_of_nodes <= 20) {
-            BOOST_CHECK(!SelectNodeToEvict(GetRandomNodeEvictionCandidates(number_of_nodes, random_context), /*force=*/false));
+            BOOST_CHECK(!SelectNodeToEvict(GetRandomNodeEvictionCandidates(number_of_nodes, random_context)));
         }
 
         // Cases left to test:
diff --git a/src/test/netbase_tests.cpp b/src/test/netbase_tests.cpp
index 50a2561fb8..3422cb8023 100644
--- a/src/test/netbase_tests.cpp
+++ b/src/test/netbase_tests.cpp
@@ -465,8 +465,7 @@ BOOST_AUTO_TEST_CASE(netpermissions_test)
     BOOST_CHECK_EQUAL(connection_direction, ConnectionDirection::Both);
 
     const auto strings = NetPermissions::ToStrings(NetPermissionFlags::All);
-    BOOST_CHECK_EQUAL(strings.size(), 8U);
-    BOOST_CHECK(std::find(strings.begin(), strings.end(), "blockfilters") != strings.end());
+    BOOST_CHECK_EQUAL(strings.size(), 7U);
     BOOST_CHECK(std::find(strings.begin(), strings.end(), "bloomfilter") != strings.end());
     BOOST_CHECK(std::find(strings.begin(), strings.end(), "forcerelay") != strings.end());
     BOOST_CHECK(std::find(strings.begin(), strings.end(), "relay") != strings.end());
diff --git a/src/test/peerman_tests.cpp b/src/test/peerman_tests.cpp
index 2923c1eb76..6de373eef2 100644
--- a/src/test/peerman_tests.cpp
+++ b/src/test/peerman_tests.cpp
@@ -21,7 +21,7 @@ static void mineBlock(const node::NodeContext& node, std::chrono::seconds block_
     auto curr_time = GetTime<std::chrono::seconds>();
     SetMockTime(block_time); // update time so the block is created with it
     node::BlockAssembler::Options options;
-    CBlock block = node::BlockAssembler{node.chainman->ActiveChainstate(), nullptr, options, node}.CreateNewBlock(CScript() << OP_TRUE)->block;
+    CBlock block = node::BlockAssembler{node.chainman->ActiveChainstate(), nullptr, options}.CreateNewBlock(CScript() << OP_TRUE)->block;
     while (!CheckProofOfWork(block.GetHash(), block.nBits, node.chainman->GetConsensus())) ++block.nNonce;
     block.fChecked = true; // little speedup
     SetMockTime(curr_time); // process block at current time
diff --git a/src/test/policyestimator_tests.cpp b/src/test/policyestimator_tests.cpp
index ceb1cfb010..83977c1c89 100644
--- a/src/test/policyestimator_tests.cpp
+++ b/src/test/policyestimator_tests.cpp
@@ -71,7 +71,7 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)
                                                                                       feeV[j],
                                                                                       virtual_size,
                                                                                       entry.nHeight,
-                                                                                      empty_ignore_rejects,
+                                                                                      /*mempool_limit_bypassed=*/false,
                                                                                       /*submitted_in_package=*/false,
                                                                                       /*chainstate_is_current=*/true,
                                                                                       /*has_no_mempool_parents=*/true)};
@@ -172,7 +172,7 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)
                                                                                       feeV[j],
                                                                                       virtual_size,
                                                                                       entry.nHeight,
-                                                                                      empty_ignore_rejects,
+                                                                                      /*mempool_limit_bypassed=*/false,
                                                                                       /*submitted_in_package=*/false,
                                                                                       /*chainstate_is_current=*/true,
                                                                                       /*has_no_mempool_parents=*/true)};
@@ -236,7 +236,7 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)
                                                                                       feeV[j],
                                                                                       virtual_size,
                                                                                       entry.nHeight,
-                                                                                      empty_ignore_rejects,
+                                                                                      /*mempool_limit_bypassed=*/false,
                                                                                       /*submitted_in_package=*/false,
                                                                                       /*chainstate_is_current=*/true,
                                                                                       /*has_no_mempool_parents=*/true)};
diff --git a/src/test/rbf_tests.cpp b/src/test/rbf_tests.cpp
index dfa5680b7a..19e45c550a 100644
--- a/src/test/rbf_tests.cpp
+++ b/src/test/rbf_tests.cpp
@@ -216,22 +216,14 @@ BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)
     BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4_high->GetModifiedFee(), entry4_high->GetTxSize()), unused_txid).has_value());
 
     // Tests for EntriesAndTxidsDisjoint
-    bool violates_policy{false};
-    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {{tx1->GetHash(), true}}, unused_txid, &violates_policy) == std::nullopt);
-    BOOST_CHECK(!violates_policy);
-    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {{tx3->GetHash(), true}}, unused_txid, &violates_policy) == std::nullopt);
-    BOOST_CHECK(!violates_policy);
-    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2_normal}, {{tx2->GetHash(), true}}, unused_txid, &violates_policy).has_value());
-    BOOST_CHECK(!violates_policy);
-    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {{tx1->GetHash(), true}}, unused_txid, &violates_policy).has_value());
-    BOOST_CHECK(!violates_policy);
-    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {{tx2->GetHash(), true}}, unused_txid, &violates_policy).has_value());
-    BOOST_CHECK(!violates_policy);
+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);
+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);
+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2_normal}, {tx2->GetHash()}, unused_txid).has_value());
+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());
+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());
     // EntriesAndTxidsDisjoint does not calculate descendants of iters_conflicting; it uses whatever
     // the caller passed in. As such, no error is returned even though entry2_normal is a descendant of tx1.
-    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2_normal}, {{tx1->GetHash(), true}}, unused_txid, &violates_policy) == std::nullopt);
-    BOOST_CHECK(!violates_policy);
-    // TODO: Add tests for policy-only conflicts
+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2_normal}, {tx1->GetHash()}, unused_txid) == std::nullopt);
 
     // Tests for PaysForRBF
     const CFeeRate incremental_relay_feerate{DEFAULT_INCREMENTAL_RELAY_FEE};
diff --git a/src/test/rpc_tests.cpp b/src/test/rpc_tests.cpp
index 97226fb72a..5089f3e8e3 100644
--- a/src/test/rpc_tests.cpp
+++ b/src/test/rpc_tests.cpp
@@ -311,17 +311,6 @@ BOOST_AUTO_TEST_CASE(rpc_parse_monetary_values)
     BOOST_CHECK_THROW(AmountFromValue(ValueFromString("93e+9")), UniValue); //overflow error
 }
 
-BOOST_AUTO_TEST_CASE(rpc_parse_fee_rate_values)
-{
-    // Test ValueFromFeeRate() and CFeeRate()
-    // ...using default CFeeRate constructor
-    BOOST_CHECK_EQUAL(ValueFromFeeRate(CFeeRate(AmountFromValue(0.00001234))).get_real(), 1.234);
-    BOOST_CHECK_EQUAL(ValueFromFeeRate(CFeeRate(AmountFromValue(0.1234))).get_real(), 12340.000);
-    BOOST_CHECK_EQUAL(ValueFromFeeRate(CFeeRate(AmountFromValue(1234))).get_real(), 123400000.000);
-    // ...using CFeeRate constructor with bytes 1000
-    BOOST_CHECK_EQUAL(ValueFromFeeRate(CFeeRate(AmountFromValue(0.00001234), 1000)).get_real(), 1.234);
-}
-
 BOOST_AUTO_TEST_CASE(rpc_ban)
 {
     BOOST_CHECK_NO_THROW(CallRPC(std::string("clearbanned")));
diff --git a/src/test/sanity_tests.cpp b/src/test/sanity_tests.cpp
index 284ed346c0..68f82b760c 100644
--- a/src/test/sanity_tests.cpp
+++ b/src/test/sanity_tests.cpp
@@ -2,8 +2,6 @@
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
-#include <dbwrapper.h>
-#include <kernel/checks.h>
 #include <key.h>
 #include <test/util/setup_common.h>
 
@@ -13,8 +11,6 @@ BOOST_FIXTURE_TEST_SUITE(sanity_tests, BasicTestingSetup)
 
 BOOST_AUTO_TEST_CASE(basic_sanity)
 {
-  BOOST_CHECK_MESSAGE(dbwrapper_SanityCheck() == true, "dbwrapper sanity test");
-  BOOST_CHECK_MESSAGE(kernel::Clang_IndVarSimplify_Bug_SanityCheck() == true, "Clang IndVarSimplify bug sanity test");
   BOOST_CHECK_MESSAGE(ECC_InitSanityCheck() == true, "secp256k1 sanity test");
 }
 
diff --git a/src/test/script_p2sh_tests.cpp b/src/test/script_p2sh_tests.cpp
index 76cda2680f..f91203cc48 100644
--- a/src/test/script_p2sh_tests.cpp
+++ b/src/test/script_p2sh_tests.cpp
@@ -3,7 +3,6 @@
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
 #include <consensus/tx_verify.h>
-#include <kernel/mempool_options.h>
 #include <key.h>
 #include <policy/policy.h>
 #include <policy/settings.h>
@@ -21,22 +20,13 @@
 // Helpers:
 static bool IsStandardTx(const CTransaction& tx, bool permit_bare_multisig, std::string& reason)
 {
-    const kernel::MemPoolOptions opts{
-        .permit_bare_pubkey = true,
-        .permit_bare_multisig = permit_bare_multisig,
-    };
-    return IsStandardTx(tx, opts, reason);
+    return IsStandardTx(tx, std::nullopt, permit_bare_multisig, CFeeRate{DUST_RELAY_TX_FEE}, reason);
 }
 
 static bool IsStandardTx(const CTransaction& tx, std::string& reason)
 {
-    kernel::MemPoolOptions opts{
-        .permit_bare_pubkey = true,
-        .permit_bare_multisig = true,
-    };
-    if (!IsStandardTx(tx, opts, reason)) return false;
-    opts.permit_bare_multisig = false;
-    return IsStandardTx(tx, opts, reason);
+    return IsStandardTx(tx, std::nullopt, /*permit_bare_multisig=*/true, CFeeRate{DUST_RELAY_TX_FEE}, reason) &&
+           IsStandardTx(tx, std::nullopt, /*permit_bare_multisig=*/false, CFeeRate{DUST_RELAY_TX_FEE}, reason);
 }
 
 static std::vector<unsigned char> Serialize(const CScript& s)
diff --git a/src/test/script_tests.cpp b/src/test/script_tests.cpp
index 22cccd776b..c5a8f2dfbc 100644
--- a/src/test/script_tests.cpp
+++ b/src/test/script_tests.cpp
@@ -2,17 +2,12 @@
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
-#if defined(HAVE_CONFIG_H)
-#include <config/bitcoin-config.h>
-#endif
-
 #include <test/data/script_tests.json.h>
 #include <test/data/bip341_wallet_vectors.json.h>
 
 #include <common/system.h>
 #include <core_io.h>
 #include <key.h>
-#include <policy/policy.h>
 #include <rpc/util.h>
 #include <script/script.h>
 #include <script/script_error.h>
@@ -28,10 +23,6 @@
 #include <util/fs.h>
 #include <util/strencodings.h>
 
-#if defined(HAVE_CONSENSUS_LIB)
-#include <script/bitcoinconsensus.h>
-#endif
-
 #include <cstdint>
 #include <fstream>
 #include <string>
@@ -144,21 +135,6 @@ void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, const CScript
         if (combined_flags & SCRIPT_VERIFY_WITNESS && ~combined_flags & SCRIPT_VERIFY_P2SH) continue;
         BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, &scriptWitness, combined_flags, MutableTransactionSignatureChecker(&tx, 0, txCredit.vout[0].nValue, MissingDataBehavior::ASSERT_FAIL), &err) == expect, message + strprintf(" (with flags %x)", combined_flags));
     }
-
-#if defined(HAVE_CONSENSUS_LIB)
-    DataStream stream;
-    stream << TX_WITH_WITNESS(tx2);
-    uint32_t libconsensus_flags{flags & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_ALL};
-    if (libconsensus_flags == flags) {
-        int expectedSuccessCode = expect ? 1 : 0;
-        if (flags & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS) {
-            BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script_with_amount(scriptPubKey.data(), scriptPubKey.size(), txCredit.vout[0].nValue, UCharCast(stream.data()), stream.size(), 0, libconsensus_flags, nullptr) == expectedSuccessCode, message);
-        } else {
-            BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script_with_amount(scriptPubKey.data(), scriptPubKey.size(), 0, UCharCast(stream.data()), stream.size(), 0, libconsensus_flags, nullptr) == expectedSuccessCode, message);
-            BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), UCharCast(stream.data()), stream.size(), 0, libconsensus_flags, nullptr) == expectedSuccessCode, message);
-        }
-    }
-#endif
 }
 
 void static NegateSignatureS(std::vector<unsigned char>& vchSig) {
@@ -1505,266 +1481,6 @@ BOOST_AUTO_TEST_CASE(script_HasValidOps)
     BOOST_CHECK(!script.HasValidOps());
 }
 
-static std::string DatacarrierBytesStr(const CScript &script) {
-    auto dcb = script.DatacarrierBytes();
-    return strprintf("%s+%s", dcb.first, dcb.second);
-}
-
-BOOST_AUTO_TEST_CASE(script_DataCarrierBytes)
-{
-    using zeros = std::vector<unsigned char>;
-
-    // empty script
-    BOOST_CHECK_EQUAL("0+0", DatacarrierBytesStr(CScript()));
-    // series of pushes are not data
-    BOOST_CHECK_EQUAL("0+0", DatacarrierBytesStr(CScript() << OP_0 << OP_0 << OP_0));
-    // unspendable if first op is OP_RETURN, then length(1), zeros(11)
-    BOOST_CHECK_EQUAL("13+0", DatacarrierBytesStr(CScript() << OP_RETURN << zeros(11)));
-    // invalid script (no data following PUSHDATA) makes it all data
-    BOOST_CHECK_EQUAL("0+2", DatacarrierBytesStr(CScript() << OP_0 << OP_PUSHDATA4));
-    // no data here
-    BOOST_CHECK_EQUAL("0+0", DatacarrierBytesStr(CScript() << OP_TRUE << OP_IF << OP_ENDIF));
-    // specific data pattern, entire script is data
-    BOOST_CHECK_EQUAL("0+4", DatacarrierBytesStr(CScript() << OP_FALSE << OP_IF << OP_7 << OP_ENDIF));
-    // consecutive data
-    BOOST_CHECK_EQUAL("0+6", DatacarrierBytesStr(CScript() << OP_FALSE << OP_IF << OP_ENDIF << OP_FALSE << OP_IF << OP_ENDIF));
-    // nested data (all is data)
-    BOOST_CHECK_EQUAL("0+6", DatacarrierBytesStr(CScript() << OP_FALSE << OP_IF << OP_TRUE << OP_IF << OP_ENDIF << OP_ENDIF));
-    // pushing then immediately dropping is data: length(1), zero(11), OP_DROP
-    BOOST_CHECK_EQUAL("0+13", DatacarrierBytesStr(CScript() << zeros(11) << OP_DROP));
-}
-
-BOOST_AUTO_TEST_CASE(script_GetScriptForTransactionInput)
-{
-    using zeros = std::vector<unsigned char>;
-
-    { // P2PK - no datacarrier bytes (tx_in doesn't matter)
-        CScript prev_script; // scriptPubKey
-        CTxIn tx_in;
-        prev_script = CScript() << zeros(65) << OP_CHECKSIG;
-        tx_in.scriptSig = CScript();
-        auto [ret_script, scale] = GetScriptForTransactionInput(prev_script, tx_in);
-        BOOST_CHECK(ret_script == tx_in.scriptSig);
-        BOOST_CHECK_EQUAL(scale, WITNESS_SCALE_FACTOR);
-        BOOST_CHECK_EQUAL(DatacarrierBytesStr(ret_script), "0+0");
-    }
-    { // P2PKH - no datacarrier bytes
-        CScript prev_script; // scriptPubKey
-        CTxIn tx_in;
-        prev_script = CScript() << OP_DUP << OP_HASH160 << zeros(20) << OP_EQUALVERIFY << OP_CHECKSIG;
-        // signature, pubkey
-        tx_in.scriptSig = CScript() << zeros(72) << zeros(33);
-        auto [ret_script, scale] = GetScriptForTransactionInput(prev_script, tx_in);
-        BOOST_CHECK(ret_script == tx_in.scriptSig);
-        BOOST_CHECK_EQUAL(scale, WITNESS_SCALE_FACTOR);
-        BOOST_CHECK_EQUAL(DatacarrierBytesStr(ret_script), "0+0");
-    }
-    { // P2SH - no datacarrier bytes
-        CScript prev_script; // scriptPubKey
-        CTxIn tx_in;
-        CScript redeem_script = CScript() << OP_DROP << OP_TRUE;
-        prev_script = CScript() << OP_HASH160 << zeros(20) << OP_EQUAL;
-        // signature, pubkey, redeem_script
-        tx_in.scriptSig = CScript() << OP_7 << std::vector<unsigned char>(redeem_script.begin(), redeem_script.end());
-        // this should return the redeem script
-        auto [ret_script, scale] = GetScriptForTransactionInput(prev_script, tx_in);
-        BOOST_CHECK(ret_script == redeem_script);
-        BOOST_CHECK_EQUAL(scale, WITNESS_SCALE_FACTOR);
-        BOOST_CHECK_EQUAL(DatacarrierBytesStr(ret_script), "0+0");
-    }
-    { // P2SH - with datacarrier bytes
-        CScript prev_script; // scriptPubKey
-        CTxIn tx_in;
-        // arbitrary amount of data (27 bytes)
-        CScript redeem_script = CScript() << OP_RETURN << zeros(27);
-        prev_script = CScript() << OP_HASH160 << zeros(20) << OP_EQUAL;
-        // signature, pubkey, redeem_script
-        tx_in.scriptSig = CScript() << OP_7 << std::vector<unsigned char>(redeem_script.begin(), redeem_script.end());
-        // this should return the redeem script
-        auto [ret_script, scale] = GetScriptForTransactionInput(prev_script, tx_in);
-        BOOST_CHECK(ret_script == redeem_script);
-        BOOST_CHECK_EQUAL(scale, WITNESS_SCALE_FACTOR);
-        // OP_RETURN(1), length(1), zeros(27) = 29
-        BOOST_CHECK_EQUAL(DatacarrierBytesStr(ret_script), "29+0");
-    }
-    { // P2WPKH - no datacarrier bytes
-        CScript prev_script; // scriptPubKey
-        CTxIn tx_in;
-        // P2WPKH is [OP_0, hash160(pubkey)]
-        prev_script = CScript() << OP_0 << zeros(20);
-        // segwit: empty scriptsig
-        tx_in.scriptSig = CScript();
-        tx_in.scriptWitness.stack.emplace_back(65); // signature
-        tx_in.scriptWitness.stack.emplace_back(33); // pubkey
-        // this should return the redeem script
-        auto [ret_script, scale] = GetScriptForTransactionInput(prev_script, tx_in);
-        // should have no script at all since it's wrapped P2WPKH
-        BOOST_CHECK(ret_script == CScript());
-        BOOST_CHECK_EQUAL(scale, 0);
-        BOOST_CHECK_EQUAL(DatacarrierBytesStr(ret_script), "0+0");
-    }
-    { // P2WSH - no datacarrier bytes
-        CScript prev_script; // scriptPubKey
-        CTxIn tx_in;
-        prev_script = CScript() << OP_0 << zeros(32);
-        // segwit: empty scriptsig
-        tx_in.scriptSig = CScript();
-        tx_in.scriptWitness.stack.emplace_back(65); // arbitrary value to satisfy redeem script
-        CScript redeem_script = CScript() << OP_0;
-        auto redeem_vec{std::vector<unsigned char>(redeem_script.begin(), redeem_script.end())};
-        tx_in.scriptWitness.stack.push_back(redeem_vec);
-        // this should return the redeem script
-        auto [ret_script, scale] = GetScriptForTransactionInput(prev_script, tx_in);
-        BOOST_CHECK(ret_script == redeem_script);
-        BOOST_CHECK_EQUAL(scale, 1);
-        BOOST_CHECK_EQUAL(DatacarrierBytesStr(ret_script), "0+0");
-    }
-    { // P2WSH - some datacarrier bytes
-        CScript prev_script; // scriptPubKey
-        CTxIn tx_in;
-        prev_script = CScript() << OP_0 << zeros(32);
-        // segwit: empty scriptsig
-        tx_in.scriptSig = CScript();
-        tx_in.scriptWitness.stack.emplace_back(65); // arbitrary value to satisfy redeem script
-        CScript redeem_script = CScript() << OP_FALSE << OP_IF << zeros(10) << OP_ENDIF;
-        auto redeem_vec{std::vector<unsigned char>(redeem_script.begin(), redeem_script.end())};
-        tx_in.scriptWitness.stack.push_back(redeem_vec);
-        // this should return the redeem script
-        auto [ret_script, scale] = GetScriptForTransactionInput(prev_script, tx_in);
-        BOOST_CHECK(ret_script == redeem_script);
-        BOOST_CHECK_EQUAL(scale, 1);
-        // OP_FALSE(1), OP_IF(1), length(1), zeros(10), OP_ENDIF(1)
-        BOOST_CHECK_EQUAL(DatacarrierBytesStr(ret_script), "0+14");
-    }
-    { // P2SH-P2WPKH - no datacarrier bytes
-        CScript prev_script; // scriptPubKey
-        CTxIn tx_in;
-        // P2WPKH is [OP_0, hash160(pubkey)]
-        CScript redeem_script = CScript() << OP_0 << zeros(20);
-        prev_script = CScript() << OP_HASH160 << zeros(20) << OP_EQUAL;
-        tx_in.scriptSig = CScript() << std::vector<unsigned char>(redeem_script.begin(), redeem_script.end());
-        // this should return the redeem script
-        auto [ret_script, scale] = GetScriptForTransactionInput(prev_script, tx_in);
-        // should have no script at all since it's wrapped P2WPKH
-        BOOST_CHECK(ret_script == CScript());
-        // data bytes in the witness get discounted (*1 instead of *4)
-        BOOST_CHECK_EQUAL(scale, 0);
-        BOOST_CHECK_EQUAL(DatacarrierBytesStr(ret_script), "0+0");
-    }
-    { // P2SH-P2WSH - no datacarrier bytes
-        CScript prev_script; // scriptPubKey
-        CTxIn tx_in;
-        // P2WSH is [OP_0, sha256(redeem_script)]
-        CScript redeem_script = CScript() << OP_0 << zeros(32);
-        prev_script = CScript() << OP_HASH160 << zeros(20) << OP_EQUAL;
-        tx_in.scriptSig = CScript() << std::vector<unsigned char>(redeem_script.begin(), redeem_script.end());
-        CScript witness_redeem_script = CScript() << OP_TRUE << OP_IF << zeros(10) << OP_ENDIF;
-
-        // in real life, one or more values (to satisfy the redeem script) would be pushed to the stack
-        CScript wit = CScript() << OP_7;
-        tx_in.scriptWitness.stack.emplace_back(wit.begin(), wit.end());
-        // and then finally the redeem script itself (as the last stack element)
-        auto redeem_vec{std::vector<unsigned char>(witness_redeem_script.begin(), witness_redeem_script.end())};
-        tx_in.scriptWitness.stack.push_back(redeem_vec);
-
-        // this should return the witness redeem script
-        auto [ret_script, scale] = GetScriptForTransactionInput(prev_script, tx_in);
-        // should have no script at all since it's wrapped P2WPKH
-        BOOST_CHECK(ret_script == witness_redeem_script);
-        // data bytes in the witness get discounted (*1 instead of *4)
-        BOOST_CHECK_EQUAL(scale, 1);
-        BOOST_CHECK_EQUAL(DatacarrierBytesStr(ret_script), "0+0");
-    }
-    { // P2SH-P2WSH - some datacarrier bytes
-        CScript prev_script; // scriptPubKey
-        CTxIn tx_in;
-        // P2WSH is [OP_0, sha256(redeem_script)]
-        CScript redeem_script = CScript() << OP_0 << zeros(32);
-        prev_script = CScript() << OP_HASH160 << zeros(20) << OP_EQUAL;
-        tx_in.scriptSig = CScript() << std::vector<unsigned char>(redeem_script.begin(), redeem_script.end());
-        CScript witness_redeem_script = CScript() << OP_FALSE << OP_IF << zeros(10) << OP_ENDIF;
-
-        // in real life, one or more values (to satisfy the redeem script) would be pushed to the stack
-        CScript wit = CScript() << OP_7;
-        tx_in.scriptWitness.stack.emplace_back(wit.begin(), wit.end());
-        // and then finally the redeem script itself (as the last stack element)
-        auto redeem_vec{std::vector<unsigned char>(witness_redeem_script.begin(), witness_redeem_script.end())};
-        tx_in.scriptWitness.stack.push_back(redeem_vec);
-
-        // this should return the witness redeem script
-        auto [ret_script, scale] = GetScriptForTransactionInput(prev_script, tx_in);
-        // should have no script at all since it's wrapped P2WPKH
-        BOOST_CHECK(ret_script == witness_redeem_script);
-        // data bytes in the witness get discounted (*1 instead of *4)
-        BOOST_CHECK_EQUAL(scale, 1);
-        // OP_FALSE(1), OP_IF(1), length(1), zeros(10), OP_ENDIF(1) = 14
-        BOOST_CHECK_EQUAL(DatacarrierBytesStr(ret_script), "0+14");
-    }
-    { // P2TR keypath - no datacarrier bytes
-        CScript prev_script; // scriptPubKey
-        CTxIn tx_in;
-        prev_script = CScript() << OP_1 << zeros(32);
-        // segwit: empty scriptsig
-        tx_in.scriptSig = CScript();
-        tx_in.scriptWitness.stack.emplace_back(65); // signature
-        auto [ret_script, scale] = GetScriptForTransactionInput(prev_script, tx_in);
-        BOOST_CHECK(ret_script == CScript());
-        BOOST_CHECK_EQUAL(scale, 0);
-        BOOST_CHECK_EQUAL(DatacarrierBytesStr(ret_script), "0+0");
-    }
-    { // P2TR keypath - annex but no script - no datacarrier bytes
-        CScript prev_script; // scriptPubKey
-        CTxIn tx_in;
-        prev_script = CScript() << OP_1 << zeros(32);
-        // segwit: empty scriptsig
-        tx_in.scriptSig = CScript();
-        tx_in.scriptWitness.stack.emplace_back(65); // signature
-        std::vector<unsigned char> annex{0x50, 0, 0};
-        tx_in.scriptWitness.stack.push_back(annex);
-        auto [ret_script, scale] = GetScriptForTransactionInput(prev_script, tx_in);
-        BOOST_CHECK(ret_script == CScript());
-        BOOST_CHECK_EQUAL(scale, 0);
-        BOOST_CHECK_EQUAL(DatacarrierBytesStr(ret_script), "0+0");
-    }
-    { // P2TR scriptpath - no datacarrier bytes
-        CScript prev_script; // scriptPubKey
-        CTxIn tx_in;
-        prev_script = CScript() << OP_1 << zeros(32);
-        // segwit: empty scriptsig
-        tx_in.scriptSig = CScript();
-        // stack: zero or more arbitrary values (script arguments); script; control block
-        // (here we have two arbitrary values)
-        tx_in.scriptWitness.stack.emplace_back(85); // arbitrary value
-        tx_in.scriptWitness.stack.emplace_back(10); // arbitrary value
-        CScript script = CScript() << OP_7 << OP_8;
-        auto script_vec{std::vector<unsigned char>(script.begin(), script.end())};
-        tx_in.scriptWitness.stack.push_back(script_vec);
-        tx_in.scriptWitness.stack.emplace_back(33); // control block
-        auto [ret_script, scale] = GetScriptForTransactionInput(prev_script, tx_in);
-        BOOST_CHECK(ret_script == script);
-        BOOST_CHECK_EQUAL(scale, 1);
-        BOOST_CHECK_EQUAL(DatacarrierBytesStr(ret_script), "0+0");
-    }
-    { // P2TR scriptpath - some datacarrier bytes
-        CScript prev_script; // scriptPubKey
-        CTxIn tx_in;
-        prev_script = CScript() << OP_1 << zeros(32);
-        // segwit: empty scriptsig
-        tx_in.scriptSig = CScript();
-        // stack: zero or more arbitrary values (script arguments); script; control block
-        // (here we have one arbitrary value)
-        tx_in.scriptWitness.stack.emplace_back(85); // arbitrary value
-        CScript script = CScript() << OP_RETURN << OP_7 << OP_8;
-        auto script_vec{std::vector<unsigned char>(script.begin(), script.end())};
-        tx_in.scriptWitness.stack.push_back(script_vec);
-        tx_in.scriptWitness.stack.emplace_back(33); // control block
-        auto [ret_script, scale] = GetScriptForTransactionInput(prev_script, tx_in);
-        BOOST_CHECK(ret_script == script);
-        BOOST_CHECK_EQUAL(scale, 1);
-        BOOST_CHECK_EQUAL(DatacarrierBytesStr(ret_script), "3+0");
-    }
-}
-
 static CMutableTransaction TxFromHex(const std::string& str)
 {
     CMutableTransaction tx;
@@ -1795,179 +1511,6 @@ static CScriptWitness ScriptWitnessFromJSON(const UniValue& univalue)
     return scriptwitness;
 }
 
-#if defined(HAVE_CONSENSUS_LIB)
-
-/* Test simple (successful) usage of bitcoinconsensus_verify_script */
-BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_returns_true)
-{
-    unsigned int libconsensus_flags = 0;
-    int nIn = 0;
-
-    CScript scriptPubKey;
-    CScript scriptSig;
-    CScriptWitness wit;
-
-    scriptPubKey << OP_1;
-    CTransaction creditTx{BuildCreditingTransaction(scriptPubKey, 1)};
-    CTransaction spendTx{BuildSpendingTransaction(scriptSig, wit, creditTx)};
-
-    DataStream stream;
-    stream << TX_WITH_WITNESS(spendTx);
-
-    bitcoinconsensus_error err;
-    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), UCharCast(stream.data()), stream.size(), nIn, libconsensus_flags, &err);
-    BOOST_CHECK_EQUAL(result, 1);
-    BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_OK);
-}
-
-/* Test bitcoinconsensus_verify_script returns invalid tx index err*/
-BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_tx_index_err)
-{
-    unsigned int libconsensus_flags = 0;
-    int nIn = 3;
-
-    CScript scriptPubKey;
-    CScript scriptSig;
-    CScriptWitness wit;
-
-    scriptPubKey << OP_EQUAL;
-    CTransaction creditTx{BuildCreditingTransaction(scriptPubKey, 1)};
-    CTransaction spendTx{BuildSpendingTransaction(scriptSig, wit, creditTx)};
-
-    DataStream stream;
-    stream << TX_WITH_WITNESS(spendTx);
-
-    bitcoinconsensus_error err;
-    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), UCharCast(stream.data()), stream.size(), nIn, libconsensus_flags, &err);
-    BOOST_CHECK_EQUAL(result, 0);
-    BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_TX_INDEX);
-}
-
-/* Test bitcoinconsensus_verify_script returns tx size mismatch err*/
-BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_tx_size)
-{
-    unsigned int libconsensus_flags = 0;
-    int nIn = 0;
-
-    CScript scriptPubKey;
-    CScript scriptSig;
-    CScriptWitness wit;
-
-    scriptPubKey << OP_EQUAL;
-    CTransaction creditTx{BuildCreditingTransaction(scriptPubKey, 1)};
-    CTransaction spendTx{BuildSpendingTransaction(scriptSig, wit, creditTx)};
-
-    DataStream stream;
-    stream << TX_WITH_WITNESS(spendTx);
-
-    bitcoinconsensus_error err;
-    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), UCharCast(stream.data()), stream.size() * 2, nIn, libconsensus_flags, &err);
-    BOOST_CHECK_EQUAL(result, 0);
-    BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_TX_SIZE_MISMATCH);
-}
-
-/* Test bitcoinconsensus_verify_script returns invalid tx serialization error */
-BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_tx_serialization)
-{
-    unsigned int libconsensus_flags = 0;
-    int nIn = 0;
-
-    CScript scriptPubKey;
-    CScript scriptSig;
-    CScriptWitness wit;
-
-    scriptPubKey << OP_EQUAL;
-    CTransaction creditTx{BuildCreditingTransaction(scriptPubKey, 1)};
-    CTransaction spendTx{BuildSpendingTransaction(scriptSig, wit, creditTx)};
-
-    DataStream stream;
-    stream << 0xffffffff;
-
-    bitcoinconsensus_error err;
-    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), UCharCast(stream.data()), stream.size(), nIn, libconsensus_flags, &err);
-    BOOST_CHECK_EQUAL(result, 0);
-    BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_TX_DESERIALIZE);
-}
-
-/* Test bitcoinconsensus_verify_script returns amount required error */
-BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_amount_required_err)
-{
-    unsigned int libconsensus_flags = bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS;
-    int nIn = 0;
-
-    CScript scriptPubKey;
-    CScript scriptSig;
-    CScriptWitness wit;
-
-    scriptPubKey << OP_EQUAL;
-    CTransaction creditTx{BuildCreditingTransaction(scriptPubKey, 1)};
-    CTransaction spendTx{BuildSpendingTransaction(scriptSig, wit, creditTx)};
-
-    DataStream stream;
-    stream << TX_WITH_WITNESS(spendTx);
-
-    bitcoinconsensus_error err;
-    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), UCharCast(stream.data()), stream.size(), nIn, libconsensus_flags, &err);
-    BOOST_CHECK_EQUAL(result, 0);
-    BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_AMOUNT_REQUIRED);
-}
-
-/* Test bitcoinconsensus_verify_script returns invalid flags err */
-BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_invalid_flags)
-{
-    unsigned int libconsensus_flags = 1 << 3;
-    int nIn = 0;
-
-    CScript scriptPubKey;
-    CScript scriptSig;
-    CScriptWitness wit;
-
-    scriptPubKey << OP_EQUAL;
-    CTransaction creditTx{BuildCreditingTransaction(scriptPubKey, 1)};
-    CTransaction spendTx{BuildSpendingTransaction(scriptSig, wit, creditTx)};
-
-    DataStream stream;
-    stream << TX_WITH_WITNESS(spendTx);
-
-    bitcoinconsensus_error err;
-    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), UCharCast(stream.data()), stream.size(), nIn, libconsensus_flags, &err);
-    BOOST_CHECK_EQUAL(result, 0);
-    BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_INVALID_FLAGS);
-}
-
-/* Test bitcoinconsensus_verify_script returns spent outputs required err */
-BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_spent_outputs_required_err)
-{
-    unsigned int libconsensus_flags{bitcoinconsensus_SCRIPT_FLAGS_VERIFY_TAPROOT};
-    const int nIn{0};
-
-    CScript scriptPubKey;
-    CScript scriptSig;
-    CScriptWitness wit;
-
-    scriptPubKey << OP_EQUAL;
-    CTransaction creditTx{BuildCreditingTransaction(scriptPubKey, 1)};
-    CTransaction spendTx{BuildSpendingTransaction(scriptSig, wit, creditTx)};
-
-    DataStream stream;
-    stream << TX_WITH_WITNESS(spendTx);
-
-    bitcoinconsensus_error err;
-    int result{bitcoinconsensus_verify_script_with_spent_outputs(scriptPubKey.data(), scriptPubKey.size(), creditTx.vout[0].nValue, UCharCast(stream.data()), stream.size(), nullptr, 0, nIn, libconsensus_flags, &err)};
-    BOOST_CHECK_EQUAL(result, 0);
-    BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_SPENT_OUTPUTS_REQUIRED);
-
-    result = bitcoinconsensus_verify_script_with_amount(scriptPubKey.data(), scriptPubKey.size(), creditTx.vout[0].nValue, UCharCast(stream.data()), stream.size(), nIn, libconsensus_flags, &err);
-    BOOST_CHECK_EQUAL(result, 0);
-    BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_SPENT_OUTPUTS_REQUIRED);
-
-    result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), UCharCast(stream.data()), stream.size(), nIn, libconsensus_flags, &err);
-    BOOST_CHECK_EQUAL(result, 0);
-    BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_SPENT_OUTPUTS_REQUIRED);
-}
-
-#endif // defined(HAVE_CONSENSUS_LIB)
-
 static std::vector<unsigned int> AllConsensusFlags()
 {
     std::vector<unsigned int> ret;
@@ -2015,28 +1558,12 @@ static void AssetTest(const UniValue& test, SignatureCache& signature_cache)
         txdata.Init(tx, std::vector<CTxOut>(prevouts));
         CachingTransactionSignatureChecker txcheck(&tx, idx, prevouts[idx].nValue, true, signature_cache, txdata);
 
-#if defined(HAVE_CONSENSUS_LIB)
-        DataStream stream;
-        stream << TX_WITH_WITNESS(tx);
-        std::vector<UTXO> utxos;
-        utxos.resize(prevouts.size());
-        for (size_t i = 0; i < prevouts.size(); i++) {
-            utxos[i].scriptPubKey = prevouts[i].scriptPubKey.data();
-            utxos[i].scriptPubKeySize = prevouts[i].scriptPubKey.size();
-            utxos[i].value = prevouts[i].nValue;
-        }
-#endif
-
         for (const auto flags : ALL_CONSENSUS_FLAGS) {
             // "final": true tests are valid for all flags. Others are only valid with flags that are
             // a subset of test_flags.
             if (fin || ((flags & test_flags) == flags)) {
                 bool ret = VerifyScript(tx.vin[idx].scriptSig, prevouts[idx].scriptPubKey, &tx.vin[idx].scriptWitness, flags, txcheck, nullptr);
                 BOOST_CHECK(ret);
-#if defined(HAVE_CONSENSUS_LIB)
-                int lib_ret = bitcoinconsensus_verify_script_with_spent_outputs(prevouts[idx].scriptPubKey.data(), prevouts[idx].scriptPubKey.size(), prevouts[idx].nValue, UCharCast(stream.data()), stream.size(), utxos.data(), utxos.size(), idx, flags, nullptr);
-                BOOST_CHECK(lib_ret == 1);
-#endif
             }
         }
     }
@@ -2049,27 +1576,11 @@ static void AssetTest(const UniValue& test, SignatureCache& signature_cache)
         txdata.Init(tx, std::vector<CTxOut>(prevouts));
         CachingTransactionSignatureChecker txcheck(&tx, idx, prevouts[idx].nValue, true, signature_cache, txdata);
 
-#if defined(HAVE_CONSENSUS_LIB)
-        DataStream stream;
-        stream << TX_WITH_WITNESS(tx);
-        std::vector<UTXO> utxos;
-        utxos.resize(prevouts.size());
-        for (size_t i = 0; i < prevouts.size(); i++) {
-            utxos[i].scriptPubKey = prevouts[i].scriptPubKey.data();
-            utxos[i].scriptPubKeySize = prevouts[i].scriptPubKey.size();
-            utxos[i].value = prevouts[i].nValue;
-        }
-#endif
-
         for (const auto flags : ALL_CONSENSUS_FLAGS) {
             // If a test is supposed to fail with test_flags, it should also fail with any superset thereof.
             if ((flags & test_flags) == test_flags) {
                 bool ret = VerifyScript(tx.vin[idx].scriptSig, prevouts[idx].scriptPubKey, &tx.vin[idx].scriptWitness, flags, txcheck, nullptr);
                 BOOST_CHECK(!ret);
-#if defined(HAVE_CONSENSUS_LIB)
-                int lib_ret = bitcoinconsensus_verify_script_with_spent_outputs(prevouts[idx].scriptPubKey.data(), prevouts[idx].scriptPubKey.size(), prevouts[idx].nValue, UCharCast(stream.data()), stream.size(), utxos.data(), utxos.size(), idx, flags, nullptr);
-                BOOST_CHECK(lib_ret == 0);
-#endif
             }
         }
     }
diff --git a/src/test/streams_tests.cpp b/src/test/streams_tests.cpp
index 69a9c364ac..3545373754 100644
--- a/src/test/streams_tests.cpp
+++ b/src/test/streams_tests.cpp
@@ -37,7 +37,6 @@ BOOST_AUTO_TEST_CASE(xor_file)
 #endif
         AutoFile xor_file{raw_file(mode), xor_pat};
         xor_file << test1 << test2;
-        BOOST_REQUIRE_EQUAL(xor_file.fclose(), 0);
     }
     {
         // Read raw from disk
@@ -378,8 +377,8 @@ BOOST_AUTO_TEST_CASE(streams_buffered_file)
     // by the rewind window (relative to our farthest read position, 40).
     BOOST_CHECK(bf.GetPos() <= 30U);
 
-    // Explicitly close the file and check that the close succeeds.
-    BOOST_REQUIRE_EQUAL(file.fclose(), 0);
+    // We can explicitly close the file, or the destructor will do it.
+    file.fclose();
 
     fs::remove(streams_test_filename);
 }
@@ -429,7 +428,7 @@ BOOST_AUTO_TEST_CASE(streams_buffered_file_skip)
     bf.SkipTo(13);
     BOOST_CHECK_EQUAL(bf.GetPos(), 13U);
 
-    BOOST_REQUIRE_EQUAL(file.fclose(), 0);
+    file.fclose();
     fs::remove(streams_test_filename);
 }
 
@@ -550,7 +549,6 @@ BOOST_AUTO_TEST_CASE(streams_buffered_file_rand)
             if (maxPos < currentPos)
                 maxPos = currentPos;
         }
-        BOOST_REQUIRE_EQUAL(file.fclose(), 0);
     }
     fs::remove(streams_test_filename);
 }
diff --git a/src/test/system_tests.cpp b/src/test/system_tests.cpp
index ee1c6a2790..c9dd9c82cd 100644
--- a/src/test/system_tests.cpp
+++ b/src/test/system_tests.cpp
@@ -32,11 +32,7 @@ BOOST_AUTO_TEST_CASE(run_command)
         BOOST_CHECK(result.isNull());
     }
     {
-#ifdef WIN32
-        const UniValue result = RunCommandParseJSON("cmd.exe /c echo {\"success\": true}");
-#else
         const UniValue result = RunCommandParseJSON("echo {\"success\": true}");
-#endif
         BOOST_CHECK(result.isObject());
         const UniValue& success = result.find_value("success");
         BOOST_CHECK(!success.isNull());
@@ -44,20 +40,12 @@ BOOST_AUTO_TEST_CASE(run_command)
     }
     {
         // An invalid command is handled by cpp-subprocess
-#ifdef WIN32
-        const std::string expected{"CreateProcess failed: "};
-#else
         const std::string expected{"execve failed: "};
-#endif
         BOOST_CHECK_EXCEPTION(RunCommandParseJSON("invalid_command"), subprocess::CalledProcessError, HasReason(expected));
     }
     {
         // Return non-zero exit code, no output to stderr
-#ifdef WIN32
-        const std::string command{"cmd.exe /c exit 1"};
-#else
         const std::string command{"false"};
-#endif
         BOOST_CHECK_EXCEPTION(RunCommandParseJSON(command), std::runtime_error, [&](const std::runtime_error& e) {
             const std::string what{e.what()};
             BOOST_CHECK(what.find(strprintf("RunCommandParseJSON error: process(%s) returned 1: \n", command)) != std::string::npos);
@@ -66,11 +54,7 @@ BOOST_AUTO_TEST_CASE(run_command)
     }
     {
         // Return non-zero exit code, with error message for stderr
-#ifdef WIN32
-        const std::string command{"cmd.exe /c \"echo err 1>&2 && exit 1\""};
-#else
         const std::string command{"sh -c 'echo err 1>&2 && false'"};
-#endif
         const std::string expected{"err"};
         BOOST_CHECK_EXCEPTION(RunCommandParseJSON(command), std::runtime_error, [&](const std::runtime_error& e) {
             const std::string what(e.what());
@@ -81,14 +65,9 @@ BOOST_AUTO_TEST_CASE(run_command)
     }
     {
         // Unable to parse JSON
-#ifdef WIN32
-        const std::string command{"cmd.exe /c echo {"};
-#else
         const std::string command{"echo {"};
-#endif
         BOOST_CHECK_EXCEPTION(RunCommandParseJSON(command), std::runtime_error, HasReason("Unable to parse JSON: {"));
     }
-#ifndef WIN32
     // Test std::in
     {
         const UniValue result = RunCommandParseJSON("cat", "{\"success\": true}");
@@ -97,7 +76,6 @@ BOOST_AUTO_TEST_CASE(run_command)
         BOOST_CHECK(!success.isNull());
         BOOST_CHECK_EQUAL(success.get_bool(), true);
     }
-#endif
 }
 #endif // ENABLE_EXTERNAL_SIGNER
 
diff --git a/src/test/transaction_tests.cpp b/src/test/transaction_tests.cpp
index d45f911e95..5622632e97 100644
--- a/src/test/transaction_tests.cpp
+++ b/src/test/transaction_tests.cpp
@@ -12,7 +12,6 @@
 #include <consensus/tx_check.h>
 #include <consensus/validation.h>
 #include <core_io.h>
-#include <kernel/mempool_options.h>
 #include <key.h>
 #include <policy/policy.h>
 #include <policy/settings.h>
@@ -45,7 +44,8 @@ using util::ToString;
 
 typedef std::vector<unsigned char> valtype;
 
-static kernel::MemPoolOptions g_mempool_opts;
+static CFeeRate g_dust{DUST_RELAY_TX_FEE};
+static bool g_bare_multi{DEFAULT_PERMIT_BAREMULTISIG};
 
 static std::map<std::string, unsigned int> mapFlagNames = {
     {std::string("P2SH"), (unsigned int)SCRIPT_VERIFY_P2SH},
@@ -796,23 +796,21 @@ BOOST_AUTO_TEST_CASE(test_IsStandard)
     CKey key = GenerateRandomKey();
     t.vout[0].scriptPubKey = GetScriptForDestination(PKHash(key.GetPubKey()));
 
-    g_mempool_opts.permit_bare_pubkey = true;
-
     constexpr auto CheckIsStandard = [](const auto& t) {
         std::string reason;
-        BOOST_CHECK(IsStandardTx(CTransaction{t}, g_mempool_opts, reason));
+        BOOST_CHECK(IsStandardTx(CTransaction{t}, MAX_OP_RETURN_RELAY, g_bare_multi, g_dust, reason));
         BOOST_CHECK(reason.empty());
     };
     constexpr auto CheckIsNotStandard = [](const auto& t, const std::string& reason_in) {
         std::string reason;
-        BOOST_CHECK(!IsStandardTx(CTransaction{t}, g_mempool_opts, reason));
+        BOOST_CHECK(!IsStandardTx(CTransaction{t}, MAX_OP_RETURN_RELAY, g_bare_multi, g_dust, reason));
         BOOST_CHECK_EQUAL(reason_in, reason);
     };
 
     CheckIsStandard(t);
 
     // Check dust with default relay fee:
-    CAmount nDustThreshold = 182 * g_mempool_opts.dust_relay_feerate.GetFeePerK() / 1000;
+    CAmount nDustThreshold = 182 * g_dust.GetFeePerK() / 1000;
     BOOST_CHECK_EQUAL(nDustThreshold, 546);
     // dust:
     t.vout[0].nValue = nDustThreshold - 1;
@@ -840,50 +838,25 @@ BOOST_AUTO_TEST_CASE(test_IsStandard)
 
     // Check dust with odd relay fee to verify rounding:
     // nDustThreshold = 182 * 3702 / 1000
-    g_mempool_opts.dust_relay_feerate = CFeeRate(3702);
+    g_dust = CFeeRate(3702);
     // dust:
     t.vout[0].nValue = 674 - 1;
     CheckIsNotStandard(t, "dust");
     // not dust:
     t.vout[0].nValue = 674;
     CheckIsStandard(t);
-    g_mempool_opts.dust_relay_feerate = CFeeRate{DUST_RELAY_TX_FEE};
+    g_dust = CFeeRate{DUST_RELAY_TX_FEE};
 
     t.vout[0].scriptPubKey = CScript() << OP_1;
     CheckIsNotStandard(t, "scriptpubkey");
 
-    // Test rejectparasites
-    t.vout[0].scriptPubKey = CScript() << OP_RETURN;
-    t.nLockTime = 21;
-    g_mempool_opts.reject_parasites = false;
-    CheckIsStandard(t);
-    g_mempool_opts.reject_parasites = true;
-    CheckIsNotStandard(t, "parasite-cat21");
-    t.nLockTime = 0;
-    CheckIsStandard(t);
-    g_mempool_opts.reject_parasites = false;
-
-    // Test rejecttokens
-    t.vout[0].scriptPubKey = CScript() << OP_RETURN << OP_13 << OP_FALSE;
-    g_mempool_opts.reject_tokens = false;
-    CheckIsStandard(t);
-    g_mempool_opts.reject_tokens = true;
-    CheckIsNotStandard(t, "tokens-runes");
-    // At least one data push is needed after OP_13 to match
-    t.vout[0].scriptPubKey = CScript() << OP_RETURN << OP_13;
-    CheckIsStandard(t);
-    g_mempool_opts.reject_tokens = false;
-
     // MAX_OP_RETURN_RELAY-byte TxoutType::NULL_DATA (standard)
-    t.vout[0].scriptPubKey = CScript() << OP_RETURN;
-    while (t.vout[0].scriptPubKey.size() < MAX_OP_RETURN_RELAY) {
-        t.vout[0].scriptPubKey << OP_0;
-    }
+    t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex("04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3804678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38");
     BOOST_CHECK_EQUAL(MAX_OP_RETURN_RELAY, t.vout[0].scriptPubKey.size());
     CheckIsStandard(t);
 
     // MAX_OP_RETURN_RELAY+1-byte TxoutType::NULL_DATA (non-standard)
-    t.vout[0].scriptPubKey << OP_0;
+    t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex("04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3804678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3800");
     BOOST_CHECK_EQUAL(MAX_OP_RETURN_RELAY + 1, t.vout[0].scriptPubKey.size());
     CheckIsNotStandard(t, "scriptpubkey");
 
@@ -985,15 +958,15 @@ BOOST_AUTO_TEST_CASE(test_IsStandard)
     CheckIsNotStandard(t, "tx-size");
 
     // Check bare multisig (standard if policy flag g_bare_multi is set)
-    g_mempool_opts.permit_bare_multisig = true;
+    g_bare_multi = true;
     t.vout[0].scriptPubKey = GetScriptForMultisig(1, {key.GetPubKey()}); // simple 1-of-1
     t.vin.resize(1);
     t.vin[0].scriptSig = CScript() << std::vector<unsigned char>(65, 0);
     CheckIsStandard(t);
 
-    g_mempool_opts.permit_bare_multisig = false;
+    g_bare_multi = false;
     CheckIsNotStandard(t, "bare-multisig");
-    g_mempool_opts.permit_bare_multisig = DEFAULT_PERMIT_BAREMULTISIG;
+    g_bare_multi = DEFAULT_PERMIT_BAREMULTISIG;
 
     // Check compressed P2PK outputs dust threshold (must have leading 02 or 03)
     t.vout[0].scriptPubKey = CScript() << std::vector<unsigned char>(33, 0x02) << OP_CHECKSIG;
diff --git a/src/test/txpackage_tests.cpp b/src/test/txpackage_tests.cpp
index 17588fb7bd..ca9dc5527d 100644
--- a/src/test/txpackage_tests.cpp
+++ b/src/test/txpackage_tests.cpp
@@ -426,7 +426,7 @@ BOOST_FIXTURE_TEST_CASE(package_submission_tests, TestChain100Setup)
             auto it_parent = result_quit_early.m_tx_results.find(tx_parent_invalid->GetWitnessHash());
             auto it_child = result_quit_early.m_tx_results.find(tx_child->GetWitnessHash());
             BOOST_CHECK_EQUAL(it_parent->second.m_state.GetResult(), TxValidationResult::TX_WITNESS_MUTATED);
-            BOOST_CHECK_EQUAL(it_parent->second.m_state.GetRejectReason(), "bad-witness-nonwitness-input");
+            BOOST_CHECK_EQUAL(it_parent->second.m_state.GetRejectReason(), "bad-witness-nonstandard");
             BOOST_CHECK_EQUAL(it_child->second.m_state.GetResult(), TxValidationResult::TX_MISSING_INPUTS);
             BOOST_CHECK_EQUAL(it_child->second.m_state.GetRejectReason(), "bad-txns-inputs-missingorspent");
         }
diff --git a/src/test/txvalidation_tests.cpp b/src/test/txvalidation_tests.cpp
index 45c1275b5f..97b27ef370 100644
--- a/src/test/txvalidation_tests.cpp
+++ b/src/test/txvalidation_tests.cpp
@@ -11,7 +11,6 @@
 #include <random.h>
 #include <script/script.h>
 #include <test/util/setup_common.h>
-#include <test/util/transaction_utils.h>
 #include <test/util/txmempool.h>
 #include <validation.h>
 
@@ -20,18 +19,6 @@
 
 BOOST_AUTO_TEST_SUITE(txvalidation_tests)
 
-std::optional<std::pair<std::string, CTransactionRef>> SingleTRUCChecks(const CTransactionRef& ptx, const CTxMemPool::setEntries& mempool_ancestors, const std::set<Txid>& direct_conflicts, int64_t vsize)
-{
-    std::string dummy;
-    return SingleTRUCChecks(ptx, dummy, dummy, empty_ignore_rejects, mempool_ancestors, direct_conflicts, vsize);
-}
-
-std::optional<std::string> PackageTRUCChecks(const CTransactionRef& ptx, int64_t vsize, const Package& package, const CTxMemPool::setEntries& mempool_ancestors)
-{
-    std::string dummy;
-    return PackageTRUCChecks(ptx, vsize, dummy, dummy, empty_ignore_rejects, package, mempool_ancestors);
-}
-
 /**
  * Ensure that the mempool won't accept coinbase transactions.
  */
diff --git a/src/test/txvalidationcache_tests.cpp b/src/test/txvalidationcache_tests.cpp
index d22b815fcd..af36a95693 100644
--- a/src/test/txvalidationcache_tests.cpp
+++ b/src/test/txvalidationcache_tests.cpp
@@ -54,7 +54,7 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, Dersig100Setup)
         spends[i].vin[0].prevout.n = 0;
         spends[i].vout.resize(1);
         spends[i].vout[0].nValue = 11*CENT;
-        spends[i].vout[0].scriptPubKey = GetScriptForDestination(PKHash(coinbaseKey.GetPubKey()));
+        spends[i].vout[0].scriptPubKey = scriptPubKey;
 
         // Sign:
         std::vector<unsigned char> vchSig;
diff --git a/src/test/util/chainstate.h b/src/test/util/chainstate.h
index 52e20c711d..e604b44c16 100644
--- a/src/test/util/chainstate.h
+++ b/src/test/util/chainstate.h
@@ -48,7 +48,6 @@ CreateAndActivateUTXOSnapshot(
     AutoFile auto_outfile{outfile};
 
     UniValue result = CreateUTXOSnapshot(
-        false, false, Span<std::byte>(), {},
         node, node.chainman->ActiveChainstate(), auto_outfile, snapshot_path, snapshot_path);
     LogPrintf(
         "Wrote UTXO snapshot to %s: %s\n", fs::PathToString(snapshot_path.make_preferred()), result.write());
diff --git a/src/test/util/mining.cpp b/src/test/util/mining.cpp
index 5152f2d6cc..ad7a38d3fe 100644
--- a/src/test/util/mining.cpp
+++ b/src/test/util/mining.cpp
@@ -112,7 +112,7 @@ std::shared_ptr<CBlock> PrepareBlock(const NodeContext& node, const CScript& coi
                                      const BlockAssembler::Options& assembler_options)
 {
     auto block = std::make_shared<CBlock>(
-        BlockAssembler{Assert(node.chainman)->ActiveChainstate(), Assert(node.mempool.get()), assembler_options, node}
+        BlockAssembler{Assert(node.chainman)->ActiveChainstate(), Assert(node.mempool.get()), assembler_options}
             .CreateNewBlock(coinbase_scriptPubKey)
             ->block);
 
diff --git a/src/test/util/setup_common.cpp b/src/test/util/setup_common.cpp
index 364a261ee6..62ff61b227 100644
--- a/src/test/util/setup_common.cpp
+++ b/src/test/util/setup_common.cpp
@@ -30,7 +30,6 @@
 #include <node/peerman_args.h>
 #include <node/warnings.h>
 #include <noui.h>
-#include <policy/coin_age_priority.h>
 #include <policy/fees.h>
 #include <pow.h>
 #include <random.h>
@@ -251,7 +250,6 @@ ChainTestingSetup::ChainTestingSetup(const ChainType chainType, TestOpts opts)
             .chainparams = chainparams,
             .datadir = m_args.GetDataDirNet(),
             .check_block_index = 1,
-            .checkpoints_enabled = false,
             .notifications = *m_node.notifications,
             .signals = m_node.validation_signals.get(),
             .worker_threads_num = 2,
@@ -391,7 +389,7 @@ CBlock TestChain100Setup::CreateBlock(
     Chainstate& chainstate)
 {
     BlockAssembler::Options options;
-    CBlock block = BlockAssembler{chainstate, nullptr, options, m_node}.CreateNewBlock(scriptPubKey)->block;
+    CBlock block = BlockAssembler{chainstate, nullptr, options}.CreateNewBlock(scriptPubKey)->block;
 
     Assert(block.vtx.size() == 1);
     for (const CMutableTransaction& tx : txns) {
@@ -522,8 +520,6 @@ CMutableTransaction TestChain100Setup::CreateValidMempoolTransaction(CTransactio
 
 std::vector<CTransactionRef> TestChain100Setup::PopulateMempool(FastRandomContext& det_rand, size_t num_transactions, bool submit)
 {
-    auto& active_chainstate = m_node.chainman->ActiveChainstate();
-    const auto height = active_chainstate.m_chain.Height();
     std::vector<CTransactionRef> mempool_transactions;
     std::deque<std::pair<COutPoint, CAmount>> unspent_prevouts;
     std::transform(m_coinbase_txns.begin(), m_coinbase_txns.end(), std::back_inserter(unspent_prevouts),
@@ -561,13 +557,9 @@ std::vector<CTransactionRef> TestChain100Setup::PopulateMempool(FastRandomContex
         if (submit) {
             LOCK2(cs_main, m_node.mempool->cs);
             LockPoints lp;
-            CAmount in_chain_input_value;
-            const double coin_age = GetCoinAge(*ptx, active_chainstate.CoinsTip(), height + 1, in_chain_input_value);
             m_node.mempool->addUnchecked(CTxMemPoolEntry(ptx, /*fee=*/(total_in - num_outputs * amount_per_output),
-                                                         /*time=*/0, /*entry_height=*/ height, /*entry_sequence=*/0,
-                                                         /*entry_tx_inputs_coin_age=*/coin_age,
-                                                         in_chain_input_value,
-                                                         /*spends_coinbase=*/false, /*extra_weight=*/0, /*sigops_cost=*/4, lp));
+                                                         /*time=*/0, /*entry_height=*/1, /*entry_sequence=*/0,
+                                                         /*spends_coinbase=*/false, /*sigops_cost=*/4, lp));
         }
         --num_transactions;
     }
@@ -597,9 +589,7 @@ void TestChain100Setup::MockMempoolMinFee(const CFeeRate& target_feerate)
         m_node.mempool->m_opts.incremental_relay_feerate.GetFee(GetVirtualTransactionSize(*tx));
     m_node.mempool->addUnchecked(CTxMemPoolEntry(tx, /*fee=*/tx_fee,
                                                  /*time=*/0, /*entry_height=*/1, /*entry_sequence=*/0,
-                                                 /*entry_tx_inputs_coin_age=*/0.0,
-                                                 /*in_chain_input_value=*/0,
-                                                 /*spends_coinbase=*/true, /*extra_weight=*/0, /*sigops_cost=*/1, lp));
+                                                 /*spends_coinbase=*/true, /*sigops_cost=*/1, lp));
     m_node.mempool->TrimToSize(0);
     assert(m_node.mempool->GetMinFee() == target_feerate);
 }
diff --git a/src/test/util/txmempool.cpp b/src/test/util/txmempool.cpp
index 989a57ad17..9d6b4810d0 100644
--- a/src/test/util/txmempool.cpp
+++ b/src/test/util/txmempool.cpp
@@ -23,7 +23,6 @@ CTxMemPool::Options MemPoolOptionsForTest(const NodeContext& node)
         // Default to always checking mempool regardless of
         // chainparams.DefaultConsistencyChecks for tests
         .check_ratio = 1,
-        .truc_policy = TRUCPolicy::Enforce,
         .signals = node.validation_signals.get(),
     };
     const auto result{ApplyArgsManOptions(*node.args, ::Params(), mempool_opts)};
@@ -38,9 +37,7 @@ CTxMemPoolEntry TestMemPoolEntryHelper::FromTx(const CMutableTransaction& tx) co
 
 CTxMemPoolEntry TestMemPoolEntryHelper::FromTx(const CTransactionRef& tx) const
 {
-    constexpr double coin_age{0};
-    const CAmount inChainValue = 0;
-    return CTxMemPoolEntry{tx, nFee, TicksSinceEpoch<std::chrono::seconds>(time), nHeight, m_sequence, /*entry_tx_inputs_coin_age=*/coin_age, inChainValue, spendsCoinbase, /*extra_weight=*/0, sigOpCost, lp};
+    return CTxMemPoolEntry{tx, nFee, TicksSinceEpoch<std::chrono::seconds>(time), nHeight, m_sequence, spendsCoinbase, sigOpCost, lp};
 }
 
 std::optional<std::string> CheckPackageMempoolAcceptResult(const Package& txns,
diff --git a/src/test/util_tests.cpp b/src/test/util_tests.cpp
index 62f350fcd6..bf1fc1ea0a 100644
--- a/src/test/util_tests.cpp
+++ b/src/test/util_tests.cpp
@@ -1,4 +1,4 @@
-// Copyright (c) 2011-present The Bitcoin Core developers
+// Copyright (c) 2011-2022 The Bitcoin Core developers
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
@@ -6,8 +6,6 @@
 #include <common/signmessage.h> // For MessageSign(), MessageVerify(), MESSAGE_MAGIC
 #include <hash.h> // For Hash()
 #include <key.h>  // For CKey
-#include <key_io.h> // EncodeDestination
-#include <outputtype.h> // For BIP-322 tests
 #include <script/parsing.h>
 #include <sync.h>
 #include <test/util/random.h>
@@ -299,56 +297,12 @@ BOOST_AUTO_TEST_CASE(util_TrimString)
     BOOST_CHECK_EQUAL(TrimStringView(std::string("\x05\x04\x03\x02\x01\x00", 6), std::string("\x05\x04\x03\x02\x01\x00", 6)), "");
 }
 
-BOOST_AUTO_TEST_CASE(util_ParseISO8601DateTime)
-{
-    BOOST_CHECK_EQUAL(ParseISO8601DateTime("1969-12-31T23:59:59Z").value(), -1);
-    BOOST_CHECK_EQUAL(ParseISO8601DateTime("1970-01-01T00:00:00Z").value(), 0);
-    BOOST_CHECK_EQUAL(ParseISO8601DateTime("1970-01-01T00:00:01Z").value(), 1);
-    BOOST_CHECK_EQUAL(ParseISO8601DateTime("2000-01-01T00:00:01Z").value(), 946684801);
-    BOOST_CHECK_EQUAL(ParseISO8601DateTime("2011-09-30T23:36:17Z").value(), 1317425777);
-    BOOST_CHECK_EQUAL(ParseISO8601DateTime("2100-12-31T23:59:59Z").value(), 4133980799);
-    BOOST_CHECK_EQUAL(ParseISO8601DateTime("9999-12-31T23:59:59Z").value(), 253402300799);
-
-    // Accept edge-cases, where the time overflows. They are not produced by
-    // FormatISO8601DateTime, so this can be changed in the future, if needed.
-    // For now, keep compatibility with the previous implementation.
-    BOOST_CHECK_EQUAL(ParseISO8601DateTime("2000-01-01T99:00:00Z").value(), 947041200);
-    BOOST_CHECK_EQUAL(ParseISO8601DateTime("2000-01-01T00:99:00Z").value(), 946690740);
-    BOOST_CHECK_EQUAL(ParseISO8601DateTime("2000-01-01T00:00:99Z").value(), 946684899);
-    BOOST_CHECK_EQUAL(ParseISO8601DateTime("2000-01-01T99:99:99Z").value(), 947047239);
-
-    // Reject date overflows.
-    BOOST_CHECK(!ParseISO8601DateTime("2000-99-01T00:00:00Z"));
-    BOOST_CHECK(!ParseISO8601DateTime("2000-01-99T00:00:00Z"));
-
-    // Reject out-of-range years
-    BOOST_CHECK(!ParseISO8601DateTime("32768-12-31T23:59:59Z"));
-    BOOST_CHECK(!ParseISO8601DateTime("32767-12-31T23:59:59Z"));
-    BOOST_CHECK(!ParseISO8601DateTime("32767-12-31T00:00:00Z"));
-    BOOST_CHECK(!ParseISO8601DateTime("999-12-31T00:00:00Z"));
-
-    // Reject invalid format
-    const std::string valid{"2000-01-01T00:00:01Z"};
-    BOOST_CHECK(ParseISO8601DateTime(valid).has_value());
-    for (auto mut{0U}; mut < valid.size(); ++mut) {
-        std::string invalid{valid};
-        invalid[mut] = 'a';
-        BOOST_CHECK(!ParseISO8601DateTime(invalid));
-    }
-}
-
 BOOST_AUTO_TEST_CASE(util_FormatISO8601DateTime)
 {
     BOOST_CHECK_EQUAL(FormatISO8601DateTime(971890963199), "32767-12-31T23:59:59Z");
     BOOST_CHECK_EQUAL(FormatISO8601DateTime(971890876800), "32767-12-31T00:00:00Z");
     BOOST_CHECK_EQUAL(FormatISO8601DateTime(1317425777), "2011-09-30T23:36:17Z");
-
-    BOOST_CHECK_EQUAL(FormatISO8601DateTime(-1), "1969-12-31T23:59:59Z");
     BOOST_CHECK_EQUAL(FormatISO8601DateTime(0), "1970-01-01T00:00:00Z");
-    BOOST_CHECK_EQUAL(FormatISO8601DateTime(1), "1970-01-01T00:00:01Z");
-    BOOST_CHECK_EQUAL(FormatISO8601DateTime(946684801), "2000-01-01T00:00:01Z");
-    BOOST_CHECK_EQUAL(FormatISO8601DateTime(4133980799), "2100-12-31T23:59:59Z");
-    BOOST_CHECK_EQUAL(FormatISO8601DateTime(253402300799), "9999-12-31T23:59:59Z");
 }
 
 BOOST_AUTO_TEST_CASE(util_FormatISO8601Date)
@@ -1086,9 +1040,9 @@ BOOST_AUTO_TEST_CASE(test_FormatSubVersion)
     std::vector<std::string> comments2;
     comments2.emplace_back("comment1");
     comments2.push_back(SanitizeString(std::string("Comment2; .,_?@-; !\"#$%&'()*+/<=>[]\\^`{|}~"), SAFE_CHARS_UA_COMMENT)); // Semicolon is discouraged but not forbidden by BIP-0014
-    BOOST_CHECK_EQUAL(FormatSubVersion("Test", 99900, std::vector<std::string>(), true),std::string("/Test:9.99.0/"));
-    BOOST_CHECK_EQUAL(FormatSubVersion("Test", 99900, comments, true),std::string("/Test:9.99.0(comment1)/"));
-    BOOST_CHECK_EQUAL(FormatSubVersion("Test", 99900, comments2, true),std::string("/Test:9.99.0(comment1; Comment2; .,_?@-; )/"));
+    BOOST_CHECK_EQUAL(FormatSubVersion("Test", 99900, std::vector<std::string>()),std::string("/Test:9.99.0/"));
+    BOOST_CHECK_EQUAL(FormatSubVersion("Test", 99900, comments),std::string("/Test:9.99.0(comment1)/"));
+    BOOST_CHECK_EQUAL(FormatSubVersion("Test", 99900, comments2),std::string("/Test:9.99.0(comment1; Comment2; .,_?@-; )/"));
 }
 
 BOOST_AUTO_TEST_CASE(test_ParseFixedPoint)
@@ -1675,38 +1629,6 @@ BOOST_AUTO_TEST_CASE(message_sign)
         "Sign with a valid private key");
 
     BOOST_CHECK_EQUAL(expected_signature, generated_signature);
-
-    // BIP-322 tests
-    // (no signing done here, as we need a wallet to do so)
-
-    auto pubkey = privkey.GetPubKey();
-    MessageVerificationResult mvr{MessageVerificationResult::OK};
-
-    // LEGACY pubkey type
-    auto dest_legacy = GetDestinationForKey(pubkey, OutputType::LEGACY);
-    BOOST_CHECK_EQUAL("15CRxFdyRpGZLW9w8HnHvVduizdL5jKNbs", EncodeDestination(dest_legacy));
-    auto txs_legacy = BIP322Txs::Create(dest_legacy, message, mvr);
-    if (!txs_legacy || mvr != MessageVerificationResult::OK) {
-        BOOST_FAIL("Failed to create BIP-322 txs for legacy address");
-    }
-
-    // P2SH_SEGWIT pubkey type
-    auto dest_p2sh_segwit = GetDestinationForKey(pubkey, OutputType::P2SH_SEGWIT);
-    BOOST_CHECK_EQUAL("35uijJkf4rcCnGzEZsn12YJenTHToDKpr2", EncodeDestination(dest_p2sh_segwit));
-    auto txs_p2sh_segwit = BIP322Txs::Create(dest_p2sh_segwit, message, mvr);
-    if (!txs_p2sh_segwit || mvr != MessageVerificationResult::OK) {
-        BOOST_FAIL("Failed to create BIP-322 txs for p2sh-segwit address");
-    }
-
-    // BECH32
-    auto dest_bech32 = GetDestinationForKey(pubkey, OutputType::BECH32);
-    BOOST_CHECK_EQUAL("bc1q9cy7s7nmzah0m6mt2ftmu6x723esjxqkkl4wsw", EncodeDestination(dest_bech32));
-    auto txs_bech32 = BIP322Txs::Create(dest_bech32, message, mvr);
-    if (!txs_bech32 || mvr != MessageVerificationResult::OK) {
-        BOOST_FAIL("Failed to create BIP-322 txs for bech32 address");
-    }
-
-    // TODO: BECH32M
 }
 
 BOOST_AUTO_TEST_CASE(message_verify)
@@ -1714,16 +1636,16 @@ BOOST_AUTO_TEST_CASE(message_verify)
     BOOST_CHECK_EQUAL(
         MessageVerify(
             "invalid address",
-            "AA==",
+            "signature should be irrelevant",
             "message too"),
         MessageVerificationResult::ERR_INVALID_ADDRESS);
 
     BOOST_CHECK_EQUAL(
         MessageVerify(
             "3B5fQsEXEaV8v6U3ejYc8XaKXAkyQj2MjV",
-            "AA==",
+            "signature should be irrelevant",
             "message too"),
-        MessageVerificationResult::ERR_INVALID /* ERR_ADDRESS_NO_KEY */);
+        MessageVerificationResult::ERR_ADDRESS_NO_KEY);
 
     BOOST_CHECK_EQUAL(
         MessageVerify(
@@ -1737,7 +1659,7 @@ BOOST_AUTO_TEST_CASE(message_verify)
             "1KqbBpLy5FARmTPD4VZnDDpYjkUvkr82Pm",
             "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",
             "message should be irrelevant"),
-        MessageVerificationResult::ERR_INVALID /* ERR_PUBKEY_NOT_RECOVERED */);
+        MessageVerificationResult::ERR_PUBKEY_NOT_RECOVERED);
 
     BOOST_CHECK_EQUAL(
         MessageVerify(
@@ -1759,124 +1681,6 @@ BOOST_AUTO_TEST_CASE(message_verify)
             "IIcaIENoYW5jZWxsb3Igb24gYnJpbmsgb2Ygc2Vjb25kIGJhaWxvdXQgZm9yIGJhbmtzIAaHRtbCeDZINyavx14=",
             "Trust me"),
         MessageVerificationResult::OK);
-
-    // BIP-322 tests
-
-    // privkey: L3VFeEujGtevx9w18HD1fhRbCH67Az2dpCymeRE1SoPK6XQtaN2k
-
-    BOOST_CHECK_EQUAL(
-        MessageVerify(
-            "bc1q9vza2e8x573nczrlzms0wvx3gsqjx7vavgkx0l",
-            "AkcwRAIgM2gBAQqvZX15ZiysmKmQpDrG83avLIT492QBzLnQIxYCIBaTpOaD20qRlEylyxFSeEA2ba9YOixpX8z46TSDtS40ASECx/EgAxlkQpQ9hYjgGu6EBCPMVPwVIVJqO4XCsMvViHI=",
-            ""),
-        MessageVerificationResult::OK);
-
-    BOOST_CHECK_EQUAL(
-        MessageVerify(
-            "bc1q9vza2e8x573nczrlzms0wvx3gsqjx7vavgkx0l",
-            "AkcwRAIgZRfIY3p7/DoVTty6YZbWS71bc5Vct9p9Fia83eRmw2QCICK/ENGfwLtptFluMGs2KsqoNSk89pO7F29zJLUx9a/sASECx/EgAxlkQpQ9hYjgGu6EBCPMVPwVIVJqO4XCsMvViHI=",
-            "Hello World"),
-        MessageVerificationResult::OK);
-
-    // BIP322 signature created using buidl-python library with same parameters as test on line 2596
-    BOOST_CHECK_EQUAL(
-        MessageVerify(
-            "bc1q9vza2e8x573nczrlzms0wvx3gsqjx7vavgkx0l",
-         "AkgwRQIhAOzyynlqt93lOKJr+wmmxIens//zPzl9tqIOua93wO6MAiBi5n5EyAcPScOjf1lAqIUIQtr3zKNeavYabHyR8eGhowEhAsfxIAMZZEKUPYWI4BruhAQjzFT8FSFSajuFwrDL1Yhy",
-            "Hello World"),
-        MessageVerificationResult::OK);
-
-    // 2-of-3 p2sh multisig BIP322 signature (created with the buidl-python library)
-    // Keys are defined as (HDRootWIF, bip322_path)
-    // Key1 (L4DksdGZ4KQJfcLHD5Dv25fu8Rxyv7hHi2RjZR4TYzr8c6h9VNrp, m/45'/0/0/1)
-    // Key2 (KzSRqnCVwjzY8id2X5oHEJWXkSHwKUYaAXusjwgkES8BuQPJnPNu, m/45'/0/0/3)
-    // Key3 (L1zt9Rw7HrU7jaguMbVzhiX8ffuVkmMis5wLHddXYuHWYf8u8uRj, m/45'/0/0/6)
-    // BIP322 includes signs from Key2 and Key3
-    BOOST_CHECK_EQUAL(
-        MessageVerify(
-            "3LnYoUkFrhyYP3V7rq3mhpwALz1XbCY9Uq",
-         "AAAAAAHNcfHaNfl8f/+ZC2gTr8aF+0KgppYjKM94egaNm/u1ZAAAAAD8AEcwRAIhAJ6hdj61vLDP+aFa30qUZQmrbBfE0kiOObYvt5nqPSxsAh9IrOKFwflfPRUcQ/5e0REkdFHVP2GGdUsMgDet+sNlAUcwRAIgH3eW/VyFDoXvCasd8qxgwj5NDVo0weXvM6qyGXLCR5YCIEwjbEV6fS6RWP6QsKOcMwvlGr1/SgdCC6pW4eH87/YgAUxpUiECKJfGy28imLcuAeNBLHCNv3NRP5jnJwFDNRXCYNY/vJ4hAv1RQtaZs7+vKqQeWl2rb/jd/gMxkEjUnjZdDGPDZkMLIQL65cH2X5O7LujjTLDL2l8Pxy0Y2UUR99u1qCfjdz7dklOuAAAAAAEAAAAAAAAAAAFqAAAAAA==",
-            "This will be a p2sh 2-of-3 multisig BIP 322 signed message"),
-        MessageVerificationResult::OK);
-
-    // 3-of-3 p2wsh multisig BIP322 signature (created with the buidl-python library)
-    // Keys are defined as (HDRootWIF, bip322_path)
-    // Key1 (L4DksdGZ4KQJfcLHD5Dv25fu8Rxyv7hHi2RjZR4TYzr8c6h9VNrp, m/45'/0/0/6)
-    // Key2 (KzSRqnCVwjzY8id2X5oHEJWXkSHwKUYaAXusjwgkES8BuQPJnPNu, m/45'/0/0/9)
-    // Key3 (L1zt9Rw7HrU7jaguMbVzhiX8ffuVkmMis5wLHddXYuHWYf8u8uRj, m/45'/0/0/11)
-    BOOST_CHECK_EQUAL(
-        MessageVerify(
-            "bc1qlqtuzpmazp2xmcutlwv0qvggdvem8vahkc333usey4gskug8nutsz53msw",    "BQBIMEUCIQDQoXvGKLH58exuujBOta+7+GN7vi0lKwiQxzBpuNuXuAIgIE0XYQlFDOfxbegGYYzlf+tqegleAKE6SXYIa1U+uCcBRzBEAiATegywVl6GWrG9jJuPpNwtgHKyVYCX2yfuSSDRFATAaQIgTLlU6reLQsSIrQSF21z3PtUO2yAUseUWGZqRUIE7VKoBSDBFAiEAgxtpidsU0Z4u/+5RB9cyeQtoCW5NcreLJmWXZ8kXCZMCIBR1sXoEinhZE4CF9P9STGIcMvCuZjY6F5F0XTVLj9SjAWlTIQP3dyWvTZjUENWJowMWBsQrrXCUs20Gu5YF79CG5Ga0XSEDwqI5GVBOuFkFzQOGH5eTExSAj2Z/LDV/hbcvAPQdlJMhA17FuuJd+4wGuj+ZbVxEsFapTKAOwyhfw9qpch52JKxbU64=",
-            "This will be a p2wsh 3-of-3 multisig BIP 322 signed message"),
-        MessageVerificationResult::OK);
-
-    // Single key p2tr BIP322 signature (created with the buidl-python library)
-    // PrivateKeyWIF L3VFeEujGtevx9w18HD1fhRbCH67Az2dpCymeRE1SoPK6XQtaN2k
-    BOOST_CHECK_EQUAL(
-        MessageVerify(
-            "bc1ppv609nr0vr25u07u95waq5lucwfm6tde4nydujnu8npg4q75mr5sxq8lt3",
-            "AUHd69PrJQEv+oKTfZ8l+WROBHuy9HKrbFCJu7U1iK2iiEy1vMU5EfMtjc+VSHM7aU0SDbak5IUZRVno2P5mjSafAQ==",
-            "Hello World"),
-        MessageVerificationResult::OK);
-
-    // Same p2tr BIP322 signature as above (created with the buidl-python library)
-    // Signature should not verify against the message
-    BOOST_CHECK_EQUAL(
-        MessageVerify(
-            "bc1ppv609nr0vr25u07u95waq5lucwfm6tde4nydujnu8npg4q75mr5sxq8lt3",
-            "AUHd69PrJQEv+oKTfZ8l+WROBHuy9HKrbFCJu7U1iK2iiEy1vMU5EfMtjc+VSHM7aU0SDbak5IUZRVno2P5mjSafAQ==",
-            "Hello World - This should fail"),
-        MessageVerificationResult::ERR_INVALID);
-
-    // wrong address
-
-    BOOST_CHECK_EQUAL(
-        MessageVerify(
-            "bc1qkecg9ly2xwxqgdy9egpuy87qc9x26smpts562s",
-            "AkcwRAIgM2gBAQqvZX15ZiysmKmQpDrG83avLIT492QBzLnQIxYCIBaTpOaD20qRlEylyxFSeEA2ba9YOixpX8z46TSDtS40ASECx/EgAxlkQpQ9hYjgGu6EBCPMVPwVIVJqO4XCsMvViHI=",
-            ""),
-        MessageVerificationResult::ERR_INVALID);
-
-    BOOST_CHECK_EQUAL(
-        MessageVerify(
-            "bc1qkecg9ly2xwxqgdy9egpuy87qc9x26smpts562s",
-            "AkcwRAIgZRfIY3p7/DoVTty6YZbWS71bc5Vct9p9Fia83eRmw2QCICK/ENGfwLtptFluMGs2KsqoNSk89pO7F29zJLUx9a/sASECx/EgAxlkQpQ9hYjgGu6EBCPMVPwVIVJqO4XCsMvViHI=",
-            "Hello World"),
-        MessageVerificationResult::ERR_INVALID);
-
-    // wrong signature / message (signatures swapped)
-
-    BOOST_CHECK_EQUAL(
-        MessageVerify(
-            "bc1q9vza2e8x573nczrlzms0wvx3gsqjx7vavgkx0l",
-            "AkcwRAIgZRfIY3p7/DoVTty6YZbWS71bc5Vct9p9Fia83eRmw2QCICK/ENGfwLtptFluMGs2KsqoNSk89pO7F29zJLUx9a/sASECx/EgAxlkQpQ9hYjgGu6EBCPMVPwVIVJqO4XCsMvViHI=",
-            ""),
-        MessageVerificationResult::ERR_INVALID);
-
-    BOOST_CHECK_EQUAL(
-        MessageVerify(
-            "bc1q9vza2e8x573nczrlzms0wvx3gsqjx7vavgkx0l",
-            "AkcwRAIgM2gBAQqvZX15ZiysmKmQpDrG83avLIT492QBzLnQIxYCIBaTpOaD20qRlEylyxFSeEA2ba9YOixpX8z46TSDtS40ASECx/EgAxlkQpQ9hYjgGu6EBCPMVPwVIVJqO4XCsMvViHI=",
-            "Hello World"),
-        MessageVerificationResult::ERR_INVALID);
-
-    // invalid address
-
-    BOOST_CHECK_EQUAL(
-        MessageVerify(
-            "bc1q9vza2e8x573nczrlzms0wvx3gsqjx7vavgkx1l",
-            "AkcwRAIgM2gBAQqvZX15ZiysmKmQpDrG83avLIT492QBzLnQIxYCIBaTpOaD20qRlEylyxFSeEA2ba9YOixpX8z46TSDtS40ASECx/EgAxlkQpQ9hYjgGu6EBCPMVPwVIVJqO4XCsMvViHI=",
-            ""),
-        MessageVerificationResult::ERR_INVALID_ADDRESS);
-
-    // malformed signature
-
-    BOOST_CHECK_EQUAL(
-        MessageVerify(
-            "bc1q9vza2e8x573nczrlzms0wvx3gsqjx7vavgkx0l",
-            "AkcwRAIgClVQ8S9yX1h8YThlGElD9lOrQbOwbFDjkYb0ebfiq+oCIDHgb/X9WNalNNtqTXb465ufbv9JuLxcJf8qi7DP6yOXASECx/EgAxlkQpQ9hYjgGu6EBCPMVPwVIVJqO4XCsMvViHI",
-            ""),
-        MessageVerificationResult::ERR_MALFORMED_SIGNATURE);
 }
 
 BOOST_AUTO_TEST_CASE(message_hash)
@@ -1890,20 +1694,10 @@ BOOST_AUTO_TEST_CASE(message_hash)
 
     const uint256 signature_hash = Hash(unsigned_tx);
     const uint256 message_hash1 = Hash(prefixed_message);
-    const uint256 message_hash2 = MessageHash(unsigned_tx, MessageSignatureFormat::LEGACY);
+    const uint256 message_hash2 = MessageHash(unsigned_tx);
 
     BOOST_CHECK_EQUAL(message_hash1, message_hash2);
     BOOST_CHECK_NE(message_hash1, signature_hash);
-
-    // BIP-322 tests
-
-    const uint256 signature_hash_0x = MessageHash("", MessageSignatureFormat::FULL);
-    const uint256 signature_hash_Hello_World = MessageHash("Hello World", MessageSignatureFormat::FULL);
-
-    std::vector<unsigned char> vec(signature_hash_0x.begin(), signature_hash_0x.end());
-    BOOST_CHECK_EQUAL("c90c269c4f8fcbe6880f72a721ddfbf1914268a794cbb21cfafee13770ae19f1", HexStr(vec));
-    vec = std::vector<unsigned char>(signature_hash_Hello_World.begin(), signature_hash_Hello_World.end());
-    BOOST_CHECK_EQUAL("f0eb03b1a75ac6d9847f55c624a99169b5dccba2a31f5b23bea77ba270de0a7a", HexStr(vec));
 }
 
 BOOST_AUTO_TEST_CASE(remove_prefix)
@@ -2037,157 +1831,4 @@ BOOST_AUTO_TEST_CASE(clearshrink_test)
     }
 }
 
-static std::string CheckModifyRWConfigFile(std::map<std::string, std::string>& settings_to_change, const std::string& current_config_file)
-{
-    std::istringstream stream_in(current_config_file);
-    std::ostringstream stream_out;
-    try {
-        ModifyRWConfigStream(stream_in, stream_out, settings_to_change);
-    } catch (...) {
-        settings_to_change.clear();
-        throw;
-    }
-    settings_to_change.clear();
-    return stream_out.str();
-}
-
-BOOST_AUTO_TEST_CASE(test_ModifyRWConfigFile)
-{
-    std::map<std::string, std::string> cs;
-
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b"), "a=b");
-
-    cs["a"] = "c";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b"), "a=c");
-    BOOST_CHECK(cs.empty());
-
-    // Multi-char name/value
-    cs["ab"] = "cd";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "ab=bc"), "ab=cd");
-
-    // Preserved final newline
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\n"), "a=b\n");
-    cs["a"] = "c";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\n"), "a=c\n");
-
-    // Preserved final tab
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\t"), "a=b\t");
-    cs["a"] = "c";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\t"), "a=c\t");
-
-    // Preserved final space
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b "), "a=b ");
-    cs["a"] = "c";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b "), "a=c ");
-
-    // Preserved final crnl
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\r\n"), "a=b\r\n");
-    cs["a"] = "c";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\r\n"), "a=c\r\n");
-
-    // Empty file
-    cs["a"] = "c";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, ""), "a=c\n");
-
-    // Ignore k=v in comment
-    cs["a"] = "c";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "#a=b"), "#a=b\na=c\n");
-
-    // Preserved comment
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\t# c"), "a=b\t# c");
-
-    // Commented out commented value
-    cs["a"] = "c";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\t# c"), "a=c\n#a=b\t# c");
-
-    // Preserved whitespace before name
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, " \t \ta=b"), " \t \ta=b");
-    cs["a"] = "c";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, " \t \ta=b"), " \t \ta=c");
-
-    // Preserved whitespace after name
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a \t \t=b"), "a \t \t=b");
-    cs["a"] = "c";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a \t \t=b"), "a \t \t=c");
-
-    // Preserved whitespace before value
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a= \t \tb"), "a= \t \tb");
-    cs["a"] = "c";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a= \t \tb"), "a= \t \tc");
-
-    // Modifying value between others
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\nab=bc\nd=e"), "a=b\nab=bc\nd=e");
-    cs["ab"] = "x";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\nab=bc\nd=e"), "a=b\nab=x\nd=e");
-
-    // Blank key/value
-    cs["ab"] = "";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\nab=bc\nd=e"), "a=b\nab=\nd=e");
-    cs[""] = "x";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\nab=bc\nd=e"), "a=b\nab=bc\nd=e\n=x\n");
-
-    // Blank line in source
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\n\nab=bc\n\nd=e"), "a=b\n\nab=bc\n\nd=e");
-    cs["ab"] = "x";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\n\nab=bc\n\nd=e"), "a=b\n\nab=x\n\nd=e");
-
-    // Duplicate keys in the source
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\nab=bc\nf=x\nab=zx\nd=e"), "a=b\nab=bc\nf=x\nab=zx\nd=e");
-    cs["ab"] = "x";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\nab=bc\nf=x\nab=zx\nd=e"), "a=b\nab=x\nf=x\nab=zx\nd=e");
-
-    // Comment out entire file if invalid input line
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\nab=bc\nGARBAGE\nd=e"), "[INVALID]\n# Error parsing line 3: GARBAGE\n#a=b\n#ab=bc\n#GARBAGE\n#d=e");
-    cs["ab"] = "x";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\nab=bc\nGARBAGE\nd=e"), "ab=x\n[INVALID]\n# Error parsing line 3: GARBAGE\n#a=b\n#ab=bc\n#GARBAGE\n#d=e");
-    cs["ab"] = "x";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\nab=bc\nGARBAGE\nd=e\n"), "ab=x\n[INVALID]\n# Error parsing line 3: GARBAGE\n#a=b\n#ab=bc\n#GARBAGE\n#d=e\n");
-
-    // Whitespace inside values
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\nab=b\t \t c\nd=e"), "a=b\nab=b\t \t c\nd=e");
-    cs["ab"] = "x \t \tx";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\nab=b\t \t c\nd=e"), "a=b\nab=x \t \tx\nd=e");
-
-    // Newline inside name/value
-    cs["a"] = "x\nx";
-    BOOST_REQUIRE_THROW(CheckModifyRWConfigFile(cs, ""), std::invalid_argument);
-    cs["a"] = "x\rx";
-    BOOST_REQUIRE_THROW(CheckModifyRWConfigFile(cs, ""), std::invalid_argument);
-    cs["a\nb"] = "x";
-    BOOST_REQUIRE_THROW(CheckModifyRWConfigFile(cs, ""), std::invalid_argument);
-    cs["a\rb"] = "x";
-    BOOST_REQUIRE_THROW(CheckModifyRWConfigFile(cs, ""), std::invalid_argument);
-
-    // Whitespace leading/trailing name/value
-    cs["a"] = " x";
-    BOOST_REQUIRE_THROW(CheckModifyRWConfigFile(cs, ""), std::invalid_argument);
-    cs["a"] = "\tx";
-    BOOST_REQUIRE_THROW(CheckModifyRWConfigFile(cs, ""), std::invalid_argument);
-    cs[" a"] = "x";
-    BOOST_REQUIRE_THROW(CheckModifyRWConfigFile(cs, ""), std::invalid_argument);
-    cs["\ta"] = "x";
-    BOOST_REQUIRE_THROW(CheckModifyRWConfigFile(cs, ""), std::invalid_argument);
-    cs["a"] = "x ";
-    BOOST_REQUIRE_THROW(CheckModifyRWConfigFile(cs, ""), std::invalid_argument);
-    cs["a"] = "x\t";
-    BOOST_REQUIRE_THROW(CheckModifyRWConfigFile(cs, ""), std::invalid_argument);
-    cs["a "] = "x";
-    BOOST_REQUIRE_THROW(CheckModifyRWConfigFile(cs, ""), std::invalid_argument);
-    cs["a\t"] = "x";
-    BOOST_REQUIRE_THROW(CheckModifyRWConfigFile(cs, ""), std::invalid_argument);
-
-    // Ignore groups
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\n[group]\nab=bc\nd=e"), "a=b\n[group]\nab=bc\nd=e");
-    cs["ab"] = "x";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\n[group]\nab=bc\nd=e"), "a=b\nab=x\n[group]\nab=bc\nd=e");
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\n\t [group] \t#c\nab=bc\nd=e"), "a=b\n\t [group] \t#c\nab=bc\nd=e");
-    cs["ab"] = "x";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\n\t [group] \t#c\nab=bc\nd=e"), "a=b\nab=x\n\t [group] \t#c\nab=bc\nd=e");
-
-    // Comment out entire file if invalid input line, even after a group
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\n[group]\nab=bc\nGARBAGE\nd=e"), "[INVALID]\n# Error parsing line 4: GARBAGE\n#a=b\n#[group]\n#ab=bc\n#GARBAGE\n#d=e");
-    cs["ab"] = "x";
-    BOOST_CHECK_EQUAL(CheckModifyRWConfigFile(cs, "a=b\n[group]\nab=bc\nGARBAGE\nd=e"), "ab=x\n[INVALID]\n# Error parsing line 4: GARBAGE\n#a=b\n#[group]\n#ab=bc\n#GARBAGE\n#d=e");
-}
-
 BOOST_AUTO_TEST_SUITE_END()
diff --git a/src/test/validation_block_tests.cpp b/src/test/validation_block_tests.cpp
index 628bfd6182..588ac60498 100644
--- a/src/test/validation_block_tests.cpp
+++ b/src/test/validation_block_tests.cpp
@@ -66,7 +66,7 @@ std::shared_ptr<CBlock> MinerTestingSetup::Block(const uint256& prev_hash)
     static uint64_t time = Params().GenesisBlock().nTime;
 
     BlockAssembler::Options options;
-    auto ptemplate = BlockAssembler{m_node.chainman->ActiveChainstate(), m_node.mempool.get(), options, m_node}.CreateNewBlock(CScript{} << i++ << OP_TRUE);
+    auto ptemplate = BlockAssembler{m_node.chainman->ActiveChainstate(), m_node.mempool.get(), options}.CreateNewBlock(CScript{} << i++ << OP_TRUE);
     auto pblock = std::make_shared<CBlock>(ptemplate->block);
     pblock->hashPrevBlock = prev_hash;
     pblock->nTime = ++time;
@@ -181,7 +181,7 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)
             bool ignored;
             FastRandomContext insecure;
             for (int i = 0; i < 1000; i++) {
-                const auto& block = blocks[insecure.randrange(blocks.size() - 1)];
+                auto block = blocks[insecure.randrange(blocks.size() - 1)];
                 Assert(m_node.chainman)->ProcessNewBlock(block, true, true, &ignored);
             }
 
@@ -331,7 +331,7 @@ BOOST_AUTO_TEST_CASE(witness_commitment_index)
     CScript pubKey;
     pubKey << 1 << OP_TRUE;
     BlockAssembler::Options options;
-    auto ptemplate = BlockAssembler{m_node.chainman->ActiveChainstate(), m_node.mempool.get(), options, m_node}.CreateNewBlock(pubKey);
+    auto ptemplate = BlockAssembler{m_node.chainman->ActiveChainstate(), m_node.mempool.get(), options}.CreateNewBlock(pubKey);
     CBlock pblock = ptemplate->block;
 
     CTxOut witness;
diff --git a/src/test/validation_chainstate_tests.cpp b/src/test/validation_chainstate_tests.cpp
index b0ae2df674..1c02066047 100644
--- a/src/test/validation_chainstate_tests.cpp
+++ b/src/test/validation_chainstate_tests.cpp
@@ -3,7 +3,6 @@
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 //
 #include <chainparams.h>
-#include <common/system.h>
 #include <consensus/validation.h>
 #include <random.h>
 #include <rpc/blockchain.h>
@@ -26,8 +25,6 @@ BOOST_FIXTURE_TEST_SUITE(validation_chainstate_tests, ChainTestingSetup)
 //!
 BOOST_AUTO_TEST_CASE(validation_chainstate_resize_caches)
 {
-    g_low_memory_threshold = 0;  // disable to get deterministic flushing
-
     ChainstateManager& manager = *Assert(m_node.chainman);
     CTxMemPool& mempool = *Assert(m_node.mempool);
     Chainstate& c1 = WITH_LOCK(cs_main, return manager.InitializeChainstate(&mempool));
diff --git a/src/test/validation_tests.cpp b/src/test/validation_tests.cpp
index 3b8f21e0ac..2e378ed30b 100644
--- a/src/test/validation_tests.cpp
+++ b/src/test/validation_tests.cpp
@@ -45,25 +45,6 @@ static void TestBlockSubsidyHalvings(int nSubsidyHalvingInterval)
     TestBlockSubsidyHalvings(consensusParams);
 }
 
-BOOST_AUTO_TEST_CASE(checkpoint_sanity)
-{
-    const auto chainParams = CreateChainParams(*m_node.args, ChainType::MAIN);
-    const auto& checkpoints = chainParams->Checkpoints();
-
-    uint256 p11111 = uint256S("0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d");
-    uint256 p134444 = uint256S("0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe");
-    BOOST_CHECK(checkpoints.CheckBlock(11111, p11111));
-    BOOST_CHECK(checkpoints.CheckBlock(134444, p134444));
-
-    // Wrong hashes at checkpoints should fail:
-    BOOST_CHECK(!checkpoints.CheckBlock(11111, p134444));
-    BOOST_CHECK(!checkpoints.CheckBlock(134444, p11111));
-
-    // ... but any hash not at a checkpoint should succeed:
-    BOOST_CHECK(checkpoints.CheckBlock(11111+1, p134444));
-    BOOST_CHECK(checkpoints.CheckBlock(134444+1, p11111));
-}
-
 BOOST_AUTO_TEST_CASE(block_subsidy_test)
 {
     const auto chainParams = CreateChainParams(*m_node.args, ChainType::MAIN);
diff --git a/src/torcontrol.cpp b/src/torcontrol.cpp
index ef26dbf997..42ba51e9c0 100644
--- a/src/torcontrol.cpp
+++ b/src/torcontrol.cpp
@@ -3,10 +3,6 @@
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
-#if defined(HAVE_CONFIG_H)
-#include <config/bitcoin-config.h>
-#endif
-
 #include <torcontrol.h>
 
 #include <chainparams.h>
@@ -28,17 +24,10 @@
 #include <util/thread.h>
 #include <util/time.h>
 
-#ifdef ENABLE_TOR_SUBPROCESS
-#include <util/subprocess.h>
-#endif // ENABLE_TOR_SUBPROCESS
-
 #include <algorithm>
 #include <cassert>
-#include <chrono>
-#include <cstdint>
 #include <cstdlib>
 #include <deque>
-#include <fstream>
 #include <functional>
 #include <map>
 #include <optional>
@@ -59,7 +48,6 @@ using util::ToString;
 
 /** Default control ip and port */
 const std::string DEFAULT_TOR_CONTROL = "127.0.0.1:" + ToString(DEFAULT_TOR_CONTROL_PORT);
-const std::string DEFAULT_TOR_EXECUTE = "tor";
 /** Tor cookie size (from control-spec.txt) */
 static const int TOR_COOKIE_SIZE = 32;
 /** Size of client/server nonce for SAFECOOKIE */
@@ -72,8 +60,6 @@ static const std::string TOR_SAFE_CLIENTKEY = "Tor safe cookie authentication co
 static const float RECONNECT_TIMEOUT_START = 1.0;
 /** Exponential backoff configuration - growth factor */
 static const float RECONNECT_TIMEOUT_EXP = 1.5;
-/** Maximum reconnect timeout in seconds to prevent excessive delays */
-static const float RECONNECT_TIMEOUT_MAX = 600.0;
 /** Maximum length for lines received on TorControlConnection.
  * tor-control-spec.txt mentions that there is explicitly no limit defined to line length,
  * this is belt-and-suspenders sanity limit to prevent memory exhaustion.
@@ -94,10 +80,6 @@ TorControlConnection::~TorControlConnection()
         bufferevent_free(b_conn);
 }
 
-void TorControlConnection::IgnoreReplyHandler(TorControlConnection &a, const TorControlReply &b)
-{
-}
-
 void TorControlConnection::readcb(struct bufferevent *bev, void *ctx)
 {
     TorControlConnection *self = static_cast<TorControlConnection*>(ctx);
@@ -336,20 +318,18 @@ std::map<std::string,std::string> ParseTorReplyMapping(const std::string &s)
     return mapping;
 }
 
-TorController::TorController(struct event_base* _base, const std::string& tor_control_center, const CService& target, const std::string& execute):
+TorController::TorController(struct event_base* _base, const std::string& tor_control_center, const CService& target):
     base(_base),
-    m_connect_tor_control_center(tor_control_center), conn(base), reconnect(true), reconnect_timeout(RECONNECT_TIMEOUT_START),
-    m_execute(execute),
+    m_tor_control_center(tor_control_center), conn(base), reconnect(true), reconnect_timeout(RECONNECT_TIMEOUT_START),
     m_target(target)
 {
     reconnect_ev = event_new(base, -1, 0, reconnect_cb, this);
     if (!reconnect_ev)
         LogPrintf("tor: Failed to create event for reconnection: out of memory?\n");
     // Start connection attempts immediately
-    m_current_tor_control_center = tor_control_center;
-    if (!conn.Connect(m_current_tor_control_center, std::bind(&TorController::connected_cb, this, std::placeholders::_1),
+    if (!conn.Connect(m_tor_control_center, std::bind(&TorController::connected_cb, this, std::placeholders::_1),
          std::bind(&TorController::disconnected_cb, this, std::placeholders::_1) )) {
-        LogPrintf("tor: Initiating connection to Tor control port %s failed\n", m_current_tor_control_center);
+        LogPrintf("tor: Initiating connection to Tor control port %s failed\n", m_tor_control_center);
     }
     // Read service private key if cached
     std::pair<bool,std::string> pkf = ReadBinaryFile(GetPrivateKeyFile());
@@ -368,12 +348,6 @@ TorController::~TorController()
     if (service.IsValid()) {
         RemoveLocal(service);
     }
-#ifdef ENABLE_TOR_SUBPROCESS
-    if (m_process) {
-        conn.Command("SIGNAL SHUTDOWN");
-        delete m_process;
-    }
-#endif
 }
 
 void TorController::get_socks_cb(TorControlConnection& _conn, const TorControlReply& reply)
@@ -483,20 +457,9 @@ void TorController::auth_cb(TorControlConnection& _conn, const TorControlReply&
     if (reply.code == 250) {
         LogPrint(BCLog::TOR, "Authentication successful\n");
 
-#ifdef ENABLE_TOR_SUBPROCESS
-        if (m_process) {
-            _conn.Command("TAKEOWNERSHIP");
-        }
-#endif
-
         // Now that we know Tor is running setup the proxy for onion addresses
         // if -onion isn't set to something else.
-        // NOTE: Our own private Tor doesn't do SOCKS, so don't configure it
-        if (gArgs.GetArg("-onion", "") == ""
-#ifdef ENABLE_TOR_SUBPROCESS
-            && !m_process
-#endif
-        ) {
+        if (gArgs.GetArg("-onion", "") == "") {
             _conn.Command("GETINFO net/listeners/socks", std::bind(&TorController::get_socks_cb, this, std::placeholders::_1, std::placeholders::_2));
         }
 
@@ -653,101 +616,28 @@ void TorController::protocolinfo_cb(TorControlConnection& _conn, const TorContro
 
 void TorController::connected_cb(TorControlConnection& _conn)
 {
-    m_try_exec = false;
     reconnect_timeout = RECONNECT_TIMEOUT_START;
     // First send a PROTOCOLINFO command to figure out what authentication is expected
     if (!_conn.Command("PROTOCOLINFO 1", std::bind(&TorController::protocolinfo_cb, this, std::placeholders::_1, std::placeholders::_2)))
         LogPrintf("tor: Error sending initial protocolinfo command\n");
 }
 
-std::string TorController::LaunchTor()
-{
-#ifdef ENABLE_TOR_SUBPROCESS
-    fs::path tor_datadir = gArgs.GetDataDirNet() / "tor";
-    const fs::path controlport_env_filepath = tor_datadir / "controlport.env";
-    fs::remove(controlport_env_filepath);  // may throw exceptions
-
-    if (m_process) {
-        try {
-            m_process->kill();
-        } catch (...) {
-            // ignore any exceptions
-        }
-        delete m_process;
-        m_process = nullptr;
-    }
-
-    try {
-        m_process = new subprocess::Popen(m_execute + " -f -", subprocess::input{subprocess::PIPE}, subprocess::close_fds{true});
-    } catch (...) {
-        LogPrint(BCLog::TOR, "tor: Failed to execute Tor process\n");
-        throw;
-    }
-    m_process->send(std::string{"SOCKSPort 0\n"});
-    m_process->send(std::string{"DataDirectory "} + fs::PathToString(tor_datadir) + "\n");
-    m_process->send(std::string{"ControlPort auto\n"});
-    m_process->send(std::string{"ControlPortWriteToFile "} + fs::PathToString(controlport_env_filepath) + "\n");
-    m_process->send(std::string{"CookieAuthentication 1\n"});
-
-    while (!fs::exists(controlport_env_filepath)) {
-        if (m_process->poll() != -1) {
-            LogPrint(BCLog::TOR, "tor: Tor process died before making control port file\n");
-            throw std::runtime_error("tor process died");
-        }
-        std::this_thread::sleep_for(std::chrono::seconds(1));
-    }
-
-    std::ifstream controlport_file(controlport_env_filepath);
-    std::string portline;
-    controlport_file >> portline;
-    if (portline.compare(0, 5, "PORT=")) {
-        LogPrint(BCLog::TOR, "tor: Unrecognized control port line in file\n");
-        m_process->kill();
-        delete m_process;
-        m_process = nullptr;
-        throw std::runtime_error("port line unrecognized");
-    }
-
-    return portline.substr(5);
-#else
-    throw std::runtime_error("not supported");
-#endif
-}
-
 void TorController::disconnected_cb(TorControlConnection& _conn)
 {
     // Stop advertising service when disconnected
     if (service.IsValid())
         RemoveLocal(service);
     service = CService();
-
-#ifdef ENABLE_TOR_SUBPROCESS
-    if (m_try_exec && !m_execute.empty()) {
-        LogPrint(BCLog::TOR, "tor: Not connected to Tor control port %s, trying to launch via %s\n", m_current_tor_control_center, m_execute);
-        try {
-            m_current_tor_control_center = LaunchTor();
-            Reconnect();
-            return;
-        } catch (...) {
-            // fall through to normal reconnect logic
-        }
-    }
-#endif
-
     if (!reconnect)
         return;
 
-    LogDebug(BCLog::TOR, "Not connected to Tor control port %s, retrying in %.2f s\n",
-             m_current_tor_control_center, reconnect_timeout);
-    m_current_tor_control_center = m_connect_tor_control_center;
-    m_try_exec = true;  // if this fails
+    LogPrint(BCLog::TOR, "Not connected to Tor control port %s, trying to reconnect\n", m_tor_control_center);
 
-    // Single-shot timer for reconnect. Use exponential backoff with a maximum.
+    // Single-shot timer for reconnect. Use exponential backoff.
     struct timeval time = MillisToTimeval(int64_t(reconnect_timeout * 1000.0));
     if (reconnect_ev)
         event_add(reconnect_ev, &time);
-
-    reconnect_timeout = std::min(reconnect_timeout * RECONNECT_TIMEOUT_EXP, RECONNECT_TIMEOUT_MAX);
+    reconnect_timeout *= RECONNECT_TIMEOUT_EXP;
 }
 
 void TorController::Reconnect()
@@ -755,9 +645,9 @@ void TorController::Reconnect()
     /* Try to reconnect and reestablish if we get booted - for example, Tor
      * may be restarting.
      */
-    if (!conn.Connect(m_current_tor_control_center, std::bind(&TorController::connected_cb, this, std::placeholders::_1),
+    if (!conn.Connect(m_tor_control_center, std::bind(&TorController::connected_cb, this, std::placeholders::_1),
          std::bind(&TorController::disconnected_cb, this, std::placeholders::_1) )) {
-        LogPrintf("tor: Re-initiating connection to Tor control port %s failed\n", m_current_tor_control_center);
+        LogPrintf("tor: Re-initiating connection to Tor control port %s failed\n", m_tor_control_center);
     }
 }
 
@@ -778,17 +668,7 @@ static std::thread torControlThread;
 
 static void TorControlThread(CService onion_service_target)
 {
-#ifdef ENABLE_TOR_SUBPROCESS
-    std::string execute_command = gArgs.GetArg("-torexecute", DEFAULT_TOR_EXECUTE);
-    if (execute_command == "1") {
-        execute_command = DEFAULT_TOR_EXECUTE;
-    } else if (execute_command == "0") {
-        execute_command.clear();
-    }
-#else
-    const std::string execute_command;
-#endif
-    TorController ctrl(gBase, gArgs.GetArg("-torcontrol", DEFAULT_TOR_CONTROL), onion_service_target, execute_command);
+    TorController ctrl(gBase, gArgs.GetArg("-torcontrol", DEFAULT_TOR_CONTROL), onion_service_target);
 
     event_base_dispatch(gBase);
 }
diff --git a/src/torcontrol.h b/src/torcontrol.h
index 500b5628f4..0b66201cf1 100644
--- a/src/torcontrol.h
+++ b/src/torcontrol.h
@@ -8,10 +8,6 @@
 #ifndef BITCOIN_TORCONTROL_H
 #define BITCOIN_TORCONTROL_H
 
-#if defined(HAVE_CONFIG_H)
-#include <config/bitcoin-config.h>
-#endif
-
 #include <netaddress.h>
 #include <util/fs.h>
 
@@ -23,13 +19,8 @@
 #include <string>
 #include <vector>
 
-namespace subprocess {
-class Popen;
-}
-
 constexpr int DEFAULT_TOR_CONTROL_PORT = 9051;
 extern const std::string DEFAULT_TOR_CONTROL;
-extern const std::string DEFAULT_TOR_EXECUTE;
 static const bool DEFAULT_LISTEN_ONION = true;
 
 void StartTorControl(CService onion_service_target);
@@ -62,7 +53,6 @@ class TorControlConnection
 public:
     typedef std::function<void(TorControlConnection&)> ConnectionCB;
     typedef std::function<void(TorControlConnection &,const TorControlReply &)> ReplyHandlerCB;
-    static void IgnoreReplyHandler(TorControlConnection &, const TorControlReply &);
 
     /** Create a new TorControlConnection.
      */
@@ -87,7 +77,7 @@ public:
      * A trailing CRLF is automatically added.
      * Return true on success.
      */
-    bool Command(const std::string &cmd, const ReplyHandlerCB& reply_handler = IgnoreReplyHandler);
+    bool Command(const std::string &cmd, const ReplyHandlerCB& reply_handler);
 
 private:
     /** Callback when ready for use */
@@ -116,7 +106,7 @@ private:
 class TorController
 {
 public:
-    TorController(struct event_base* base, const std::string& tor_control_center, const CService& target, const std::string& execute);
+    TorController(struct event_base* base, const std::string& tor_control_center, const CService& target);
     TorController() : conn{nullptr} {
         // Used for testing only.
     }
@@ -129,19 +119,13 @@ public:
     void Reconnect();
 private:
     struct event_base* base;
-    const std::string m_connect_tor_control_center;
-    std::string m_current_tor_control_center;
+    const std::string m_tor_control_center;
     TorControlConnection conn;
     std::string private_key;
     std::string service_id;
-    bool m_try_exec{true};
     bool reconnect;
     struct event *reconnect_ev = nullptr;
     float reconnect_timeout;
-    std::string m_execute{DEFAULT_TOR_EXECUTE};
-#ifdef ENABLE_TOR_SUBPROCESS
-    subprocess::Popen *m_process{nullptr};
-#endif
     CService service;
     const CService m_target;
     /** Cookie for SAFECOOKIE auth */
@@ -167,8 +151,6 @@ public:
 
     /** Callback for reconnect timer */
     static void reconnect_cb(evutil_socket_t fd, short what, void *arg);
-
-    std::string LaunchTor();
 };
 
 #endif // BITCOIN_TORCONTROL_H
diff --git a/src/txdb.h b/src/txdb.h
index 0c74a2055d..e0acb09e98 100644
--- a/src/txdb.h
+++ b/src/txdb.h
@@ -24,9 +24,9 @@ class uint256;
 //! -dbcache default (MiB)
 static const int64_t nDefaultDbCache = 450;
 //! -dbbatchsize default (bytes)
-static const int64_t nDefaultDbBatchSize = 64 << 20;
+static const int64_t nDefaultDbBatchSize = 16 << 20;
 //! max. -dbcache (MiB)
-static constexpr int64_t nMaxDbCache = sizeof(void*) > 4 ? 1048576 : 1024;
+static const int64_t nMaxDbCache = sizeof(void*) > 4 ? 16384 : 1024;
 //! min. -dbcache (MiB)
 static const int64_t nMinDbCache = 4;
 //! Max memory allocated to block tree DB specific cache, if no -txindex (MiB)
@@ -49,9 +49,7 @@ struct CoinsViewOptions {
     int simulate_crash_ratio = 0;
 };
 
-/** CCoinsView backed by the coin database (chainstate/)
- * Cursor requires FlushStateToDisk for consistency.
- */
+/** CCoinsView backed by the coin database (chainstate/) */
 class CCoinsViewDB final : public CCoinsView
 {
 protected:
diff --git a/src/txmempool.cpp b/src/txmempool.cpp
index 638c4d6fc6..b523c5fe09 100644
--- a/src/txmempool.cpp
+++ b/src/txmempool.cpp
@@ -11,16 +11,11 @@
 #include <consensus/consensus.h>
 #include <consensus/tx_verify.h>
 #include <consensus/validation.h>
-#include <crypto/ripemd160.h>
 #include <logging.h>
-#include <policy/coin_age_priority.h>
-#include <policy/fees.h>
 #include <policy/policy.h>
 #include <policy/settings.h>
 #include <random.h>
-#include <scheduler.h>
 #include <tinyformat.h>
-#include <script/script.h>
 #include <util/check.h>
 #include <util/feefrac.h>
 #include <util/moneystr.h>
@@ -56,13 +51,6 @@ bool TestLockPointValidity(CChain& active_chain, const LockPoints& lp)
     return true;
 }
 
-uint160 ScriptHashkey(const CScript& script)
-{
-    uint160 hash;
-    CRIPEMD160().Write(script.data(), script.size()).Finalize(hash.begin());
-    return hash;
-}
-
 void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap& cachedDescendants,
                                       const std::set<uint256>& setExclude, std::set<uint256>& descendants_to_remove)
 {
@@ -413,7 +401,7 @@ void CTxMemPoolEntry::UpdateAncestorState(int32_t modifySize, CAmount modifyFee,
 static CTxMemPool::Options&& Flatten(CTxMemPool::Options&& opts, bilingual_str& error)
 {
     opts.check_ratio = std::clamp<int>(opts.check_ratio, 0, 1'000'000);
-    int64_t descendant_limit_bytes = maxmempoolMinimumBytes(opts.limits.descendant_size_vbytes);
+    int64_t descendant_limit_bytes = opts.limits.descendant_size_vbytes * 40;
     if (opts.max_size_bytes < 0 || opts.max_size_bytes < descendant_limit_bytes) {
         error = strprintf(_("-maxmempool must be at least %d MB"), std::ceil(descendant_limit_bytes / 1'000'000.0));
     }
@@ -423,13 +411,6 @@ static CTxMemPool::Options&& Flatten(CTxMemPool::Options&& opts, bilingual_str&
 CTxMemPool::CTxMemPool(Options opts, bilingual_str& error)
     : m_opts{Flatten(std::move(opts), error)}
 {
-    Assert(m_opts.scheduler || !m_opts.dust_relay_target);
-    m_opts.dust_relay_feerate_floor = m_opts.dust_relay_feerate;
-    if (m_opts.scheduler) {
-        m_opts.scheduler->scheduleEvery([this]{
-            UpdateDynamicDustFeerate();
-        }, DYNAMIC_DUST_FEERATE_UPDATE_INTERVAL);
-    }
 }
 
 bool CTxMemPool::isSpent(const COutPoint& outpoint) const
@@ -456,10 +437,8 @@ void CTxMemPool::addUnchecked(const CTxMemPoolEntry &entry, setEntries &setAnces
     indexed_transaction_set::iterator newit = mapTx.emplace(CTxMemPoolEntry::ExplicitCopy, entry).first;
 
     // Update transaction for any feeDelta created by PrioritiseTransaction
-    double priority_delta{0.};
     CAmount delta{0};
-    ApplyDeltas(entry.GetTx().GetHash(), priority_delta, delta);
-    // NOTE: priority_delta is handled in addPriorityTxs
+    ApplyDelta(entry.GetTx().GetHash(), delta);
     // The following call to UpdateModifiedFee assumes no previous fee modifications
     Assume(entry.GetFee() == entry.GetModifiedFee());
     if (delta) {
@@ -498,17 +477,6 @@ void CTxMemPool::addUnchecked(const CTxMemPoolEntry &entry, setEntries &setAnces
     txns_randomized.emplace_back(newit->GetSharedTx());
     newit->idx_randomized = txns_randomized.size() - 1;
 
-    for (auto& vSPK : entry.mapSPK) {
-        const uint160& SPKKey = vSPK.first;
-        const MemPool_SPK_State& claims = vSPK.second;
-        if (claims & MSS_CREATED) {
-            mapUsedSPK[SPKKey].first = &tx;
-        }
-        if (claims & MSS_SPENT) {
-            mapUsedSPK[SPKKey].second = &tx;
-        }
-    }
-
     TRACE3(mempool, added,
         entry.GetTx().GetHash().data(),
         entry.GetTxSize(),
@@ -537,7 +505,6 @@ void CTxMemPool::removeUnchecked(txiter it, MemPoolRemovalReason reason)
         std::chrono::duration_cast<std::chrono::duration<std::uint64_t>>(it->GetTime()).count()
     );
 
-    const CTransaction& tx = it->GetTx();
     for (const CTxIn& txin : it->GetTx().vin)
         mapNextTx.erase(txin.prevout);
 
@@ -554,19 +521,6 @@ void CTxMemPool::removeUnchecked(txiter it, MemPoolRemovalReason reason)
     } else
         txns_randomized.clear();
 
-    for (auto& vSPK : it->mapSPK) {
-        const uint160& SPKKey = vSPK.first;
-        if (mapUsedSPK[SPKKey].first == &tx) {
-            mapUsedSPK[SPKKey].first = NULL;
-        }
-        if (mapUsedSPK[SPKKey].second == &tx) {
-            mapUsedSPK[SPKKey].second = NULL;
-        }
-        if (!(mapUsedSPK[SPKKey].first || mapUsedSPK[SPKKey].second)) {
-            mapUsedSPK.erase(SPKKey);
-        }
-    }
-
     totalTxSize -= it->GetTxSize();
     m_total_fee -= it->GetFee();
     cachedInnerUsage -= it->DynamicMemoryUsage();
@@ -682,7 +636,6 @@ void CTxMemPool::removeForBlock(const std::vector<CTransactionRef>& vtx, unsigne
     txs_removed_for_block.reserve(vtx.size());
     for (const auto& tx : vtx)
     {
-        UpdateDependentPriorities(*tx, nBlockHeight, true);
         txiter it = mapTx.find(tx->GetHash());
         if (it != mapTx.end()) {
             setEntries stage;
@@ -700,36 +653,6 @@ void CTxMemPool::removeForBlock(const std::vector<CTransactionRef>& vtx, unsigne
     blockSinceLastRollingFeeBump = true;
 }
 
-void CTxMemPool::UpdateDynamicDustFeerate()
-{
-    CFeeRate est_feerate{0};
-    if (m_opts.dust_relay_target < 0 && m_opts.estimator) {
-        static constexpr double target_success_threshold{0.8};
-        est_feerate = m_opts.estimator->estimateRawFee(-m_opts.dust_relay_target, target_success_threshold, FeeEstimateHorizon::LONG_HALFLIFE, nullptr);
-    } else if (m_opts.dust_relay_target > 0) {
-        auto bytes_remaining = int64_t{m_opts.dust_relay_target} * 1'000;
-        LOCK(cs);
-        for (auto mi = mapTx.get<ancestor_score>().begin(); mi != mapTx.get<ancestor_score>().end(); ++mi) {
-            bytes_remaining -= mi->GetTxSize();
-            if (bytes_remaining <= 0) {
-                est_feerate = CFeeRate(mi->GetFee(), mi->GetTxSize());
-                break;
-            }
-        }
-    }
-
-    est_feerate = (est_feerate * m_opts.dust_relay_multiplier) / 1'000;
-
-    if (est_feerate < m_opts.dust_relay_feerate_floor) {
-        est_feerate = m_opts.dust_relay_feerate_floor;
-    }
-
-    if (m_opts.dust_relay_feerate != est_feerate) {
-        LogPrint(BCLog::MEMPOOL, "Updating dust feerate to %s\n", est_feerate.ToString(FeeEstimateMode::SAT_VB));
-        m_opts.dust_relay_feerate = est_feerate;
-    }
-}
-
 void CTxMemPool::check(const CCoinsViewCache& active_coins_tip, int64_t spendheight) const
 {
     if (m_opts.check_ratio == 0) return;
@@ -749,15 +672,6 @@ void CTxMemPool::check(const CCoinsViewCache& active_coins_tip, int64_t spendhei
 
     for (const auto& it : GetSortedDepthAndScore()) {
         checkTotal += it->GetTxSize();
-        CAmount dummyValue;
-        const double fresh_coin_age = GetCoinAge(it->GetTx(), active_coins_tip, spendheight, dummyValue);
-        const auto fresh_mod_vsize = CalculateModifiedSize(it->GetTx(), it->GetTxSize());
-        const double freshPriority = ComputePriority2(fresh_coin_age, fresh_mod_vsize);
-        double cachePriority = it->GetPriority(spendheight);
-        double priDiff = cachePriority > freshPriority ? cachePriority - freshPriority : freshPriority - cachePriority;
-        // Verify that the difference between the on the fly calculation and a fresh calculation
-        // is small enough to be a result of double imprecision.
-        assert(priDiff < .0001 * freshPriority + 1);
         check_total_fee += it->GetFee();
         innerUsage += it->DynamicMemoryUsage();
         const CTransaction& tx = it->GetTx();
@@ -894,21 +808,6 @@ std::vector<CTxMemPool::indexed_transaction_set::const_iterator> CTxMemPool::Get
     return iters;
 }
 
-void CTxMemPool::FindScriptPubKey(const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {
-    LOCK(cs);
-    for (const CTxMemPoolEntry& entry : mapTx) {
-        const CTransaction& tx = entry.GetTx();
-        const Txid& hash = tx.GetHash();
-        for (size_t txo_index = tx.vout.size(); txo_index > 0; ) {
-            --txo_index;
-            const CTxOut& txo = tx.vout[txo_index];
-            if (needles.count(txo.scriptPubKey)) {
-                out_results.emplace(COutPoint(hash, txo_index), Coin(txo, MEMPOOL_HEIGHT, false));
-            }
-        }
-    }
-}
-
 static TxMempoolInfo GetInfo(CTxMemPool::indexed_transaction_set::const_iterator it) {
     return TxMempoolInfo{it->GetSharedTx(), it->GetTime(), it->GetFee(), it->GetTxSize(), it->GetModifiedFee() - it->GetFee()};
 }
@@ -975,17 +874,15 @@ TxMempoolInfo CTxMemPool::info_for_relay(const GenTxid& gtxid, uint64_t last_seq
     }
 }
 
-void CTxMemPool::PrioritiseTransaction(const uint256& hash, double dPriorityDelta, const CAmount& nFeeDelta)
+void CTxMemPool::PrioritiseTransaction(const uint256& hash, const CAmount& nFeeDelta)
 {
     {
         LOCK(cs);
-        std::pair<double, CAmount> &deltas = mapDeltas[hash];
-        deltas.first += dPriorityDelta;
-        deltas.second = SaturatingAdd(deltas.second, nFeeDelta);
+        CAmount &delta = mapDeltas[hash];
+        delta = SaturatingAdd(delta, nFeeDelta);
         txiter it = mapTx.find(hash);
         if (it != mapTx.end()) {
             mapTx.modify(it, [&nFeeDelta](CTxMemPoolEntry& e) { e.UpdateModifiedFee(nFeeDelta); });
-
             // Now update all ancestors' modified fees with descendants
             auto ancestors{AssumeCalculateMemPoolAncestors(__func__, *it, Limits::NoLimits(), /*fSearchForParents=*/false)};
             for (txiter ancestorIt : ancestors) {
@@ -1000,29 +897,27 @@ void CTxMemPool::PrioritiseTransaction(const uint256& hash, double dPriorityDelt
             }
             ++nTransactionsUpdated;
         }
-        if (deltas.first == 0. && deltas.second == 0) {
+        if (delta == 0) {
             mapDeltas.erase(hash);
             LogPrintf("PrioritiseTransaction: %s (%sin mempool) delta cleared\n", hash.ToString(), it == mapTx.end() ? "not " : "");
         } else {
-            LogPrintf("PrioritiseTransaction: %s (%sin mempool) priority += %f, fee += %s, new delta=%s\n",
+            LogPrintf("PrioritiseTransaction: %s (%sin mempool) fee += %s, new delta=%s\n",
                       hash.ToString(),
                       it == mapTx.end() ? "not " : "",
-                      dPriorityDelta,
                       FormatMoney(nFeeDelta),
-                      FormatMoney(deltas.second));
+                      FormatMoney(delta));
         }
     }
 }
 
-void CTxMemPool::ApplyDeltas(const uint256& hash, double &dPriorityDelta, CAmount &nFeeDelta) const
+void CTxMemPool::ApplyDelta(const uint256& hash, CAmount &nFeeDelta) const
 {
     AssertLockHeld(cs);
-    std::map<uint256, std::pair<double, CAmount> >::const_iterator pos = mapDeltas.find(hash);
+    std::map<uint256, CAmount>::const_iterator pos = mapDeltas.find(hash);
     if (pos == mapDeltas.end())
         return;
-    const std::pair<double, CAmount> &deltas = pos->second;
-    dPriorityDelta += deltas.first;
-    nFeeDelta += deltas.second;
+    const CAmount &delta = pos->second;
+    nFeeDelta += delta;
 }
 
 void CTxMemPool::ClearPrioritisation(const uint256& hash)
@@ -1042,7 +937,7 @@ std::vector<CTxMemPool::delta_info> CTxMemPool::GetPrioritisedTransactions() con
         const bool in_mempool{iter != mapTx.end()};
         std::optional<CAmount> modified_fee;
         if (in_mempool) modified_fee = iter->GetModifiedFee();
-        result.emplace_back(delta_info{in_mempool, delta.second, delta.first, modified_fee, txid});
+        result.emplace_back(delta_info{in_mempool, delta, modified_fee, txid});
     }
     return result;
 }
diff --git a/src/txmempool.h b/src/txmempool.h
index e8bb09528a..d0cb41a078 100644
--- a/src/txmempool.h
+++ b/src/txmempool.h
@@ -17,7 +17,6 @@
 #include <policy/feerate.h>
 #include <policy/packages.h>
 #include <primitives/transaction.h>
-#include <script/script.h>
 #include <sync.h>
 #include <util/epochguard.h>
 #include <util/hasher.h>
@@ -42,20 +41,13 @@
 #include <vector>
 
 class CChain;
-class CScript;
 class ValidationSignals;
 
 struct bilingual_str;
 
-static constexpr std::chrono::minutes DYNAMIC_DUST_FEERATE_UPDATE_INTERVAL{15};
-
 /** Fake height value used in Coin to signify they are only in the memory pool (since 0.8) */
 static const uint32_t MEMPOOL_HEIGHT = 0x7FFFFFFF;
 
-inline int64_t maxmempoolMinimumBytes(const int64_t descendant_size_vbytes) {
-    return descendant_size_vbytes * 40;
-}
-
 /**
  * Test whether the LockPoints height and time are still valid on the current chain
  */
@@ -208,16 +200,12 @@ public:
     }
 };
 
-uint160 ScriptHashkey(const CScript& script);
-
 // Multi_index tag names
 struct descendant_score {};
 struct entry_time {};
 struct ancestor_score {};
 struct index_by_wtxid {};
 
-class CBlockPolicyEstimator;
-
 /**
  * Information about a mempool transaction.
  */
@@ -410,9 +398,6 @@ public:
     using Limits = kernel::MemPoolLimits;
 
     uint64_t CalculateDescendantMaximum(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);
-
-    std::map<uint160, std::pair<const CTransaction *, const CTransaction *>> mapUsedSPK;
-
 private:
     typedef std::map<txiter, setEntries, CompareIteratorByHash> cacheMap;
 
@@ -447,11 +432,11 @@ private:
 
 public:
     indirectmap<COutPoint, const CTransaction*> mapNextTx GUARDED_BY(cs);
-    std::map<uint256, std::pair<double, CAmount> > mapDeltas GUARDED_BY(cs);
+    std::map<uint256, CAmount> mapDeltas GUARDED_BY(cs);
 
     using Options = kernel::MemPoolOptions;
 
-    Options m_opts;
+    const Options m_opts;
 
     /** Create a new CTxMemPool.
      * Sanity checks will be off by default for performance, because otherwise
@@ -499,19 +484,10 @@ public:
      * the tx is not dependent on other mempool transactions to be included in a block.
      */
     bool HasNoInputsOf(const CTransaction& tx) const EXCLUSIVE_LOCKS_REQUIRED(cs);
-    /**
-     * Update all transactions in the mempool which depend on tx to recalculate their priority
-     * and adjust the input value that will age to reflect that the inputs from this transaction have
-     * either just been added to the chain or just been removed.
-     */
-    void UpdateDependentPriorities(const CTransaction &tx, unsigned int nBlockHeight, bool addToChain);
-
-    void UpdateDynamicDustFeerate();
 
     /** Affect CreateNewBlock prioritisation of transactions */
-    void PrioritiseTransaction(const uint256& hash, double dPriorityDelta, const CAmount& nFeeDelta);
-    void PrioritiseTransaction(const uint256& hash, const CAmount& nFeeDelta) { PrioritiseTransaction(hash, 0., nFeeDelta); }
-    void ApplyDeltas(const uint256& hash, double &dPriorityDelta, CAmount &nFeeDelta) const EXCLUSIVE_LOCKS_REQUIRED(cs);
+    void PrioritiseTransaction(const uint256& hash, const CAmount& nFeeDelta);
+    void ApplyDelta(const uint256& hash, CAmount &nFeeDelta) const EXCLUSIVE_LOCKS_REQUIRED(cs);
     void ClearPrioritisation(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs);
 
     struct delta_info {
@@ -519,7 +495,6 @@ public:
         const bool in_mempool;
         /** The fee delta added using PrioritiseTransaction(). */
         const CAmount delta;
-        const double priority_delta;
         /** The modified fee (base fee + delta) of this entry. Only present if in_mempool=true. */
         std::optional<CAmount> modified_fee;
         /** The prioritised transaction's txid. */
@@ -712,8 +687,6 @@ public:
     std::vector<CTxMemPoolEntryRef> entryAll() const EXCLUSIVE_LOCKS_REQUIRED(cs);
     std::vector<TxMempoolInfo> infoAll() const;
 
-    void FindScriptPubKey(const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results);
-
     size_t DynamicMemoryUsage() const;
 
     /** Adds a transaction to the unbroadcast set */
@@ -857,9 +830,6 @@ public:
  * It also allows you to sign a double-spend directly in
  * signrawtransactionwithkey and signrawtransactionwithwallet,
  * as long as the conflicting transaction is not yet confirmed.
- *
- * Its Cursor also doesn't work. In general, it is broken as a CCoinsView
- * implementation outside of a few use cases.
  */
 class CCoinsViewMemPool : public CCoinsViewBacked
 {
diff --git a/src/txorphanage.cpp b/src/txorphanage.cpp
index bc027f8890..faab208333 100644
--- a/src/txorphanage.cpp
+++ b/src/txorphanage.cpp
@@ -33,7 +33,7 @@ bool TxOrphanage::AddTx(const CTransactionRef& tx, NodeId peer)
         return false;
     }
 
-    auto ret = m_orphans.emplace(wtxid, OrphanTx{{tx, peer, Now<NodeSeconds>() + ORPHAN_TX_EXPIRE_TIME}, m_orphan_list.size()});
+    auto ret = m_orphans.emplace(wtxid, OrphanTx{tx, peer, Now<NodeSeconds>() + ORPHAN_TX_EXPIRE_TIME, m_orphan_list.size()});
     assert(ret.second);
     m_orphan_list.push_back(ret.first);
     for (const CTxIn& txin : tx->vin) {
@@ -277,13 +277,3 @@ std::vector<std::pair<CTransactionRef, NodeId>> TxOrphanage::GetChildrenFromDiff
     }
     return children_found;
 }
-
-std::vector<TxOrphanage::OrphanTxBase> TxOrphanage::GetOrphanTransactions() const
-{
-    std::vector<OrphanTxBase> ret;
-    ret.reserve(m_orphans.size());
-    for (auto const& o : m_orphans) {
-        ret.push_back({o.second.tx, o.second.fromPeer, o.second.nTimeExpire});
-    }
-    return ret;
-}
diff --git a/src/txorphanage.h b/src/txorphanage.h
index 5501d10922..2c53d1d40f 100644
--- a/src/txorphanage.h
+++ b/src/txorphanage.h
@@ -72,17 +72,11 @@ public:
         return m_orphans.size();
     }
 
-    /** Allows providing orphan information externally */
-    struct OrphanTxBase {
+protected:
+    struct OrphanTx {
         CTransactionRef tx;
         NodeId fromPeer;
         NodeSeconds nTimeExpire;
-    };
-
-    std::vector<OrphanTxBase> GetOrphanTransactions() const;
-
-protected:
-    struct OrphanTx : public OrphanTxBase {
         size_t list_pos;
     };
 
diff --git a/src/univalue/include/univalue.h b/src/univalue/include/univalue.h
index 0e5404eb1d..da12157555 100644
--- a/src/univalue/include/univalue.h
+++ b/src/univalue/include/univalue.h
@@ -70,8 +70,6 @@ public:
 
     size_t size() const { return values.size(); }
 
-    void reserve(size_t new_cap);
-
     void getObjMap(std::map<std::string,UniValue>& kv) const;
     bool checkObject(const std::map<std::string,UniValue::VType>& memberTypes) const;
     const UniValue& operator[](const std::string& key) const;
diff --git a/src/univalue/lib/univalue.cpp b/src/univalue/lib/univalue.cpp
index 4d37c81fe8..656d2e8203 100644
--- a/src/univalue/lib/univalue.cpp
+++ b/src/univalue/lib/univalue.cpp
@@ -240,10 +240,3 @@ const UniValue& UniValue::find_value(std::string_view key) const
     return NullUniValue;
 }
 
-void UniValue::reserve(size_t new_cap)
-{
-    values.reserve(new_cap);
-    if (typ == VOBJ) {
-        keys.reserve(new_cap);
-    }
-}
diff --git a/src/util/fs.h b/src/util/fs.h
index 56a71b042c..f841e0d76c 100644
--- a/src/util/fs.h
+++ b/src/util/fs.h
@@ -90,10 +90,6 @@ static inline bool exists(const path& p)
 {
     return std::filesystem::exists(p);
 }
-static inline bool exists(const std::filesystem::file_status& s)
-{
-    return std::filesystem::exists(s);
-}
 
 // Allow explicit quoted stream I/O.
 static inline auto quoted(const std::string& s)
diff --git a/src/util/fs_helpers.cpp b/src/util/fs_helpers.cpp
index 7f8588e0ca..41c8fe3b8f 100644
--- a/src/util/fs_helpers.cpp
+++ b/src/util/fs_helpers.cpp
@@ -41,11 +41,6 @@
 #include <shlobj.h> /* For SHGetSpecialFolderPathW */
 #endif // WIN32
 
-#ifdef __APPLE__
-#include <sys/mount.h>
-#include <sys/param.h>
-#endif
-
 /** Mutex to protect dir_locks. */
 static GlobalMutex cs_dir_locks;
 /** A map that contains all the currently held directory locks. After
@@ -217,8 +212,7 @@ void AllocateFileRange(FILE* file, unsigned int offset, unsigned int length)
     ftruncate(fileno(file), static_cast<off_t>(offset) + length);
 #else
 #if defined(HAVE_POSIX_FALLOCATE)
-    // Use posix_fallocate to advise the kernel how much data we have to write,
-    // if this system supports it.
+    // Version using posix_fallocate
     off_t nEndPos = (off_t)offset + length;
     if (0 == posix_fallocate(fileno(file), 0, nEndPos)) return;
 #endif
@@ -238,50 +232,6 @@ void AllocateFileRange(FILE* file, unsigned int offset, unsigned int length)
 #endif
 }
 
-FILE* AdviseSequential(FILE *file) {
-#ifdef _POSIX_C_SOURCE
-# if _POSIX_C_SOURCE >= 200112L
-    // Since this whole thing is advisory anyway, we can ignore any errors
-    // encountered up to and including the posix_fadvise call. However, we must
-    // rewind the file to the appropriate position if we've changed the seek
-    // offset.
-    if (file == nullptr) {
-        return nullptr;
-    }
-    const int fd = fileno(file);
-    if (fd == -1) {
-        return file;
-    }
-    const off_t start = lseek(fd, 0, SEEK_CUR);
-    if (start == -1) {
-        return file;
-    }
-    posix_fadvise(fd, start, 0, POSIX_FADV_WILLNEED);
-    posix_fadvise(fd, start, 0, POSIX_FADV_SEQUENTIAL);
-# endif
-#endif
-    return file;
-}
-
-int CloseAndUncache(FILE *file) {
-#ifdef _POSIX_C_SOURCE
-# if _POSIX_C_SOURCE >= 200112L
-    // Ignore any errors up to and including the posix_fadvise call since it's
-    // advisory.
-    if (file != nullptr) {
-        const int fd = fileno(file);
-        if (fd != -1) {
-            const off_t end = lseek(fd, 0, SEEK_END);
-            if (end != (off_t)-1) {
-                posix_fadvise(fd, 0, end, POSIX_FADV_DONTNEED);
-            }
-        }
-    }
-# endif
-#endif
-    return std::fclose(file);
-}
-
 #ifdef WIN32
 fs::path GetSpecialFolderPath(int nFolder, bool fCreate)
 {
@@ -325,57 +275,25 @@ std::string PermsToSymbolicString(fs::perms p)
 {
     std::string perm_str(9, '-');
 
-    auto set_perm = [&](size_t pos, fs::perms required_perm, char letter, char else_letter = '\0') {
+    auto set_perm = [&](size_t pos, fs::perms required_perm, char letter) {
         if ((p & required_perm) != fs::perms::none) {
             perm_str[pos] = letter;
-        } else if (else_letter) {
-            perm_str[pos] = else_letter;
         }
     };
 
     set_perm(0, fs::perms::owner_read,   'r');
     set_perm(1, fs::perms::owner_write,  'w');
-    if ((p & fs::perms::owner_exec) != fs::perms::none) {
-        set_perm(2, fs::perms::set_uid,  's', 'x');
-    } else {
-        set_perm(2, fs::perms::set_uid,  'S');
-    }
-
+    set_perm(2, fs::perms::owner_exec,   'x');
     set_perm(3, fs::perms::group_read,   'r');
     set_perm(4, fs::perms::group_write,  'w');
-    if ((p & fs::perms::group_exec) != fs::perms::none) {
-        set_perm(5, fs::perms::set_gid,  's', 'x');
-    } else {
-        set_perm(5, fs::perms::set_gid,  'S');
-    }
-
+    set_perm(5, fs::perms::group_exec,   'x');
     set_perm(6, fs::perms::others_read,  'r');
     set_perm(7, fs::perms::others_write, 'w');
-    if ((p & fs::perms::others_exec)  != fs::perms::none) {
-        set_perm(8, fs::perms::sticky_bit, 't', 'x');
-    } else {
-        set_perm(8, fs::perms::sticky_bit, 'T');
-    }
+    set_perm(8, fs::perms::others_exec,  'x');
 
     return perm_str;
 }
 
-static std::optional<unsigned> StringToOctal(const std::string& str)
-{
-    unsigned ret = 0;
-    for (char c : str) {
-        if (c < '0' || c > '7') return std::nullopt;
-        ret = (ret << 3) | (c - '0');
-    }
-    return ret;
-}
-
-static auto ConvertPermsToOctal(const std::string& str) noexcept -> std::optional<unsigned>
-{
-    if ((str.length() == 3) || (str.length() == 4)) return StringToOctal(str);
-    return std::nullopt;
-}
-
 std::optional<fs::perms> InterpretPermString(const std::string& s)
 {
     if (s == "owner") {
@@ -387,23 +305,7 @@ std::optional<fs::perms> InterpretPermString(const std::string& s)
         return fs::perms::owner_read | fs::perms::owner_write |
                fs::perms::group_read |
                fs::perms::others_read;
-    } else if (auto octal_perms = ConvertPermsToOctal(s)) {
-        return static_cast<fs::perms>(*octal_perms);
     } else {
         return std::nullopt;
     }
 }
-
-#ifdef __APPLE__
-FSType GetFilesystemType(const fs::path& path) {
-    struct statfs fs_info;
-    if (statfs(path.c_str(), &fs_info) != 0) {
-        return FSType::ERROR;
-    }
-
-    if (strcmp(fs_info.f_fstypename, "exfat") == 0) {
-        return FSType::EXFAT;
-    }
-    return FSType::OTHER;
-}
-#endif
diff --git a/src/util/fs_helpers.h b/src/util/fs_helpers.h
index 9acd189172..28dd6d979d 100644
--- a/src/util/fs_helpers.h
+++ b/src/util/fs_helpers.h
@@ -14,23 +14,6 @@
 #include <limits>
 #include <optional>
 
-#ifdef __APPLE__
-enum class FSType {
-    EXFAT,
-    OTHER,
-    ERROR
-};
-
-/**
- * Detect filesystem type for a given path.
- * Currently identifies exFAT filesystems which cause issues on MacOS.
- *
- * @param[in] path The directory path to check
- * @return FSType enum indicating the filesystem type
- */
-FSType GetFilesystemType(const fs::path& path);
-#endif
-
 /**
  * Ensure file contents are fully committed to disk, using a platform-specific
  * feature analogous to fsync().
@@ -72,15 +55,6 @@ bool CheckDiskSpace(const fs::path& dir, uint64_t additional_bytes = 0);
  */
 std::streampos GetFileSize(const char* path, std::streamsize max = std::numeric_limits<std::streamsize>::max());
 
-//! Return the original FILE* unchanged. On systems that support it,
-//! also advise the OS that the file will be accessed sequentially.
-FILE* AdviseSequential(FILE*);
-
-//! Close a file and return the result of fclose(). On systems that
-//! support it, advise the OS to remove the file contents from the page
-//! cache (which can help on memory-constrained systems).
-int CloseAndUncache(FILE*);
-
 /** Release all directory locks. This is used for unit testing only, at runtime
  * the global destructor will take care of the locks.
  */
diff --git a/src/util/ioprio.cpp b/src/util/ioprio.cpp
deleted file mode 100644
index b569f8ff93..0000000000
--- a/src/util/ioprio.cpp
+++ /dev/null
@@ -1,81 +0,0 @@
-// Copyright (c) 2016 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#if defined(HAVE_CONFIG_H)
-#include <config/bitcoin-config.h>
-#endif
-
-#include <util/ioprio.h>
-
-#if HAVE_IOPRIO_SYSCALL
-
-#ifndef _GNU_SOURCE
-#define _GNU_SOURCE
-#endif
-#include <unistd.h>
-#include <sys/syscall.h>
-
-#ifndef IOPRIO_WHO_PROCESS
-#define IOPRIO_WHO_PROCESS   1
-#endif
-#ifndef IOPRIO_CLASS_IDLE
-#define IOPRIO_CLASS_IDLE    3
-#endif
-#ifndef IOPRIO_CLASS_SHIFT
-#define IOPRIO_CLASS_SHIFT  13
-#endif
-
-int ioprio_get() {
-    return syscall(SYS_ioprio_get, IOPRIO_WHO_PROCESS, 0);
-}
-
-int ioprio_set(const int ioprio) {
-    return syscall(SYS_ioprio_set, IOPRIO_WHO_PROCESS, 0, ioprio);
-}
-
-int ioprio_set_idle() {
-    return ioprio_set(7 | (IOPRIO_CLASS_IDLE << IOPRIO_CLASS_SHIFT));
-}
-
-#elif HAVE_IOPOLICY
-
-#include <sys/resource.h>
-
-int ioprio_get() {
-    return getiopolicy_np(IOPOL_TYPE_DISK, IOPOL_SCOPE_THREAD);
-}
-
-int ioprio_set(const int ioprio) {
-    return setiopolicy_np(IOPOL_TYPE_DISK, IOPOL_SCOPE_THREAD, ioprio);
-}
-
-int ioprio_set_idle() {
-    return ioprio_set(IOPOL_UTILITY);
-}
-
-#endif
-
-
-#if HAVE_WINDOWS_IOPRIO
-
-#include <windows.h>
-#include <io.h>
-#include <cstddef>
-#include <cstdint>
-#include <cstdio>
-
-bool ioprio_set_file_idle(FILE * const F) {
-    FILE_IO_PRIORITY_HINT_INFO priorityHint = {
-        .PriorityHint = IoPriorityHintLow,
-    };
-    intptr_t osfhandle = _get_osfhandle(_fileno(F));
-    if (osfhandle == (intptr_t)INVALID_HANDLE_VALUE || osfhandle == (intptr_t)-2) {
-        return false;
-    }
-    HANDLE hFile = (HANDLE)osfhandle;
-
-    return SetFileInformationByHandle(hFile, FileIoPriorityHintInfo, &priorityHint, sizeof(priorityHint));
-}
-
-#endif
diff --git a/src/util/ioprio.h b/src/util/ioprio.h
deleted file mode 100644
index 1496f59da5..0000000000
--- a/src/util/ioprio.h
+++ /dev/null
@@ -1,63 +0,0 @@
-// Copyright (c) 2016 Satoshi Nakamoto
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#ifndef BITCOIN_UTIL_IOPRIO_H
-#define BITCOIN_UTIL_IOPRIO_H
-
-#if defined(HAVE_CONFIG_H)
-#include <config/bitcoin-config.h>
-#endif
-
-#include <logging.h>
-
-#if HAVE_IOPRIO_SYSCALL || HAVE_IOPOLICY
-int ioprio_get();
-int ioprio_set(int ioprio);
-int ioprio_set_idle();
-
-class ioprio_idler {
-private:
-    int orig;
-
-public:
-    ioprio_idler(const bool lowprio) {
-        if (!lowprio) {
-            orig = -1;
-            return;
-        }
-
-        orig = ioprio_get();
-        if (orig == -1) {
-            return;
-        }
-        if (ioprio_set_idle() == -1) {
-            orig = -1;
-        }
-    }
-
-    ~ioprio_idler() {
-        if (orig == -1) {
-            return;
-        }
-        if (ioprio_set(orig) == -1) {
-            LogPrintf("failed to restore ioprio\n");
-        }
-    }
-};
-#define IOPRIO_IDLER(lowprio)  ioprio_idler ioprio_idler_(lowprio)
-
-#else
-#define ioprio_get() ((void)-1)
-#define ioprio_set(ioprio) ((void)-1)
-#define ioprio_set_idle() ((void)-1)
-#define IOPRIO_IDLER(lowprio)  (void)lowprio;
-#endif
-
-#if HAVE_WINDOWS_IOPRIO
-bool ioprio_set_file_idle(FILE *);
-#else
-#define ioprio_set_file_idle(f)  ((void)false)
-#endif
-
-#endif // BITCOIN_UTIL_IOPRIO_H
diff --git a/src/util/strencodings.cpp b/src/util/strencodings.cpp
index a9520297b4..e030262a32 100644
--- a/src/util/strencodings.cpp
+++ b/src/util/strencodings.cpp
@@ -3,7 +3,6 @@
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
-#include <tinyformat.h>
 #include <util/strencodings.h>
 
 #include <crypto/hex_base.h>
@@ -26,17 +25,14 @@ static const std::string SAFE_CHARS[] =
     CHARS_ALPHA_NUM + " .,;-_?@", // SAFE_CHARS_UA_COMMENT
     CHARS_ALPHA_NUM + ".-_", // SAFE_CHARS_FILENAME
     CHARS_ALPHA_NUM + "!*'();:@&=+$,/?#[]-_.~%", // SAFE_CHARS_URI
-    CHARS_ALPHA_NUM + " .,;-_/:?@()!\"#$%&'*+<=>[\\]^`{|}~"  // SAFE_CHARS_PRINTABLE
 };
 
-std::string SanitizeString(std::string_view str, int rule, bool escape)
+std::string SanitizeString(std::string_view str, int rule)
 {
     std::string result;
     for (char c : str) {
-        if (SAFE_CHARS[rule].find(c) != std::string::npos || (c == '%' && escape)) {
+        if (SAFE_CHARS[rule].find(c) != std::string::npos) {
             result.push_back(c);
-        } else if (escape) {
-            result += strprintf("%%%02X", c);
         }
     }
     return result;
diff --git a/src/util/strencodings.h b/src/util/strencodings.h
index d546f18280..e5c2d3ddf2 100644
--- a/src/util/strencodings.h
+++ b/src/util/strencodings.h
@@ -31,7 +31,6 @@ enum SafeChars
     SAFE_CHARS_UA_COMMENT, //!< BIP-0014 subset
     SAFE_CHARS_FILENAME, //!< Chars allowed in filenames
     SAFE_CHARS_URI, //!< Chars allowed in URIs (RFC 3986)
-    SAFE_CHARS_PRINTABLE, //!< The full set of printable chars
 };
 
 /**
@@ -58,7 +57,7 @@ enum class ByteUnit : uint64_t {
 * @param[in] rule   The set of safe chars to choose (default: least restrictive)
 * @return           A new string without unsafe chars
 */
-std::string SanitizeString(std::string_view str, int rule = SAFE_CHARS_DEFAULT, bool escape = false);
+std::string SanitizeString(std::string_view str, int rule = SAFE_CHARS_DEFAULT);
 /** Parse the hex string into bytes (uint8_t or std::byte). Ignores whitespace. Returns nullopt on invalid input. */
 template <typename Byte = std::byte>
 std::optional<std::vector<Byte>> TryParseHex(std::string_view str);
diff --git a/src/util/subprocess.h b/src/util/subprocess.h
index 48b29cf09a..3449fa3b1b 100644
--- a/src/util/subprocess.h
+++ b/src/util/subprocess.h
@@ -36,8 +36,6 @@ Documentation for C++ subprocessing library.
 #ifndef BITCOIN_UTIL_SUBPROCESS_H
 #define BITCOIN_UTIL_SUBPROCESS_H
 
-#include <util/fs.h>
-#include <util/strencodings.h>
 #include <util/syserror.h>
 
 #include <algorithm>
@@ -57,7 +55,7 @@ Documentation for C++ subprocessing library.
 #include <string>
 #include <vector>
 
-#ifdef WIN32
+#if (defined _MSC_VER) || (defined __MINGW32__)
   #define __USING_WINDOWS__
 #endif
 
@@ -67,20 +65,16 @@ Documentation for C++ subprocessing library.
 
 extern "C" {
 #ifdef __USING_WINDOWS__
-  #include <windows.h>
+  #include <Windows.h>
   #include <io.h>
   #include <cwchar>
 
-  #define subprocess_close _close
-  #define subprocess_open _open
-  #define subprocess_fileno _fileno
+  #define close _close
+  #define open _open
+  #define fileno _fileno
 #else
   #include <sys/wait.h>
   #include <unistd.h>
-
-  #define subprocess_close close
-  #define subprocess_open open
-  #define subprocess_fileno fileno
 #endif
   #include <csignal>
   #include <fcntl.h>
@@ -175,7 +169,7 @@ namespace util
     //
 
     if (force == false && argument.empty() == false &&
-        argument.find_first_of(L" \t\n\v") == argument.npos) {
+        argument.find_first_of(L" \t\n\v\"") == argument.npos) {
       command_line.append(argument);
     }
     else {
@@ -417,7 +411,7 @@ namespace util
 #ifdef __USING_WINDOWS__
     return (int)fread(buf, 1, read_upto, fp);
 #else
-    int fd = subprocess_fileno(fp);
+    int fd = fileno(fp);
     int rbytes = 0;
     int eintr_cnter = 0;
 
@@ -526,20 +520,6 @@ namespace util
  * -------------------------------
  */
 
-/*!
- * Option to close all file descriptors
- * when the child process is spawned.
- * The close fd list does not include
- * input/output/error if they are explicitly
- * set as part of the Popen arguments.
- *
- * Default value is false.
- */
-struct close_fds {
-  explicit close_fds(bool c): close_all(c) {}
-  bool close_all = false;
-};
-
 /*!
  * Base class for all arguments involving string value.
  */
@@ -593,10 +573,10 @@ struct input
   explicit input(int fd): rd_ch_(fd) {}
 
   // FILE pointer.
-  explicit input (FILE* fp):input(subprocess_fileno(fp)) { assert(fp); }
+  explicit input (FILE* fp):input(fileno(fp)) { assert(fp); }
 
   explicit input(const char* filename) {
-    int fd = subprocess_open(filename, O_RDONLY);
+    int fd = open(filename, O_RDONLY);
     if (fd == -1) throw OSError("File not found: ", errno);
     rd_ch_ = fd;
   }
@@ -626,10 +606,10 @@ struct output
 {
   explicit output(int fd): wr_ch_(fd) {}
 
-  explicit output (FILE* fp):output(subprocess_fileno(fp)) { assert(fp); }
+  explicit output (FILE* fp):output(fileno(fp)) { assert(fp); }
 
   explicit output(const char* filename) {
-    int fd = subprocess_open(filename, O_APPEND | O_CREAT | O_RDWR, 0640);
+    int fd = open(filename, O_APPEND | O_CREAT | O_RDWR, 0640);
     if (fd == -1) throw OSError("File not found: ", errno);
     wr_ch_ = fd;
   }
@@ -657,10 +637,10 @@ struct error
 {
   explicit error(int fd): wr_ch_(fd) {}
 
-  explicit error(FILE* fp):error(subprocess_fileno(fp)) { assert(fp); }
+  explicit error(FILE* fp):error(fileno(fp)) { assert(fp); }
 
   explicit error(const char* filename) {
-    int fd = subprocess_open(filename, O_APPEND | O_CREAT | O_RDWR, 0640);
+    int fd = open(filename, O_APPEND | O_CREAT | O_RDWR, 0640);
     if (fd == -1) throw OSError("File not found: ", errno);
     wr_ch_ = fd;
   }
@@ -737,7 +717,6 @@ struct ArgumentDeducer
   void set_option(input&& inp);
   void set_option(output&& out);
   void set_option(error&& err);
-  void set_option(close_fds&& cfds);
 
 private:
   Popen* popen_ = nullptr;
@@ -824,28 +803,28 @@ public:
   void cleanup_fds()
   {
     if (write_to_child_ != -1 && read_from_parent_ != -1) {
-      subprocess_close(write_to_child_);
+      close(write_to_child_);
     }
     if (write_to_parent_ != -1 && read_from_child_ != -1) {
-      subprocess_close(read_from_child_);
+      close(read_from_child_);
     }
     if (err_write_ != -1 && err_read_ != -1) {
-      subprocess_close(err_read_);
+      close(err_read_);
     }
   }
 
   void close_parent_fds()
   {
-    if (write_to_child_ != -1)  subprocess_close(write_to_child_);
-    if (read_from_child_ != -1) subprocess_close(read_from_child_);
-    if (err_read_ != -1)        subprocess_close(err_read_);
+    if (write_to_child_ != -1)  close(write_to_child_);
+    if (read_from_child_ != -1) close(read_from_child_);
+    if (err_read_ != -1)        close(err_read_);
   }
 
   void close_child_fds()
   {
-    if (write_to_parent_ != -1)  subprocess_close(write_to_parent_);
-    if (read_from_parent_ != -1) subprocess_close(read_from_parent_);
-    if (err_write_ != -1)        subprocess_close(err_write_);
+    if (write_to_parent_ != -1)  close(write_to_parent_);
+    if (read_from_parent_ != -1) close(read_from_parent_);
+    if (err_write_ != -1)        close(err_write_);
   }
 
   FILE* input()  { return input_.get(); }
@@ -923,8 +902,6 @@ private:
  *    Command provided in a single string.
  * wait()             - Wait for the child to exit.
  * retcode()          - The return code of the exited child.
- * poll()             - Check the status of the running child.
- * kill(sig_num)      - Kill the child. SIGTERM used by default.
  * send(...)          - Send input to the input channel of the child.
  * communicate(...)   - Get the output/error from the child and close the channels
  *                      from the parent side.
@@ -975,12 +952,6 @@ public:
 
   int wait() noexcept(false);
 
-  int poll() noexcept(false);
-
-  // Does not fail, Caller is expected to recheck the
-  // status with a call to poll()
-  void kill(int sig_num = 9);
-
   void set_out_buf_cap(size_t cap) { stream_.set_out_buf_cap(cap); }
 
   void set_err_buf_cap(size_t cap) { stream_.set_err_buf_cap(cap); }
@@ -1033,8 +1004,6 @@ private:
   std::future<void> cleanup_future_;
 #endif
 
-  bool close_fds_ = false;
-
   std::string exe_name_;
 
   // Command in string format
@@ -1043,7 +1012,6 @@ private:
   std::vector<std::string> vargs_;
   std::vector<char*> cargv_;
 
-  bool child_created_ = false;
   // Pid of the child process
   int child_pid_ = -1;
 
@@ -1074,15 +1042,8 @@ inline int Popen::wait() noexcept(false)
 {
 #ifdef __USING_WINDOWS__
   int ret = WaitForSingleObject(process_handle_, INFINITE);
-  if (ret != WAIT_OBJECT_0) return -1;
 
-  DWORD dretcode_;
-  if (FALSE == GetExitCodeProcess(process_handle_, &dretcode_))
-      throw OSError("GetExitCodeProcess", 0);
-
-  CloseHandle(process_handle_);
-
-  return (int)dretcode_;
+  return 0;
 #else
   int ret, status;
   std::tie(ret, status) = util::wait_for_child_exit(child_pid_);
@@ -1098,68 +1059,6 @@ inline int Popen::wait() noexcept(false)
 #endif
 }
 
-inline int Popen::poll() noexcept(false)
-{
-#ifdef __USING_WINDOWS__
-  int ret = WaitForSingleObject(process_handle_, 0);
-  if (ret != WAIT_OBJECT_0) return -1;
-
-  DWORD dretcode_;
-  if (FALSE == GetExitCodeProcess(process_handle_, &dretcode_))
-      throw OSError("GetExitCodeProcess", 0);
-
-  retcode_ = (int)dretcode_;
-  CloseHandle(process_handle_);
-
-  return retcode_;
-#else
-  if (!child_created_) return -1; // TODO: ??
-
-  int status;
-
-  // Returns zero if child is still running
-  int ret = waitpid(child_pid_, &status, WNOHANG);
-  if (ret == 0) return -1;
-
-  if (ret == child_pid_) {
-    if (WIFSIGNALED(status)) {
-      retcode_ = WTERMSIG(status);
-    } else if (WIFEXITED(status)) {
-      retcode_ = WEXITSTATUS(status);
-    } else {
-      retcode_ = 255;
-    }
-    return retcode_;
-  }
-
-  if (ret == -1) {
-    // From subprocess.py
-    // This happens if SIGCHLD is set to be ignored
-    // or waiting for child process has otherwise been disabled
-    // for our process. This child is dead, we cannot get the
-    // status.
-    if (errno == ECHILD) retcode_ = 0;
-    else throw OSError("waitpid failed", errno);
-  } else {
-    retcode_ = ret;
-  }
-
-  return retcode_;
-#endif
-}
-
-inline void Popen::kill(int sig_num)
-{
-#ifdef __USING_WINDOWS__
-  if (!TerminateProcess(this->process_handle_, (UINT)sig_num)) {
-    throw OSError("TerminateProcess", 0);
-  }
-#else
-  ::kill(child_pid_, sig_num);
-#endif
-}
-
-
 inline void Popen::execute_process() noexcept(false)
 {
 #ifdef __USING_WINDOWS__
@@ -1257,27 +1156,25 @@ inline void Popen::execute_process() noexcept(false)
   child_pid_ = fork();
 
   if (child_pid_ < 0) {
-    subprocess_close(err_rd_pipe);
-    subprocess_close(err_wr_pipe);
+    close(err_rd_pipe);
+    close(err_wr_pipe);
     throw OSError("fork failed", errno);
   }
 
-  child_created_ = true;
-
   if (child_pid_ == 0)
   {
     // Close descriptors belonging to parent
     stream_.close_parent_fds();
 
     //Close the read end of the error pipe
-    subprocess_close(err_rd_pipe);
+    close(err_rd_pipe);
 
     detail::Child chld(this, err_wr_pipe);
     chld.execute_child();
   }
   else
   {
-    subprocess_close(err_wr_pipe);// close child side of pipe, else get stuck in read below
+    close (err_wr_pipe);// close child side of pipe, else get stuck in read below
 
     stream_.close_child_fds();
 
@@ -1288,7 +1185,7 @@ inline void Popen::execute_process() noexcept(false)
                                   fdopen(err_rd_pipe, "r"),
                                   err_buf,
                                   SP_MAX_ERR_BUF_SIZ);
-      subprocess_close(err_rd_pipe);
+      close(err_rd_pipe);
 
       if (read_bytes || strlen(err_buf)) {
         // Call waitpid to reap the child process
@@ -1336,10 +1233,6 @@ namespace detail {
     if (err.rd_ch_ != -1) popen_->stream_.err_read_ = err.rd_ch_;
   }
 
-  inline void ArgumentDeducer::set_option(close_fds&& cfds) {
-    popen_->close_fds_ = cfds.close_all;
-  }
-
 
   inline void Child::execute_child() {
 #ifndef __USING_WINDOWS__
@@ -1378,32 +1271,13 @@ namespace detail {
 
       // Close the duped descriptors
       if (stream.read_from_parent_ != -1 && stream.read_from_parent_ > 2)
-        subprocess_close(stream.read_from_parent_);
+        close(stream.read_from_parent_);
 
       if (stream.write_to_parent_ != -1 && stream.write_to_parent_ > 2)
-        subprocess_close(stream.write_to_parent_);
+        close(stream.write_to_parent_);
 
       if (stream.err_write_ != -1 && stream.err_write_ > 2)
-        subprocess_close(stream.err_write_);
-
-      // Close all the inherited fd's except the error write pipe
-      if (parent_->close_fds_) {
-        try {
-            std::vector<int> fds_to_close;
-            for (const auto& it : fs::directory_iterator("/proc/self/fd")) {
-                int64_t fd;
-                if (!ParseInt64(it.path().filename().native(), &fd)) continue;
-                if (fd <= 2) continue;  // leave std{in,out,err} alone
-                if (fd == err_wr_pipe_) continue;
-                fds_to_close.push_back(fd);
-            }
-            for (const int fd : fds_to_close) {
-                close(fd);
-            }
-        } catch (...) {
-            // TODO: maybe log this - but we're in a child process, so maybe non-trivial!
-        }
-      }
+        close(stream.err_write_);
 
       // Replace the current image with the executable
       sys_ret = execvp(parent_->exe_name_.c_str(), parent_->cargv_.data());
diff --git a/src/util/time.cpp b/src/util/time.cpp
index 0dd518a512..f08eb5300a 100644
--- a/src/util/time.cpp
+++ b/src/util/time.cpp
@@ -1,34 +1,19 @@
 // Copyright (c) 2009-2010 Satoshi Nakamoto
-// Copyright (c) 2009-present The Bitcoin Core developers
+// Copyright (c) 2009-2022 The Bitcoin Core developers
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
-#include <config/bitcoin-config.h> // IWYU pragma: keep
-
 #include <util/time.h>
 
 #include <compat/compat.h>
 #include <tinyformat.h>
 #include <util/check.h>
-#include <util/strencodings.h>
 
 #include <atomic>
 #include <chrono>
-#include <optional>
 #include <string>
-#include <string_view>
 #include <thread>
 
-#ifdef HAVE_CLOCK_GETTIME
-#include <time.h>
-#elif defined(HAVE_GETTHREADTIMES)
-#include <windows.h>
-#include <winnt.h>
-
-#include <processthreadsapi.h>
-#endif
-
-
 void UninterruptibleSleep(const std::chrono::microseconds& n) { std::this_thread::sleep_for(n); }
 
 static std::atomic<std::chrono::seconds> g_mock_time{}; //!< For testing
@@ -75,38 +60,6 @@ std::string FormatISO8601Date(int64_t nTime)
     return strprintf("%04i-%02u-%02u", signed{ymd.year()}, unsigned{ymd.month()}, unsigned{ymd.day()});
 }
 
-std::optional<int64_t> ParseISO8601DateTime(std::string_view str)
-{
-    constexpr auto FMT_SIZE{std::string_view{"2000-01-01T01:01:01Z"}.size()};
-    if (str.size() != FMT_SIZE || str[4] != '-' || str[7] != '-' || str[10] != 'T' || str[13] != ':' || str[16] != ':' || str[19] != 'Z') {
-        return {};
-    }
-    const auto year{ToIntegral<uint16_t>(str.substr(0, 4))};
-    const auto month{ToIntegral<uint8_t>(str.substr(5, 2))};
-    const auto day{ToIntegral<uint8_t>(str.substr(8, 2))};
-    const auto hour{ToIntegral<uint8_t>(str.substr(11, 2))};
-    const auto min{ToIntegral<uint8_t>(str.substr(14, 2))};
-    const auto sec{ToIntegral<uint8_t>(str.substr(17, 2))};
-    if (!year || !month || !day || !hour || !min || !sec) {
-        return {};
-    }
-    const std::chrono::year_month_day ymd{std::chrono::year{*year}, std::chrono::month{*month}, std::chrono::day{*day}};
-    if (!ymd.ok()) {
-        return {};
-    }
-    const auto time{std::chrono::hours{*hour} + std::chrono::minutes{*min} + std::chrono::seconds{*sec}};
-    const auto tp{std::chrono::sys_days{ymd} + time};
-    return int64_t{TicksSinceEpoch<std::chrono::seconds>(tp)};
-}
-
-std::string FormatISO8601Time(int64_t nTime)
-{
-    const std::chrono::sys_seconds secs{std::chrono::seconds{nTime}};
-    const auto days{std::chrono::floor<std::chrono::days>(secs)};
-    const std::chrono::hh_mm_ss hms{secs - days};
-    return strprintf("%02i:%02i:%02iZ", hms.hours().count(), hms.minutes().count(), hms.seconds().count());
-}
-
 struct timeval MillisToTimeval(int64_t nTimeout)
 {
     struct timeval timeout;
@@ -119,62 +72,3 @@ struct timeval MillisToTimeval(std::chrono::milliseconds ms)
 {
     return MillisToTimeval(count_milliseconds(ms));
 }
-
-std::chrono::nanoseconds ThreadCpuTime()
-{
-#ifdef HAVE_CLOCK_GETTIME
-    // An alternative to clock_gettime() is getrusage().
-
-    timespec t;
-    if (clock_gettime(CLOCK_THREAD_CPUTIME_ID, &t) == -1) {
-        return std::chrono::nanoseconds{0};
-    }
-    return std::chrono::seconds{t.tv_sec} + std::chrono::nanoseconds{t.tv_nsec};
-#elif defined(HAVE_GETTHREADTIMES)
-    // An alternative to GetThreadTimes() is QueryThreadCycleTime() but it
-    // counts CPU cycles.
-
-    FILETIME creation;
-    FILETIME exit;
-    FILETIME kernel;
-    FILETIME user;
-    // GetThreadTimes():
-    // https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadtimes
-    if (GetThreadTimes(GetCurrentThread(), &creation, &exit, &kernel, &user) == 0) {
-        return std::chrono::nanoseconds{0};
-    }
-
-    // https://learn.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-filetime
-    // "... you should copy the low- and high-order parts of the file time to a
-    // ULARGE_INTEGER structure, perform 64-bit arithmetic on the QuadPart
-    // member ..."
-
-    ULARGE_INTEGER kernel_;
-    kernel_.LowPart = kernel.dwLowDateTime;
-    kernel_.HighPart = kernel.dwHighDateTime;
-
-    ULARGE_INTEGER user_;
-    user_.LowPart = user.dwLowDateTime;
-    user_.HighPart = user.dwHighDateTime;
-
-    // https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadtimes
-    // "Thread kernel mode and user mode times are amounts of time. For example,
-    // if a thread has spent one second in kernel mode, this function will fill
-    // the FILETIME structure specified by lpKernelTime with a 64-bit value of
-    // ten million. That is the number of 100-nanosecond units in one second."
-    return std::chrono::nanoseconds{(kernel_.QuadPart + user_.QuadPart) * 100};
-#else
-    return std::chrono::nanoseconds{0};
-#endif
-}
-
-std::chrono::nanoseconds operator+=(std::atomic<std::chrono::nanoseconds>& a, std::chrono::nanoseconds b)
-{
-    std::chrono::nanoseconds expected;
-    std::chrono::nanoseconds desired;
-    do {
-        expected = a.load();
-        desired = expected + b;
-    } while (!a.compare_exchange_weak(expected, desired));
-    return desired;
-}
diff --git a/src/util/time.h b/src/util/time.h
index 87f0a2dedc..108560e0e0 100644
--- a/src/util/time.h
+++ b/src/util/time.h
@@ -1,18 +1,14 @@
 // Copyright (c) 2009-2010 Satoshi Nakamoto
-// Copyright (c) 2009-present The Bitcoin Core developers
+// Copyright (c) 2009-2022 The Bitcoin Core developers
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
 #ifndef BITCOIN_UTIL_TIME_H
 #define BITCOIN_UTIL_TIME_H
 
-#include <atomic>
 #include <chrono> // IWYU pragma: export
 #include <cstdint>
-#include <functional>
-#include <optional>
 #include <string>
-#include <string_view>
 
 using namespace std::chrono_literals;
 
@@ -109,8 +105,6 @@ T GetTime()
  */
 std::string FormatISO8601DateTime(int64_t nTime);
 std::string FormatISO8601Date(int64_t nTime);
-std::string FormatISO8601Time(int64_t nTime);
-std::optional<int64_t> ParseISO8601DateTime(std::string_view str);
 
 /**
  * Convert milliseconds to a struct timeval for e.g. select.
@@ -122,46 +116,4 @@ struct timeval MillisToTimeval(int64_t nTimeout);
  */
 struct timeval MillisToTimeval(std::chrono::milliseconds ms);
 
-/**
- * Retrieve the CPU time (user + system) spent by the current thread.
- */
-std::chrono::nanoseconds ThreadCpuTime();
-
-/**
- * Measure CPU time spent by the current thread.
- * A clock is started when a CpuTimer is created. When the object is destroyed
- * the elapsed CPU time is calculated and a callback function is invoked,
- * providing it the elapsed CPU time.
- */
-class CpuTimer
-{
-public:
-    using FinishedCB = std::function<void(std::chrono::nanoseconds)>;
-
-    /**
-     * Construct a timer.
-     * @param[in] finished_cb A callback to invoke when this object is destroyed.
-     */
-    CpuTimer(const FinishedCB& finished_cb)
-        : m_start{ThreadCpuTime()},
-          m_finished_cb{finished_cb}
-    {
-    }
-
-    ~CpuTimer()
-    {
-        m_finished_cb(ThreadCpuTime() - m_start);
-    }
-
-private:
-    const std::chrono::nanoseconds m_start;
-    FinishedCB m_finished_cb;
-};
-
-/**
- * Add `b` nanoseconds to a nanoseconds atomic.
- * @return The value of `a` immediately after the operation.
- */
-std::chrono::nanoseconds operator+=(std::atomic<std::chrono::nanoseconds>& a, std::chrono::nanoseconds b);
-
 #endif // BITCOIN_UTIL_TIME_H
diff --git a/src/validation.cpp b/src/validation.cpp
index 388ba9de56..59beb5cbda 100644
--- a/src/validation.cpp
+++ b/src/validation.cpp
@@ -11,7 +11,6 @@
 #include <chain.h>
 #include <checkqueue.h>
 #include <clientversion.h>
-#include <common/system.h>
 #include <consensus/amount.h>
 #include <consensus/consensus.h>
 #include <consensus/merkle.h>
@@ -33,7 +32,6 @@
 #include <logging/timer.h>
 #include <node/blockstorage.h>
 #include <node/utxo_snapshot.h>
-#include <policy/coin_age_priority.h>
 #include <policy/policy.h>
 #include <policy/rbf.h>
 #include <policy/settings.h>
@@ -45,7 +43,6 @@
 #include <script/script.h>
 #include <script/sigcache.h>
 #include <signet.h>
-#include <stats/stats.h>
 #include <tinyformat.h>
 #include <txdb.h>
 #include <txmempool.h>
@@ -55,7 +52,6 @@
 #include <util/fs.h>
 #include <util/fs_helpers.h>
 #include <util/hasher.h>
-#include <util/ioprio.h>
 #include <util/moneystr.h>
 #include <util/rbf.h>
 #include <util/result.h>
@@ -90,8 +86,6 @@ using node::CBlockIndexHeightOnlyComparator;
 using node::CBlockIndexWorkComparator;
 using node::SnapshotMetadata;
 
-/** Size threshold for warning about slow UTXO set flush to disk. */
-static constexpr size_t WARN_FLUSH_COINS_SIZE = 1 << 30; // 1 GiB
 /** Time to wait between writing blocks/block index to disk. */
 static constexpr std::chrono::hours DATABASE_WRITE_INTERVAL{1};
 /** Time to wait between flushing chainstate to disk. */
@@ -106,11 +100,16 @@ const std::vector<std::string> CHECKLEVEL_DOC {
     "level 4 tries to reconnect the blocks",
     "each level includes the checks of the previous levels",
 };
+/** The number of blocks to keep below the deepest prune lock.
+ *  There is nothing special about this number. It is higher than what we
+ *  expect to see in regular mainnet reorgs, but not so high that it would
+ *  noticeably interfere with the pruning mechanism.
+ * */
+static constexpr int PRUNE_LOCK_BUFFER{10};
 
 GlobalMutex g_best_block_mutex;
 std::condition_variable g_best_block_cv;
 uint256 g_best_block;
-SpkReuseModes SpkReuseMode;
 
 const CBlockIndex* Chainstate::FindForkInGlobalIndex(const CBlockLocator& locator) const
 {
@@ -263,39 +262,7 @@ bool CheckSequenceLocksAtTip(CBlockIndex* tip,
 // Returns the script flags which should be checked for a given block
 static unsigned int GetBlockScriptFlags(const CBlockIndex& block_index, const ChainstateManager& chainman);
 
-/** Compute accurate total signature operation cost of a transaction.
- *  Not consensus-critical, since legacy sigops counting is always used in the protocol.
- */
-int64_t GetAccurateTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, int flags)
-{
-    if (tx.IsCoinBase()) {
-        return 0;
-    }
-
-    unsigned int nSigOps = 0;
-    for (const auto& txin : tx.vin) {
-        nSigOps += txin.scriptSig.GetSigOpCount(false);
-    }
-
-    if (flags & SCRIPT_VERIFY_P2SH) {
-        nSigOps += GetP2SHSigOpCount(tx, inputs);
-    }
-
-    nSigOps *= WITNESS_SCALE_FACTOR;
-
-    if (flags & SCRIPT_VERIFY_WITNESS) {
-        for (const auto& txin : tx.vin) {
-            const Coin& coin = inputs.AccessCoin(txin.prevout);
-            assert(!coin.IsSpent());
-            const CTxOut &prevout = coin.out;
-            nSigOps += CountWitnessSigOps(txin.scriptSig, prevout.scriptPubKey, &txin.scriptWitness, flags);
-        }
-    }
-
-    return nSigOps;
-}
-
-void LimitMempoolSize(CTxMemPool& pool, CCoinsViewCache& coins_cache)
+static void LimitMempoolSize(CTxMemPool& pool, CCoinsViewCache& coins_cache)
     EXCLUSIVE_LOCKS_REQUIRED(::cs_main, pool.cs)
 {
     AssertLockHeld(::cs_main);
@@ -482,7 +449,7 @@ public:
     struct ATMPArgs {
         const CChainParams& m_chainparams;
         const int64_t m_accept_time;
-        const ignore_rejects_type& m_ignore_rejects;
+        const bool m_bypass_limits;
         /*
          * Return any outpoints which were not previously present in the coins
          * cache, but were added as a result of validating the tx for mempool
@@ -519,11 +486,11 @@ public:
 
         /** Parameters for single transaction mempool validation. */
         static ATMPArgs SingleAccept(const CChainParams& chainparams, int64_t accept_time,
-                                     const ignore_rejects_type& ignore_rejects, std::vector<COutPoint>& coins_to_uncache,
+                                     bool bypass_limits, std::vector<COutPoint>& coins_to_uncache,
                                      bool test_accept) {
             return ATMPArgs{/* m_chainparams */ chainparams,
                             /* m_accept_time */ accept_time,
-                            /* m_ignore_rejects */ ignore_rejects,
+                            /* m_bypass_limits */ bypass_limits,
                             /* m_coins_to_uncache */ coins_to_uncache,
                             /* m_test_accept */ test_accept,
                             /* m_allow_replacement */ true,
@@ -537,10 +504,10 @@ public:
 
         /** Parameters for test package mempool validation through testmempoolaccept. */
         static ATMPArgs PackageTestAccept(const CChainParams& chainparams, int64_t accept_time,
-                                          const ignore_rejects_type& ignore_rejects, std::vector<COutPoint>& coins_to_uncache) {
+                                          std::vector<COutPoint>& coins_to_uncache) {
             return ATMPArgs{/* m_chainparams */ chainparams,
                             /* m_accept_time */ accept_time,
-                            /* m_ignore_rejects */ ignore_rejects,
+                            /* m_bypass_limits */ false,
                             /* m_coins_to_uncache */ coins_to_uncache,
                             /* m_test_accept */ true,
                             /* m_allow_replacement */ false,
@@ -554,10 +521,10 @@ public:
 
         /** Parameters for child-with-unconfirmed-parents package validation. */
         static ATMPArgs PackageChildWithParents(const CChainParams& chainparams, int64_t accept_time,
-                                                std::vector<COutPoint>& coins_to_uncache, const std::optional<CFeeRate>& client_maxfeerate, const ignore_rejects_type& ignore_rejects) {
+                                                std::vector<COutPoint>& coins_to_uncache, const std::optional<CFeeRate>& client_maxfeerate) {
             return ATMPArgs{/* m_chainparams */ chainparams,
                             /* m_accept_time */ accept_time,
-                            /* m_ignore_rejects */ ignore_rejects,
+                            /* m_bypass_limits */ false,
                             /* m_coins_to_uncache */ coins_to_uncache,
                             /* m_test_accept */ false,
                             /* m_allow_replacement */ true,
@@ -573,7 +540,7 @@ public:
         static ATMPArgs SingleInPackageAccept(const ATMPArgs& package_args) {
             return ATMPArgs{/* m_chainparams */ package_args.m_chainparams,
                             /* m_accept_time */ package_args.m_accept_time,
-                            empty_ignore_rejects,
+                            /* m_bypass_limits */ false,
                             /* m_coins_to_uncache */ package_args.m_coins_to_uncache,
                             /* m_test_accept */ package_args.m_test_accept,
                             /* m_allow_replacement */ true,
@@ -590,7 +557,7 @@ public:
         // mixing up the order of the arguments. Use static functions above instead.
         ATMPArgs(const CChainParams& chainparams,
                  int64_t accept_time,
-                 const ignore_rejects_type& ignore_rejects,
+                 bool bypass_limits,
                  std::vector<COutPoint>& coins_to_uncache,
                  bool test_accept,
                  bool allow_replacement,
@@ -601,7 +568,7 @@ public:
                  bool allow_carveouts)
             : m_chainparams{chainparams},
               m_accept_time{accept_time},
-              m_ignore_rejects{ignore_rejects},
+              m_bypass_limits{bypass_limits},
               m_coins_to_uncache{coins_to_uncache},
               m_test_accept{test_accept},
               m_allow_replacement{allow_replacement},
@@ -661,8 +628,7 @@ private:
         explicit Workspace(const CTransactionRef& ptx) : m_ptx(ptx), m_hash(ptx->GetHash()) {}
         /** Txids of mempool transactions that this transaction directly conflicts with or may
          * replace via sibling eviction. */
-        /** .second=true is a consensus conflict, and .second=false is a policy conflict. */
-        std::map<Txid, bool> m_conflicts_incl_policy;
+        std::set<Txid> m_conflicts;
         /** Iterators to mempool entries that this transaction directly conflicts with or may
          * replace via sibling eviction. */
         CTxMemPool::setEntries m_iters_conflicting;
@@ -697,23 +663,6 @@ private:
         PrecomputedTransactionData m_precomputed_txdata;
     };
 
-    static inline bool MaybeReject_(TxValidationResult reason, const std::string& reason_str, const std::string& debug_msg, const ignore_rejects_type& ignore_rejects, TxValidationState& state) {
-        if (ignore_rejects.count(reason_str)) {
-            return false;
-        }
-
-        state.Invalid(reason, reason_str, debug_msg);
-        return true;
-    }
-
-#define MaybeRejectDbg(reason, reason_str, debug_msg)  do {  \
-    if (MaybeReject_(reason, reason_str, debug_msg, ignore_rejects, state)) {  \
-        return false;  \
-    }  \
-} while(0)
-
-#define MaybeReject(reason, reason_str)  MaybeRejectDbg(reason, reason_str, "")
-
     // Run the policy checks on a given transaction, excluding any script checks.
     // Looks up inputs, calculates feerate, considers replacement, evaluates
     // package limits, etc. As this function can be invoked for "free" by a peer,
@@ -721,11 +670,11 @@ private:
     bool PreChecks(ATMPArgs& args, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);
 
     // Run checks for mempool replace-by-fee, only used in AcceptSingleTransaction.
-    bool ReplacementChecks(ATMPArgs& args, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);
+    bool ReplacementChecks(Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);
 
     // Enforce package mempool ancestor/descendant limits (distinct from individual
     // ancestor/descendant limits done in PreChecks) and run Package RBF checks.
-    bool PackageMempoolChecks(const ATMPArgs& args, const std::vector<CTransactionRef>& txns,
+    bool PackageMempoolChecks(const std::vector<CTransactionRef>& txns,
                               std::vector<Workspace>& workspaces,
                               int64_t total_vsize,
                               PackageValidationState& package_state) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);
@@ -753,16 +702,16 @@ private:
          EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);
 
     // Compare a package's feerate against minimum allowed.
-    bool CheckFeeRate(size_t package_size, CAmount package_fee, TxValidationState& state, const ignore_rejects_type& ignore_rejects) EXCLUSIVE_LOCKS_REQUIRED(::cs_main, m_pool.cs)
+    bool CheckFeeRate(size_t package_size, CAmount package_fee, TxValidationState& state) EXCLUSIVE_LOCKS_REQUIRED(::cs_main, m_pool.cs)
     {
         AssertLockHeld(::cs_main);
         AssertLockHeld(m_pool.cs);
         CAmount mempoolRejectFee = m_pool.GetMinFee().GetFee(package_size);
-        if (mempoolRejectFee > 0 && package_fee < mempoolRejectFee && !ignore_rejects.count(rejectmsg_lowfee_mempool)) {
+        if (mempoolRejectFee > 0 && package_fee < mempoolRejectFee) {
             return state.Invalid(TxValidationResult::TX_RECONSIDERABLE, "mempool min fee not met", strprintf("%d < %d", package_fee, mempoolRejectFee));
         }
 
-        if (package_fee < m_pool.m_opts.min_relay_feerate.GetFee(package_size) && !ignore_rejects.count(rejectmsg_lowfee_relay)) {
+        if (package_fee < m_pool.m_opts.min_relay_feerate.GetFee(package_size)) {
             return state.Invalid(TxValidationResult::TX_RECONSIDERABLE, "min relay fee not met",
                                  strprintf("%d < %d", package_fee, m_pool.m_opts.min_relay_feerate.GetFee(package_size)));
         }
@@ -827,7 +776,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)
 
     // Copy/alias what we need out of args
     const int64_t nAcceptTime = args.m_accept_time;
-    const ignore_rejects_type& ignore_rejects = args.m_ignore_rejects;
+    const bool bypass_limits = args.m_bypass_limits;
     std::vector<COutPoint>& coins_to_uncache = args.m_coins_to_uncache;
 
     // Alias what we need out of ws
@@ -842,25 +791,21 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)
     if (tx.IsCoinBase())
         return state.Invalid(TxValidationResult::TX_CONSENSUS, "coinbase");
 
-    if (tx.version == TRUC_VERSION && m_pool.m_opts.truc_policy == TRUCPolicy::Reject) {
-        return state.Invalid(TxValidationResult::TX_NOT_STANDARD, "version");
-    }
-
     // Rather not work on nonstandard transactions (unless -testnet/-regtest)
     std::string reason;
-    if (m_pool.m_opts.require_standard && !IsStandardTx(tx, m_pool.m_opts, reason, ignore_rejects)) {
+    if (m_pool.m_opts.require_standard && !IsStandardTx(tx, m_pool.m_opts.max_datacarrier_bytes, m_pool.m_opts.permit_bare_multisig, m_pool.m_opts.dust_relay_feerate, reason)) {
         return state.Invalid(TxValidationResult::TX_NOT_STANDARD, reason);
     }
 
     // Transactions smaller than 65 non-witness bytes are not relayed to mitigate CVE-2017-12842.
     if (::GetSerializeSize(TX_NO_WITNESS(tx)) < MIN_STANDARD_TX_NONWITNESS_SIZE)
-        MaybeReject(TxValidationResult::TX_NOT_STANDARD, "tx-size-small");
+        return state.Invalid(TxValidationResult::TX_NOT_STANDARD, "tx-size-small");
 
     // Only accept nLockTime-using transactions that can be mined in the next
     // block; we don't want our mempool filled up with transactions that can't
     // be mined yet.
     if (!CheckFinalTxAtTip(*Assert(m_active_chainstate.m_chain.Tip()), tx)) {
-        MaybeReject(TxValidationResult::TX_PREMATURE_SPEND, "non-final");
+        return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, "non-final");
     }
 
     if (m_pool.exists(GenTxid::Wtxid(tx.GetWitnessHash()))) {
@@ -872,12 +817,6 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)
         return state.Invalid(TxValidationResult::TX_CONFLICT, "txn-same-nonwitness-data-in-mempool");
     }
 
-    auto spk_reuse_mode = SpkReuseMode;
-    if (ignore_rejects.count("txn-spk-reused")) {
-        spk_reuse_mode = SRM_ALLOW;
-    }
-    SPKStates_t mapSPK;
-
     // Check for conflicts with in-memory transactions
     for (const CTxIn &txin : tx.vin)
     {
@@ -887,7 +826,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)
                 // Transaction conflicts with a mempool tx, but we're not allowing replacements.
                 return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, "bip125-replacement-disallowed");
             }
-            if (!ws.m_conflicts_incl_policy.count(ptxConflicting->GetHash()))
+            if (!ws.m_conflicts.count(ptxConflicting->GetHash()))
             {
                 // Transactions that don't explicitly signal replaceability are
                 // *not* replaceable with the current logic, even if one of their
@@ -901,42 +840,16 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)
                 //
                 // Replaceability signaling of the original transactions may be
                 // ignored due to node setting.
-                bool allow_rbf;
-                if (m_pool.m_opts.rbf_policy == RBFPolicy::Always || ignore_rejects.count("txn-mempool-conflict")) {
-                    allow_rbf = true;
-                } else if (m_pool.m_opts.rbf_policy == RBFPolicy::Never) {
-                    allow_rbf = false;
-                } else {
-                    allow_rbf = SignalsOptInRBF(*ptxConflicting) || ptxConflicting->version == TRUC_VERSION;
-                }
+                const bool allow_rbf{m_pool.m_opts.full_rbf || SignalsOptInRBF(*ptxConflicting) || ptxConflicting->version == TRUC_VERSION};
                 if (!allow_rbf) {
                     return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, "txn-mempool-conflict");
                 }
 
-                ws.m_conflicts_incl_policy.emplace(ptxConflicting->GetHash(), true);
+                ws.m_conflicts.insert(ptxConflicting->GetHash());
             }
         }
     }
 
-    if (spk_reuse_mode != SRM_ALLOW) {
-        for (const CTxOut& txout : tx.vout) {
-            uint160 hashSPK = ScriptHashkey(txout.scriptPubKey);
-            const auto& SPKUsedIn = m_pool.mapUsedSPK.find(hashSPK);
-            if (SPKUsedIn != m_pool.mapUsedSPK.end()) {
-                if (SPKUsedIn->second.first) {
-                    ws.m_conflicts_incl_policy.emplace(SPKUsedIn->second.first->GetHash(), false);
-                }
-                if (SPKUsedIn->second.second) {
-                    ws.m_conflicts_incl_policy.emplace(SPKUsedIn->second.second->GetHash(), false);
-                }
-            }
-            if (mapSPK.find(hashSPK) != mapSPK.end()) {
-                MaybeReject(TxValidationResult::TX_MEMPOOL_POLICY, "txn-spk-reused-twinoutputs");
-            }
-            mapSPK[hashSPK] = MemPool_SPK_State(mapSPK[hashSPK] | MSS_CREATED);
-        }
-    }
-
     m_view.SetBackend(m_viewmempool);
 
     const CCoinsViewCache& coins_cache = m_active_chainstate.CoinsTip();
@@ -979,7 +892,6 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)
     // Pass in m_view which has all of the relevant inputs cached. Note that, since m_view's
     // backend was removed, it no longer pulls coins from the mempool.
     const std::optional<LockPoints> lock_points{CalculateLockPointsAtTip(m_active_chainstate.m_chain.Tip(), m_view, tx)};
-    // NOTE: The miner doesn't check this again, so for now it may not be overridden.
     if (!lock_points.has_value() || !CheckSequenceLocksAtTip(m_active_chainstate.m_chain.Tip(), *lock_points)) {
         return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, "non-BIP68-final");
     }
@@ -989,56 +901,20 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)
         return false; // state filled in by CheckTxInputs
     }
 
-    if (spk_reuse_mode != SRM_ALLOW) {
-        for (const CTxIn& txin : tx.vin) {
-            const Coin &coin = m_view.AccessCoin(txin.prevout);
-            uint160 hashSPK = ScriptHashkey(coin.out.scriptPubKey);
-
-            SPKStates_t::iterator mssit = mapSPK.find(hashSPK);
-            if (mssit != mapSPK.end()) {
-                if (mssit->second & MSS_CREATED) {
-                    MaybeReject(TxValidationResult::TX_MEMPOOL_POLICY, "txn-spk-reused-change");
-                }
-            }
-            const auto& SPKit = m_pool.mapUsedSPK.find(hashSPK);
-            if (SPKit != m_pool.mapUsedSPK.end()) {
-                if (SPKit->second.second /* Spent */) {
-                    ws.m_conflicts_incl_policy.emplace(SPKit->second.second->GetHash(), false);
-                }
-            }
-            mapSPK[hashSPK] = MemPool_SPK_State(mapSPK[hashSPK] | MSS_SPENT);
-        }
-    }
-
-    if (m_pool.m_opts.require_standard && !AreInputsStandard(tx, m_view, "bad-txns-input-", reason, ignore_rejects)) {
-        return state.Invalid(TxValidationResult::TX_INPUTS_NOT_STANDARD, reason);
-    }
-
-    if (m_pool.m_opts.datacarrier_fullcount || !m_pool.m_opts.accept_non_std_datacarrier) {
-        const auto dcb = DatacarrierBytes(tx, m_view);
-        if (dcb.second > 0 && !(m_pool.m_opts.accept_non_std_datacarrier || ignore_rejects.count("txn-datacarrier-nonstandard"))) {
-            return state.Invalid(TxValidationResult::TX_INPUTS_NOT_STANDARD, "txn-datacarrier-nonstandard");
-        }
-        if (m_pool.m_opts.datacarrier_fullcount && (!ignore_rejects.count("txn-datacarrier-exceeded")) && dcb.first + dcb.second > m_pool.m_opts.max_datacarrier_bytes.value_or(0)) {
-            return state.Invalid(TxValidationResult::TX_INPUTS_NOT_STANDARD, "txn-datacarrier-exceeded");
-        }
+    if (m_pool.m_opts.require_standard && !AreInputsStandard(tx, m_view)) {
+        return state.Invalid(TxValidationResult::TX_INPUTS_NOT_STANDARD, "bad-txns-nonstandard-inputs");
     }
 
     // Check for non-standard witnesses.
-    if (tx.HasWitness() && m_pool.m_opts.require_standard && !IsWitnessStandard(tx, m_view, "bad-witness-", reason, ignore_rejects)) {
-        return state.Invalid(TxValidationResult::TX_WITNESS_MUTATED, reason);
+    if (tx.HasWitness() && m_pool.m_opts.require_standard && !IsWitnessStandard(tx, m_view)) {
+        return state.Invalid(TxValidationResult::TX_WITNESS_MUTATED, "bad-witness-nonstandard");
     }
 
     int64_t nSigOpsCost = GetTransactionSigOpCost(tx, m_view, STANDARD_SCRIPT_VERIFY_FLAGS);
 
     // ws.m_modified_fees includes any fee deltas from PrioritiseTransaction
     ws.m_modified_fees = ws.m_base_fees;
-    double nPriorityDummy{0};
-    m_pool.ApplyDeltas(hash, nPriorityDummy, ws.m_modified_fees);
-
-    CAmount inChainInputValue;
-    // Since entries arrive *after* the tip's height, their priority is for the height+1
-    const double coin_age = GetCoinAge(tx, m_view, m_active_chainstate.m_chain.Height() + 1, inChainInputValue);
+    m_pool.ApplyDelta(hash, ws.m_modified_fees);
 
     // Keep track of transactions that spend a coinbase, which we re-scan
     // during reorgs to ensure COINBASE_MATURITY is still met.
@@ -1051,23 +927,16 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)
         }
     }
 
-    // Set entry_sequence to 0 when rejectmsg_zero_mempool_entry_seq is used; this allows txs from a block
+    // Set entry_sequence to 0 when bypass_limits is used; this allows txs from a block
     // reorg to be marked earlier than any child txs that were already in the mempool.
-    const uint64_t entry_sequence = args.m_ignore_rejects.count(rejectmsg_zero_mempool_entry_seq) ? 0 : m_pool.GetSequence();
-    int32_t extra_weight = CalculateExtraTxWeight(*ptx, m_view, ::g_weight_per_data_byte);
+    const uint64_t entry_sequence = bypass_limits ? 0 : m_pool.GetSequence();
     entry.reset(new CTxMemPoolEntry(ptx, ws.m_base_fees, nAcceptTime, m_active_chainstate.m_chain.Height(), entry_sequence,
-                                    /*entry_tx_inputs_coin_age=*/coin_age,
-                                    inChainInputValue,
-                                    fSpendsCoinbase, extra_weight, nSigOpsCost, lock_points.value()));
+                                    fSpendsCoinbase, nSigOpsCost, lock_points.value()));
     ws.m_vsize = entry->GetTxSize();
-    entry->mapSPK = mapSPK;
 
-    // To avoid rejecting low-sigop bare-multisig transactions, the sigops
-    // are counted a second time more accurately.
-    if ((nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST) || (nBytesPerSigOpStrict && GetAccurateTransactionSigOpCost(tx, m_view, STANDARD_SCRIPT_VERIFY_FLAGS) > ws.m_vsize * WITNESS_SCALE_FACTOR / nBytesPerSigOpStrict)) {
-        MaybeRejectDbg(TxValidationResult::TX_NOT_STANDARD, "bad-txns-too-many-sigops",
+    if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)
+        return state.Invalid(TxValidationResult::TX_NOT_STANDARD, "bad-txns-too-many-sigops",
                 strprintf("%d", nSigOpsCost));
-    }
 
     // No individual transactions are allowed below the min relay feerate except from disconnected blocks.
     // This requirement, unlike CheckFeeRate, cannot be bypassed using m_package_feerates because,
@@ -1075,7 +944,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)
     // method of ensuring the tx remains bumped. For example, the fee-bumping child could disappear
     // due to a replacement.
     // The only exception is TRUC transactions.
-    if ((ws.m_ptx->version != TRUC_VERSION || m_pool.m_opts.truc_policy != TRUCPolicy::Enforce) && ws.m_modified_fees < m_pool.m_opts.min_relay_feerate.GetFee(ws.m_vsize) && !args.m_ignore_rejects.count(rejectmsg_lowfee_relay)) {
+    if (!bypass_limits && ws.m_ptx->version != TRUC_VERSION && ws.m_modified_fees < m_pool.m_opts.min_relay_feerate.GetFee(ws.m_vsize)) {
         // Even though this is a fee-related failure, this result is TX_MEMPOOL_POLICY, not
         // TX_RECONSIDERABLE, because it cannot be bypassed using package validation.
         return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, "min relay fee not met",
@@ -1084,20 +953,16 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)
     // No individual transactions are allowed below the mempool min feerate except from disconnected
     // blocks and transactions in a package. Package transactions will be checked using package
     // feerate later.
-    if (!args.m_package_feerates && !CheckFeeRate(ws.m_vsize, ws.m_modified_fees, state, args.m_ignore_rejects)) return false;
+    if (!bypass_limits && !args.m_package_feerates && !CheckFeeRate(ws.m_vsize, ws.m_modified_fees, state)) return false;
 
-    std::set<Txid> conflicts_as_a_set;
-    std::transform(ws.m_conflicts_incl_policy.begin(), ws.m_conflicts_incl_policy.end(),
-                    std::inserter(conflicts_as_a_set, conflicts_as_a_set.end()),
-                    [](const std::pair<Txid, bool>& pair){ return pair.first; });
-    ws.m_iters_conflicting = m_pool.GetIterSet(conflicts_as_a_set);
+    ws.m_iters_conflicting = m_pool.GetIterSet(ws.m_conflicts);
 
     // Note that these modifications are only applicable to single transaction scenarios;
     // carve-outs are disabled for multi-transaction evaluations.
     CTxMemPool::Limits maybe_rbf_limits = m_pool.m_opts.limits;
 
     // Calculate in-mempool ancestors, up to a limit.
-    if (ws.m_conflicts_incl_policy.size() == 1 && args.m_allow_carveouts) {
+    if (ws.m_conflicts.size() == 1 && args.m_allow_carveouts) {
         // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we
         // would meet the chain limits after the conflicts have been removed. However, there isn't a practical
         // way to do this short of calculating the ancestor and descendant sets with an overlay cache of
@@ -1132,13 +997,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)
         maybe_rbf_limits.descendant_size_vbytes += conflict->GetSizeWithDescendants();
     }
 
-    CTxMemPool::Limits limits;
-    if (ignore_rejects.count("too-long-mempool-chain")) {
-        limits = CTxMemPool::Limits::NoLimits();
-    } else {
-        limits = maybe_rbf_limits;
-    }
-    if (auto ancestors{m_pool.CalculateMemPoolAncestors(*entry, limits)}) {
+    if (auto ancestors{m_pool.CalculateMemPoolAncestors(*entry, maybe_rbf_limits)}) {
         ws.m_ancestors = std::move(*ancestors);
     } else {
         // If CalculateMemPoolAncestors fails second time, we want the original error string.
@@ -1167,7 +1026,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)
             .descendant_count = maybe_rbf_limits.descendant_count + 1,
             .descendant_size_vbytes = maybe_rbf_limits.descendant_size_vbytes + EXTRA_DESCENDANT_TX_SIZE_LIMIT,
         };
-        if (ws.m_vsize > EXTRA_DESCENDANT_TX_SIZE_LIMIT || (ws.m_ptx->version == TRUC_VERSION && m_pool.m_opts.truc_policy == TRUCPolicy::Enforce)) {
+        if (ws.m_vsize > EXTRA_DESCENDANT_TX_SIZE_LIMIT || ws.m_ptx->version == TRUC_VERSION) {
             return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, "too-long-mempool-chain", error_message);
         }
         if (auto ancestors_retry{m_pool.CalculateMemPoolAncestors(*entry, cpfp_carve_out_limits)}) {
@@ -1180,8 +1039,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)
     // Even though just checking direct mempool parents for inheritance would be sufficient, we
     // check using the full ancestor set here because it's more convenient to use what we have
     // already calculated.
-    if (m_pool.m_opts.truc_policy == TRUCPolicy::Enforce) {
-    if (const auto err{SingleTRUCChecks(ws.m_ptx, "truc-", reason, ignore_rejects, ws.m_ancestors, conflicts_as_a_set, ws.m_vsize)}) {
+    if (const auto err{SingleTRUCChecks(ws.m_ptx, ws.m_ancestors, ws.m_conflicts, ws.m_vsize)}) {
         // Single transaction contexts only.
         if (args.m_allow_sibling_eviction && err->second != nullptr) {
             // We should only be considering where replacement is considered valid as well.
@@ -1189,8 +1047,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)
 
             // Potential sibling eviction. Add the sibling to our list of mempool conflicts to be
             // included in RBF checks.
-            ws.m_conflicts_incl_policy.emplace(err->second->GetHash(), false);
-            conflicts_as_a_set.insert(err->second->GetHash());
+            ws.m_conflicts.insert(err->second->GetHash());
             // Adding the sibling to m_iters_conflicting here means that it doesn't count towards
             // RBF Carve Out above. This is correct, since removing to-be-replaced transactions from
             // the descendant count is done separately in SingleTRUCChecks for TRUC transactions.
@@ -1201,30 +1058,26 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)
             // (which is normally done in PreChecks). However, the only way a TRUC transaction can
             // have a non-TRUC and non-BIP125 descendant is due to a reorg.
         } else {
-            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, reason, err->first);
+            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, "TRUC-violation", err->first);
         }
-    }}
+    }
 
     // A transaction that spends outputs that would be replaced by it is invalid. Now
     // that we have the set of all ancestors we can detect this
     // pathological case by making sure ws.m_conflicts and ws.m_ancestors don't
     // intersect.
-    bool has_policy_conflict{false};
-    if (const auto err_string{EntriesAndTxidsDisjoint(ws.m_ancestors, ws.m_conflicts_incl_policy, hash, &has_policy_conflict)}) {
+    if (const auto err_string{EntriesAndTxidsDisjoint(ws.m_ancestors, ws.m_conflicts, hash)}) {
         // We classify this as a consensus error because a transaction depending on something it
         // conflicts with would be inconsistent.
         return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-spends-conflicting-tx", *err_string);
     }
-    if (has_policy_conflict) {
-        MaybeReject(TxValidationResult::TX_MEMPOOL_POLICY, "txn-spk-reused-chained");
-    }
 
     // We want to detect conflicts in any tx in a package to trigger package RBF logic
-    m_subpackage.m_rbf |= !ws.m_conflicts_incl_policy.empty();
+    m_subpackage.m_rbf |= !ws.m_conflicts.empty();
     return true;
 }
 
-bool MemPoolAccept::ReplacementChecks(ATMPArgs& args, Workspace& ws)
+bool MemPoolAccept::ReplacementChecks(Workspace& ws)
 {
     AssertLockHeld(cs_main);
     AssertLockHeld(m_pool.cs);
@@ -1243,29 +1096,25 @@ bool MemPoolAccept::ReplacementChecks(ATMPArgs& args, Workspace& ws)
     //   guarantee that this is incentive-compatible for miners, because it is possible for a
     //   descendant transaction of a direct conflict to pay a higher feerate than the transaction that
     //   might replace them, under these rules.
-    if (!args.m_ignore_rejects.count("insufficient fee")) {
     if (const auto err_string{PaysMoreThanConflicts(ws.m_iters_conflicting, newFeeRate, hash)}) {
         // This fee-related failure is TX_RECONSIDERABLE because validating in a package may change
         // the result.
         return state.Invalid(TxValidationResult::TX_RECONSIDERABLE,
                              strprintf("insufficient fee%s", ws.m_sibling_eviction ? " (including sibling eviction)" : ""), *err_string);
     }
-    }  // ignore_rejects
 
     // Calculate all conflicting entries and enforce Rule #5.
-    if (const auto err_string{GetEntriesForConflicts(tx, m_pool, ws.m_iters_conflicting, m_subpackage.m_all_conflicts, args.m_ignore_rejects)}) {
+    if (const auto err_string{GetEntriesForConflicts(tx, m_pool, ws.m_iters_conflicting, m_subpackage.m_all_conflicts)}) {
         return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY,
                              strprintf("too many potential replacements%s", ws.m_sibling_eviction ? " (including sibling eviction)" : ""), *err_string);
     }
     // Enforce Rule #2.
-    if (!args.m_ignore_rejects.count("replacement-adds-unconfirmed")) {
     if (const auto err_string{HasNoNewUnconfirmed(tx, m_pool, m_subpackage.m_all_conflicts)}) {
         // Sibling eviction is only done for TRUC transactions, which cannot have multiple ancestors.
         Assume(!ws.m_sibling_eviction);
         return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY,
                              strprintf("replacement-adds-unconfirmed%s", ws.m_sibling_eviction ? " (including sibling eviction)" : ""), *err_string);
     }
-    }  // ignore_rejects
 
     // Check if it's economically rational to mine this transaction rather than the ones it
     // replaces and pays for its own relay fees. Enforce Rules #3 and #4.
@@ -1273,18 +1122,16 @@ bool MemPoolAccept::ReplacementChecks(ATMPArgs& args, Workspace& ws)
         m_subpackage.m_conflicting_fees += it->GetModifiedFee();
         m_subpackage.m_conflicting_size += it->GetTxSize();
     }
-    if (!args.m_ignore_rejects.count("insufficient fee")) {
     if (const auto err_string{PaysForRBF(m_subpackage.m_conflicting_fees, ws.m_modified_fees, ws.m_vsize,
                                          m_pool.m_opts.incremental_relay_feerate, hash)}) {
         // Result may change in a package context
         return state.Invalid(TxValidationResult::TX_RECONSIDERABLE,
                              strprintf("insufficient fee%s", ws.m_sibling_eviction ? " (including sibling eviction)" : ""), *err_string);
     }
-    }  // ignore_rejects
     return true;
 }
 
-bool MemPoolAccept::PackageMempoolChecks(const ATMPArgs& args, const std::vector<CTransactionRef>& txns,
+bool MemPoolAccept::PackageMempoolChecks(const std::vector<CTransactionRef>& txns,
                                          std::vector<Workspace>& workspaces,
                                          const int64_t total_vsize,
                                          PackageValidationState& package_state)
@@ -1298,13 +1145,7 @@ bool MemPoolAccept::PackageMempoolChecks(const ATMPArgs& args, const std::vector
 
     assert(txns.size() == workspaces.size());
 
-    util::Result<void> result = [&]() EXCLUSIVE_LOCKS_REQUIRED(m_pool.cs) {
-        if (args.m_ignore_rejects.count("package-mempool-limits")) {
-            return util::Result<void>();
-        } else {
-            return m_pool.CheckPackageLimits(txns, total_vsize);
-        }
-    }();
+    auto result = m_pool.CheckPackageLimits(txns, total_vsize);
     if (!result) {
         // This is a package-wide error, separate from an individual transaction error.
         return package_state.Invalid(PackageValidationResult::PCKG_POLICY, "package-mempool-limits", util::ErrorString(result).original);
@@ -1454,6 +1295,7 @@ bool MemPoolAccept::Finalize(const ATMPArgs& args, Workspace& ws)
     const CTransaction& tx = *ws.m_ptx;
     const uint256& hash = ws.m_hash;
     TxValidationState& state = ws.m_state;
+    const bool bypass_limits = args.m_bypass_limits;
     std::unique_ptr<CTxMemPoolEntry>& entry = ws.m_entry;
 
     if (!m_subpackage.m_all_conflicts.empty()) Assume(args.m_allow_replacement);
@@ -1491,7 +1333,7 @@ bool MemPoolAccept::Finalize(const ATMPArgs& args, Workspace& ws)
     // If we are validating a package, don't trim here because we could evict a previous transaction
     // in the package. LimitMempoolSize() should be called at the very end to make sure the mempool
     // is still within limits and package submission happens atomically.
-    if (!args.m_package_submission && !args.m_ignore_rejects.count(rejectmsg_mempoolfull)) {
+    if (!args.m_package_submission && !bypass_limits) {
         LimitMempoolSize(m_pool, m_active_chainstate.CoinsTip());
         if (!m_pool.exists(GenTxid::Txid(hash)))
             // The tx no longer meets our (new) mempool minimum feerate but could be reconsidered in a package.
@@ -1530,7 +1372,7 @@ bool MemPoolAccept::SubmitPackage(const ATMPArgs& args, std::vector<Workspace>&
         // Re-calculate mempool ancestors to call addUnchecked(). They may have changed since the
         // last calculation done in PreChecks, since package ancestors have already been submitted.
         {
-            auto ancestors{m_pool.CalculateMemPoolAncestors(*ws.m_entry, CTxMemPool::Limits::NoLimits())};
+            auto ancestors{m_pool.CalculateMemPoolAncestors(*ws.m_entry, m_pool.m_opts.limits)};
             if(!ancestors) {
                 results.emplace(ws.m_ptx->GetWitnessHash(), MempoolAcceptResult::Failure(ws.m_state));
                 // Since PreChecks() and PackageMempoolChecks() both enforce limits, this should never fail.
@@ -1582,7 +1424,7 @@ bool MemPoolAccept::SubmitPackage(const ATMPArgs& args, std::vector<Workspace>&
         const CTransaction& tx = *ws.m_ptx;
         const auto tx_info = NewMempoolTransactionInfo(ws.m_ptx, ws.m_base_fees,
                                                        ws.m_vsize, ws.m_entry->GetHeight(),
-                                                       args.m_ignore_rejects, args.m_package_submission,
+                                                       args.m_bypass_limits, args.m_package_submission,
                                                        IsCurrentForFeeEstimation(m_active_chainstate),
                                                        m_pool.HasNoInputsOf(tx));
         m_pool.m_opts.signals->TransactionAddedToMempool(tx_info, m_pool.GetAndIncrementSequence());
@@ -1595,8 +1437,6 @@ MempoolAcceptResult MemPoolAccept::AcceptSingleTransaction(const CTransactionRef
     AssertLockHeld(cs_main);
     LOCK(m_pool.cs); // mempool "read lock" (held through m_pool.m_opts.signals->TransactionAddedToMempool())
 
-    const CFeeRate mempool_min_fee_rate = m_pool.GetMinFee();
-
     Workspace ws(ptx);
     const std::vector<Wtxid> single_wtxid{ws.m_ptx->GetWitnessHash()};
 
@@ -1614,7 +1454,7 @@ MempoolAcceptResult MemPoolAccept::AcceptSingleTransaction(const CTransactionRef
         return MempoolAcceptResult::Failure(ws.m_state);
     }
 
-    if (m_subpackage.m_rbf && !ReplacementChecks(args, ws)) {
+    if (m_subpackage.m_rbf && !ReplacementChecks(ws)) {
         if (ws.m_state.GetResult() == TxValidationResult::TX_RECONSIDERABLE) {
             // Failed for incentives-based fee reasons. Provide the effective feerate and which tx was included.
             return MempoolAcceptResult::FeeFailure(ws.m_state, CFeeRate(ws.m_modified_fees, ws.m_vsize), single_wtxid);
@@ -1646,7 +1486,7 @@ MempoolAcceptResult MemPoolAccept::AcceptSingleTransaction(const CTransactionRef
         const CTransaction& tx = *ws.m_ptx;
         const auto tx_info = NewMempoolTransactionInfo(ws.m_ptx, ws.m_base_fees,
                                                        ws.m_vsize, ws.m_entry->GetHeight(),
-                                                       args.m_ignore_rejects, args.m_package_submission,
+                                                       args.m_bypass_limits, args.m_package_submission,
                                                        IsCurrentForFeeEstimation(m_active_chainstate),
                                                        m_pool.HasNoInputsOf(tx));
         m_pool.m_opts.signals->TransactionAddedToMempool(tx_info, m_pool.GetAndIncrementSequence());
@@ -1659,9 +1499,6 @@ MempoolAcceptResult MemPoolAccept::AcceptSingleTransaction(const CTransactionRef
                  ws.m_vsize - static_cast<int>(m_subpackage.m_conflicting_size));
     }
 
-    // update mempool stats cache
-    CStats::DefaultStats()->addMempoolSample(m_pool.size(), m_pool.DynamicMemoryUsage(), mempool_min_fee_rate.GetFeePerK());
-
     return MempoolAcceptResult::Success(std::move(m_subpackage.m_replaced_transactions), ws.m_vsize, ws.m_base_fees,
                                         effective_feerate, single_wtxid);
 }
@@ -1716,14 +1553,12 @@ PackageMempoolAcceptResult MemPoolAccept::AcceptMultipleTransactions(const std::
 
     // At this point we have all in-mempool ancestors, and we know every transaction's vsize.
     // Run the TRUC checks on the package.
-    if (m_pool.m_opts.truc_policy == TRUCPolicy::Enforce) {
-    std::string reason;
     for (Workspace& ws : workspaces) {
-        if (auto err{PackageTRUCChecks(ws.m_ptx, ws.m_vsize, "truc-", reason, args.m_ignore_rejects, txns, ws.m_ancestors)}) {
-            package_state.Invalid(PackageValidationResult::PCKG_POLICY, reason, err.value());
+        if (auto err{PackageTRUCChecks(ws.m_ptx, ws.m_vsize, txns, ws.m_ancestors)}) {
+            package_state.Invalid(PackageValidationResult::PCKG_POLICY, "TRUC-violation", err.value());
             return PackageMempoolAcceptResult(package_state, {});
         }
-    }}
+    }
 
     // Transactions must meet two minimum feerates: the mempool minimum fee and min relay fee.
     // For transactions consisting of exactly one child and its parents, it suffices to use the
@@ -1745,8 +1580,7 @@ PackageMempoolAcceptResult MemPoolAccept::AcceptMultipleTransactions(const std::
                    [](const auto& ws) { return ws.m_ptx->GetWitnessHash(); });
     TxValidationState placeholder_state;
     if (args.m_package_feerates &&
-        (!args.m_ignore_rejects.count("package-fee-too-low")) &&
-        !CheckFeeRate(m_subpackage.m_total_vsize, m_subpackage.m_total_modified_fees, placeholder_state, empty_ignore_rejects)) {
+        !CheckFeeRate(m_subpackage.m_total_vsize, m_subpackage.m_total_modified_fees, placeholder_state)) {
         package_state.Invalid(PackageValidationResult::PCKG_TX, "transaction failed");
         return PackageMempoolAcceptResult(package_state, {{workspaces.back().m_ptx->GetWitnessHash(),
             MempoolAcceptResult::FeeFailure(placeholder_state, CFeeRate(m_subpackage.m_total_modified_fees, m_subpackage.m_total_vsize), all_package_wtxids)}});
@@ -1754,7 +1588,7 @@ PackageMempoolAcceptResult MemPoolAccept::AcceptMultipleTransactions(const std::
 
     // Apply package mempool ancestor/descendant limits. Skip if there is only one transaction,
     // because it's unnecessary.
-    if (txns.size() > 1 && !PackageMempoolChecks(args, txns, workspaces, m_subpackage.m_total_vsize, package_state)) {
+    if (txns.size() > 1 && !PackageMempoolChecks(txns, workspaces, m_subpackage.m_total_vsize, package_state)) {
         return PackageMempoolAcceptResult(package_state, std::move(results));
     }
 
@@ -2021,7 +1855,7 @@ PackageMempoolAcceptResult MemPoolAccept::AcceptPackage(const Package& package,
 } // anon namespace
 
 MempoolAcceptResult AcceptToMemoryPool(Chainstate& active_chainstate, const CTransactionRef& tx,
-                                       int64_t accept_time, const ignore_rejects_type& ignore_rejects, bool test_accept)
+                                       int64_t accept_time, bool bypass_limits, bool test_accept)
 {
     AssertLockHeld(::cs_main);
     const CChainParams& chainparams{active_chainstate.m_chainman.GetParams()};
@@ -2029,7 +1863,7 @@ MempoolAcceptResult AcceptToMemoryPool(Chainstate& active_chainstate, const CTra
     CTxMemPool& pool{*active_chainstate.GetMempool()};
 
     std::vector<COutPoint> coins_to_uncache;
-    auto args = MemPoolAccept::ATMPArgs::SingleAccept(chainparams, accept_time, ignore_rejects, coins_to_uncache, test_accept);
+    auto args = MemPoolAccept::ATMPArgs::SingleAccept(chainparams, accept_time, bypass_limits, coins_to_uncache, test_accept);
     MempoolAcceptResult result = MemPoolAccept(pool, active_chainstate).AcceptSingleTransaction(tx, args);
     if (result.m_result_type != MempoolAcceptResult::ResultType::VALID) {
         // Remove coins that were not present in the coins cache before calling
@@ -2051,7 +1885,7 @@ MempoolAcceptResult AcceptToMemoryPool(Chainstate& active_chainstate, const CTra
 }
 
 PackageMempoolAcceptResult ProcessNewPackage(Chainstate& active_chainstate, CTxMemPool& pool,
-                                                   const Package& package, bool test_accept, const std::optional<CFeeRate>& client_maxfeerate, const ignore_rejects_type& ignore_rejects)
+                                                   const Package& package, bool test_accept, const std::optional<CFeeRate>& client_maxfeerate)
 {
     AssertLockHeld(cs_main);
     assert(!package.empty());
@@ -2062,10 +1896,10 @@ PackageMempoolAcceptResult ProcessNewPackage(Chainstate& active_chainstate, CTxM
     auto result = [&]() EXCLUSIVE_LOCKS_REQUIRED(cs_main) {
         AssertLockHeld(cs_main);
         if (test_accept) {
-            auto args = MemPoolAccept::ATMPArgs::PackageTestAccept(chainparams, GetTime(), ignore_rejects, coins_to_uncache);
+            auto args = MemPoolAccept::ATMPArgs::PackageTestAccept(chainparams, GetTime(), coins_to_uncache);
             return MemPoolAccept(pool, active_chainstate).AcceptMultipleTransactions(package, args);
         } else {
-            auto args = MemPoolAccept::ATMPArgs::PackageChildWithParents(chainparams, GetTime(), coins_to_uncache, client_maxfeerate, ignore_rejects);
+            auto args = MemPoolAccept::ATMPArgs::PackageChildWithParents(chainparams, GetTime(), coins_to_uncache, client_maxfeerate);
             return MemPoolAccept(pool, active_chainstate).AcceptPackage(package, args);
         }
     }();
@@ -2141,8 +1975,6 @@ void Chainstate::InitCoinsDB(
             .obfuscate = true,
             .options = m_chainman.m_options.coins_db},
         m_chainman.m_options.coins_view);
-
-    m_coinsdb_cache_size_bytes = cache_size_bytes;
 }
 
 void Chainstate::InitCoinsCache(size_t cache_size_bytes)
@@ -2350,8 +2182,6 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState& state,
         if (pvChecks) {
             pvChecks->emplace_back(std::move(check));
         } else if (!check()) {
-            ScriptError error{check.GetScriptError()};
-
             if (flags & STANDARD_NOT_MANDATORY_VERIFY_FLAGS) {
                 // Check whether the failure was caused by a
                 // non-mandatory script verification check, such as
@@ -2365,14 +2195,6 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState& state,
                         flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);
                 if (check2())
                     return state.Invalid(TxValidationResult::TX_NOT_STANDARD, strprintf("non-mandatory-script-verify-flag (%s)", ScriptErrorString(check.GetScriptError())));
-
-                // If the second check failed, it failed due to a mandatory script verification
-                // flag, but the first check might have failed on a non-mandatory script
-                // verification flag.
-                //
-                // Avoid reporting a mandatory script check failure with a non-mandatory error
-                // string by reporting the error from the second check.
-                error = check2.GetScriptError();
             }
             // MANDATORY flag failures correspond to
             // TxValidationResult::TX_CONSENSUS. Because CONSENSUS
@@ -2383,7 +2205,7 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState& state,
             // support, to avoid splitting the network (but this
             // depends on the details of how net_processing handles
             // such errors).
-            return state.Invalid(TxValidationResult::TX_CONSENSUS, strprintf("mandatory-script-verify-flag-failed (%s)", ScriptErrorString(error)));
+            return state.Invalid(TxValidationResult::TX_CONSENSUS, strprintf("mandatory-script-verify-flag-failed (%s)", ScriptErrorString(check.GetScriptError())));
         }
     }
 
@@ -2589,7 +2411,7 @@ bool Chainstate::ConnectBlock(const CBlock& block, BlockValidationState& state,
 
     uint256 block_hash{block.GetHash()};
     assert(*pindex->phashBlock == block_hash);
-    const bool parallel_script_checks{m_chainman.m_script_check_queue_enabled && m_chainman.GetCheckQueue().HasThreads()};
+    const bool parallel_script_checks{m_chainman.GetCheckQueue().HasThreads()};
 
     const auto time_start{SteadyClock::now()};
     const CChainParams& params{m_chainman.GetParams()};
@@ -2979,6 +2801,21 @@ bool Chainstate::FlushStateToDisk(
             // make sure we don't prune above any of the prune locks bestblocks
             // pruning is height-based
             int last_prune{m_chain.Height()}; // last height we can prune
+            std::optional<std::string> limiting_lock; // prune lock that actually was the limiting factor, only used for logging
+
+            for (const auto& prune_lock : m_blockman.m_prune_locks) {
+                if (prune_lock.second.height_first == std::numeric_limits<int>::max()) continue;
+                // Remove the buffer and one additional block here to get actual height that is outside of the buffer
+                const int lock_height{prune_lock.second.height_first - PRUNE_LOCK_BUFFER - 1};
+                last_prune = std::max(1, std::min(last_prune, lock_height));
+                if (last_prune == lock_height) {
+                    limiting_lock = prune_lock.first;
+                }
+            }
+
+            if (limiting_lock) {
+                LogPrint(BCLog::PRUNE, "%s limited pruning to height %d\n", limiting_lock.value(), last_prune);
+            }
 
             if (nManualPruneHeight > 0) {
                 LOG_TIME_MILLIS_WITH_CATEGORY("find files to prune (manual)", BCLog::BENCH);
@@ -3011,15 +2848,8 @@ bool Chainstate::FlushStateToDisk(
         }
         // The cache is large and we're within 10% and 10 MiB of the limit, but we have time now (not in the middle of a block processing).
         bool fCacheLarge = mode == FlushStateMode::PERIODIC && cache_state >= CoinsCacheSizeState::LARGE;
-        bool fCacheCritical = false;
-        if (mode == FlushStateMode::IF_NEEDED) {
-            if (cache_state >= CoinsCacheSizeState::CRITICAL) {
-                // The cache is over the limit, we have to write now.
-                fCacheCritical = true;
-            } else if (SystemNeedsMemoryReleased()) {
-                fCacheCritical = true;
-            }
-        }
+        // The cache is over the limit, we have to write now.
+        bool fCacheCritical = mode == FlushStateMode::IF_NEEDED && cache_state >= CoinsCacheSizeState::CRITICAL;
         // It's been a while since we wrote the block index to disk. Do this frequently, so we don't need to redownload after a crash.
         bool fPeriodicWrite = mode == FlushStateMode::PERIODIC && nNow > m_last_write + DATABASE_WRITE_INTERVAL;
         // It's been very long since we flushed the cache. Do this infrequently, to optimize cache usage.
@@ -3061,9 +2891,8 @@ bool Chainstate::FlushStateToDisk(
         }
         // Flush best chain related state. This can only be done if the blocks / block index write was also done.
         if (fDoFullFlush && !CoinsTip().GetBestBlock().IsNull()) {
-            if (coins_mem_usage >= WARN_FLUSH_COINS_SIZE) LogWarning("Flushing large (%d GiB) UTXO set to disk, it may take several minutes", coins_mem_usage >> 30);
-            LOG_TIME_MILLIS_WITH_CATEGORY(strprintf("write coins cache to disk (%d coins, %.2fKiB)",
-                coins_count, coins_mem_usage >> 10), BCLog::BENCH);
+            LOG_TIME_MILLIS_WITH_CATEGORY(strprintf("write coins cache to disk (%d coins, %.2fkB)",
+                coins_count, coins_mem_usage / 1000), BCLog::BENCH);
 
             // Typical Coin structures on disk are around 48 bytes in size.
             // Pushing a new one to the database can cause it to be written
@@ -3172,69 +3001,15 @@ void Chainstate::UpdateTip(const CBlockIndex* pindexNew)
             WarningBitsConditionChecker checker(m_chainman, bit);
             ThresholdState state = checker.GetStateFor(pindex, params.GetConsensus(), m_chainman.m_warningcache.at(bit));
             if (state == ThresholdState::ACTIVE || state == ThresholdState::LOCKED_IN) {
-                const bilingual_str warning = strprintf(_("WARNING: Unknown new rules activated (versionbit %i) - this software is not secure"), bit);
-                m_chainman.GetNotifications().warningSet(kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED, warning);
-                warning_messages.push_back(warning);
-            }
-        }
-
-        // Check the version of the last 100 blocks to see if we need to upgrade:
-        int unexpected_bit_count[VERSIONBITS_NUM_BITS], nonversionbit_count = 0;
-        for (size_t i = 0; i < VERSIONBITS_NUM_BITS; ++i) unexpected_bit_count[i] = 0;
-        // NOTE: The warning_threshold_hit* variables are static to ensure the warnings persist even after the condition changes, until the node is restarted
-        static std::set<uint8_t> warning_threshold_hit_bits;
-        static int32_t warning_threshold_hit_int{-1};
-        for (int i = 0; i < 100 && pindex != nullptr; i++)
-        {
-            int32_t nExpectedVersion = m_chainman.m_versionbitscache.ComputeBlockVersion(pindex->pprev, params.GetConsensus());
-            if (pindex->nVersion <= VERSIONBITS_LAST_OLD_BLOCK_VERSION) {
-                // We don't care
-            } else if ((pindex->nVersion & VERSIONBITS_TOP_MASK) != VERSIONBITS_TOP_BITS) {
-                // Non-versionbits upgrade
-                static constexpr int WARNING_THRESHOLD = 100/2;
-                if (++nonversionbit_count > WARNING_THRESHOLD) {
-                    if (warning_threshold_hit_int == -1) {
-                        warning_threshold_hit_int = pindex->nVersion;
-                    } else if (warning_threshold_hit_int != pindex->nVersion) {
-                        warning_threshold_hit_int = -2;
-                    }
-                }
-            } else if ((pindex->nVersion & ~nExpectedVersion) != 0) {
-                for (int bit = 0; bit < VERSIONBITS_NUM_BITS; ++bit) {
-                    const int32_t mask = 1 << bit;
-                    if ((pindex->nVersion & mask) && !(nExpectedVersion & mask)) {
-                        const int warning_threshold = (bit > 12 ? 75 : 50);
-                        if (++unexpected_bit_count[bit] > warning_threshold) {
-                            warning_threshold_hit_bits.insert(bit);
-                        }
-                    }
+                const bilingual_str warning = strprintf(_("Unknown new rules activated (versionbit %i)"), bit);
+                if (state == ThresholdState::ACTIVE) {
+                    m_chainman.GetNotifications().warningSet(kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED, warning);
+                } else {
+                    warning_messages.push_back(warning);
                 }
             }
-            pindex = pindex->pprev;
         }
-        if (!warning_threshold_hit_bits.empty()) {
-            const auto warning = strprintf(_("Warning: Miners are attempting to activate unknown new rules (bit %s)! You may or may not need to act to remain secure"), util::Join(warning_threshold_hit_bits, ", ", [](const uint8_t bit){ return util::ToString(int(bit)); }));
-            m_chainman.GetNotifications().warningSet(kernel::Warning::UNKNOWN_NEW_RULES_SIGNAL_VBITS, warning, /*update=*/true);
-            warning_messages.push_back(warning);
-        }
-        if (warning_threshold_hit_int != -1) {
-            bilingual_str warning;
-            if (warning_threshold_hit_int == -2) {
-                warning = _("Warning: Unrecognised block versions are being mined! Unknown rules may or may not be in effect");
-            } else {
-                warning = strprintf(_("Warning: Unrecognised block version (0x%08x) is being mined! Unknown rules may or may not be in effect"), warning_threshold_hit_int);
-            }
-            m_chainman.GetNotifications().warningSet(kernel::Warning::UNKNOWN_NEW_RULES_SIGNAL_INTVER, warning, /*update=*/true);
-            warning_messages.push_back(warning);
-        }
-    }
-
-    static constexpr int32_t BIP320_MASK = 0x1fffe000UL;
-    if ((pindexNew->nVersion & BIP320_MASK) && pindexNew->nVersion != m_chainman.m_versionbitscache.ComputeBlockVersion(pindexNew->pprev, params.GetConsensus())) {
-        const auto warning = _("Miner violated version bit protocol");
-        warning_messages.push_back(warning);
     }
-
     UpdateTipLog(coins_tip, pindexNew, params, __func__, "",
                  util::Join(warning_messages, Untranslated(", ")).original);
 }
@@ -3280,14 +3055,13 @@ bool Chainstate::DisconnectTip(BlockValidationState& state, DisconnectedBlockTra
              Ticks<MillisecondsDouble>(SteadyClock::now() - time_start));
 
     {
-        // Prune locks that began around the tip should be moved backward so they get a chance to reorg
-        const uint64_t max_height_first{static_cast<uint64_t>(pindexDelete->nHeight - 1)};
+        // Prune locks that began at or after the tip should be moved backward so they get a chance to reorg
+        const int max_height_first{pindexDelete->nHeight - 1};
         for (auto& prune_lock : m_blockman.m_prune_locks) {
-            if (prune_lock.second.height_first < max_height_first) continue;
+            if (prune_lock.second.height_first <= max_height_first) continue;
 
-            --prune_lock.second.height_first;
-            LogPrint(BCLog::PRUNE, "%s prune lock moved back to %d\n", prune_lock.first, prune_lock.second.height_first);
-            // NOTE: Don't need to write to db here, since it will get synced with the rest of the chainstate
+            prune_lock.second.height_first = max_height_first;
+            LogPrint(BCLog::PRUNE, "%s prune lock moved back to %d\n", prune_lock.first, max_height_first);
         }
     }
 
@@ -3297,9 +3071,6 @@ bool Chainstate::DisconnectTip(BlockValidationState& state, DisconnectedBlockTra
     }
 
     if (disconnectpool && m_mempool) {
-        for (auto it = block.vtx.rbegin(); it != block.vtx.rend(); ++it) {
-            m_mempool->UpdateDependentPriorities(*(*it), pindexDelete->nHeight, false);
-        }
         // Save transactions to re-add to mempool at end of reorg. If any entries are evicted for
         // exceeding memory limits, remove them and their descendants from the mempool.
         for (auto&& evicted_tx : disconnectpool->AddTransactionsFromBlock(block.vtx)) {
@@ -3315,12 +3086,6 @@ bool Chainstate::DisconnectTip(BlockValidationState& state, DisconnectedBlockTra
     if (m_chainman.m_options.signals) {
         m_chainman.m_options.signals->BlockDisconnected(pblock, pindexDelete);
     }
-
-    if (m_mempool) {
-        // add mempool stats sample
-        CStats::DefaultStats()->addMempoolSample(m_mempool->size(), m_mempool->DynamicMemoryUsage(), m_mempool->GetMinFee().GetFeePerK());
-    }
-
     return true;
 }
 
@@ -3444,11 +3209,6 @@ bool Chainstate::ConnectTip(BlockValidationState& state, CBlockIndex* pindexNew,
     m_chain.SetTip(*pindexNew);
     UpdateTip(pindexNew);
 
-    if (m_mempool) {
-        // add mempool stats sample
-        CStats::DefaultStats()->addMempoolSample(m_mempool->size(), m_mempool->DynamicMemoryUsage(), m_mempool->GetMinFee().GetFeePerK());
-    }
-
     const auto time_6{SteadyClock::now()};
     m_chainman.time_post_connect += time_6 - time_5;
     m_chainman.time_total += time_6 - time_1;
@@ -4412,18 +4172,11 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, BlockValidatio
         // Don't accept any forks from the main chain prior to last checkpoint.
         // GetLastCheckpoint finds the last checkpoint in MapCheckpoints that's in our
         // BlockIndex().
-        const auto& checkpoint_data = chainman.GetParams().Checkpoints();
-        const CBlockIndex* pcheckpoint = blockman.GetLastCheckpoint(checkpoint_data);
+        const CBlockIndex* pcheckpoint = blockman.GetLastCheckpoint(chainman.GetParams().Checkpoints());
         if (pcheckpoint && nHeight < pcheckpoint->nHeight) {
             LogPrintf("ERROR: %s: forked chain older than last checkpoint (height %d)\n", __func__, nHeight);
             return state.Invalid(BlockValidationResult::BLOCK_CHECKPOINT, "bad-fork-prior-to-checkpoint");
         }
-
-        // Check that the block chain matches the known block chain up to a checkpoint
-        if (!checkpoint_data.CheckBlock(nHeight, block.GetHash())) {
-            LogPrintf("ERROR: %s: rejected by checkpoint lock-in at %d\n", __func__, nHeight);
-            return state.Invalid(BlockValidationResult::BLOCK_CHECKPOINT, "checkpoint-mismatch");
-        }
     }
 
     // Check timestamp against prev
@@ -4455,19 +4208,6 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, BlockValidatio
                                  strprintf("rejected nVersion=0x%08x block", block.nVersion));
     }
 
-    if (IsThisSoftwareExpired(block.nTime)) {
-        // Wait an extra day before we start rejecting blocks
-        CBlockIndex const *blockindex_old = pindexPrev;
-        for (int i = 0; i < 144; ++i) {
-            assert(blockindex_old);
-            blockindex_old = blockindex_old->pprev;
-        }
-        assert(blockindex_old);
-        if (IsThisSoftwareExpired(blockindex_old->GetMedianTimePast())) {
-            return state.Invalid(BlockValidationResult::BLOCK_TIME_FUTURE, "node-expired", "node software has expired");
-        }
-    }
-
     return true;
 }
 
@@ -4852,7 +4592,7 @@ bool ChainstateManager::ProcessNewBlock(const std::shared_ptr<const CBlock>& blo
     return true;
 }
 
-MempoolAcceptResult ChainstateManager::ProcessTransaction(const CTransactionRef& tx, bool test_accept, const ignore_rejects_type& ignore_rejects)
+MempoolAcceptResult ChainstateManager::ProcessTransaction(const CTransactionRef& tx, bool test_accept)
 {
     AssertLockHeld(cs_main);
     Chainstate& active_chainstate = ActiveChainstate();
@@ -4861,7 +4601,7 @@ MempoolAcceptResult ChainstateManager::ProcessTransaction(const CTransactionRef&
         state.Invalid(TxValidationResult::TX_NO_MEMPOOL, "no-mempool");
         return MempoolAcceptResult::Failure(state);
     }
-    auto result = AcceptToMemoryPool(active_chainstate, tx, GetTime(), ignore_rejects, test_accept);
+    auto result = AcceptToMemoryPool(active_chainstate, tx, GetTime(), /*bypass_limits=*/ false, test_accept);
     active_chainstate.GetMempool()->check(active_chainstate.CoinsTip(), active_chainstate.m_chain.Height() + 1);
     return result;
 }
@@ -5003,7 +4743,7 @@ VerifyDBResult CVerifyDB::VerifyDB(
         }
         CBlock block;
         // check level 0: read from disk
-        if (!chainstate.m_blockman.ReadBlockFromDisk(block, *pindex, /*lowprio=*/true)) {
+        if (!chainstate.m_blockman.ReadBlockFromDisk(block, *pindex)) {
             LogPrintf("Verification error: ReadBlockFromDisk failed at %d, hash=%s\n", pindex->nHeight, pindex->GetBlockHash().ToString());
             return VerifyDBResult::CORRUPTED_BLOCK_DB;
         }
@@ -5069,7 +4809,7 @@ VerifyDBResult CVerifyDB::VerifyDB(
             m_notifications.progress(_("Verifying blocks…"), percentageDone, false);
             pindex = chainstate.m_chain.Next(pindex);
             CBlock block;
-            if (!chainstate.m_blockman.ReadBlockFromDisk(block, *pindex, /*lowprio=*/true)) {
+            if (!chainstate.m_blockman.ReadBlockFromDisk(block, *pindex)) {
                 LogPrintf("Verification error: ReadBlockFromDisk failed at %d, hash=%s\n", pindex->nHeight, pindex->GetBlockHash().ToString());
                 return VerifyDBResult::CORRUPTED_BLOCK_DB;
             }
@@ -5098,7 +4838,7 @@ bool Chainstate::RollforwardBlock(const CBlockIndex* pindex, CCoinsViewCache& in
     AssertLockHeld(cs_main);
     // TODO: merge with ConnectBlock
     CBlock block;
-    if (!m_blockman.ReadBlockFromDisk(block, *pindex, /*lowprio=*/true)) {
+    if (!m_blockman.ReadBlockFromDisk(block, *pindex)) {
         LogError("ReplayBlock(): ReadBlockFromDisk failed at %d, hash=%s\n", pindex->nHeight, pindex->GetBlockHash().ToString());
         return false;
     }
@@ -5156,7 +4896,7 @@ bool Chainstate::ReplayBlocks()
     while (pindexOld != pindexFork) {
         if (pindexOld->nHeight > 0) { // Never disconnect the genesis block.
             CBlock block;
-            if (!m_blockman.ReadBlockFromDisk(block, *pindexOld, /*lowprio=*/true)) {
+            if (!m_blockman.ReadBlockFromDisk(block, *pindexOld)) {
                 LogError("RollbackBlock(): ReadBlockFromDisk() failed at %d, hash=%s\n", pindexOld->nHeight, pindexOld->GetBlockHash().ToString());
                 return false;
             }
@@ -5296,9 +5036,6 @@ void ChainstateManager::LoadExternalBlockFile(
 
     int nLoaded = 0;
     try {
-        IOPRIO_IDLER(/*lowprio=*/true);
-        file_in.SetIdlePriority();
-
         BufferedFile blkdat{file_in, 2 * MAX_BLOCK_SERIALIZED_SIZE, MAX_BLOCK_SERIALIZED_SIZE + 8};
         // nRewind indicates where to resume scanning in case something goes wrong,
         // such as a block fails to deserialize.
@@ -5829,8 +5566,9 @@ double GuessVerificationProgress(const ChainTxData& data, const CBlockIndex *pin
     if (pindex == nullptr)
         return 0.0;
 
-    if (pindex->m_chain_tx_count == 0) {
-        LogDebug(BCLog::VALIDATION, "Block %d has unset m_chain_tx_count. Unable to estimate verification progress.\n", pindex->nHeight);
+    if (!Assume(pindex->m_chain_tx_count > 0)) {
+        LogWarning("Internal bug detected: block %d has unset m_chain_tx_count (%s %s). Please report this issue here: %s\n",
+                   pindex->nHeight, PACKAGE_NAME, FormatFullVersion(), PACKAGE_BUGREPORT);
         return 0.0;
     }
 
diff --git a/src/validation.h b/src/validation.h
index b6fc2d3439..bc9bacf7ce 100644
--- a/src/validation.h
+++ b/src/validation.h
@@ -64,8 +64,6 @@ namespace util {
 class SignalInterrupt;
 } // namespace util
 
-/** Default for using fee filter */
-static const bool DEFAULT_FEEFILTER = true;
 /** Block files containing a block-height within MIN_BLOCKS_TO_KEEP of ActiveChain().Tip() will not be pruned. */
 static const unsigned int MIN_BLOCKS_TO_KEEP = 288;
 static const signed int DEFAULT_CHECKBLOCKS = 6;
@@ -92,13 +90,6 @@ extern std::condition_variable g_best_block_cv;
 /** Used to notify getblocktemplate RPC of new tips. */
 extern uint256 g_best_block;
 
-enum SpkReuseModes {
-    SRM_ALLOW,
-    SRM_REJECT,
-};
-
-extern SpkReuseModes SpkReuseMode;
-
 /** Documentation for argument 'checklevel'. */
 extern const std::vector<std::string> CHECKLEVEL_DOC;
 
@@ -263,11 +254,6 @@ struct PackageMempoolAcceptResult
         : m_tx_results{ {wtxid, result} } {}
 };
 
-static const std::string rejectmsg_lowfee_mempool = "mempool min fee not met";
-static const std::string rejectmsg_lowfee_relay = "min relay fee not met";
-static const std::string rejectmsg_mempoolfull = "mempool full";
-static const std::string rejectmsg_zero_mempool_entry_seq = "zero mempool entry sequence";
-
 /**
  * Try to add a transaction to the mempool. This is an internal function and is exposed only for testing.
  * Client code should use ChainstateManager::ProcessTransaction()
@@ -276,18 +262,15 @@ static const std::string rejectmsg_zero_mempool_entry_seq = "zero mempool entry
  * @param[in]  tx                 The transaction to submit for mempool acceptance.
  * @param[in]  accept_time        The timestamp for adding the transaction to the mempool.
  *                                It is also used to determine when the entry expires.
- * @param[in]  ignore_rejects     Set of reject reasons to ignore and bypass, if possible.
+ * @param[in]  bypass_limits      When true, don't enforce mempool fee and capacity limits,
+ *                                and set entry_sequence to zero.
  * @param[in]  test_accept        When true, run validation checks but don't submit to mempool.
  *
  * @returns a MempoolAcceptResult indicating whether the transaction was accepted/rejected with reason.
  */
 MempoolAcceptResult AcceptToMemoryPool(Chainstate& active_chainstate, const CTransactionRef& tx,
-                                       int64_t accept_time, const ignore_rejects_type& ignore_rejects, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
-
-static inline MempoolAcceptResult AcceptToMemoryPool(Chainstate& active_chainstate, const CTransactionRef& tx, int64_t accept_time, bool bypass_limits, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {
-    static const ignore_rejects_type ignore_rejects_legacy{rejectmsg_lowfee_mempool, rejectmsg_lowfee_relay, rejectmsg_mempoolfull, rejectmsg_zero_mempool_entry_seq};
-    return AcceptToMemoryPool(active_chainstate, tx, accept_time, (bypass_limits ? ignore_rejects_legacy : empty_ignore_rejects), test_accept);
-}
+                                       int64_t accept_time, bool bypass_limits, bool test_accept)
+    EXCLUSIVE_LOCKS_REQUIRED(cs_main);
 
 /**
 * Validate (and maybe submit) a package to the mempool. See doc/policy/packages.md for full details
@@ -300,7 +283,7 @@ static inline MempoolAcceptResult AcceptToMemoryPool(Chainstate& active_chainsta
 * possible for the package to be partially submitted.
 */
 PackageMempoolAcceptResult ProcessNewPackage(Chainstate& active_chainstate, CTxMemPool& pool,
-                                                   const Package& txns, bool test_accept, const std::optional<CFeeRate>& client_maxfeerate, const ignore_rejects_type& ignore_rejects=empty_ignore_rejects)
+                                                   const Package& txns, bool test_accept, const std::optional<CFeeRate>& client_maxfeerate)
                                                    EXCLUSIVE_LOCKS_REQUIRED(cs_main);
 
 /* Mempool validation helper functions */
@@ -345,8 +328,6 @@ std::optional<LockPoints> CalculateLockPointsAtTip(
 bool CheckSequenceLocksAtTip(CBlockIndex* tip,
                              const LockPoints& lock_points);
 
-void LimitMempoolSize(CTxMemPool&, CCoinsViewCache&);
-
 /**
  * Closure representing one script verification
  * Note that this stores references to the spending transaction
@@ -519,7 +500,7 @@ enum class CoinsCacheSizeState
  * current best chain.
  *
  * Eventually, the API here is targeted at being exposed externally as a
- * consumable libconsensus library, so any functions added must only call
+ * consumable library, so any functions added must only call
  * other class member functions, pure functions in other parts of the consensus
  * library, callbacks via the validation interface, or read/write-to-disk
  * functions (eventually this will also be via callbacks).
@@ -1272,7 +1253,7 @@ public:
      * @param[in]  tx              The transaction to submit for mempool acceptance.
      * @param[in]  test_accept     When true, run validation checks but don't submit to mempool.
      */
-    [[nodiscard]] MempoolAcceptResult ProcessTransaction(const CTransactionRef& tx, bool test_accept=false, const ignore_rejects_type& ignore_rejects=empty_ignore_rejects)
+    [[nodiscard]] MempoolAcceptResult ProcessTransaction(const CTransactionRef& tx, bool test_accept=false)
         EXCLUSIVE_LOCKS_REQUIRED(cs_main);
 
     //! Load the block tree and coins database from disk, initializing state if we're running with -reindex
@@ -1339,7 +1320,6 @@ public:
     //! nullopt.
     std::optional<int> GetSnapshotBaseHeight() const EXCLUSIVE_LOCKS_REQUIRED(::cs_main);
 
-    bool m_script_check_queue_enabled{true};
     CCheckQueue<CScriptCheck>& GetCheckQueue() { return m_script_check_queue; }
 
     ~ChainstateManager();
diff --git a/src/validationinterface.cpp b/src/validationinterface.cpp
index 03b4db5c52..0ebcf926ca 100644
--- a/src/validationinterface.cpp
+++ b/src/validationinterface.cpp
@@ -128,15 +128,11 @@ void ValidationSignals::UnregisterSharedValidationInterface(std::shared_ptr<CVal
 
 void ValidationSignals::UnregisterValidationInterface(CValidationInterface* callbacks)
 {
-    callbacks->ValidationInterfaceUnregistering();
-
     m_internals->Unregister(callbacks);
 }
 
 void ValidationSignals::UnregisterAllValidationInterfaces()
 {
-    m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.ValidationInterfaceUnregistering(); });
-
     m_internals->Clear();
 }
 
@@ -260,8 +256,3 @@ void ValidationSignals::NewPoWValidBlock(const CBlockIndex *pindex, const std::s
     LOG_EVENT("%s: block hash=%s", __func__, block->GetHash().ToString());
     m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.NewPoWValidBlock(pindex, block); });
 }
-
-void ValidationSignals::NewBlockTemplate(const std::shared_ptr<node::CBlockTemplate>& blocktemplate) {
-    LOG_EVENT("%s", __func__);
-    m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.NewBlockTemplate(blocktemplate); });
-}
diff --git a/src/validationinterface.h b/src/validationinterface.h
index 994b97c708..3cf75aa210 100644
--- a/src/validationinterface.h
+++ b/src/validationinterface.h
@@ -25,7 +25,6 @@ class BlockValidationState;
 class CBlock;
 class CBlockIndex;
 struct CBlockLocator;
-namespace node { struct CBlockTemplate; }
 enum class MemPoolRemovalReason;
 struct RemovedMempoolTransactionInfo;
 struct NewMempoolTransactionInfo;
@@ -158,15 +157,6 @@ protected:
      * has been received and connected to the headers tree, though not validated yet.
      */
     virtual void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& block) {};
-
-    virtual void NewBlockTemplate(const std::shared_ptr<node::CBlockTemplate>& blocktemplate) {}
-    /**
-     * Notifies the validation interface that it is being unregistered
-     */
-    virtual void ValidationInterfaceUnregistering() {};
-
-    friend void UnregisterValidationInterface(CValidationInterface*);
-    friend void UnregisterAllValidationInterfaces();
     friend class ValidationSignals;
     friend class ValidationInterfaceTest;
 };
@@ -237,7 +227,6 @@ public:
     void ChainStateFlushed(ChainstateRole, const CBlockLocator &);
     void BlockChecked(const CBlock&, const BlockValidationState&);
     void NewPoWValidBlock(const CBlockIndex *, const std::shared_ptr<const CBlock>&);
-    void NewBlockTemplate(const std::shared_ptr<node::CBlockTemplate>& blocktemplate);
 };
 
 #endif // BITCOIN_VALIDATIONINTERFACE_H
diff --git a/src/wallet/coincontrol.h b/src/wallet/coincontrol.h
index 08daaa2932..d36314312a 100644
--- a/src/wallet/coincontrol.h
+++ b/src/wallet/coincontrol.h
@@ -86,8 +86,6 @@ public:
     std::optional<OutputType> m_change_type;
     //! If false, only safe inputs will be used
     bool m_include_unsafe_inputs = false;
-    //! If true, only segwit inputs are selected
-    bool m_segwit_inputs_only = false;
     //! If true, the selection process can add extra unselected inputs from the wallet
     //! while requires all selected inputs be used
     bool m_allow_other_inputs = true;
diff --git a/src/wallet/db.cpp b/src/wallet/db.cpp
index f2b0fe2c12..400b9dc44f 100644
--- a/src/wallet/db.cpp
+++ b/src/wallet/db.cpp
@@ -11,7 +11,6 @@
 
 #include <exception>
 #include <fstream>
-#include <set>
 #include <string>
 #include <system_error>
 #include <vector>
@@ -22,24 +21,6 @@ bool operator<(Span<const std::byte> a, BytePrefix b) { return a.subspan(0, std:
 
 std::vector<std::pair<fs::path, std::string>> ListDatabases(const fs::path& wallet_dir)
 {
-    const fs::path& data_dir = gArgs.GetDataDirNet();
-    const fs::path& blocks_dir = gArgs.GetBlocksDirPath();
-
-    // Here we place the top level dirs we want to skip in case walletdir is datadir or blocksdir
-    // Those directories are referenced in doc/files.md
-    const std::set<fs::path> ignore_paths = {
-                                        blocks_dir,
-                                        data_dir / "blktree",
-                                        data_dir / "blocks",
-                                        data_dir / "chainstate",
-                                        data_dir / "coins",
-                                        data_dir / "database",
-                                        data_dir / "indexes",
-                                        data_dir / "regtest",
-                                        data_dir / "signet",
-                                        data_dir / "testnet3"
-                                        };
-
     std::vector<std::pair<fs::path, std::string>> paths;
     std::error_code ec;
 
@@ -54,12 +35,6 @@ std::vector<std::pair<fs::path, std::string>> ListDatabases(const fs::path& wall
             continue;
         }
 
-        // We don't want to iterate through those special node dirs
-        if (ignore_paths.count(it->path())) {
-            it.disable_recursion_pending();
-            continue;
-        }
-
         try {
             const fs::path path{it->path().lexically_relative(wallet_dir)};
 
diff --git a/src/wallet/dump.cpp b/src/wallet/dump.cpp
index 892c4359d9..db2756e0ca 100644
--- a/src/wallet/dump.cpp
+++ b/src/wallet/dump.cpp
@@ -21,8 +21,15 @@ namespace wallet {
 static const std::string DUMP_MAGIC = "BITCOIN_CORE_WALLET_DUMP";
 uint32_t DUMP_VERSION = 1;
 
-bool DumpWallet(WalletDatabase& db, bilingual_str& error, const std::string& dump_filename)
+bool DumpWallet(const ArgsManager& args, WalletDatabase& db, bilingual_str& error)
 {
+    // Get the dumpfile
+    std::string dump_filename = args.GetArg("-dumpfile", "");
+    if (dump_filename.empty()) {
+        error = _("No dump file provided. To use dump, -dumpfile=<filename> must be provided.");
+        return false;
+    }
+
     fs::path path = fs::PathFromString(dump_filename);
     path = fs::absolute(path);
     if (fs::exists(path)) {
@@ -174,9 +181,6 @@ bool CreateFromDump(const ArgsManager& args, const std::string& name, const fs::
         error = _("No wallet file format provided. To use createfromdump, -format=<format> must be provided.");
         return false;
     }
-    if (file_format.starts_with("bdb") || format_value.starts_with("bdb")) {
-        warnings.push_back(_("Warning: BDB-backed wallets have a wallet id that is not currently restored."));
-    }
     DatabaseFormat data_format;
     if (file_format == "bdb") {
         data_format = DatabaseFormat::BERKELEY;
diff --git a/src/wallet/dump.h b/src/wallet/dump.h
index c7b626decf..9b44af922e 100644
--- a/src/wallet/dump.h
+++ b/src/wallet/dump.h
@@ -16,7 +16,7 @@ class ArgsManager;
 namespace wallet {
 class WalletDatabase;
 
-bool DumpWallet(WalletDatabase& db, bilingual_str& error, const std::string& dump_filename);
+bool DumpWallet(const ArgsManager& args, WalletDatabase& db, bilingual_str& error);
 bool CreateFromDump(const ArgsManager& args, const std::string& name, const fs::path& wallet_path, bilingual_str& error, std::vector<bilingual_str>& warnings);
 } // namespace wallet
 
diff --git a/src/wallet/init.cpp b/src/wallet/init.cpp
index c5bbbf2647..14d22bb54e 100644
--- a/src/wallet/init.cpp
+++ b/src/wallet/init.cpp
@@ -14,7 +14,6 @@
 #include <node/context.h>
 #include <node/interface_ui.h>
 #include <outputtype.h>
-#include <script/signingprovider.h>
 #include <univalue.h>
 #include <util/check.h>
 #include <util/moneystr.h>
@@ -77,9 +76,8 @@ void WalletInit::AddWalletOptions(ArgsManager& argsman) const
     argsman.AddArg("-wallet=<path>", "Specify wallet path to load at startup. Can be used multiple times to load multiple wallets. Path is to a directory containing wallet data and log files. If the path is not absolute, it is interpreted relative to <walletdir>. This only loads existing wallets and does not create new ones. For backwards compatibility this also accepts names of existing top-level data files in <walletdir>.", ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::WALLET);
     argsman.AddArg("-walletbroadcast",  strprintf("Make the wallet broadcast transactions (default: %u)", DEFAULT_WALLETBROADCAST), ArgsManager::ALLOW_ANY, OptionsCategory::WALLET);
     argsman.AddArg("-walletdir=<dir>", "Specify directory to hold wallets (default: <datadir>/wallets if it exists, otherwise <datadir>)", ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::WALLET);
-    argsman.AddArg("-walletimplicitsegwit", strprintf("Support segwit when restoring wallet backups and importing keys (default: %u)", DEFAULT_WALLET_IMPLICIT_SEGWIT), ArgsManager::ALLOW_ANY, OptionsCategory::WALLET);
 #if HAVE_SYSTEM
-    argsman.AddArg("-walletnotify=<cmd>", "Execute command when a wallet transaction changes. %s in cmd is replaced by TxID, %w is replaced by wallet name, %b is replaced by the hash of the block including the transaction (set to 'unconfirmed' if the transaction is not included) and %h is replaced by the block height (-1 if not included). %w should NOT be quoted because this would break shell escaping used to invoke the command.", ArgsManager::ALLOW_ANY, OptionsCategory::WALLET);
+    argsman.AddArg("-walletnotify=<cmd>", "Execute command when a wallet transaction changes. %s in cmd is replaced by TxID, %w is replaced by wallet name, %b is replaced by the hash of the block including the transaction (set to 'unconfirmed' if the transaction is not included) and %h is replaced by the block height (-1 if not included). %w is not currently implemented on windows. On systems where %w is supported, it should NOT be quoted because this would break shell escaping used to invoke the command.", ArgsManager::ALLOW_ANY, OptionsCategory::WALLET);
 #endif
     argsman.AddArg("-walletrbf", strprintf("Send transactions with full-RBF opt-in enabled (RPC only, default: %u)", DEFAULT_WALLET_RBF), ArgsManager::ALLOW_ANY, OptionsCategory::WALLET);
 
@@ -121,13 +119,6 @@ bool WalletInit::ParameterInteraction() const
         LogPrintf("%s: parameter interaction: -blocksonly=1 -> setting -walletbroadcast=0\n", __func__);
     }
 
-    g_implicit_segwit = gArgs.GetBoolArg("-walletimplicitsegwit", DEFAULT_WALLET_IMPLICIT_SEGWIT);
-    if (!g_implicit_segwit) {
-        if (gArgs.SoftSetArg("-addresstype", "legacy")) {
-            LogPrintf("%s: parameter interaction: -walletimplicitsegwit=%u -> setting -addresstype=legacy\n", __func__, g_implicit_segwit);
-        }
-    }
-
     return true;
 }
 
diff --git a/src/wallet/interfaces.cpp b/src/wallet/interfaces.cpp
index 955b5acb48..21e8a0b3bd 100644
--- a/src/wallet/interfaces.cpp
+++ b/src/wallet/interfaces.cpp
@@ -8,7 +8,6 @@
 #include <consensus/amount.h>
 #include <interfaces/chain.h>
 #include <interfaces/handler.h>
-#include <key_io.h>
 #include <node/types.h>
 #include <policy/fees.h>
 #include <primitives/transaction.h>
@@ -22,7 +21,6 @@
 #include <util/ui_change_type.h>
 #include <wallet/coincontrol.h>
 #include <wallet/context.h>
-#include <wallet/dump.h>
 #include <wallet/feebumper.h>
 #include <wallet/fees.h>
 #include <wallet/types.h>
@@ -33,7 +31,6 @@
 #include <wallet/wallet.h>
 
 #include <memory>
-#include <set>
 #include <string>
 #include <utility>
 #include <vector>
@@ -54,16 +51,6 @@ using interfaces::WalletTxOut;
 using interfaces::WalletTxStatus;
 using interfaces::WalletValueMap;
 
-std::set<CScript> AddressesToKeys(std::vector<std::string> addresses)
-{
-    std::set<CScript> keys;
-    for (const auto& address : addresses) {
-        CScript scriptPubKey = GetScriptForDestination(DecodeDestination(address));
-        keys.insert(scriptPubKey);
-    }
-    return keys;
-}
-
 namespace wallet {
 // All members of the classes in this namespace are intentionally public, as the
 // classes themselves are private.
@@ -117,7 +104,6 @@ WalletTxStatus MakeWalletTxStatus(const CWallet& wallet, const CWalletTx& wtx)
     result.is_abandoned = wtx.isAbandoned();
     result.is_coinbase = wtx.IsCoinBase();
     result.is_in_main_chain = wtx.isConfirmed();
-    result.is_assumed = wallet.IsTxAssumed(wtx);
     return result;
 }
 
@@ -165,18 +151,7 @@ public:
         return m_wallet->ChangeWalletPassphrase(old_wallet_passphrase, new_wallet_passphrase);
     }
     void abortRescan() override { m_wallet->AbortRescan(); }
-    bool canBackupToDbDump() override {
-        return (m_wallet->GetDatabase().Format() != "bdb");
-    }
-    bool backupWallet(const std::string& filename, const WalletBackupFormat format, bilingual_str& error) override {
-        switch (format) {
-            case WalletBackupFormat::DbDump:
-                return DumpWallet(m_wallet->GetDatabase(), error, filename);
-            case WalletBackupFormat::Raw:
-                return m_wallet->BackupWallet(filename);
-        }
-        return false;
-    }
+    bool backupWallet(const std::string& filename) override { return m_wallet->BackupWallet(filename); }
     std::string getWalletName() override { return m_wallet->GetName(); }
     util::Result<CTxDestination> getNewDestination(const OutputType type, const std::string& label) override
     {
@@ -191,9 +166,9 @@ public:
         }
         return false;
     }
-    SigningResult signMessage(const MessageSignatureFormat format, const std::string& message, const CTxDestination& address, std::string& str_sig) override
+    SigningResult signMessage(const std::string& message, const PKHash& pkhash, std::string& str_sig) override
     {
-        return m_wallet->SignMessage(format, message, address, str_sig);
+        return m_wallet->SignMessage(message, pkhash, str_sig);
     }
     bool isSpendable(const CTxDestination& dest) override
     {
@@ -279,23 +254,6 @@ public:
         LOCK(m_wallet->cs_wallet);
         return m_wallet->DisplayAddress(dest);
     }
-    bool checkAddressForUsage(const std::vector<std::string>& addresses) const override
-    {
-        LOCK(m_wallet->cs_wallet);
-        return m_wallet->FindScriptPubKeyUsed(AddressesToKeys(addresses));
-    }
-    bool findAddressUsage(const std::vector<std::string>& addresses, std::function<void(const std::string&, const WalletTx&, uint32_t)> callback) const override
-    {
-        LOCK(m_wallet->cs_wallet);
-        return m_wallet->FindScriptPubKeyUsed(AddressesToKeys(addresses), [&callback, this](const CWalletTx& wtx, uint32_t output_index){
-            CTxDestination dest;
-            bool success = ExtractDestination(wtx.tx->vout[output_index].scriptPubKey, dest);
-            assert(success);  // It shouldn't be possible to end up here with anything unrecognised
-            std::string address = EncodeDestination(dest);
-            WalletTx interface_wtx = MakeWalletTx(*m_wallet, wtx);
-            callback(address, interface_wtx, output_index);
-        });
-    }
     bool lockCoin(const COutPoint& output, const bool write_to_db) override
     {
         LOCK(m_wallet->cs_wallet);
@@ -616,18 +574,13 @@ public:
     }
     ~WalletLoaderImpl() override { UnloadWallets(m_context); }
 
-    //! HACK to workaround libc++ bugs (assigning from other locations such as sweepprivkeys breaks std::any_cast type checking); see also https://github.com/llvm/llvm-project/issues/55684
-    void assignContextHACK(std::any& a) override
-    {
-        a = &m_context;
-    }
     //! ChainClient methods
     void registerRpcs() override
     {
         for (const CRPCCommand& command : GetWalletRPCCommands()) {
             m_rpc_commands.emplace_back(command.category, command.name, [this, &command](const JSONRPCRequest& request, UniValue& result, bool last_handler) {
                 JSONRPCRequest wallet_request = request;
-                assignContextHACK(wallet_request.context);
+                wallet_request.context = &m_context;
                 return command.actor(wallet_request, result, last_handler);
             }, command.argNames, command.unique_id);
             m_rpc_handlers.emplace_back(m_context.chain->handleRpc(m_rpc_commands.back()));
diff --git a/src/wallet/load.cpp b/src/wallet/load.cpp
index de72f16351..129b5c7c2a 100644
--- a/src/wallet/load.cpp
+++ b/src/wallet/load.cpp
@@ -7,7 +7,6 @@
 
 #include <common/args.h>
 #include <interfaces/chain.h>
-#include <node/interface_ui.h>
 #include <scheduler.h>
 #include <util/check.h>
 #include <util/fs.h>
@@ -25,17 +24,6 @@
 using util::Join;
 
 namespace wallet {
-
-bool HandleWalletLoadError(interfaces::Chain& chain, const std::string& wallet_file, const bilingual_str& error_string)
-{
-    if (!chain.initQuestion(error_string + Untranslated("\n\n") + _("Continue without this wallet?"), error_string, _("Error"), CClientUIInterface::MSG_ERROR | CClientUIInterface::MODAL | CClientUIInterface::BTN_OK | CClientUIInterface::BTN_ABORT)) {
-        return false;
-    }
-
-    RemoveWalletSetting(chain, wallet_file);
-    return true;
-}
-
 bool VerifyWallets(WalletContext& context)
 {
     interfaces::Chain& chain = *context.chain;
@@ -88,7 +76,6 @@ bool VerifyWallets(WalletContext& context)
     // Keep track of each wallet absolute path to detect duplicates.
     std::set<fs::path> wallet_paths;
 
-    bool modified_wallet_list = false;
     for (const auto& wallet : chain.getSettingsList("wallet")) {
         const auto& wallet_file = wallet.get_str();
         const fs::path path = fsbridge::AbsPathJoin(GetWalletDir(), fs::PathFromString(wallet_file));
@@ -108,20 +95,12 @@ bool VerifyWallets(WalletContext& context)
             if (status == DatabaseStatus::FAILED_NOT_FOUND) {
                 chain.initWarning(Untranslated(strprintf("Skipping -wallet path that doesn't exist. %s", error_string.original)));
             } else {
-                if (HandleWalletLoadError(chain, wallet_file, error_string)) {
-                    modified_wallet_list = true;
-                } else {
-                    return false;
-                }
+                chain.initError(error_string);
+                return false;
             }
         }
     }
 
-    if (modified_wallet_list) {
-        // Ensure new wallet list overrides commandline options
-        args.ForceSetArgV("wallet", chain.getRwSetting("wallet"));
-    }
-
     return true;
 }
 
@@ -150,11 +129,8 @@ bool LoadWallets(WalletContext& context)
             std::shared_ptr<CWallet> pwallet = database ? CWallet::Create(context, name, std::move(database), options.create_flags, error, warnings) : nullptr;
             if (!warnings.empty()) chain.initWarning(Join(warnings, Untranslated("\n")));
             if (!pwallet) {
-                if (HandleWalletLoadError(chain, name, error)) {
-                    continue;
-                } else {
-                    return false;
-                }
+                chain.initError(error);
+                return false;
             }
 
             NotifyWalletLoaded(context, pwallet);
diff --git a/src/wallet/receive.cpp b/src/wallet/receive.cpp
index e4d92d536a..c164266f80 100644
--- a/src/wallet/receive.cpp
+++ b/src/wallet/receive.cpp
@@ -4,7 +4,6 @@
 
 #include <consensus/amount.h>
 #include <consensus/consensus.h>
-#include <util/check.h>
 #include <wallet/receive.h>
 #include <wallet/transaction.h>
 #include <wallet/wallet.h>
@@ -320,90 +319,6 @@ Balance GetBalance(const CWallet& wallet, const int min_depth, bool avoid_reuse)
     return ret;
 }
 
-// Calculate total balance in a different way from GetBalance. The biggest
-// difference is that GetBalance sums up all unspent TxOuts paying to the
-// wallet, while this sums up both spent and unspent TxOuts paying to the
-// wallet, and then subtracts the values of TxIns spending from the wallet. This
-// also has fewer restrictions on which unconfirmed transactions are considered
-// trusted.
-CAmount CWallet::GetLegacyBalance(const isminefilter& filter, int minDepth) const
-{
-    LOCK(cs_wallet);
-
-    const auto tip_height = GetLastBlockHeight();
-    const auto tip_blockhash = m_last_block_processed;
-    int64_t tip_mtp = -1;
-    const auto checkFinalTx = [&](const CTransaction& tx) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet) {
-        // cloned from tx_verify:IsFinalTx, but optimised a bit
-        // NOTE: LOCKTIME_THRESHOLD would need to be checked before AD ~11500
-        // NOTE: <= rather than < because we care about the *next* block
-        if ((int64_t)tx.nLockTime <= tip_height) {
-            return true;
-        }
-        for (const auto& txin : tx.vin) {
-            if (!(txin.nSequence == CTxIn::SEQUENCE_FINAL)) {
-                if (tx.nLockTime >= LOCKTIME_THRESHOLD) {
-                    if (tip_mtp == -1) {
-                        CHECK_NONFATAL(this->chain().findBlock(tip_blockhash, interfaces::FoundBlock().mtpTime(tip_mtp)));
-                    }
-                    if (tx.nLockTime < tip_mtp) {
-                        return true;
-                    }
-                }
-
-                return false;
-            }
-        }
-        return true;
-    };
-
-    CAmount balance = 0;
-    for (const auto& entry : mapWallet) {
-        const CWalletTx& wtx = entry.second;
-        const int depth = GetTxDepthInMainChain(wtx);
-        if (depth < 0 || IsTxImmatureCoinBase(wtx)) {
-            continue;
-        }
-
-        if (depth == 0) {
-            bool have_conflicts = false;
-            for (const CTxIn& txin : wtx.tx->vin) {
-                if (mapTxSpends.count(txin.prevout) > 1) {
-                    have_conflicts = true;
-                    break;
-                }
-            }
-            if (have_conflicts && !wtx.InMempool()) {
-                // Rather than include two conflicting unconfirmed transactions in the same balance, only include ones in our mempool (which cannot contain conflicts)
-                continue;
-            }
-
-            if (!checkFinalTx(*wtx.tx)) {
-                continue;
-            }
-        }
-
-        // Loop through tx outputs and add incoming payments. For outgoing txs,
-        // treat change outputs specially, as part of the amount debited.
-        CAmount debit = GetDebit(*wtx.tx, filter);
-        const bool outgoing = debit > 0;
-        for (const CTxOut& out : wtx.tx->vout) {
-            if (outgoing && OutputIsChange(*this, out)) {
-                debit -= out.nValue;
-            } else if (IsMine(out) & filter && depth >= minDepth) {
-                balance += out.nValue;
-            }
-        }
-
-        // For outgoing txs, subtract amount debited.
-        if (outgoing) {
-            balance -= debit;
-        }
-    }
-
-    return balance;
-}
-
 std::map<CTxDestination, CAmount> GetAddressBalances(const CWallet& wallet)
 {
     std::map<CTxDestination, CAmount> balances;
diff --git a/src/wallet/rpc/addresses.cpp b/src/wallet/rpc/addresses.cpp
index 4455767881..838d062108 100644
--- a/src/wallet/rpc/addresses.cpp
+++ b/src/wallet/rpc/addresses.cpp
@@ -223,7 +223,6 @@ RPCHelpMan addmultisigaddress()
                 "This functionality is only intended for use with non-watchonly addresses.\n"
                 "See `importaddress` for watchonly p2sh address support.\n"
                 "If 'label' is specified, assign address to that label.\n"
-                "Public keys can be sorted according to BIP67 during the request if required.\n"
                 "Note: This command is only compatible with legacy wallets.\n",
                 {
                     {"nrequired", RPCArg::Type::NUM, RPCArg::Optional::NO, "The number of required signatures out of the n keys or addresses."},
@@ -232,14 +231,8 @@ RPCHelpMan addmultisigaddress()
                             {"key", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "bitcoin address or hex-encoded public key"},
                         },
                         },
-                    {"options|label", {RPCArg::Type::OBJ_NAMED_PARAMS, RPCArg::Type::STR}, RPCArg::Optional::OMITTED, "",
-                        {
-                            {"address_type", RPCArg::Type::STR, RPCArg::DefaultHint{"set by -addresstype"}, "The address type to use. Options are \"legacy\", \"p2sh-segwit\", and \"bech32\".", RPCArgOptions{.also_positional = true}},
-                            {"label", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "A label to assign the address to.", RPCArgOptions{.also_positional = true}},
-                            {"sort", RPCArg::Type::BOOL, RPCArg::Default{false}, "Whether to sort public keys according to BIP67."},
-                        },
-                        RPCArgOptions{.oneline_description="\"options\""}},
-                    {"address_type", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "", RPCArgOptions{.hidden=true}},
+                    {"label", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "A label to assign the addresses to."},
+                    {"address_type", RPCArg::Type::STR, RPCArg::DefaultHint{"set by -addresstype"}, "The address type to use. Options are \"legacy\", \"p2sh-segwit\", and \"bech32\"."},
                 },
                 RPCResult{
                     RPCResult::Type::OBJ, "", "",
@@ -257,7 +250,7 @@ RPCHelpMan addmultisigaddress()
             "\nAdd a multisig address from 2 addresses\n"
             + HelpExampleCli("addmultisigaddress", "2 \"[\\\"" + EXAMPLE_ADDRESS[0] + "\\\",\\\"" + EXAMPLE_ADDRESS[1] + "\\\"]\"") +
             "\nAs a JSON-RPC call\n"
-            + HelpExampleRpc("addmultisigaddress", "2, [\"" + EXAMPLE_ADDRESS[0] + "\",\"" + EXAMPLE_ADDRESS[1] + "\"]")
+            + HelpExampleRpc("addmultisigaddress", "2, \"[\\\"" + EXAMPLE_ADDRESS[0] + "\\\",\\\"" + EXAMPLE_ADDRESS[1] + "\\\"]\"")
                 },
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
 {
@@ -268,46 +261,9 @@ RPCHelpMan addmultisigaddress()
 
     LOCK2(pwallet->cs_wallet, spk_man.cs_KeyStore);
 
-    int required = request.params[0].getInt<int>();
-
-    std::string label;
-    OutputType output_type = pwallet->m_default_address_type;
-    bool sort = false;
-
-    if (!request.params[2].isNull()) {
-        if (request.params[2].type() == UniValue::VSTR) {
-            // Backward compatibility
-            label = LabelFromValue(request.params[2]);
-        } else {
-            const UniValue& options = request.params[2];
-            RPCTypeCheckObj(options,
-                {
-                    {"address_type", UniValueType(UniValue::VSTR)},
-                    {"label", UniValueType(UniValue::VSTR)},
-                    {"sort", UniValueType(UniValue::VBOOL)},
-                },
-                true, true);
-
-            if (options.exists("address_type")) {
-                if (!request.params[3].isNull()) {
-                    throw JSONRPCError(RPC_MISC_ERROR, "address_type provided in both options and 4th parameter");
-                }
-                std::optional<OutputType> parsed = ParseOutputType(options["address_type"].get_str());
-                if (!parsed) {
-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf("Unknown address type '%s'", options["address_type"].get_str()));
-                }
-                output_type = parsed.value();
-            }
+    const std::string label{LabelFromValue(request.params[2])};
 
-            if (options.exists("label")) {
-                label = LabelFromValue(options["label"]);
-            }
-
-            if (options.exists("sort")) {
-                sort = options["sort"].get_bool();
-            }
-        }
-    }
+    int required = request.params[0].getInt<int>();
 
     // Get the public keys
     const UniValue& keys_or_addrs = request.params[1].get_array();
@@ -318,11 +274,9 @@ RPCHelpMan addmultisigaddress()
         } else {
             pubkeys.push_back(AddrToPubKey(spk_man, keys_or_addrs[i].get_str()));
         }
-        if (sort && !pubkeys.back().IsCompressed()) {
-            throw std::runtime_error(strprintf("Compressed key required for BIP67: %s", keys_or_addrs[i].get_str()));
-        }
     }
 
+    OutputType output_type = pwallet->m_default_address_type;
     if (!request.params[3].isNull()) {
         std::optional<OutputType> parsed = ParseOutputType(request.params[3].get_str());
         if (!parsed) {
@@ -336,7 +290,7 @@ RPCHelpMan addmultisigaddress()
     // Construct multisig scripts
     FlatSigningProvider provider;
     CScript inner;
-    CTxDestination dest = AddAndGetMultisigDestination(required, pubkeys, output_type, provider, inner, sort);
+    CTxDestination dest = AddAndGetMultisigDestination(required, pubkeys, output_type, provider, inner);
 
     // Import scripts into the wallet
     for (const auto& [id, script] : provider.scripts) {
@@ -577,7 +531,6 @@ RPCHelpMan getaddressinfo()
                         {RPCResult::Type::STR, "address", "The bitcoin address validated."},
                         {RPCResult::Type::STR_HEX, "scriptPubKey", "The hex-encoded output script generated by the address."},
                         {RPCResult::Type::BOOL, "ismine", "If the address is yours."},
-                        {RPCResult::Type::BOOL, "isactive", "If the key is in the active keypool (always equal to \"ismine\" in descriptor wallets)."},
                         {RPCResult::Type::BOOL, "iswatchonly", "If the address is watchonly."},
                         {RPCResult::Type::BOOL, "solvable", "If we know how to spend coins sent to this address, ignoring the possible lack of private keys."},
                         {RPCResult::Type::STR, "desc", /*optional=*/true, "A descriptor for spending coins sent to this address (only when solvable)."},
@@ -612,10 +565,6 @@ RPCHelpMan getaddressinfo()
                         {
                             {RPCResult::Type::STR, "label name", "Label name (defaults to \"\")."},
                         }},
-                        {RPCResult::Type::ARR, "use_txids", "",
-                        {
-                            {RPCResult::Type::STR_HEX, "txid", "The ids of transactions involving this wallet which received with the address"},
-                        }},
                     }
                 },
                 RPCExamples{
@@ -652,7 +601,6 @@ RPCHelpMan getaddressinfo()
 
     isminetype mine = pwallet->IsMine(dest);
     ret.pushKV("ismine", bool(mine & ISMINE_SPENDABLE));
-    ret.pushKV("isactive", pwallet->IsDestinationActive(dest));
 
     if (provider) {
         auto inferred = InferDescriptor(scriptPubKey, *provider);
@@ -710,15 +658,6 @@ RPCHelpMan getaddressinfo()
     }
     ret.pushKV("labels", std::move(labels));
 
-    // NOTE: Intentionally not special-casing a single txid: while addresses
-    // should never be reused, it's not unexpected to have RBF result in
-    // multiple txids for a single use.
-    UniValue use_txids(UniValue::VARR);
-    pwallet->FindScriptPubKeyUsed(std::set<CScript>{scriptPubKey}, [&use_txids](const CWalletTx&wtx) {
-        use_txids.push_back(wtx.GetHash().GetHex());
-    });
-    ret.pushKV("use_txids", std::move(use_txids));
-
     return ret;
 },
     };
diff --git a/src/wallet/rpc/backup.cpp b/src/wallet/rpc/backup.cpp
index 2750b13ae4..0d0e86ed24 100644
--- a/src/wallet/rpc/backup.cpp
+++ b/src/wallet/rpc/backup.cpp
@@ -6,7 +6,6 @@
 
 #include <chain.h>
 #include <clientversion.h>
-#include <codex32.h>
 #include <core_io.h>
 #include <hash.h>
 #include <interfaces/chain.h>
@@ -217,8 +216,6 @@ RPCHelpMan importprivkey()
     };
 }
 
-UniValue ProcessDescriptorImport(CWallet& wallet, const UniValue& data, const int64_t timestamp, const std::vector<CExtKey>& master_keys = {}) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);
-
 RPCHelpMan importaddress()
 {
     return RPCHelpMan{"importaddress",
@@ -232,7 +229,7 @@ RPCHelpMan importaddress()
             "\nNote: If you import a non-standard raw script in hex form, outputs sending to it will be treated\n"
             "as change, and not show up in many RPCs.\n"
             "Note: Use \"getwalletinfo\" to query the scanning progress.\n"
-            "Note: For descriptor wallets, this command will create new descriptor/s, and only works if the wallet has private keys disabled.\n",
+            "Note: This command is only compatible with legacy wallets. Use \"importdescriptors\" for descriptor wallets.\n",
                 {
                     {"address", RPCArg::Type::STR, RPCArg::Optional::NO, "The Bitcoin address (or hex-encoded script)"},
                     {"label", RPCArg::Type::STR, RPCArg::Default{""}, "An optional label"},
@@ -253,18 +250,7 @@ RPCHelpMan importaddress()
     std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);
     if (!pwallet) return UniValue::VNULL;
 
-    // Use legacy spkm only if the wallet does not support descriptors.
-    bool use_legacy = !pwallet->IsWalletFlagSet(WALLET_FLAG_DESCRIPTORS);
-    if (use_legacy) {
-        // In case the wallet is blank
     EnsureLegacyScriptPubKeyMan(*pwallet, true);
-    } else {
-        // We don't allow mixing watch-only descriptors with spendable ones.
-        if (!pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {
-            throw JSONRPCError(RPC_WALLET_ERROR, "Cannot import address in wallet with private keys enabled. "
-                                                 "Create wallet with no private keys to watch specific addresses/scripts");
-        }
-    }
 
     const std::string strLabel{LabelFromValue(request.params[1])};
 
@@ -290,41 +276,23 @@ RPCHelpMan importaddress()
     if (!request.params[3].isNull())
         fP2SH = request.params[3].get_bool();
 
-    // Import descriptor helper function
-    const auto& import_descriptor = [pwallet](const std::string& desc, const std::string label) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet) {
-        UniValue data(UniValue::VType::VOBJ);
-        data.pushKV("desc", AddChecksum(desc));
-        if (!label.empty()) data.pushKV("label", label);
-        const UniValue& ret = ProcessDescriptorImport(*pwallet, data, /*timestamp=*/1);
-        if (ret.exists("error")) throw ret["error"];
-    };
-
     {
         LOCK(pwallet->cs_wallet);
 
-        const std::string& address = request.params[0].get_str();
-        CTxDestination dest = DecodeDestination(address);
+        CTxDestination dest = DecodeDestination(request.params[0].get_str());
         if (IsValidDestination(dest)) {
             if (fP2SH) {
                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Cannot use the p2sh flag with an address - use a script instead");
             }
             if (OutputTypeFromDestination(dest) == OutputType::BECH32M) {
-                if (use_legacy)
                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Bech32m addresses cannot be imported into legacy wallets");
             }
 
             pwallet->MarkDirty();
 
-            if (use_legacy) {
             pwallet->ImportScriptPubKeys(strLabel, {GetScriptForDestination(dest)}, /*have_solving_data=*/false, /*apply_label=*/true, /*timestamp=*/1);
-            } else {
-                import_descriptor("addr(" + address + ")", strLabel);
-            }
         } else if (IsHex(request.params[0].get_str())) {
-            const std::string& hex = request.params[0].get_str();
-
-            if (use_legacy) {
-                std::vector<unsigned char> data(ParseHex(hex));
+            std::vector<unsigned char> data(ParseHex(request.params[0].get_str()));
             CScript redeem_script(data.begin(), data.end());
 
             std::set<CScript> scripts = {redeem_script};
@@ -335,14 +303,6 @@ RPCHelpMan importaddress()
             }
 
             pwallet->ImportScriptPubKeys(strLabel, scripts, /*have_solving_data=*/false, /*apply_label=*/true, /*timestamp=*/1);
-            } else {
-                // P2SH Not allowed. Can't detect inner P2SH function from a raw hex.
-                if (fP2SH) throw JSONRPCError(RPC_WALLET_ERROR, "P2SH import feature disabled for descriptors' wallet. "
-                                                                "Use 'importdescriptors' to specify inner P2SH function");
-
-                // Import descriptors
-                import_descriptor("raw(" + hex + ")", strLabel);
-            }
         } else {
             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid Bitcoin address or script");
         }
@@ -545,8 +505,6 @@ RPCHelpMan importwallet()
                 },
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
 {
-    EnsureNotWalletRestricted(request);
-
     std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);
     if (!pwallet) return UniValue::VNULL;
 
@@ -721,47 +679,6 @@ RPCHelpMan dumpprivkey()
     };
 }
 
-RPCHelpMan dumpmasterprivkey()
-{
-    return RPCHelpMan{"dumpmasterprivkey",
-                "Reveals the current master private key.\n",
-                {},
-                RPCResult{
-                    RPCResult::Type::STR, "key", "The HD master private key"
-                },
-                RPCExamples{
-                    HelpExampleCli("dumpmasterprivkey", "")
-                },
-        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
-{
-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);
-    if (!wallet) return NullUniValue;
-    const CWallet* const pwallet = wallet.get();
-
-    LegacyScriptPubKeyMan& spk_man = EnsureLegacyScriptPubKeyMan(*wallet);
-
-    LOCK2(pwallet->cs_wallet, spk_man.cs_KeyStore);
-
-    EnsureWalletIsUnlocked(*pwallet);
-
-    CKeyID seed_id = spk_man.GetHDChain().seed_id;
-    if (!spk_man.IsHDEnabled()) {
-        throw JSONRPCError(RPC_WALLET_ERROR, "Wallet is not a HD wallet.");
-    }
-    CKey seed;
-    if (spk_man.GetKey(seed_id, seed)) {
-        CExtKey masterKey;
-        masterKey.SetSeed(seed);
-
-        return EncodeExtKey(masterKey);
-    } else {
-        throw JSONRPCError(RPC_WALLET_ERROR, "Unable to retrieve HD master private key");
-        return NullUniValue;
-    }
-},
-    };
-}
-
 
 RPCHelpMan dumpwallet()
 {
@@ -786,8 +703,6 @@ RPCHelpMan dumpwallet()
                 },
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
 {
-    EnsureNotWalletRestricted(request);
-
     const std::shared_ptr<const CWallet> pwallet = GetWalletForJSONRPCRequest(request);
     if (!pwallet) return UniValue::VNULL;
 
@@ -882,13 +797,7 @@ RPCHelpMan dumpwallet()
             } else {
                 file << "change=1";
             }
-            if (metadata.has_key_origin) {
-                file << " hdkeypath=" + WriteHDKeypath(metadata.key_origin.path, /*apostrophe=*/true);
-                if (!(metadata.hd_seed_id.IsNull() || (metadata.hdKeypath == "s" && metadata.hd_seed_id == keyid))) {
-                    file << " hdseedid=" + metadata.hd_seed_id.GetHex();
-                }
-            }
-            file << strprintf(" # addr=%s\n", strAddr);
+            file << strprintf(" # addr=%s%s\n", strAddr, (metadata.has_key_origin ? " hdkeypath="+WriteHDKeypath(metadata.key_origin.path, /*apostrophe=*/true) : ""));
         }
     }
     file << "\n";
@@ -1526,7 +1435,7 @@ RPCHelpMan importmulti()
     };
 }
 
-UniValue ProcessDescriptorImport(CWallet& wallet, const UniValue& data, const int64_t timestamp, const std::vector<CExtKey>& master_keys) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet)
+static UniValue ProcessDescriptorImport(CWallet& wallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet)
 {
     UniValue warnings(UniValue::VARR);
     UniValue result(UniValue::VOBJ);
@@ -1543,10 +1452,6 @@ UniValue ProcessDescriptorImport(CWallet& wallet, const UniValue& data, const in
 
         // Parse descriptor string
         FlatSigningProvider keys;
-        for (const auto& mk : master_keys) {
-            keys.AddMasterKey(mk);
-        }
-
         std::string error;
         auto parsed_desc = Parse(descriptor, keys, error, /* require_checksum = */ true);
         if (!parsed_desc) {
@@ -1699,15 +1604,6 @@ RPCHelpMan importdescriptors()
                             },
                         },
                         RPCArgOptions{.oneline_description="requests"}},
-                    {"seeds", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, "BIP32 master seeds for the above descriptors",
-                        {
-                            {"shares", RPCArg::Type::ARR, RPCArg::Optional::OMITTED, "a codex32 (BIP 93) encoded seed, or list of codex32-encoded shares",
-                                {
-                                    {"share 1", RPCArg::Type::STR, RPCArg::Optional::OMITTED, ""},
-                                },
-                            },
-                        },
-                        RPCArgOptions{.oneline_description="seeds"}},
                 },
                 RPCResult{
                     RPCResult::Type::ARR, "", "Response is an array with the same size as the input that has the execution result",
@@ -1760,48 +1656,6 @@ RPCHelpMan importdescriptors()
     int64_t now = 0;
     int64_t lowest_timestamp = 0;
     bool rescan = false;
-
-    // Parse codex32 strings
-    std::vector<CExtKey> master_keys;
-    if (main_request.params[1].isArray()) {
-        const auto& req_seeds = main_request.params[1].get_array();
-        master_keys.reserve(req_seeds.size());
-        for (size_t i = 0; i < req_seeds.size(); ++i) {
-            const auto& req_shares = req_seeds[i].get_array();
-            std::vector<codex32::Result> shares;
-            shares.reserve(req_shares.size());
-            for (size_t j = 0; j < req_shares.size(); ++j) {
-                if (!req_shares[j].isStr()) {
-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "codex32 shares must be strings");
-                }
-                codex32::Result key_res{req_shares[j].get_str()};
-                if (!key_res.IsValid()) {
-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid codex32 share: " + codex32::ErrorString(key_res.error()));
-                }
-                shares.push_back(key_res);
-            }
-
-            // Recover seed
-            std::vector<unsigned char> seed;
-            if (shares.size() == 1) {
-                if (shares[0].GetShareIndex() != 's') {
-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid codex32: single share must be the S share");
-                }
-                seed = shares[0].GetPayload();
-            } else {
-                codex32::Result s{shares, 's'};
-                if (!s.IsValid()) {
-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Failed to derive codex32 seed: " + codex32::ErrorString(s.error()));
-                }
-                seed = s.GetPayload();
-            }
-
-            CExtKey master_key;
-            master_key.SetSeed(Span{(std::byte*) seed.data(), seed.size()});
-            master_keys.push_back(master_key);
-        }
-    }
-
     UniValue response(UniValue::VARR);
     {
         LOCK(pwallet->cs_wallet);
@@ -1813,7 +1667,7 @@ RPCHelpMan importdescriptors()
         for (const UniValue& request : requests.getValues()) {
             // This throws an error if "timestamp" doesn't exist
             const int64_t timestamp = std::max(GetImportTimestamp(request, now), minimum_timestamp);
-            const UniValue result = ProcessDescriptorImport(*pwallet, request, timestamp, master_keys);
+            const UniValue result = ProcessDescriptorImport(*pwallet, request, timestamp);
             response.push_back(result);
 
             if (lowest_timestamp > timestamp ) {
@@ -2005,8 +1859,6 @@ RPCHelpMan backupwallet()
                 },
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
 {
-    EnsureNotWalletRestricted(request);
-
     const std::shared_ptr<const CWallet> pwallet = GetWalletForJSONRPCRequest(request);
     if (!pwallet) return UniValue::VNULL;
 
@@ -2057,7 +1909,6 @@ RPCHelpMan restorewallet()
         },
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
 {
-    EnsureNotWalletRestricted(request);
 
     WalletContext& context = EnsureWalletContext(request.context);
 
diff --git a/src/wallet/rpc/coins.cpp b/src/wallet/rpc/coins.cpp
index 5dbbf01456..f1430a3c60 100644
--- a/src/wallet/rpc/coins.cpp
+++ b/src/wallet/rpc/coins.cpp
@@ -167,8 +167,8 @@ RPCHelpMan getbalance()
                 "The available balance is what the wallet considers currently spendable, and is\n"
                 "thus affected by options which limit spendability such as -spendzeroconfchange.\n",
                 {
-                    {"dummy|account", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "Set to null to only account for trusted transactions, or \"*\" to account for all transactions."},
-                    {"minconf", RPCArg::Type::NUM, RPCArg::Default{1}, "Only include incoming transactions confirmed at least this many times. (Requires dummy=\"*\")"},
+                    {"dummy", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "Remains for backward compatibility. Must be excluded or set to \"*\"."},
+                    {"minconf", RPCArg::Type::NUM, RPCArg::Default{0}, "Only include transactions confirmed at least this many times."},
                     {"include_watchonly", RPCArg::Type::BOOL, RPCArg::DefaultHint{"true for watch-only wallets, otherwise false"}, "Also include balance in watch-only addresses (see 'importaddress')"},
                     {"avoid_reuse", RPCArg::Type::BOOL, RPCArg::Default{true}, "(only available if avoid_reuse wallet flag is set) Do not include balance in dirty outputs; addresses are considered dirty if they have previously been used in a transaction."},
                 },
@@ -199,23 +199,12 @@ RPCHelpMan getbalance()
         throw JSONRPCError(RPC_METHOD_DEPRECATED, "dummy first argument must be excluded or set to \"*\".");
     }
 
-    const auto min_depth{dummy_value ? self.Arg<int>("minconf") : 0};
+    const auto min_depth{self.Arg<int>("minconf")};
 
     bool include_watchonly = ParseIncludeWatchonly(request.params[2], *pwallet);
 
     bool avoid_reuse = GetAvoidReuseFlag(*pwallet, request.params[3]);
 
-    if (dummy_value) {
-        if (avoid_reuse) throw JSONRPCError(RPC_INVALID_PARAMETER, "getbalance avoid_reuse flag is not supported if dummy is set to \"*\"");
-        isminefilter filter = ISMINE_SPENDABLE;
-        if (include_watchonly) filter = filter | ISMINE_WATCH_ONLY;
-        return ValueFromAmount(pwallet->GetLegacyBalance(filter, min_depth));
-    }
-
-    if (!request.params[1].isNull()) {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "getbalance minconf option is only currently supported if dummy is set to \"*\"");
-    }
-
     const auto bal = GetBalance(*pwallet, min_depth, avoid_reuse);
 
     return ValueFromAmount(bal.m_mine_trusted + (include_watchonly ? bal.m_watchonly_trusted : 0));
@@ -287,7 +276,7 @@ RPCHelpMan lockunspent()
             "\nLock the transaction persistently in the wallet database\n"
             + HelpExampleCli("lockunspent", "false \"[{\\\"txid\\\":\\\"a08e6907dbbd3d809776dbfc5d82e371b764ed838b5655e72f463568df1aadf0\\\",\\\"vout\\\":1}]\" true") +
             "\nAs a JSON-RPC call\n"
-            + HelpExampleRpc("lockunspent", "false, [{\"txid\":\"a08e6907dbbd3d809776dbfc5d82e371b764ed838b5655e72f463568df1aadf0\",\"vout\":1}]")
+            + HelpExampleRpc("lockunspent", "false, \"[{\\\"txid\\\":\\\"a08e6907dbbd3d809776dbfc5d82e371b764ed838b5655e72f463568df1aadf0\\\",\\\"vout\\\":1}]\"")
                 },
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
 {
@@ -565,9 +554,9 @@ RPCHelpMan listunspent()
                 RPCExamples{
                     HelpExampleCli("listunspent", "")
             + HelpExampleCli("listunspent", "6 9999999 \"[\\\"" + EXAMPLE_ADDRESS[0] + "\\\",\\\"" + EXAMPLE_ADDRESS[1] + "\\\"]\"")
-            + HelpExampleRpc("listunspent", "6, 9999999, [\"" + EXAMPLE_ADDRESS[0] + "\",\"" + EXAMPLE_ADDRESS[1] + "\"]")
+            + HelpExampleRpc("listunspent", "6, 9999999 \"[\\\"" + EXAMPLE_ADDRESS[0] + "\\\",\\\"" + EXAMPLE_ADDRESS[1] + "\\\"]\"")
             + HelpExampleCli("listunspent", "6 9999999 '[]' true '{ \"minimumAmount\": 0.005 }'")
-            + HelpExampleRpc("listunspent", "6, 9999999, [], true, { \"minimumAmount\": 0.005 } ")
+            + HelpExampleRpc("listunspent", "6, 9999999, [] , true, { \"minimumAmount\": 0.005 } ")
                 },
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
 {
diff --git a/src/wallet/rpc/signmessage.cpp b/src/wallet/rpc/signmessage.cpp
index cd41cf3eb6..edf93ecab7 100644
--- a/src/wallet/rpc/signmessage.cpp
+++ b/src/wallet/rpc/signmessage.cpp
@@ -51,14 +51,12 @@ RPCHelpMan signmessage()
             }
 
             const PKHash* pkhash = std::get_if<PKHash>(&dest);
-            MessageSignatureFormat sig_format{MessageSignatureFormat::LEGACY};
-            // TODO: Make sig_format choosable
             if (!pkhash) {
-                sig_format = MessageSignatureFormat::SIMPLE;
+                throw JSONRPCError(RPC_TYPE_ERROR, "Address does not refer to key");
             }
 
             std::string signature;
-            SigningResult err = pwallet->SignMessage(sig_format, strMessage, dest, signature);
+            SigningResult err = pwallet->SignMessage(strMessage, *pkhash, signature);
             if (err == SigningResult::SIGNING_FAILED) {
                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, SigningResultString(err));
             } else if (err != SigningResult::OK) {
diff --git a/src/wallet/rpc/spend.cpp b/src/wallet/rpc/spend.cpp
index ba556a64b5..601d8e4fa7 100644
--- a/src/wallet/rpc/spend.cpp
+++ b/src/wallet/rpc/spend.cpp
@@ -12,7 +12,6 @@
 #include <rpc/util.h>
 #include <script/script.h>
 #include <util/rbf.h>
-#include <util/strencodings.h>
 #include <util/translation.h>
 #include <util/vector.h>
 #include <wallet/coincontrol.h>
@@ -60,13 +59,9 @@ static void InterpretFeeEstimationInstructions(const UniValue& conf_target, cons
     } else {
         options.pushKV("fee_rate", fee_rate);
     }
-    auto estimate_mode_set = !options["estimate_mode"].isNull() && (ToLower(options["estimate_mode"].get_str()) != "unset");
-    if (!options["conf_target"].isNull() && !estimate_mode_set) {
+    if (!options["conf_target"].isNull() && (options["estimate_mode"].isNull() || (options["estimate_mode"].get_str() == "unset"))) {
         throw JSONRPCError(RPC_INVALID_PARAMETER, "Specify estimate_mode");
     }
-    if (options["conf_target"].isNull() && estimate_mode_set) {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "estimate_mode should be passed with conf_target");
-    }
 }
 
 std::set<int> InterpretSubtractFeeFromOutputInstructions(const UniValue& sffo_instructions, const std::vector<std::string>& destinations)
@@ -100,21 +95,8 @@ std::set<int> InterpretSubtractFeeFromOutputInstructions(const UniValue& sffo_in
     return sffo_set;
 }
 
-static UniValue FinishTransaction(const std::shared_ptr<CWallet> pwallet, const UniValue& options, CMutableTransaction& rawTx)
+static UniValue FinishTransaction(const std::shared_ptr<CWallet> pwallet, const UniValue& options, const CMutableTransaction& rawTx)
 {
-    bool can_anti_fee_snipe = !options.exists("locktime");
-
-    for (const CTxIn& tx_in : rawTx.vin) {
-        // Checks sequence values consistent with DiscourageFeeSniping
-        can_anti_fee_snipe &= (tx_in.nSequence == CTxIn::MAX_SEQUENCE_NONFINAL || tx_in.nSequence == MAX_BIP125_RBF_SEQUENCE);
-    }
-
-    if (can_anti_fee_snipe) {
-        LOCK(pwallet->cs_wallet);
-        FastRandomContext rng_fast;
-        DiscourageFeeSniping(rawTx, rng_fast, pwallet->chain(), pwallet->GetLastBlockHash(), pwallet->GetLastBlockHeight());
-    }
-
     // Make a blank psbt
     PartiallySignedTransaction psbtx(rawTx);
 
@@ -227,7 +209,7 @@ static void SetFeeEstimateMode(const CWallet& wallet, CCoinControl& cc, const Un
         if (!conf_target.isNull()) {
             throw JSONRPCError(RPC_INVALID_PARAMETER, "Cannot specify both conf_target and fee_rate. Please provide either a confirmation target in blocks for automatic fee estimation, or an explicit fee rate.");
         }
-        if (!estimate_mode.isNull() && ToLower(estimate_mode.get_str()) != "unset") {
+        if (!estimate_mode.isNull() && estimate_mode.get_str() != "unset") {
             throw JSONRPCError(RPC_INVALID_PARAMETER, "Cannot specify both estimate_mode and fee_rate");
         }
         // Fee rates in sat/vB cannot represent more than 3 significant digits.
@@ -433,80 +415,6 @@ RPCHelpMan sendmany()
     };
 }
 
-RPCHelpMan setfeerate()
-{
-    return RPCHelpMan{
-        "setfeerate",
-        "\nSet the transaction fee rate in " + CURRENCY_ATOM + "/vB for this wallet.\n"
-        "Overrides the global -paytxfee configuration option. Like -paytxfee, it is not persisted after bitcoind shutdown/restart.\n"
-        "Can be deactivated by passing 0 as the fee rate, in which case automatic fee selection will be used by default.\n",
-        {
-            {"amount", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, "The transaction fee rate in " + CURRENCY_ATOM + "/vB to set (0 to unset)"},
-        },
-        RPCResult{
-            RPCResult::Type::OBJ, "", "",
-            {
-                {RPCResult::Type::STR, "wallet_name", "Name of the wallet the fee rate setting applies to"},
-                {RPCResult::Type::NUM, "fee_rate", "Fee rate in " + CURRENCY_ATOM + "/vB for the wallet after this operation"},
-                {RPCResult::Type::STR, "result", /* optional */ true, "Description of result, if successful"},
-                {RPCResult::Type::STR, "error", /* optional */ true, "Description of error, if any"},
-            },
-        },
-        RPCExamples{
-            ""
-            "\nSet a fee rate of 1 " + CURRENCY_ATOM + "/vB\n"
-            + HelpExampleCli("setfeerate", "1") +
-            "\nSet a fee rate of 3.141 " + CURRENCY_ATOM + "/vB\n"
-            + HelpExampleCli("setfeerate", "3.141") +
-            "\nSet a fee rate of 7.75 " + CURRENCY_ATOM + "/vB with named arguments\n"
-            + HelpExampleCli("-named setfeerate", "amount=\"7.75\"") +
-            "\nSet a fee rate of 25 " + CURRENCY_ATOM + "/vB with the RPC\n"
-            + HelpExampleRpc("setfeerate", "25")
-        },
-        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue {
-            std::shared_ptr<CWallet> const rpc_wallet{GetWalletForJSONRPCRequest(request)};
-            if (!rpc_wallet) return NullUniValue;
-            CWallet& wallet = *rpc_wallet;
-
-            LOCK(wallet.cs_wallet);
-            const CFeeRate amount{AmountFromValue(request.params[0]), COIN /* sat/vB */};
-            const CFeeRate relay_min_feerate{wallet.chain().relayMinFee().GetFeePerK()};
-            const CFeeRate wallet_min_feerate{wallet.m_min_fee.GetFeePerK()};
-            const CFeeRate wallet_max_feerate{wallet.m_default_max_tx_fee, 1000 /* BTC/kvB */};
-            const CFeeRate zero{CFeeRate{0}};
-            const std::string amount_str{amount.ToString(FeeEstimateMode::SAT_VB)};
-            const std::string current_setting{strprintf("The current setting of %s for this wallet remains unchanged.", wallet.m_pay_tx_fee == zero ? "0 (unset)" : wallet.m_pay_tx_fee.ToString(FeeEstimateMode::SAT_VB))};
-            std::string result, error;
-
-            if (amount == zero) {
-                if (request.params[0].get_real() != 0) throw JSONRPCError(RPC_TYPE_ERROR, "Invalid amount");
-                wallet.m_pay_tx_fee = amount;
-                result = "Fee rate for transactions with this wallet successfully unset. By default, automatic fee selection will be used.";
-            } else if (amount < relay_min_feerate) {
-                error = strprintf("The requested fee rate of %s cannot be less than the minimum relay fee rate of %s. %s", amount_str, relay_min_feerate.ToString(FeeEstimateMode::SAT_VB), current_setting);
-            } else if (amount < wallet_min_feerate) {
-                error = strprintf("The requested fee rate of %s cannot be less than the wallet min fee rate of %s. %s", amount_str, wallet_min_feerate.ToString(FeeEstimateMode::SAT_VB), current_setting);
-            } else if (amount > wallet_max_feerate) {
-                error = strprintf("The requested fee rate of %s cannot be greater than the wallet max fee rate of %s. %s", amount_str, wallet_max_feerate.ToString(FeeEstimateMode::SAT_VB), current_setting);
-            } else {
-                wallet.m_pay_tx_fee = amount;
-                result = "Fee rate for transactions with this wallet successfully set to " + amount_str;
-            }
-            CHECK_NONFATAL(result.empty() != error.empty());
-
-            UniValue obj{UniValue::VOBJ};
-            obj.pushKV("wallet_name", wallet.GetName());
-            obj.pushKV("fee_rate", ValueFromFeeRate(wallet.m_pay_tx_fee));
-            if (error.empty()) {
-                obj.pushKV("result", result);
-            } else {
-                obj.pushKV("error", error);
-            }
-            return obj;
-        },
-    };
-}
-
 RPCHelpMan settxfee()
 {
     return RPCHelpMan{"settxfee",
@@ -630,13 +538,11 @@ CreatedTransactionResult FundTransaction(CWallet& wallet, const CMutableTransact
                 {"subtract_fee_from_outputs", UniValueType(UniValue::VARR)},
                 {"replaceable", UniValueType(UniValue::VBOOL)},
                 {"conf_target", UniValueType(UniValue::VNUM)},
-                {"min_conf", UniValueType(UniValue::VNUM)},
                 {"estimate_mode", UniValueType(UniValue::VSTR)},
                 {"minconf", UniValueType(UniValue::VNUM)},
                 {"maxconf", UniValueType(UniValue::VNUM)},
                 {"input_weights", UniValueType(UniValue::VARR)},
                 {"max_tx_weight", UniValueType(UniValue::VNUM)},
-                {"segwit_inputs_only", UniValueType(UniValue::VBOOL)},
             },
             true, true);
 
@@ -644,10 +550,6 @@ CreatedTransactionResult FundTransaction(CWallet& wallet, const CMutableTransact
             coinControl.m_allow_other_inputs = options["add_inputs"].get_bool();
         }
 
-        if (options.exists("segwit_inputs_only")) {
-            coinControl.m_segwit_inputs_only = options["segwit_inputs_only"].get_bool();
-        }
-
         if (options.exists("changeAddress") || options.exists("change_address")) {
             const std::string change_address_str = (options.exists("change_address") ? options["change_address"] : options["changeAddress"]).get_str();
             CTxDestination dest = DecodeDestination(change_address_str);
@@ -714,17 +616,6 @@ CreatedTransactionResult FundTransaction(CWallet& wallet, const CMutableTransact
                 throw JSONRPCError(RPC_INVALID_PARAMETER, "Negative minconf");
             }
         }
-        if (options.exists("min_conf")) {
-            if (options.exists("minconf")) {
-                throw JSONRPCError(RPC_INVALID_PARAMETER, "min_conf and minconf options should not both be set. Use minconf (min_conf is deprecated).");
-            }
-
-            coinControl.m_min_depth = options["min_conf"].getInt<int>();
-
-            if (coinControl.m_min_depth < 0) {
-                throw JSONRPCError(RPC_INVALID_PARAMETER, "Negative min_conf");
-            }
-        }
 
         if (options.exists("maxconf")) {
             coinControl.m_max_depth = options["maxconf"].getInt<int>();
@@ -902,7 +793,6 @@ RPCHelpMan fundrawtransaction()
                              },
                             {"max_tx_weight", RPCArg::Type::NUM, RPCArg::Default{MAX_STANDARD_TX_WEIGHT}, "The maximum acceptable transaction weight.\n"
                                                           "Transaction building will fail if this can not be satisfied."},
-                            {"segwit_inputs_only", RPCArg::Type::BOOL, RPCArg::Default{false}, "Whether to only use segwit inputs for transaction."},
                         },
                         FundTxDoc()),
                         RPCArgOptions{
@@ -1014,8 +904,6 @@ RPCHelpMan signrawtransactionwithwallet()
                     {
                         {RPCResult::Type::STR_HEX, "hex", "The hex-encoded raw transaction with signature(s)"},
                         {RPCResult::Type::BOOL, "complete", "If the transaction has a complete set of signatures"},
-                        {RPCResult::Type::STR_AMOUNT, "fee", /*optional=*/true, "The fee (input amounts minus output amounts), if known"},
-                        {RPCResult::Type::STR_AMOUNT, "feerate", /*optional=*/true, "The fee rate (in " + CURRENCY_UNIT + "/kB), if fee is known"},
                         {RPCResult::Type::ARR, "errors", /*optional=*/true, "Script verification errors (if there are any)",
                         {
                             {RPCResult::Type::OBJ, "", "",
@@ -1065,11 +953,10 @@ RPCHelpMan signrawtransactionwithwallet()
 
     // Script verification errors
     std::map<int, bilingual_str> input_errors;
-    std::optional<CAmount> inputs_amount_sum;
 
-    bool complete = pwallet->SignTransaction(mtx, coins, nHashType, input_errors, &inputs_amount_sum);
+    bool complete = pwallet->SignTransaction(mtx, coins, nHashType, input_errors);
     UniValue result(UniValue::VOBJ);
-    SignTransactionResultToJSON(mtx, complete, coins, input_errors, result, inputs_amount_sum);
+    SignTransactionResultToJSON(mtx, complete, coins, input_errors, result);
     return result;
 },
     };
@@ -1089,7 +976,7 @@ static std::vector<RPCArg> OutputsDoc()
         },
         {"", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, "",
             {
-                {"data", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "A key-value pair. The key must be \"data\", the value is hex-encoded data that becomes a part of an OP_RETURN output"},
+                {"data", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "A key-value pair. The key must be \"data\", the value is hex-encoded data"},
             },
         },
     };
@@ -1337,21 +1224,19 @@ RPCHelpMan send()
                     {"include_watching", RPCArg::Type::BOOL, RPCArg::DefaultHint{"true for watch-only wallets, otherwise false"}, "Also select inputs which are watch only.\n"
                                           "Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\n"
                                           "e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field."},
-                    {"inputs", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, "Specify inputs instead of adding them automatically.",
+                    {"inputs", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, "Specify inputs instead of adding them automatically. A JSON array of JSON objects",
                         {
-                          {"", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, "", {
                             {"txid", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "The transaction id"},
                             {"vout", RPCArg::Type::NUM, RPCArg::Optional::NO, "The output number"},
-                            {"sequence", RPCArg::Type::NUM, RPCArg::DefaultHint{"depends on the value of the 'replaceable' and 'locktime' arguments"}, "The sequence number"},
+                            {"sequence", RPCArg::Type::NUM, RPCArg::Optional::NO, "The sequence number"},
                             {"weight", RPCArg::Type::NUM, RPCArg::DefaultHint{"Calculated from wallet and solving data"}, "The maximum weight for this input, "
                                         "including the weight of the outpoint and sequence number. "
                                         "Note that signature sizes are not guaranteed to be consistent, "
                                         "so the maximum DER signatures size of 73 bytes should be used when considering ECDSA signatures."
                                         "Remember to convert serialized sizes to weight units when necessary."},
-                          }},
                         },
                     },
-                    {"locktime", RPCArg::Type::NUM, RPCArg::DefaultHint{"locktime close to block height to prevent fee sniping"}, "Raw locktime. Non-0 value also locktime-activates inputs"},
+                    {"locktime", RPCArg::Type::NUM, RPCArg::Default{0}, "Raw locktime. Non-0 value also locktime-activates inputs"},
                     {"lock_unspents", RPCArg::Type::BOOL, RPCArg::Default{false}, "Lock selected unspent outputs"},
                     {"psbt", RPCArg::Type::BOOL,  RPCArg::DefaultHint{"automatic"}, "Always return a PSBT, implies add_to_wallet=false."},
                     {"subtract_fee_from_outputs", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, "Outputs to subtract the fee from, specified as integer indices.\n"
@@ -1420,8 +1305,7 @@ RPCHelpMan send()
             rawTx.vout.clear();
             auto txr = FundTransaction(*pwallet, rawTx, recipients, options, coin_control, /*override_min_fee=*/false);
 
-            CMutableTransaction tx = CMutableTransaction(*txr.tx);
-            return FinishTransaction(pwallet, options, tx);
+            return FinishTransaction(pwallet, options, CMutableTransaction(*txr.tx));
         }
     };
 }
@@ -1469,7 +1353,7 @@ RPCHelpMan sendall()
                                 },
                             },
                         },
-                        {"locktime", RPCArg::Type::NUM, RPCArg::DefaultHint{"locktime close to block height to prevent fee sniping"}, "Raw locktime. Non-0 value also locktime-activates inputs"},
+                        {"locktime", RPCArg::Type::NUM, RPCArg::Default{0}, "Raw locktime. Non-0 value also locktime-activates inputs"},
                         {"lock_unspents", RPCArg::Type::BOOL, RPCArg::Default{false}, "Lock selected unspent outputs"},
                         {"psbt", RPCArg::Type::BOOL,  RPCArg::DefaultHint{"automatic"}, "Always return a PSBT, implies add_to_wallet=false."},
                         {"send_max", RPCArg::Type::BOOL, RPCArg::Default{false}, "When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs."},
@@ -1694,25 +1578,17 @@ RPCHelpMan walletprocesspsbt()
         HELP_REQUIRING_PASSPHRASE,
                 {
                     {"psbt", RPCArg::Type::STR, RPCArg::Optional::NO, "The transaction base64 string"},
-                    {"options|sign", {RPCArg::Type::OBJ_NAMED_PARAMS, RPCArg::Type::BOOL}, RPCArg::Optional::OMITTED, "",
-                        {
-                            {"sign", RPCArg::Type::BOOL, RPCArg::Default{true}, "Also sign the transaction when updating (requires wallet to be unlocked)", RPCArgOptions{.also_positional = true}},
-                            {"sighashtype", RPCArg::Type::STR, RPCArg::Default{"DEFAULT for Taproot, ALL otherwise"}, "The signature hash type to sign with if not specified by the PSBT. Must be one of\n"
-                    "       \"DEFAULT\"\n"
-                    "       \"ALL\"\n"
-                    "       \"NONE\"\n"
-                    "       \"SINGLE\"\n"
-                    "       \"ALL|ANYONECANPAY\"\n"
-                    "       \"NONE|ANYONECANPAY\"\n"
-                    "       \"SINGLE|ANYONECANPAY\"",
-                                RPCArgOptions{.also_positional = true}},
-                            {"bip32derivs", RPCArg::Type::BOOL, RPCArg::Default{true}, "Include BIP 32 derivation paths for public keys if we know them", RPCArgOptions{.also_positional = true}},
-                            {"finalize", RPCArg::Type::BOOL, RPCArg::Default{true}, "Also finalize inputs if possible", RPCArgOptions{.also_positional = true}},
-                        },
-                    RPCArgOptions{.oneline_description="options"}},
-                    {"sighashtype", RPCArg::Type::STR, RPCArg::Default{"DEFAULT"}, "for backwards compatibility", RPCArgOptions{.hidden=true}},
-                    {"bip32derivs", RPCArg::Type::BOOL, RPCArg::Default{true}, "for backwards compatibility", RPCArgOptions{.hidden=true}},
-                    {"finalize", RPCArg::Type::BOOL, RPCArg::Default{true}, "for backwards compatibility", RPCArgOptions{.hidden=true}},
+                    {"sign", RPCArg::Type::BOOL, RPCArg::Default{true}, "Also sign the transaction when updating (requires wallet to be unlocked)"},
+                    {"sighashtype", RPCArg::Type::STR, RPCArg::Default{"DEFAULT for Taproot, ALL otherwise"}, "The signature hash type to sign with if not specified by the PSBT. Must be one of\n"
+            "       \"DEFAULT\"\n"
+            "       \"ALL\"\n"
+            "       \"NONE\"\n"
+            "       \"SINGLE\"\n"
+            "       \"ALL|ANYONECANPAY\"\n"
+            "       \"NONE|ANYONECANPAY\"\n"
+            "       \"SINGLE|ANYONECANPAY\""},
+                    {"bip32derivs", RPCArg::Type::BOOL, RPCArg::Default{true}, "Include BIP 32 derivation paths for public keys if we know them"},
+                    {"finalize", RPCArg::Type::BOOL, RPCArg::Default{true}, "Also finalize inputs if possible"},
                 },
                 RPCResult{
                     RPCResult::Type::OBJ, "", "",
@@ -1742,47 +1618,13 @@ RPCHelpMan walletprocesspsbt()
         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf("TX decode failed %s", error));
     }
 
-    // Get options
-    bool sign = true;
-    bool bip32derivs = true;
-    bool finalize = true;
-    int nHashType = ParseSighashString(NullUniValue); // Use ParseSighashString default
-    if (request.params[1].isBool() || request.params[1].isNull()) {
-        // Old style positional parameters
-        sign = request.params[1].isNull() ? true : request.params[1].get_bool();
-        nHashType = ParseSighashString(request.params[2]);
-        bip32derivs = request.params[3].isNull() ? true : request.params[3].get_bool();
-        finalize = request.params[4].isNull() ? true : request.params[4].get_bool();
-    } else {
-        // New style options are in an object
-        UniValue options = request.params[1];
-        RPCTypeCheckObj(options,
-            {
-                {"sign", UniValueType(UniValue::VBOOL)},
-                {"bip32derivs", UniValueType(UniValue::VBOOL)},
-                {"finalize", UniValueType(UniValue::VBOOL)},
-                {"sighashtype", UniValueType(UniValue::VSTR)},
-            },
-            true, true);
-        if (options.exists("sign")) {
-            sign = options["sign"].get_bool();
-        }
-        if (options.exists("bip32derivs")) {
-            bip32derivs = options["bip32derivs"].get_bool();
-        }
-        if (options.exists("finalize")) {
-            finalize = options["finalize"].get_bool();
-        }
-        if (options.exists("sighashtype")) {
-            nHashType = ParseSighashString(options["sighashtype"]);
-        }
-        if (request.params.size() > 2) {
-            // Same behaviour as too many args passed normally
-            throw std::runtime_error(self.ToString());
-        }
-    }
+    // Get the sighash type
+    int nHashType = ParseSighashString(request.params[2]);
 
     // Fill transaction with our data and also sign
+    bool sign = request.params[1].isNull() ? true : request.params[1].get_bool();
+    bool bip32derivs = request.params[3].isNull() ? true : request.params[3].get_bool();
+    bool finalize = request.params[4].isNull() ? true : request.params[4].get_bool();
     bool complete = true;
 
     if (sign) EnsureWalletIsUnlocked(*pwallet);
@@ -1883,10 +1725,8 @@ RPCHelpMan walletcreatefundedpsbt()
                     }
                                 },
                                 RPCExamples{
-                            "\nCreate a PSBT with automatically picked inputs that sends 0.5 BTC to an address and has a fee rate of 2 sat/vB:\n"
-                            + HelpExampleCli("walletcreatefundedpsbt", "\"[]\" \"[{\\\"" + EXAMPLE_ADDRESS[0] + "\\\":0.5}]\" 0 \"{\\\"add_inputs\\\":true,\\\"fee_rate\\\":2}\"")
-                            + "\nCreate the same PSBT as the above one instead using named arguments:\n"
-                            + HelpExampleCli("-named walletcreatefundedpsbt", "outputs=\"[{\\\"" + EXAMPLE_ADDRESS[0] + "\\\":0.5}]\" add_inputs=true fee_rate=2")
+                            "\nCreate a transaction with no inputs\n"
+                            + HelpExampleCli("walletcreatefundedpsbt", "\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":0}]\" \"[{\\\"data\\\":\\\"00010203\\\"}]\"")
                                 },
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
 {
diff --git a/src/wallet/rpc/transactions.cpp b/src/wallet/rpc/transactions.cpp
index b5413a72e4..61cf36a6c1 100644
--- a/src/wallet/rpc/transactions.cpp
+++ b/src/wallet/rpc/transactions.cpp
@@ -19,12 +19,7 @@ static void WalletTxToJSON(const CWallet& wallet, const CWalletTx& wtx, UniValue
 {
     interfaces::Chain& chain = wallet.chain();
     int confirms = wallet.GetTxDepthInMainChain(wtx);
-    if (confirms > 0 && wallet.IsTxAssumed(wtx)) {
-        entry.pushKV("confirmations", 0);
-        entry.pushKV("confirmations_assumed", confirms);
-    } else {
     entry.pushKV("confirmations", confirms);
-    }
     if (wtx.IsCoinBase())
         entry.pushKV("generated", true);
     if (auto* conf = wtx.state<TxStateConfirmed>())
@@ -37,7 +32,6 @@ static void WalletTxToJSON(const CWallet& wallet, const CWalletTx& wtx, UniValue
         entry.pushKV("blocktime", block_time);
     } else {
         entry.pushKV("trusted", CachedTxIsTrusted(wallet, wtx));
-        entry.pushKV("in_mempool", wtx.InMempool());
     }
     uint256 hash = wtx.GetHash();
     entry.pushKV("txid", hash.GetHex());
@@ -412,11 +406,9 @@ static std::vector<RPCResult> TransactionDescriptionString()
 {
     return{{RPCResult::Type::NUM, "confirmations", "The number of confirmations for the transaction. Negative confirmations means the\n"
                "transaction conflicted that many blocks ago."},
-           {RPCResult::Type::NUM, "confirmations_assumed", /*optional=*/true, "The number of unverified confirmations for the transaction (eg, in an assumed-valid UTXO set)."},
            {RPCResult::Type::BOOL, "generated", /*optional=*/true, "Only present if the transaction's only input is a coinbase one."},
            {RPCResult::Type::BOOL, "trusted", /*optional=*/true, "Whether we consider the transaction to be trusted and safe to spend from.\n"
                 "Only present when the transaction has 0 confirmations (or negative confirmations, if conflicted)."},
-           {RPCResult::Type::BOOL, "in_mempool", /*optional=*/true, "True if the transaction is in this node's memory pool. Only present on unconfirmed transactions."},
            {RPCResult::Type::STR_HEX, "blockhash", /*optional=*/true, "The block hash containing the transaction."},
            {RPCResult::Type::NUM, "blockheight", /*optional=*/true, "The block height containing the transaction."},
            {RPCResult::Type::NUM, "blockindex", /*optional=*/true, "The index of the transaction in the block that includes it."},
diff --git a/src/wallet/rpc/util.cpp b/src/wallet/rpc/util.cpp
index 022239d267..67b5ae0fe2 100644
--- a/src/wallet/rpc/util.cpp
+++ b/src/wallet/rpc/util.cpp
@@ -1,11 +1,10 @@
-// Copyright (c) 2011-2012 The Bitcoin Core developers
+// Copyright (c) 2011-2022 The Bitcoin Core developers
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
 #include <wallet/rpc/util.h>
 
 #include <common/url.h>
-#include <httprpc.h>
 #include <rpc/util.h>
 #include <util/any.h>
 #include <util/translation.h>
@@ -15,13 +14,24 @@
 #include <string_view>
 #include <univalue.h>
 
+#include <boost/date_time/posix_time/posix_time.hpp>
+
 namespace wallet {
 static const std::string WALLET_ENDPOINT_BASE = "/wallet/";
 const std::string HELP_REQUIRING_PASSPHRASE{"\nRequires wallet passphrase to be set with walletpassphrase call if wallet is encrypted.\n"};
 
 int64_t ParseISO8601DateTime(const std::string& str)
 {
-    return ::ParseISO8601DateTime(str).value_or(0);
+    static const boost::posix_time::ptime epoch = boost::posix_time::from_time_t(0);
+    static const std::locale loc(std::locale::classic(),
+        new boost::posix_time::time_input_facet("%Y-%m-%dT%H:%M:%SZ"));
+    std::istringstream iss(str);
+    iss.imbue(loc);
+    boost::posix_time::ptime ptime(boost::date_time::not_a_date_time);
+    iss >> ptime;
+    if (ptime.is_not_a_date_time() || epoch > ptime)
+        return 0;
+    return (ptime - epoch).total_seconds();
 }
 
 bool GetAvoidReuseFlag(const CWallet& wallet, const UniValue& param) {
@@ -65,48 +75,23 @@ std::shared_ptr<CWallet> GetWalletForJSONRPCRequest(const JSONRPCRequest& reques
     CHECK_NONFATAL(request.mode == JSONRPCRequest::EXECUTE);
     WalletContext& context = EnsureWalletContext(request.context);
 
-    bool have_wallet_restriction;
-    std::string authorized_wallet_name;
-    have_wallet_restriction = GetWalletRestrictionFromJSONRPCRequest(request, authorized_wallet_name);
-
-    bool have_requested_wallet;
-    std::string requested_wallet_name;
-    have_requested_wallet = GetWalletNameFromJSONRPCRequest(request, requested_wallet_name);
-
-    std::shared_ptr<CWallet> pwallet;
-    size_t count{0};
-
-    if (!have_wallet_restriction) {
-        // Any wallet is permitted; select by endpoint, or use the sole wallet
-        if (have_requested_wallet) {
-            pwallet = GetWallet(context, requested_wallet_name);
-        } else {
-            auto wallet = GetDefaultWallet(context, count);
-            if (wallet) pwallet = wallet;
-        }
-    } else if (authorized_wallet_name == "-") {
-        // Block wallet access always
-    } else if ((!have_requested_wallet) || requested_wallet_name == authorized_wallet_name) {
-        // Select specifically the authorized wallet
-        pwallet = GetWallet(context, authorized_wallet_name);
-    }
-
-    if (pwallet) {
+    std::string wallet_name;
+    if (GetWalletNameFromJSONRPCRequest(request, wallet_name)) {
+        std::shared_ptr<CWallet> pwallet = GetWallet(context, wallet_name);
+        if (!pwallet) throw JSONRPCError(RPC_WALLET_NOT_FOUND, "Requested wallet does not exist or is not loaded");
         return pwallet;
     }
 
-    if (have_requested_wallet) {
-        throw JSONRPCError(RPC_WALLET_NOT_FOUND, "Requested wallet does not exist or is not loaded");
-    }
-    if (have_wallet_restriction
-    ? (authorized_wallet_name == "-" || !GetWallet(context, authorized_wallet_name))
-    : (count == 0)
-     ) {
+    size_t count{0};
+    auto wallet = GetDefaultWallet(context, count);
+    if (wallet) return wallet;
+
+    if (count == 0) {
         throw JSONRPCError(
             RPC_WALLET_NOT_FOUND, "No wallet is loaded. Load a wallet using loadwallet or create a new one with createwallet. (Note: A default wallet is no longer automatically created)");
     }
     throw JSONRPCError(RPC_WALLET_NOT_SPECIFIED,
-        "Multiple wallets are loaded. Please select which wallet to use by requesting the RPC through the /wallet/<walletname> URI path.");
+        "Wallet file not specified (must request wallet RPC through /wallet/<filename> uri-path).");
 }
 
 void EnsureWalletIsUnlocked(const CWallet& wallet)
diff --git a/src/wallet/rpc/wallet.cpp b/src/wallet/rpc/wallet.cpp
index ca54f97583..39582b3f6a 100644
--- a/src/wallet/rpc/wallet.cpp
+++ b/src/wallet/rpc/wallet.cpp
@@ -29,9 +29,6 @@ static const std::map<uint64_t, std::string> WALLET_FLAG_CAVEATS{
      "You need to rescan the blockchain in order to correctly mark used "
      "destinations in the past. Until this is done, some destinations may "
      "be considered unused, even if the opposite is the case."},
-    {WALLET_FLAG_EXTERNAL_SIGNER,
-     "Wallet must be unloaded and loaded for change to take effect. "
-     "The ability to toggle this flag may be removed in a future update."},
 };
 
 /** Checks if a CKey is in the given CWallet compressed or otherwise*/
@@ -245,14 +242,6 @@ static RPCHelpMan loadwallet()
     WalletContext& context = EnsureWalletContext(request.context);
     const std::string name(request.params[0].get_str());
 
-    {
-        std::string authorized_wallet_name;
-        const bool have_wallet_restriction = GetWalletRestrictionFromJSONRPCRequest(request, authorized_wallet_name);
-        if (have_wallet_restriction && authorized_wallet_name != name) {
-            throw JSONRPCError(RPC_WALLET_NOT_FOUND, "Wallet usage is restricted.");
-        }
-    }
-
     DatabaseOptions options;
     DatabaseStatus status;
     ReadDatabaseArgs(*context.args, options);
@@ -320,16 +309,6 @@ static RPCHelpMan setwalletflag()
 
     auto flag = WALLET_FLAG_MAP.at(flag_str);
 
-    if (flag == WALLET_FLAG_EXTERNAL_SIGNER) {
-#ifdef ENABLE_EXTERNAL_SIGNER
-        if (!pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) || !pwallet->IsWalletFlagSet(WALLET_FLAG_DESCRIPTORS)) {
-            throw JSONRPCError(RPC_WALLET_ERROR, "This flag can only be set on a watch-only descriptor wallet");
-        }
-#else
-        throw JSONRPCError(RPC_WALLET_ERROR, "Compiled without external signing support (required for external signing)");
-#endif
-    }
-
     if (!(flag & MUTABLE_WALLET_FLAGS)) {
         throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Wallet flag is immutable: %s", flag_str));
     }
@@ -370,7 +349,8 @@ static RPCHelpMan createwallet()
             {"passphrase", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "Encrypt the wallet with this passphrase."},
             {"avoid_reuse", RPCArg::Type::BOOL, RPCArg::Default{false}, "Keep track of coin reuse, and treat dirty and clean coins differently with privacy considerations in mind."},
             {"descriptors", RPCArg::Type::BOOL, RPCArg::Default{true}, "Create a native descriptor wallet. The wallet will use descriptors internally to handle address creation."
-                                                                       " Setting to \"false\" will create a legacy wallet"},
+                                                                       " Setting to \"false\" will create a legacy wallet; This is only possible with the -deprecatedrpc=create_bdb setting because, the legacy wallet type is being deprecated and"
+                                                                       " support for creating and opening legacy wallets will be removed in the future."},
             {"load_on_startup", RPCArg::Type::BOOL, RPCArg::Optional::OMITTED, "Save wallet name to persistent settings and load on startup. True to add wallet to startup list, false to remove, null to leave unchanged."},
             {"external_signer", RPCArg::Type::BOOL, RPCArg::Default{false}, "Use an external signer such as a hardware wallet. Requires -signer to be configured. Wallet creation will fail if keys cannot be fetched. Requires disable_private_keys and descriptors set to true."},
         },
@@ -392,14 +372,6 @@ static RPCHelpMan createwallet()
         },
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
 {
-    {
-        std::string authorized_wallet_name;
-        const bool have_wallet_restriction = GetWalletRestrictionFromJSONRPCRequest(request, authorized_wallet_name);
-        if (have_wallet_restriction && authorized_wallet_name != request.params[0].get_str()) {
-            throw JSONRPCError(RPC_WALLET_ERROR, "Wallet usage is restricted.");
-        }
-    }
-
     WalletContext& context = EnsureWalletContext(request.context);
     uint64_t flags = 0;
     if (!request.params[1].isNull() && request.params[1].get_bool()) {
@@ -428,6 +400,11 @@ static RPCHelpMan createwallet()
         throw JSONRPCError(RPC_WALLET_ERROR, "Compiled without sqlite support (required for descriptor wallets)");
 #endif
         flags |= WALLET_FLAG_DESCRIPTORS;
+    } else {
+        if (!context.chain->rpcEnableDeprecated("create_bdb")) {
+            throw JSONRPCError(RPC_WALLET_ERROR, "BDB wallet creation is deprecated and will be removed in a future release."
+                                                 " In this release it can be re-enabled temporarily with the -deprecatedrpc=create_bdb setting.");
+        }
     }
     if (!request.params[7].isNull() && request.params[7].get_bool()) {
 #ifdef ENABLE_EXTERNAL_SIGNER
@@ -497,14 +474,7 @@ static RPCHelpMan unloadwallet()
     }
 
     WalletContext& context = EnsureWalletContext(request.context);
-    std::shared_ptr<CWallet> wallet;
-    {
-        std::string authorized_wallet_name;
-        const bool have_wallet_restriction = GetWalletRestrictionFromJSONRPCRequest(request, authorized_wallet_name);
-        if ((!have_wallet_restriction) || authorized_wallet_name == wallet_name) {
-            wallet = GetWallet(context, wallet_name);
-        }
-    }
+    std::shared_ptr<CWallet> wallet = GetWallet(context, wallet_name);
     if (!wallet) {
         throw JSONRPCError(RPC_WALLET_NOT_FOUND, "Requested wallet does not exist or is not loaded");
     }
@@ -806,9 +776,6 @@ static RPCHelpMan migratewallet()
         },
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
         {
-            // New wallets do not necessarily have the same name as the migrated wallet
-            EnsureNotWalletRestricted(request);
-
             std::string wallet_name;
             if (GetWalletNameFromJSONRPCRequest(request, wallet_name)) {
                 if (!(request.params[0].isNull() || request.params[0].get_str() == wallet_name)) {
@@ -1076,7 +1043,6 @@ RPCHelpMan walletdisplayaddress();
 
 // backup
 RPCHelpMan dumpprivkey();
-RPCHelpMan dumpmasterprivkey();
 RPCHelpMan importprivkey();
 RPCHelpMan importaddress();
 RPCHelpMan importpubkey();
@@ -1109,7 +1075,6 @@ RPCHelpMan encryptwallet();
 // spend
 RPCHelpMan sendtoaddress();
 RPCHelpMan sendmany();
-RPCHelpMan setfeerate();
 RPCHelpMan settxfee();
 RPCHelpMan fundrawtransaction();
 RPCHelpMan bumpfee();
@@ -1147,7 +1112,6 @@ Span<const CRPCCommand> GetWalletRPCCommands()
         {"wallet", &createwalletdescriptor},
         {"wallet", &restorewallet},
         {"wallet", &dumpprivkey},
-        {"wallet", &dumpmasterprivkey},
         {"wallet", &dumpwallet},
         {"wallet", &encryptwallet},
         {"wallet", &getaddressesbylabel},
@@ -1192,7 +1156,6 @@ Span<const CRPCCommand> GetWalletRPCCommands()
         {"wallet", &sendtoaddress},
         {"wallet", &sethdseed},
         {"wallet", &setlabel},
-        {"wallet", &setfeerate},
         {"wallet", &settxfee},
         {"wallet", &setwalletflag},
         {"wallet", &signmessage},
@@ -1202,7 +1165,6 @@ Span<const CRPCCommand> GetWalletRPCCommands()
         {"wallet", &unloadwallet},
         {"wallet", &upgradewallet},
         {"wallet", &walletcreatefundedpsbt},
-
 #ifdef ENABLE_EXTERNAL_SIGNER
         {"wallet", &walletdisplayaddress},
 #endif // ENABLE_EXTERNAL_SIGNER
diff --git a/src/wallet/scriptpubkeyman.cpp b/src/wallet/scriptpubkeyman.cpp
index bfd987b74a..ae61696dd0 100644
--- a/src/wallet/scriptpubkeyman.cpp
+++ b/src/wallet/scriptpubkeyman.cpp
@@ -218,47 +218,6 @@ IsMineResult IsMineInner(const LegacyDataSPKM& keystore, const CScript& scriptPu
 
 } // namespace
 
-SigningResult ScriptPubKeyMan::SignMessageBIP322(MessageSignatureFormat format, const SigningProvider* keystore, const std::string& message, const CTxDestination& address, std::string& str_sig) const
-{
-    assert(format != MessageSignatureFormat::LEGACY);
-
-    MessageVerificationResult result; // unused
-    auto txs = BIP322Txs::Create(address, message, result);
-    assert(txs);
-
-    const CTransaction& to_spend = txs->m_to_spend;
-    CMutableTransaction to_sign(txs->m_to_sign);
-
-    // Create the "unspent output" map, consisting of the to_spend output
-    std::map<COutPoint, Coin> coins;
-    coins[to_sign.vin[0].prevout] = Coin(to_spend.vout[0], 1, false);
-
-    // Sign the transaction
-    std::map<int, bilingual_str> errors;
-    if (!::SignTransaction(to_sign, keystore, coins, SIGHASH_ALL, errors)) {
-        // TODO: this may be a multisig which successfully signed but needed additional signatures
-        return SigningResult::SIGNING_FAILED;
-    }
-
-    // We force the format to FULL, if this turned out to be a legacy format (p2pkh) signature
-    if (to_sign.vin[0].scriptSig.size() > 0 || to_sign.vin[0].scriptWitness.IsNull()) {
-        format = MessageSignatureFormat::FULL;
-    }
-
-    DataStream ds;
-    if (format == MessageSignatureFormat::SIMPLE) {
-        // Simple format output
-        ds << to_sign.vin[0].scriptWitness.stack;
-    } else {
-        // Full format output
-        ds << TX_WITH_WITNESS(to_sign);
-    }
-
-    str_sig = EncodeBase64(ds);
-
-    return SigningResult::OK;
-}
-
 isminetype LegacyDataSPKM::IsMine(const CScript& script) const
 {
     switch (IsMineInner(*this, script, IsMineSigVersion::TOP)) {
@@ -443,23 +402,6 @@ std::vector<WalletDestination> LegacyScriptPubKeyMan::MarkUnusedAddresses(const
     return result;
 }
 
-bool LegacyDataSPKM::IsKeyActive(const CScript& script) const
-{
-    LOCK(cs_KeyStore);
-
-    if (!IsMine(script)) return false; // Not in the keystore at all
-
-    for (const auto& key_id : GetAffectedKeys(script, *this)) {
-        const auto it = mapKeyMetadata.find(key_id);
-        if (it == mapKeyMetadata.end()) return false; // This key must be really old
-
-        if (!it->second.hd_seed_id.IsNull() && it->second.hd_seed_id == m_hd_chain.seed_id) return true;
-    }
-
-    // Imported or dumped for a new keypool
-    return false;
-}
-
 void LegacyScriptPubKeyMan::UpgradeKeyMetadata()
 {
     LOCK(cs_KeyStore);
@@ -672,31 +614,21 @@ bool LegacyScriptPubKeyMan::CanProvide(const CScript& script, SignatureData& sig
     }
 }
 
-bool LegacyScriptPubKeyMan::SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, bilingual_str>& input_errors, std::optional<CAmount>* inputs_amount_sum) const
+bool LegacyScriptPubKeyMan::SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, bilingual_str>& input_errors) const
 {
-    return ::SignTransaction(tx, this, coins, sighash, input_errors, inputs_amount_sum);
+    return ::SignTransaction(tx, this, coins, sighash, input_errors);
 }
 
-SigningResult LegacyScriptPubKeyMan::SignMessage(const MessageSignatureFormat format, const std::string& message, const CTxDestination& address, std::string& str_sig) const
+SigningResult LegacyScriptPubKeyMan::SignMessage(const std::string& message, const PKHash& pkhash, std::string& str_sig) const
 {
-    if (format != MessageSignatureFormat::LEGACY) {
-        return SignMessageBIP322(format, this, message, address, str_sig);
-    }
-
-    const PKHash* pkhash = std::get_if<PKHash>(&address);
-    if (!pkhash) {
-        return SigningResult::PRIVATE_KEY_NOT_AVAILABLE;
-    }
-
     CKey key;
-    if (!GetKey(ToKeyID(*pkhash), key)) {
+    if (!GetKey(ToKeyID(pkhash), key)) {
         return SigningResult::PRIVATE_KEY_NOT_AVAILABLE;
     }
 
     if (MessageSign(key, message, str_sig)) {
         return SigningResult::OK;
     }
-
     return SigningResult::SIGNING_FAILED;
 }
 
@@ -1573,7 +1505,6 @@ void LegacyScriptPubKeyMan::LearnRelatedScripts(const CPubKey& key, OutputType t
 
 void LegacyScriptPubKeyMan::LearnAllRelatedScripts(const CPubKey& key)
 {
-    if (!g_implicit_segwit) return;
     // OutputType::P2SH_SEGWIT always adds all necessary scripts for all types.
     LearnRelatedScripts(key, OutputType::P2SH_SEGWIT);
 }
@@ -2545,7 +2476,7 @@ bool DescriptorScriptPubKeyMan::CanProvide(const CScript& script, SignatureData&
     return IsMine(script);
 }
 
-bool DescriptorScriptPubKeyMan::SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, bilingual_str>& input_errors, std::optional<CAmount>* inputs_amount_sum) const
+bool DescriptorScriptPubKeyMan::SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, bilingual_str>& input_errors) const
 {
     std::unique_ptr<FlatSigningProvider> keys = std::make_unique<FlatSigningProvider>();
     for (const auto& coin_pair : coins) {
@@ -2556,34 +2487,24 @@ bool DescriptorScriptPubKeyMan::SignTransaction(CMutableTransaction& tx, const s
         keys->Merge(std::move(*coin_keys));
     }
 
-    return ::SignTransaction(tx, keys.get(), coins, sighash, input_errors, inputs_amount_sum);
+    return ::SignTransaction(tx, keys.get(), coins, sighash, input_errors);
 }
 
-SigningResult DescriptorScriptPubKeyMan::SignMessage(const MessageSignatureFormat format, const std::string& message, const CTxDestination& address, std::string& str_sig) const
+SigningResult DescriptorScriptPubKeyMan::SignMessage(const std::string& message, const PKHash& pkhash, std::string& str_sig) const
 {
-    std::unique_ptr<FlatSigningProvider> keys = GetSigningProvider(GetScriptForDestination(address), true);
+    std::unique_ptr<FlatSigningProvider> keys = GetSigningProvider(GetScriptForDestination(pkhash), true);
     if (!keys) {
         return SigningResult::PRIVATE_KEY_NOT_AVAILABLE;
     }
 
-    if (format != MessageSignatureFormat::LEGACY) {
-        return SignMessageBIP322(format, keys.get(), message, address, str_sig);
-    }
-
-    const PKHash* pkhash = std::get_if<PKHash>(&address);
-    if (!pkhash) {
-        return SigningResult::PRIVATE_KEY_NOT_AVAILABLE;
-    }
-
     CKey key;
-    if (!keys->GetKey(ToKeyID(*pkhash), key)) {
+    if (!keys->GetKey(ToKeyID(pkhash), key)) {
         return SigningResult::PRIVATE_KEY_NOT_AVAILABLE;
     }
 
     if (!MessageSign(key, message, str_sig)) {
         return SigningResult::SIGNING_FAILED;
     }
-
     return SigningResult::OK;
 }
 
diff --git a/src/wallet/scriptpubkeyman.h b/src/wallet/scriptpubkeyman.h
index 5233f0f777..6659cbf52b 100644
--- a/src/wallet/scriptpubkeyman.h
+++ b/src/wallet/scriptpubkeyman.h
@@ -176,8 +176,6 @@ class ScriptPubKeyMan
 protected:
     WalletStorage& m_storage;
 
-    SigningResult SignMessageBIP322(MessageSignatureFormat format, const SigningProvider* keystore, const std::string& message, const CTxDestination& address, std::string& str_sig) const;
-
 public:
     explicit ScriptPubKeyMan(WalletStorage& storage) : m_storage(storage) {}
     virtual ~ScriptPubKeyMan() = default;
@@ -207,9 +205,6 @@ public:
      */
     virtual std::vector<WalletDestination> MarkUnusedAddresses(const CScript& script) { return {}; }
 
-    /* Determines if address is derived from active key manager */
-    virtual bool IsKeyActive(const CScript& script) const = 0;
-
     /** Sets up the key generation stuff, i.e. generates new HD seeds and sets them as active.
       * Returns false if already setup or setup fails, true if setup is successful
       * Set force=true to make it re-setup if already setup, used for upgrades
@@ -246,9 +241,9 @@ public:
     virtual bool CanProvide(const CScript& script, SignatureData& sigdata) { return false; }
 
     /** Creates new signatures and adds them to the transaction. Returns whether all inputs were signed */
-    virtual bool SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, bilingual_str>& input_errors, std::optional<CAmount>* inputs_amount_sum = nullptr) const { return false; }
+    virtual bool SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, bilingual_str>& input_errors) const { return false; }
     /** Sign a message with the given script */
-    virtual SigningResult SignMessage(const MessageSignatureFormat format, const std::string& message, const CTxDestination& address, std::string& str_sig) const { return SigningResult::SIGNING_FAILED; };
+    virtual SigningResult SignMessage(const std::string& message, const PKHash& pkhash, std::string& str_sig) const { return SigningResult::SIGNING_FAILED; };
     /** Adds script and derivation path information to a PSBT, and optionally signs it. */
     virtual std::optional<common::PSBTError> FillPSBT(PartiallySignedTransaction& psbt, const PrecomputedTransactionData& txdata, int sighash_type = SIGHASH_DEFAULT, bool sign = true, bool bip32derivs = false, int* n_signed = nullptr, bool finalize = true) const { return common::PSBTError::UNSUPPORTED; }
 
@@ -318,7 +313,6 @@ public:
 
     // ScriptPubKeyMan overrides
     bool CheckDecryptionKey(const CKeyingMaterial& master_key) override;
-    [[nodiscard]] bool IsKeyActive(const CScript& script) const override;
     std::unordered_set<CScript, SaltedSipHasher> GetScriptPubKeys() const override;
     std::unique_ptr<SigningProvider> GetSolvingProvider(const CScript& script) const override;
     uint256 GetID() const override { return uint256::ONE; }
@@ -493,8 +487,8 @@ public:
 
     bool CanProvide(const CScript& script, SignatureData& sigdata) override;
 
-    bool SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, bilingual_str>& input_errors, std::optional<CAmount>* inputs_amount_sum = nullptr) const override;
-    SigningResult SignMessage(const MessageSignatureFormat format, const std::string& message, const CTxDestination& address, std::string& str_sig) const override;
+    bool SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, bilingual_str>& input_errors) const override;
+    SigningResult SignMessage(const std::string& message, const PKHash& pkhash, std::string& str_sig) const override;
     std::optional<common::PSBTError> FillPSBT(PartiallySignedTransaction& psbt, const PrecomputedTransactionData& txdata, int sighash_type = SIGHASH_DEFAULT, bool sign = true, bool bip32derivs = false, int* n_signed = nullptr, bool finalize = true) const override;
 
     uint256 GetID() const override;
@@ -656,8 +650,6 @@ public:
 
     std::vector<WalletDestination> MarkUnusedAddresses(const CScript& script) override;
 
-    [[nodiscard]] bool IsKeyActive(const CScript& script) const override { return IsMine(script); }
-
     bool IsHDEnabled() const override;
 
     //! Setup descriptors based on the given CExtkey
@@ -681,8 +673,8 @@ public:
 
     bool CanProvide(const CScript& script, SignatureData& sigdata) override;
 
-    bool SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, bilingual_str>& input_errors, std::optional<CAmount>* inputs_amount_sum = nullptr) const override;
-    SigningResult SignMessage(const MessageSignatureFormat format, const std::string& message, const CTxDestination& address, std::string& str_sig) const override;
+    bool SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, bilingual_str>& input_errors) const override;
+    SigningResult SignMessage(const std::string& message, const PKHash& pkhash, std::string& str_sig) const override;
     std::optional<common::PSBTError> FillPSBT(PartiallySignedTransaction& psbt, const PrecomputedTransactionData& txdata, int sighash_type = SIGHASH_DEFAULT, bool sign = true, bool bip32derivs = false, int* n_signed = nullptr, bool finalize = true) const override;
 
     uint256 GetID() const override;
diff --git a/src/wallet/spend.cpp b/src/wallet/spend.cpp
index 420bd284f2..7abf7f59c0 100644
--- a/src/wallet/spend.cpp
+++ b/src/wallet/spend.cpp
@@ -320,7 +320,6 @@ CoinsResult AvailableCoins(const CWallet& wallet,
     const int min_depth = {coinControl ? coinControl->m_min_depth : DEFAULT_MIN_DEPTH};
     const int max_depth = {coinControl ? coinControl->m_max_depth : DEFAULT_MAX_DEPTH};
     const bool only_safe = {coinControl ? !coinControl->m_include_unsafe_inputs : true};
-    const bool segwit_inputs_only = {coinControl ? coinControl->m_segwit_inputs_only : false};
     const bool can_grind_r = wallet.CanGrindR();
     std::vector<COutPoint> outpoints;
 
@@ -414,10 +413,6 @@ CoinsResult AvailableCoins(const CWallet& wallet,
 
             std::unique_ptr<SigningProvider> provider = wallet.GetSolvingProvider(output.scriptPubKey);
 
-            if (segwit_inputs_only && !IsSegWitOutput(*provider, wtx.tx->vout[i].scriptPubKey)) {
-                continue;
-            }
-
             int input_bytes = CalculateMaximumSignedInputSize(output, COutPoint(), provider.get(), can_grind_r, coinControl);
             // Because CalculateMaximumSignedInputSize infers a solvable descriptor to get the satisfaction size,
             // it is safe to assume that this input is solvable if input_bytes is greater than -1.
@@ -937,7 +932,11 @@ static bool IsCurrentForAntiFeeSniping(interfaces::Chain& chain, const uint256&
     return true;
 }
 
-void DiscourageFeeSniping(CMutableTransaction& tx, FastRandomContext& rng_fast,
+/**
+ * Set a height-based locktime for new transactions (uses the height of the
+ * current chain tip unless we are not synced with the current chain
+ */
+static void DiscourageFeeSniping(CMutableTransaction& tx, FastRandomContext& rng_fast,
                                  interfaces::Chain& chain, const uint256& block_hash, int block_height)
 {
     // All inputs must be added by now
diff --git a/src/wallet/spend.h b/src/wallet/spend.h
index 26a063dceb..62a7b4e4c8 100644
--- a/src/wallet/spend.h
+++ b/src/wallet/spend.h
@@ -213,12 +213,6 @@ struct CreatedTransactionResult
         : tx(_tx), fee(_fee), fee_calc(_fee_calc), change_pos(_change_pos) {}
 };
 
-/**
- * Set a height-based locktime for new transactions (uses the height of the
- * current chain tip unless we are not synced with the current chain
- */
-void DiscourageFeeSniping(CMutableTransaction& tx, FastRandomContext& rng_fast, interfaces::Chain& chain, const uint256& block_hash, int block_height);
-
 /**
  * Create a new transaction paying the recipients with a set of coins
  * selected by SelectCoins(); Also create the change output, when needed
diff --git a/src/wallet/test/db_tests.cpp b/src/wallet/test/db_tests.cpp
index 8fa98f905a..2fac356263 100644
--- a/src/wallet/test/db_tests.cpp
+++ b/src/wallet/test/db_tests.cpp
@@ -62,7 +62,6 @@ static void CheckPrefix(DatabaseBatch& batch, Span<const std::byte> prefix, Mock
 
 BOOST_FIXTURE_TEST_SUITE(db_tests, BasicTestingSetup)
 
-#ifdef USE_BDB
 static std::shared_ptr<BerkeleyEnvironment> GetWalletEnv(const fs::path& path, fs::path& database_filename)
 {
     fs::path data_file = BDBDataFile(path);
@@ -125,7 +124,6 @@ BOOST_AUTO_TEST_CASE(getwalletenv_g_dbenvs_free_instance)
     BOOST_CHECK(env_1_a != env_1_b);
     BOOST_CHECK(env_2_a == env_2_b);
 }
-#endif
 
 static std::vector<std::unique_ptr<WalletDatabase>> TestDatabases(const fs::path& path_root)
 {
diff --git a/src/wallet/test/fuzz/notifications.cpp b/src/wallet/test/fuzz/notifications.cpp
index f2b96e69c9..792079e6c6 100644
--- a/src/wallet/test/fuzz/notifications.cpp
+++ b/src/wallet/test/fuzz/notifications.cpp
@@ -18,7 +18,6 @@
 #include <test/fuzz/FuzzedDataProvider.h>
 #include <test/fuzz/fuzz.h>
 #include <test/fuzz/util.h>
-#include <test/util/transaction_utils.h>
 #include <test/util/setup_common.h>
 #include <tinyformat.h>
 #include <uint256.h>
diff --git a/src/wallet/test/fuzz/parse_iso8601.cpp b/src/wallet/test/fuzz/parse_iso8601.cpp
index a1ded0d655..c1bafc1073 100644
--- a/src/wallet/test/fuzz/parse_iso8601.cpp
+++ b/src/wallet/test/fuzz/parse_iso8601.cpp
@@ -22,8 +22,13 @@ FUZZ_TARGET(parse_iso8601)
     const std::string iso8601_datetime = FormatISO8601DateTime(random_time);
     (void)FormatISO8601Date(random_time);
     const int64_t parsed_time_1 = wallet::ParseISO8601DateTime(iso8601_datetime);
+    if (random_time >= 0) {
+        assert(parsed_time_1 >= 0);
+        if (iso8601_datetime.length() == 20) {
             assert(parsed_time_1 == random_time);
+        }
+    }
 
-    [[maybe_unused]]
     const int64_t parsed_time_2 = wallet::ParseISO8601DateTime(random_string);
+    assert(parsed_time_2 >= 0);
 }
diff --git a/src/wallet/test/fuzz/scriptpubkeyman.cpp b/src/wallet/test/fuzz/scriptpubkeyman.cpp
index a739d5581e..315efa0dca 100644
--- a/src/wallet/test/fuzz/scriptpubkeyman.cpp
+++ b/src/wallet/test/fuzz/scriptpubkeyman.cpp
@@ -137,7 +137,7 @@ FUZZ_TARGET(scriptpubkeyman, .init = initialize_spkm)
                                            *std::get_if<PKHash>(&dest) :
                                            PKHash{ConsumeUInt160(fuzzed_data_provider)}};
                         std::string str_sig;
-                        (void)spk_manager->SignMessage(MessageSignatureFormat::LEGACY, msg, pk_hash, str_sig);
+                        (void)spk_manager->SignMessage(msg, pk_hash, str_sig);
                         (void)spk_manager->GetMetadata(dest);
                     }
                 }
diff --git a/src/wallet/test/fuzz/wallet_bdb_parser.cpp b/src/wallet/test/fuzz/wallet_bdb_parser.cpp
index 3a35578033..6fbd695fc5 100644
--- a/src/wallet/test/fuzz/wallet_bdb_parser.cpp
+++ b/src/wallet/test/fuzz/wallet_bdb_parser.cpp
@@ -38,7 +38,6 @@ FUZZ_TARGET(wallet_bdb_parser, .init = initialize_wallet_bdb_parser)
     {
         AutoFile outfile{fsbridge::fopen(wallet_path, "wb")};
         outfile << Span{buffer};
-        assert(outfile.fclose() == 0);
     }
 
     const DatabaseOptions options{};
@@ -57,7 +56,7 @@ FUZZ_TARGET(wallet_bdb_parser, .init = initialize_wallet_bdb_parser)
 #endif
     auto db{MakeBerkeleyRODatabase(wallet_path, options, status, error)};
     if (db) {
-        assert(DumpWallet(*db, error, fs::PathToString(bdb_ro_dumpfile)));
+        assert(DumpWallet(g_setup->m_args, *db, error));
     } else {
 #ifdef USE_BDB
         bdb_ro_err = true;
@@ -118,7 +117,7 @@ FUZZ_TARGET(wallet_bdb_parser, .init = initialize_wallet_bdb_parser)
             return;
         }
         assert(!bdb_ro_err);
-        assert(DumpWallet(*db, error, fs::PathToString(bdb_dumpfile)));
+        assert(DumpWallet(g_setup->m_args, *db, error));
     } catch (const std::runtime_error& e) {
         if (bdb_ro_err) return;
         throw e;
diff --git a/src/wallet/test/rpc_util_tests.cpp b/src/wallet/test/rpc_util_tests.cpp
index e694cb95ec..32f6f5ab46 100644
--- a/src/wallet/test/rpc_util_tests.cpp
+++ b/src/wallet/test/rpc_util_tests.cpp
@@ -13,6 +13,7 @@ BOOST_AUTO_TEST_SUITE(wallet_util_tests)
 BOOST_AUTO_TEST_CASE(util_ParseISO8601DateTime)
 {
     BOOST_CHECK_EQUAL(ParseISO8601DateTime("1970-01-01T00:00:00Z"), 0);
+    BOOST_CHECK_EQUAL(ParseISO8601DateTime("1960-01-01T00:00:00Z"), 0);
     BOOST_CHECK_EQUAL(ParseISO8601DateTime("2000-01-01T00:00:01Z"), 946684801);
     BOOST_CHECK_EQUAL(ParseISO8601DateTime("2011-09-30T23:36:17Z"), 1317425777);
     BOOST_CHECK_EQUAL(ParseISO8601DateTime("2100-12-31T23:59:59Z"), 4133980799);
diff --git a/src/wallet/test/scriptpubkeyman_tests.cpp b/src/wallet/test/scriptpubkeyman_tests.cpp
index 0c0719324a..15bff04221 100644
--- a/src/wallet/test/scriptpubkeyman_tests.cpp
+++ b/src/wallet/test/scriptpubkeyman_tests.cpp
@@ -40,174 +40,5 @@ BOOST_AUTO_TEST_CASE(CanProvide)
     BOOST_CHECK(keyman.CanProvide(p2sh_script, data));
 }
 
-static void legacy_IsKeyActive(const node::NodeContext& node, bool implicit_segwit)
-{
-    const bool save_g_implicit_segwit{g_implicit_segwit};
-    g_implicit_segwit = implicit_segwit;
-    CWallet wallet(node.chain.get(), "", CreateMockableWalletDatabase());
-    {
-        LOCK(wallet.cs_wallet);
-        wallet.SetMinVersion(FEATURE_LATEST);
-        wallet.m_keypool_size = 10;
-    }
-    LegacyScriptPubKeyMan& spkm = *wallet.GetOrCreateLegacyScriptPubKeyMan();
-
-    // Start off empty
-    BOOST_CHECK(spkm.GetScriptPubKeys().empty());
-
-    // Generate 20 keypool keys (10 internal, 10 external)
-    {
-        LOCK(wallet.cs_wallet);
-        spkm.SetupGeneration();
-    }
-
-    // 4 scripts per keypool key (P2PK, P2PKH, P2WPKH, P2SH-P2WPKH)
-    // Plus 4 scripts for the seed key
-    // (If !implicit_segwit, P2WPKH and P2SH-P2WPKH are not generated.)
-    auto scripts1 = spkm.GetScriptPubKeys();
-    BOOST_CHECK_EQUAL(scripts1.size(), implicit_segwit ? 84 : 42);
-
-    // All keys are active
-    for (const CScript& script : scripts1) {
-        BOOST_CHECK(spkm.IsKeyActive(script));
-    }
-
-    // Requesting single from spkm should not deactivate key
-    CTxDestination dest1;
-    {
-        LOCK(wallet.cs_wallet);
-        auto result = spkm.GetNewDestination(OutputType::BECH32);
-        dest1 = result.value();
-    }
-    CScript script = GetScriptForDestination(dest1);
-    BOOST_CHECK(spkm.IsKeyActive(script));
-
-    // Key pool size did not change
-    // (If !implicit_segwit, the two segwit addresses are added back.)
-    auto scripts2 = spkm.GetScriptPubKeys();
-    BOOST_CHECK_EQUAL(scripts2.size(), implicit_segwit ? 84 : 44);
-
-    // Use key that is not the next key
-    // (i.e. address gap in wallet recovery)
-    {
-        LOCK(wallet.cs_wallet);
-        LOCK(spkm.cs_KeyStore);
-        auto keys = spkm.MarkReserveKeysAsUsed(5);
-        BOOST_CHECK_EQUAL(keys.size(), 4); // Because we already used one with GetNewDestination
-    }
-
-    // Key pool size did not change
-    auto scripts3 = spkm.GetScriptPubKeys();
-    BOOST_CHECK_EQUAL(scripts3.size(), implicit_segwit ? 84 : 44);
-
-    // All keys are still active
-    for (const CScript& script : scripts3) {
-        BOOST_CHECK(spkm.IsKeyActive(script));
-    }
-
-    // When user encrypts wallet for the first time,
-    // all existing keys are removed from active keypool
-    {
-        LOCK(wallet.cs_wallet);
-        // called by EncryptWallet()
-        spkm.SetupGeneration(true);
-    }
-
-    // 20 new keys were added
-    auto scripts4 = spkm.GetScriptPubKeys();
-    BOOST_CHECK_EQUAL(scripts4.size(), (implicit_segwit ? 84 : 43) * 2);
-
-    // All 10 original keys are now inactive
-    for (const CScript& script : scripts3) {
-        BOOST_CHECK(!spkm.IsKeyActive(script));
-    }
-    g_implicit_segwit = save_g_implicit_segwit;
-}
-
-BOOST_AUTO_TEST_CASE(Legacy_IsKeyActive)
-{
-    legacy_IsKeyActive(m_node, /*implicit_segwit=*/true);
-}
-
-BOOST_AUTO_TEST_CASE(Legacy_IsKeyActive_no_implicit_segwit)
-{
-    legacy_IsKeyActive(m_node, /*implicit_segwit=*/false);
-}
-
-BOOST_AUTO_TEST_CASE(Descriptor_IsKeyActive)
-{
-    CWallet wallet(m_node.chain.get(), "", CreateMockableWalletDatabase());
-    {
-        LOCK(wallet.cs_wallet);
-        wallet.LoadMinVersion(FEATURE_LATEST);
-        wallet.SetWalletFlag(WALLET_FLAG_DESCRIPTORS);
-        wallet.m_keypool_size = 10;
-        wallet.SetupDescriptorScriptPubKeyMans();
-    }
-    DescriptorScriptPubKeyMan* spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(wallet.GetScriptPubKeyMan(OutputType::BECH32, /*internal=*/false));
-
-    // Start off with 10 pre-generated keys, 1 script each
-    auto scripts1 = spkm->GetScriptPubKeys();
-    BOOST_CHECK_EQUAL(scripts1.size(), 10);
-
-    // All keys are active
-    for (const CScript& script : scripts1) {
-        BOOST_CHECK(spkm->IsKeyActive(script));
-    }
-
-    // Requesting single key from spkm should not deactivate key
-    auto dest1 = spkm->GetNewDestination(OutputType::BECH32);
-    CScript script = GetScriptForDestination(dest1.value());
-    BOOST_CHECK(spkm->IsKeyActive(script));
-
-    // Key pool size did not change
-    auto scripts2 = spkm->GetScriptPubKeys();
-    BOOST_CHECK_EQUAL(scripts2.size(), 10);
-
-    // Use key that is not the next key
-    // (i.e. address gap in wallet recovery)
-    {
-        LOCK(spkm->cs_desc_man);
-        WalletDescriptor descriptor = spkm->GetWalletDescriptor();
-        FlatSigningProvider provider;
-        std::vector<CScript> scripts3;
-        descriptor.descriptor->ExpandFromCache(/*pos=*/5, descriptor.cache, scripts3, provider);
-
-        BOOST_CHECK_EQUAL(scripts3.size(), 1);
-        spkm->MarkUnusedAddresses(scripts3.front());
-    }
-
-    // Key pool size increased to replace used keys
-    auto scripts4 = spkm->GetScriptPubKeys();
-    BOOST_CHECK_EQUAL(scripts4.size(), 16);
-
-    // All keys are still active
-    for (const CScript& script : scripts4) {
-        BOOST_CHECK(spkm->IsKeyActive(script));
-    }
-
-    // When user encrypts wallet for the first time,
-    // all existing keys are removed from active keypool
-    {
-        LOCK(wallet.cs_wallet);
-        // called by EncryptWallet()
-        wallet.SetupDescriptorScriptPubKeyMans();
-    }
-
-    // This SPKM is not affected
-    for (const CScript& script : scripts4) {
-        BOOST_CHECK(spkm->IsKeyActive(script));
-    }
-
-    // ...but at the wallet level all the keys from that SPKM are deactivated
-    int num_script_keys_not_found = 0;
-    for (const CScript& script : scripts4) {
-        if (!wallet.IsDestinationActive(WitnessV0ScriptHash(script))) {
-            ++num_script_keys_not_found;
-        }
-    }
-    BOOST_CHECK_EQUAL(num_script_keys_not_found, 16);
-}
-
 BOOST_AUTO_TEST_SUITE_END()
 } // namespace wallet
diff --git a/src/wallet/test/util.cpp b/src/wallet/test/util.cpp
index 44a613ac45..ec6c9e6f3f 100644
--- a/src/wallet/test/util.cpp
+++ b/src/wallet/test/util.cpp
@@ -23,7 +23,6 @@ std::unique_ptr<CWallet> CreateSyncedWallet(interfaces::Chain& chain, CChain& cc
     {
         LOCK2(wallet->cs_wallet, ::cs_main);
         wallet->SetLastBlockProcessed(cchain.Height(), cchain.Tip()->GetBlockHash());
-        wallet->m_default_address_type = OutputType::BECH32M;
     }
     {
         LOCK(wallet->cs_wallet);
diff --git a/src/wallet/test/wallet_tests.cpp b/src/wallet/test/wallet_tests.cpp
index 264276f2e2..12d5a3b3eb 100644
--- a/src/wallet/test/wallet_tests.cpp
+++ b/src/wallet/test/wallet_tests.cpp
@@ -10,7 +10,6 @@
 #include <vector>
 
 #include <addresstype.h>
-#include <common/system.h>
 #include <interfaces/chain.h>
 #include <key_io.h>
 #include <node/blockstorage.h>
@@ -239,7 +238,6 @@ BOOST_FIXTURE_TEST_CASE(importmulti_rescan, TestChain100Setup)
         keys.push_back(std::move(key));
         JSONRPCRequest request;
         request.context = &context;
-        request.m_wallet_restriction = "";
         request.params.setArray();
         request.params.push_back(std::move(keys));
 
@@ -295,7 +293,6 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)
         }
         JSONRPCRequest request;
         request.context = &context;
-        request.m_wallet_restriction = "";
         request.params.setArray();
         request.params.push_back(backup_file);
 
@@ -314,7 +311,6 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)
         context.args = &m_args;
         JSONRPCRequest request;
         request.context = &context;
-        request.m_wallet_restriction = "";
         request.params.setArray();
         request.params.push_back(backup_file);
         AddWallet(context, wallet);
@@ -823,9 +819,6 @@ BOOST_FIXTURE_TEST_CASE(wallet_descriptor_test, BasicTestingSetup)
 //! rescanning where new transactions in new blocks could be lost.
 BOOST_FIXTURE_TEST_CASE(CreateWallet, TestChain100Setup)
 {
-    // FIXME: this test fails for some reason if there's a flush
-    g_low_memory_threshold = 0;
-
     m_args.ForceSetArg("-unsafesqlitesync", "1");
     // Create new wallet with known key and unload it.
     WalletContext context;
@@ -864,7 +857,7 @@ BOOST_FIXTURE_TEST_CASE(CreateWallet, TestChain100Setup)
     m_coinbase_txns.push_back(CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey())).vtx[0]);
     auto block_tx = TestSimpleSpend(*m_coinbase_txns[0], 0, coinbaseKey, GetScriptForRawPubKey(key.GetPubKey()));
     m_coinbase_txns.push_back(CreateAndProcessBlock({block_tx}, GetScriptForRawPubKey(coinbaseKey.GetPubKey())).vtx[0]);
-    auto mempool_tx = TestSimpleSpend(*m_coinbase_txns[1], 0, coinbaseKey, GetScriptForDestination(PKHash(key.GetPubKey())));
+    auto mempool_tx = TestSimpleSpend(*m_coinbase_txns[1], 0, coinbaseKey, GetScriptForRawPubKey(key.GetPubKey()));
     BOOST_CHECK(m_node.chain->broadcastTransaction(MakeTransactionRef(mempool_tx), DEFAULT_TRANSACTION_MAXFEE, false, error));
 
 
@@ -906,7 +899,7 @@ BOOST_FIXTURE_TEST_CASE(CreateWallet, TestChain100Setup)
             m_coinbase_txns.push_back(CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey())).vtx[0]);
             block_tx = TestSimpleSpend(*m_coinbase_txns[2], 0, coinbaseKey, GetScriptForRawPubKey(key.GetPubKey()));
             m_coinbase_txns.push_back(CreateAndProcessBlock({block_tx}, GetScriptForRawPubKey(coinbaseKey.GetPubKey())).vtx[0]);
-            mempool_tx = TestSimpleSpend(*m_coinbase_txns[3], 0, coinbaseKey, GetScriptForDestination(PKHash(key.GetPubKey())));
+            mempool_tx = TestSimpleSpend(*m_coinbase_txns[3], 0, coinbaseKey, GetScriptForRawPubKey(key.GetPubKey()));
             BOOST_CHECK(m_node.chain->broadcastTransaction(MakeTransactionRef(mempool_tx), DEFAULT_TRANSACTION_MAXFEE, false, error));
             m_node.validation_signals->SyncWithValidationInterfaceQueue();
         });
diff --git a/src/wallet/wallet.cpp b/src/wallet/wallet.cpp
index 2175e062c8..be630cec8c 100644
--- a/src/wallet/wallet.cpp
+++ b/src/wallet/wallet.cpp
@@ -91,11 +91,6 @@ using util::ToString;
 
 namespace wallet {
 
-/*
- * Signal when transactions are added to wallet
- */
-boost::signals2::signal<void (const CTransactionRef &ptxn, const uint256 &blockHash)> CWallet::TransactionAddedToWallet;
-
 bool AddWalletSetting(interfaces::Chain& chain, const std::string& wallet_name)
 {
     const auto update_function = [&wallet_name](common::SettingsValue& setting_value) {
@@ -293,6 +288,11 @@ std::shared_ptr<CWallet> LoadWalletInternal(WalletContext& context, const std::s
             return nullptr;
         }
 
+        // Legacy wallets are being deprecated, warn if the loaded wallet is legacy
+        if (!wallet->IsWalletFlagSet(WALLET_FLAG_DESCRIPTORS)) {
+            warnings.push_back(_("Wallet loaded successfully. The legacy wallet type is being deprecated and support for creating and opening legacy wallets will be removed in the future. Legacy wallets can be migrated to a descriptor wallet with migratewallet."));
+        }
+
         NotifyWalletLoaded(context, wallet);
         AddWallet(context, wallet);
         wallet->postInitProcess();
@@ -481,13 +481,16 @@ std::shared_ptr<CWallet> CreateWallet(WalletContext& context, const std::string&
     // Write the wallet settings
     UpdateWalletSetting(*context.chain, name, load_on_start, warnings);
 
+    // Legacy wallets are being deprecated, warn if a newly created wallet is legacy
+    if (!(wallet_creation_flags & WALLET_FLAG_DESCRIPTORS)) {
+        warnings.push_back(_("Wallet created successfully. The legacy wallet type is being deprecated and support for creating and opening legacy wallets will be removed in the future."));
+    }
+
     status = DatabaseStatus::SUCCESS;
     return wallet;
 }
 
-// Re-creates wallet from the backup file by renaming and moving it into the wallet's directory.
-// If 'load_after_restore=true', the wallet object will be fully initialized and appended to the context.
-std::shared_ptr<CWallet> RestoreWallet(WalletContext& context, const fs::path& backup_file, const std::string& wallet_name, std::optional<bool> load_on_start, DatabaseStatus& status, bilingual_str& error, std::vector<bilingual_str>& warnings, bool load_after_restore)
+std::shared_ptr<CWallet> RestoreWallet(WalletContext& context, const fs::path& backup_file, const std::string& wallet_name, std::optional<bool> load_on_start, DatabaseStatus& status, bilingual_str& error, std::vector<bilingual_str>& warnings)
 {
     DatabaseOptions options;
     ReadDatabaseArgs(*context.args, options);
@@ -512,17 +515,13 @@ std::shared_ptr<CWallet> RestoreWallet(WalletContext& context, const fs::path& b
 
         fs::copy_file(backup_file, wallet_file, fs::copy_options::none);
 
-        if (load_after_restore) {
-            wallet = LoadWallet(context, wallet_name, load_on_start, options, status, error, warnings);
-        }
+        wallet = LoadWallet(context, wallet_name, load_on_start, options, status, error, warnings);
     } catch (const std::exception& e) {
         assert(!wallet);
         if (!error.empty()) error += Untranslated("\n");
         error += strprintf(Untranslated("Unexpected exception: %s"), e.what());
     }
-
-    // Remove created wallet path only when loading fails
-    if (load_after_restore && !wallet) {
+    if (!wallet) {
         fs::remove_all(wallet_path);
     }
 
@@ -802,60 +801,6 @@ void CWallet::AddToSpends(const CWalletTx& wtx, WalletBatch* batch)
         AddToSpends(txin.prevout, wtx.GetHash(), batch);
 }
 
-void CWallet::InitialiseAddressBookUsed()
-{
-    for (const auto& entry : mapWallet) {
-        const CWalletTx& wtx = entry.second;
-        UpdateAddressBookUsed(wtx);
-    }
-}
-
-void CWallet::UpdateAddressBookUsed(const CWalletTx& wtx)
-{
-    for (const auto& output : wtx.tx->vout) {
-        CTxDestination dest;
-        if (!ExtractDestination(output.scriptPubKey, dest)) continue;
-        m_address_book[dest].m_used = true;
-    }
-}
-
-bool CWallet::FindScriptPubKeyUsed(const std::set<CScript>& keys, const std::variant<std::monostate, std::function<void(const CWalletTx&)>, std::function<void(const CWalletTx&, uint32_t)>>& callback) const
-{
-    AssertLockHeld(cs_wallet);
-    bool found_any = false;
-    for (const auto& key : keys) {
-        CTxDestination dest;
-        if (!ExtractDestination(key, dest)) continue;
-        const auto& address_book_it = m_address_book.find(dest);
-        if (address_book_it == m_address_book.end()) continue;
-        if (address_book_it->second.m_used) {
-            found_any = true;
-            break;
-        }
-    }
-    if (!found_any) return false;
-    if (std::holds_alternative<std::monostate>(callback)) return true;
-
-    found_any = false;
-    for (const auto& entry : mapWallet) {
-        const CWalletTx& wtx = entry.second;
-        for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {
-            const auto& output = wtx.tx->vout[i];
-            if (keys.count(output.scriptPubKey)) {
-                found_any = true;
-                const auto callback_type = callback.index();
-                if (callback_type == 1) {
-                    std::get<std::function<void(const CWalletTx&)>>(callback)(wtx);
-                    break;
-                }
-                std::get<std::function<void(const CWalletTx&, uint32_t)>>(callback)(wtx, i);
-            }
-        }
-    }
-
-    return found_any;
-}
-
 bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)
 {
     if (IsCrypted())
@@ -1152,7 +1097,6 @@ CWalletTx* CWallet::AddToWallet(CTransactionRef tx, const TxState& state, const
 
         // Update birth time when tx time is older than it.
         MaybeUpdateBirthTime(wtx.GetTxTime());
-        UpdateAddressBookUsed(wtx);
     }
 
     if (!fInsertedNew)
@@ -1216,32 +1160,31 @@ CWalletTx* CWallet::AddToWallet(CTransactionRef tx, const TxState& state, const
     // Notify UI of new or updated transaction
     NotifyTransactionChanged(hash, fInsertedNew ? CT_NEW : CT_UPDATED);
 
-    // Notify listeners on new wallet transaction
-    CWallet::TransactionAddedToWallet(wtx.tx, TxStateSerializedBlockHash(wtx.m_state));
-
 #if HAVE_SYSTEM
     // notify an external script when a wallet transaction comes in or is updated
-    if (!m_notify_tx_changed_scripts.empty()) {
-        const std::string walletname_escaped = ShellEscape(GetName());
-        const std::string txid_hex = hash.GetHex();
-        std::string blockhash_hex, blockheight_str;
-        if (auto* conf = wtx.state<TxStateConfirmed>()) {
-            blockhash_hex = conf->confirmed_block_hash.GetHex();
-            blockheight_str = ToString(conf->confirmed_block_height);
-        } else {
-            blockhash_hex = "unconfirmed";
-            blockheight_str = "-1";
-        }
-
-        for (std::string command : m_notify_tx_changed_scripts) {
-            ReplaceAll(command, "%s", txid_hex);
-            ReplaceAll(command, "%b", blockhash_hex);
-            ReplaceAll(command, "%h", blockheight_str);
-            ReplaceAll(command, "%w", walletname_escaped);
+    std::string strCmd = m_notify_tx_changed_script;
 
-            std::thread t(runCommand, command);
-            t.detach(); // thread runs free
-        }
+    if (!strCmd.empty())
+    {
+        ReplaceAll(strCmd, "%s", hash.GetHex());
+        if (auto* conf = wtx.state<TxStateConfirmed>())
+        {
+            ReplaceAll(strCmd, "%b", conf->confirmed_block_hash.GetHex());
+            ReplaceAll(strCmd, "%h", ToString(conf->confirmed_block_height));
+        } else {
+            ReplaceAll(strCmd, "%b", "unconfirmed");
+            ReplaceAll(strCmd, "%h", "-1");
+        }
+#ifndef WIN32
+        // Substituting the wallet name isn't currently supported on windows
+        // because windows shell escaping has not been implemented yet:
+        // https://github.com/bitcoin/bitcoin/pull/13339#issuecomment-537384875
+        // A few ways it could be implemented in the future are described in:
+        // https://github.com/bitcoin/bitcoin/pull/13339#issuecomment-461288094
+        ReplaceAll(strCmd, "%w", ShellEscape(GetName()));
+#endif
+        std::thread t(runCommand, strCmd);
+        t.detach(); // thread runs free
     }
 #endif
 
@@ -1562,23 +1505,12 @@ void CWallet::transactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRe
 
 void CWallet::blockConnected(ChainstateRole role, const interfaces::BlockInfo& block)
 {
+    if (role == ChainstateRole::BACKGROUND) {
+        return;
+    }
     assert(block.data);
     LOCK(cs_wallet);
 
-    switch (role) {
-        case ChainstateRole::BACKGROUND:
-            m_background_validation_height = block.height;
-            return;
-        case ChainstateRole::ASSUMEDVALID:
-            if (m_background_validation_height == -1) {
-                m_background_validation_height = 0;
-            }
-            break;
-        case ChainstateRole::NORMAL:
-            m_background_validation_height = -1;
-            break;
-    } // no default case, so the compiler can warn about missing cases
-
     m_last_block_processed_height = block.height;
     m_last_block_processed = block.hash;
 
@@ -2238,13 +2170,13 @@ bool CWallet::SignTransaction(CMutableTransaction& tx) const
     return SignTransaction(tx, coins, SIGHASH_DEFAULT, input_errors);
 }
 
-bool CWallet::SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, bilingual_str>& input_errors, std::optional<CAmount>* inputs_amount_sum) const
+bool CWallet::SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, bilingual_str>& input_errors) const
 {
     // Try to sign with all ScriptPubKeyMans
     for (ScriptPubKeyMan* spk_man : GetAllScriptPubKeyMans()) {
         // spk_man->SignTransaction will return true if the transaction is complete,
         // so we can exit early and return true if that happens
-        if (spk_man->SignTransaction(tx, coins, sighash, input_errors, inputs_amount_sum)) {
+        if (spk_man->SignTransaction(tx, coins, sighash, input_errors)) {
             return true;
         }
     }
@@ -2307,14 +2239,14 @@ std::optional<PSBTError> CWallet::FillPSBT(PartiallySignedTransaction& psbtx, bo
     return {};
 }
 
-SigningResult CWallet::SignMessage(const MessageSignatureFormat format, const std::string& message, const CTxDestination& address, std::string& str_sig) const
+SigningResult CWallet::SignMessage(const std::string& message, const PKHash& pkhash, std::string& str_sig) const
 {
     SignatureData sigdata;
-    CScript script_pub_key = GetScriptForDestination(address);
+    CScript script_pub_key = GetScriptForDestination(pkhash);
     for (const auto& spk_man_pair : m_spk_managers) {
         if (spk_man_pair.second->CanProvide(script_pub_key, sigdata)) {
             LOCK(cs_wallet);  // DescriptorScriptPubKeyMan calls IsLocked which can lock cs_wallet in a deadlocking order
-            return spk_man_pair.second->SignMessage(format, message, address, str_sig);
+            return spk_man_pair.second->SignMessage(message, pkhash, str_sig);
         }
     }
     return SigningResult::PRIVATE_KEY_NOT_AVAILABLE;
@@ -2350,7 +2282,7 @@ OutputType CWallet::TransactionChangeType(const std::optional<OutputType>& chang
     }
 
     const bool has_bech32m_spkman(GetScriptPubKeyMan(OutputType::BECH32M, /*internal=*/true));
-    if (has_bech32m_spkman && any_tr && m_default_address_type == OutputType::BECH32M) {
+    if (has_bech32m_spkman && any_tr) {
         // Currently tr is the only type supported by the BECH32M spkman
         return OutputType::BECH32M;
     }
@@ -2370,16 +2302,6 @@ OutputType CWallet::TransactionChangeType(const std::optional<OutputType>& chang
         // Currently pkh is the only type supported by the LEGACY spkman
         return OutputType::LEGACY;
     }
-    if (!GetScriptPubKeyMan(m_default_address_type, /*internal=*/true)) {
-        // Default type not available, so look for anything else to fallback to
-        // NOTE: Sane behaviour assumes OUTPUT_TYPES is sorted oldest to newest
-        for (const auto& ot : OUTPUT_TYPES) {
-            if (GetScriptPubKeyMan(ot, /*internal=*/true)) {
-                return ot;
-            }
-        }
-    }
-    return m_default_address_type;
 
     if (has_bech32m_spkman) {
         return OutputType::BECH32M;
@@ -2432,7 +2354,7 @@ void CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::ve
     }
 }
 
-DBErrors CWallet::LoadWallet(const do_init_used_flag do_init_used_flag_val)
+DBErrors CWallet::LoadWallet()
 {
     LOCK(cs_wallet);
 
@@ -2454,13 +2376,7 @@ DBErrors CWallet::LoadWallet(const do_init_used_flag do_init_used_flag_val)
         assert(m_internal_spk_managers.empty());
     }
 
-    if (nLoadWalletRet != DBErrors::LOAD_OK) {
-        return nLoadWalletRet;
-    }
-
-    if (do_init_used_flag_val == do_init_used_flag::Init) InitialiseAddressBookUsed();
-
-    return DBErrors::LOAD_OK;
+    return nLoadWalletRet;
 }
 
 util::Result<void> CWallet::RemoveTxs(std::vector<uint256>& txs_to_remove)
@@ -2700,13 +2616,6 @@ void CWallet::ForEachAddrBookEntry(const ListAddrBookFunc& func) const
     }
 }
 
-bool CWallet::IsDestinationActive(const CTxDestination& dest) const
-{
-    const CScript& script{GetScriptForDestination(dest)};
-    const std::set<ScriptPubKeyMan*>& spkms{GetActiveScriptPubKeyMans()};
-    return std::any_of(spkms.cbegin(), spkms.cend(), [&script](const auto& spkm) { return spkm->IsKeyActive(script); });
-}
-
 std::vector<CTxDestination> CWallet::ListAddrBookAddresses(const std::optional<AddrBookFilter>& _filter) const
 {
     AssertLockHeld(cs_wallet);
@@ -3071,7 +2980,7 @@ std::shared_ptr<CWallet> CWallet::Create(WalletContext& context, const std::stri
     // should be possible to use std::allocate_shared.
     std::shared_ptr<CWallet> walletInstance(new CWallet(chain, name, std::move(database)), FlushAndDeleteWallet);
     walletInstance->m_keypool_size = std::max(args.GetIntArg("-keypool", DEFAULT_KEYPOOL_SIZE), int64_t{1});
-    walletInstance->m_notify_tx_changed_scripts = args.GetArgs("-walletnotify");
+    walletInstance->m_notify_tx_changed_script = args.GetArg("-walletnotify", "");
 
     // Load wallet
     bool rescan_required = false;
@@ -3553,18 +3462,6 @@ bool CWallet::IsTxImmatureCoinBase(const CWalletTx& wtx) const
     return GetTxBlocksToMaturity(wtx) > 0;
 }
 
-bool CWallet::IsTxAssumed(const CWalletTx& wtx) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet)
-{
-    AssertLockHeld(cs_wallet);
-    if (GetBackgroundValidationHeight() == -1) return false;
-    if (auto* conf = wtx.state<TxStateConfirmed>()) {
-        int height{conf->confirmed_block_height};
-        return height > GetBackgroundValidationHeight();
-    }
-    return false;
-}
-
-
 bool CWallet::IsCrypted() const
 {
     return HasEncryptionKeys();
@@ -4167,11 +4064,7 @@ bool CWallet::ApplyMigrationData(MigrationData& data, bilingual_str& error)
         if (ExtractDestination(script, dest)) not_migrated_dests.emplace(dest);
     }
 
-    // When the legacy wallet has no spendable scripts, the main wallet will be empty, leaving its script cache empty as well.
-    // The watch-only and/or solvable wallet(s) will contain the scripts in their respective caches.
-    if (!data.desc_spkms.empty()) Assume(!m_cached_spks.empty());
-    if (!data.watch_descs.empty()) Assume(!data.watchonly_wallet->m_cached_spks.empty());
-    if (!data.solvable_descs.empty()) Assume(!data.solvable_wallet->m_cached_spks.empty());
+    Assume(!m_cached_spks.empty());
 
     for (auto& desc_spkm : data.desc_spkms) {
         if (m_spk_managers.count(desc_spkm->GetID()) > 0) {
@@ -4620,7 +4513,7 @@ util::Result<MigrationResult> MigrateLegacyToDescriptor(const std::string& walle
     }
     if (!success) {
         // Migration failed, cleanup
-        // Before deleting the wallet's directory, copy the backup file to the top-level wallets dir
+        // Copy the backup to the actual wallet dir
         fs::path temp_backup_location = fsbridge::AbsPathJoin(GetWalletDir(), backup_filename);
         fs::copy_file(backup_path, temp_backup_location, fs::copy_options::none);
 
@@ -4657,24 +4550,17 @@ util::Result<MigrationResult> MigrateLegacyToDescriptor(const std::string& walle
         }
 
         // Restore the backup
-        // Convert the backup file to the wallet db file by renaming it and moving it into the wallet's directory.
-        // Reload it into memory if the wallet was previously loaded.
-        bilingual_str restore_error;
-        const auto& ptr_wallet = RestoreWallet(context, temp_backup_location, wallet_name, /*load_on_start=*/std::nullopt, status, restore_error, warnings, /*load_after_restore=*/was_loaded);
-        if (!restore_error.empty()) {
-            error += restore_error + _("\nUnable to restore backup of wallet.");
+        DatabaseStatus status;
+        std::vector<bilingual_str> warnings;
+        if (!RestoreWallet(context, temp_backup_location, wallet_name, /*load_on_start=*/std::nullopt, status, error, warnings)) {
+            error += _("\nUnable to restore backup of wallet.");
             return util::Error{error};
         }
 
-        // The wallet directory has been restored, but just in case, copy the previously created backup to the wallet dir
+        // Move the backup to the wallet dir
         fs::copy_file(temp_backup_location, backup_path, fs::copy_options::none);
         fs::remove(temp_backup_location);
 
-        // Verify that there is no dangling wallet: when the wallet wasn't loaded before, expect null.
-        // This check is performed after restoration to avoid an early error before saving the backup.
-        bool wallet_reloaded = ptr_wallet != nullptr;
-        assert(was_loaded == wallet_reloaded);
-
         return util::Error{error};
     }
     return res;
diff --git a/src/wallet/wallet.h b/src/wallet/wallet.h
index ba86ad4187..3ea1cf48b2 100644
--- a/src/wallet/wallet.h
+++ b/src/wallet/wallet.h
@@ -47,7 +47,6 @@
 #include <string>
 #include <unordered_map>
 #include <utility>
-#include <variant>
 #include <vector>
 
 #include <boost/signals2/signal.hpp>
@@ -96,7 +95,7 @@ std::shared_ptr<CWallet> GetDefaultWallet(WalletContext& context, size_t& count)
 std::shared_ptr<CWallet> GetWallet(WalletContext& context, const std::string& name);
 std::shared_ptr<CWallet> LoadWallet(WalletContext& context, const std::string& name, std::optional<bool> load_on_start, const DatabaseOptions& options, DatabaseStatus& status, bilingual_str& error, std::vector<bilingual_str>& warnings);
 std::shared_ptr<CWallet> CreateWallet(WalletContext& context, const std::string& name, std::optional<bool> load_on_start, DatabaseOptions& options, DatabaseStatus& status, bilingual_str& error, std::vector<bilingual_str>& warnings);
-std::shared_ptr<CWallet> RestoreWallet(WalletContext& context, const fs::path& backup_file, const std::string& wallet_name, std::optional<bool> load_on_start, DatabaseStatus& status, bilingual_str& error, std::vector<bilingual_str>& warnings, bool load_after_restore = true);
+std::shared_ptr<CWallet> RestoreWallet(WalletContext& context, const fs::path& backup_file, const std::string& wallet_name, std::optional<bool> load_on_start, DatabaseStatus& status, bilingual_str& error, std::vector<bilingual_str>& warnings);
 std::unique_ptr<interfaces::Handler> HandleLoadWallet(WalletContext& context, LoadWalletFn load_wallet);
 void NotifyWalletLoaded(WalletContext& context, const std::shared_ptr<CWallet>& wallet);
 std::unique_ptr<WalletDatabase> MakeWalletDatabase(const std::string& name, const DatabaseOptions& options, DatabaseStatus& status, bilingual_str& error);
@@ -128,7 +127,7 @@ static const bool DEFAULT_SPEND_ZEROCONF_CHANGE = true;
 //! Default for -walletrejectlongchains
 static const bool DEFAULT_WALLET_REJECT_LONG_CHAINS{true};
 //! -txconfirmtarget default
-static const unsigned int DEFAULT_TX_CONFIRM_TARGET = 144;
+static const unsigned int DEFAULT_TX_CONFIRM_TARGET = 6;
 //! -walletrbf default
 static const bool DEFAULT_WALLET_RBF = true;
 static const bool DEFAULT_WALLETBROADCAST = true;
@@ -158,7 +157,6 @@ static constexpr uint64_t KNOWN_WALLET_FLAGS =
     |   WALLET_FLAG_EXTERNAL_SIGNER;
 
 static constexpr uint64_t MUTABLE_WALLET_FLAGS =
-        WALLET_FLAG_EXTERNAL_SIGNER |
         WALLET_FLAG_AVOID_REUSE;
 
 static const std::map<std::string,WalletFlags> WALLET_FLAG_MAP{
@@ -238,12 +236,6 @@ struct CAddressBookData
      */
     std::optional<std::string> label;
 
-    /** Whether address is the destination of any wallet transation.
-     * Unlike other fields in address data struct, the used value is determined
-     * at runtime and not serialized as part of address data.
-     */
-    bool m_used{false};
-
     /**
      * Address purpose which was originally recorded for payment protocol
      * support but now serves as a cached IsMine value. Wallet code should
@@ -344,9 +336,6 @@ private:
     void AddToSpends(const COutPoint& outpoint, const uint256& wtxid, WalletBatch* batch = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
     void AddToSpends(const CWalletTx& wtx, WalletBatch* batch = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
 
-    void InitialiseAddressBookUsed() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
-    void UpdateAddressBookUsed(const CWalletTx&) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
-
     /**
      * Add a transaction to the wallet, or update it.  confirm.block_* should
      * be set when the transaction was known to be included in a block.  When
@@ -419,13 +408,6 @@ private:
      */
     int m_last_block_processed_height GUARDED_BY(cs_wallet) = -1;
 
-    /**
-     * The following is used to track whether a confirmed transaction is in
-     * a block that background validation hasn't checked yet, or above the
-     * assume utxo snapshot height when background validation hasn't completed.
-     */
-    int m_background_validation_height GUARDED_BY(cs_wallet) = -1;
-
     std::map<OutputType, ScriptPubKeyMan*> m_external_spk_managers;
     std::map<OutputType, ScriptPubKeyMan*> m_internal_spk_managers;
 
@@ -536,7 +518,6 @@ public:
      * referenced in transaction, and might cause assert failures.
      */
     int GetTxDepthInMainChain(const CWalletTx& wtx) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
-    bool IsTxAssumed(const CWalletTx& wtx) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
 
     /**
      * @return number of blocks to maturity for this transaction:
@@ -564,8 +545,6 @@ public:
     bool UnlockAllCoins() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
     void ListLockedCoins(std::vector<COutPoint>& vOutpts) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
 
-    bool FindScriptPubKeyUsed(const std::set<CScript>& keys, const std::variant<std::monostate, std::function<void(const CWalletTx&)>, std::function<void(const CWalletTx&, uint32_t)>>& callback = std::monostate()) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
-
     /*
      * Rescan abort properties
      */
@@ -656,15 +635,13 @@ public:
     bool ShouldResend() const;
     void ResubmitWalletTransactions(bool relay, bool force);
 
-    CAmount GetLegacyBalance(const isminefilter& filter, int minDepth) const;
-
     OutputType TransactionChangeType(const std::optional<OutputType>& change_type, const std::vector<CRecipient>& vecSend) const;
 
     /** Fetch the inputs and sign with SIGHASH_ALL. */
     bool SignTransaction(CMutableTransaction& tx) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
     /** Sign the tx given the input coins and sighash. */
-    bool SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, bilingual_str>& input_errors, std::optional<CAmount>* inputs_amount_sum = nullptr) const;
-    SigningResult SignMessage(const MessageSignatureFormat format, const std::string& message, const CTxDestination& address, std::string& str_sig) const;
+    bool SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, bilingual_str>& input_errors) const;
+    SigningResult SignMessage(const std::string& message, const PKHash& pkhash, std::string& str_sig) const;
 
     /**
      * Fills out a PSBT with information from the wallet. Fills in UTXOs if we have
@@ -754,7 +731,7 @@ public:
     int64_t m_keypool_size{DEFAULT_KEYPOOL_SIZE};
 
     /** Notify external script when a wallet transaction comes in or is updated (handled by -walletnotify) */
-    std::vector<std::string> m_notify_tx_changed_scripts;
+    std::string m_notify_tx_changed_script;
 
     size_t KeypoolCountExternalKeys() const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
     bool TopUpKeyPool(unsigned int kpSize = 0);
@@ -786,11 +763,6 @@ public:
     using ListAddrBookFunc = std::function<void(const CTxDestination& dest, const std::string& label, bool is_change, const std::optional<AddressPurpose> purpose)>;
     void ForEachAddrBookEntry(const ListAddrBookFunc& func) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
 
-    /**
-     * Determines if a destination is in the active spkm (not imported and not dumped for a new keypool)
-     */
-    [[nodiscard]] bool IsDestinationActive(const CTxDestination& dest) const;
-
     /**
      * Marks all outputs in each one of the destinations dirty, so their cache is
      * reset and does not return outdated information.
@@ -815,8 +787,7 @@ public:
     CAmount GetDebit(const CTransaction& tx, const isminefilter& filter) const;
     void chainStateFlushed(ChainstateRole role, const CBlockLocator& loc) override;
 
-    enum class do_init_used_flag { Init, Skip };
-    DBErrors LoadWallet(const do_init_used_flag do_init_used_flag_val = do_init_used_flag::Init);
+    DBErrors LoadWallet();
 
     /** Erases the provided transactions from the wallet. */
     util::Result<void> RemoveTxs(std::vector<uint256>& txs_to_remove) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
@@ -871,9 +842,6 @@ public:
      */
     boost::signals2::signal<void(const uint256& hashTx, ChangeType status)> NotifyTransactionChanged;
 
-    static boost::signals2::signal<void (const CTransactionRef &ptxn,
-                                  const uint256 &blockHash)> TransactionAddedToWallet;
-
     /** Show progress e.g. for rescan */
     boost::signals2::signal<void (const std::string &title, int nProgress)> ShowProgress;
 
@@ -1022,12 +990,6 @@ public:
         m_last_block_processed_height = block_height;
         m_last_block_processed = block_hash;
     };
-    /** Height of background validation. Returns -1 if there is no background validation. */
-    int GetBackgroundValidationHeight() const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet)
-    {
-        AssertLockHeld(cs_wallet);
-        return m_background_validation_height;
-    };
 
     //! Connect the signals from ScriptPubKeyMans to the signals in CWallet
     void ConnectScriptPubKeyManNotifiers();
diff --git a/src/wallet/walletdb.h b/src/wallet/walletdb.h
index c56fc4b212..bffcc87202 100644
--- a/src/wallet/walletdb.h
+++ b/src/wallet/walletdb.h
@@ -136,7 +136,6 @@ class CKeyMetadata
 {
 public:
     static const int VERSION_BASIC=1;
-    static const int VERSION_WITH_FLAGS = 2;  // not supported, but preserved
     static const int VERSION_WITH_HDDATA=10;
     static const int VERSION_WITH_KEY_ORIGIN = 12;
     static const int CURRENT_VERSION=VERSION_WITH_KEY_ORIGIN;
@@ -144,7 +143,6 @@ public:
     int64_t nCreateTime; // 0 means unknown
     std::string hdKeypath; //optional HD/bip32 keypath. Still used to determine whether a key is a seed. Also kept for backwards compatibility
     CKeyID hd_seed_id; //id of the HD seed used to derive this key
-    uint8_t unsupported_key_flags;
     KeyOriginInfo key_origin; // Key origin info with path and fingerprint
     bool has_key_origin = false; //!< Whether the key_origin is useful
 
@@ -163,8 +161,6 @@ public:
         READWRITE(obj.nVersion, obj.nCreateTime);
         if (obj.nVersion >= VERSION_WITH_HDDATA) {
             READWRITE(obj.hdKeypath, obj.hd_seed_id);
-        } else if (obj.nVersion >= VERSION_WITH_FLAGS) {
-            READWRITE(obj.unsupported_key_flags);
         }
         if (obj.nVersion >= VERSION_WITH_KEY_ORIGIN)
         {
diff --git a/src/wallet/wallettool.cpp b/src/wallet/wallettool.cpp
index 3768ba65a5..10785ad354 100644
--- a/src/wallet/wallettool.cpp
+++ b/src/wallet/wallettool.cpp
@@ -7,8 +7,6 @@
 #include <wallet/wallettool.h>
 
 #include <common/args.h>
-#include <tinyformat.h>
-#include <univalue.h>
 #include <util/fs.h>
 #include <util/translation.h>
 #include <wallet/dump.h>
@@ -16,15 +14,7 @@
 #include <wallet/wallet.h>
 #include <wallet/walletutil.h>
 
-#include <cassert>
-#include <fstream>
-#include <string>
-
 namespace wallet {
-
-UniValue ProcessDescriptorImport(CWallet& wallet, const UniValue& data, const int64_t timestamp, const std::vector<CExtKey>& master_keys = {})
-    EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);
-
 namespace WalletTool {
 
 // The standard wallet deleter function blocks on the validation interface
@@ -44,10 +34,6 @@ static void WalletCreate(CWallet* wallet_instance, uint64_t wallet_creation_flag
     wallet_instance->SetMinVersion(FEATURE_LATEST);
     wallet_instance->InitWalletFlags(wallet_creation_flags);
 
-    if (wallet_instance->IsWalletFlagSet(WALLET_FLAG_BLANK_WALLET)) {
-        return;
-    }
-
     if (!wallet_instance->IsWalletFlagSet(WALLET_FLAG_DESCRIPTORS)) {
         auto spk_man = wallet_instance->GetOrCreateLegacyScriptPubKeyMan();
         spk_man->SetupGeneration(false);
@@ -59,7 +45,7 @@ static void WalletCreate(CWallet* wallet_instance, uint64_t wallet_creation_flag
     wallet_instance->TopUpKeyPool();
 }
 
-static std::shared_ptr<CWallet> MakeWallet(const std::string& name, const fs::path& path, DatabaseOptions options, CWallet::do_init_used_flag do_init_used_flag_val = CWallet::do_init_used_flag::Init)
+static std::shared_ptr<CWallet> MakeWallet(const std::string& name, const fs::path& path, DatabaseOptions options)
 {
     DatabaseStatus status;
     bilingual_str error;
@@ -73,7 +59,7 @@ static std::shared_ptr<CWallet> MakeWallet(const std::string& name, const fs::pa
     std::shared_ptr<CWallet> wallet_instance{new CWallet(/*chain=*/nullptr, name, std::move(database)), WalletToolReleaseWallet};
     DBErrors load_wallet_ret;
     try {
-        load_wallet_ret = wallet_instance->LoadWallet(do_init_used_flag_val);
+        load_wallet_ret = wallet_instance->LoadWallet();
     } catch (const std::runtime_error&) {
         tfm::format(std::cerr, "Error loading %s. Is wallet being used by another process?\n", name);
         return nullptr;
@@ -124,40 +110,14 @@ static void WalletShowInfo(CWallet* wallet_instance)
     tfm::format(std::cout, "Address Book: %zu\n", wallet_instance->m_address_book.size());
 }
 
-static bool ReadAndParseColdcardFile(const fs::path& path, UniValue& decriptors)
-{
-    std::ifstream file;
-    file.open(path);
-    if (!file.is_open()) {
-        tfm::format(std::cerr, "%s. Please check permissions.\n", fs::PathToString(path));
-        return false;
-    }
-
-    std::string line;
-    while (std::getline(file, line)) {
-        if (line.substr(0, 22) == "importdescriptors \'[{\"") break;
-    }
-
-    file.close();
-
-    decriptors.clear();
-    if (!decriptors.read(line.substr(19, line.size() - 20))) {
-        tfm::format(std::cerr, "Unable to parse %s\n", fs::PathToString(path));
-        return false;
-    }
-
-    assert(decriptors.isArray());
-    return true;
-}
-
 bool ExecuteWalletToolFunc(const ArgsManager& args, const std::string& command)
 {
     if (args.IsArgSet("-format") && command != "createfromdump") {
         tfm::format(std::cerr, "The -format option can only be used with the \"createfromdump\" command.\n");
         return false;
     }
-    if (args.IsArgSet("-dumpfile") && command != "dump" && command != "createfromdump" && command != "importfromcoldcard") {
-        tfm::format(std::cerr, "The -dumpfile option can only be used with the \"dump\", \"createfromdump\" and \"importfromcoldcard\" commands.\n");
+    if (args.IsArgSet("-dumpfile") && command != "dump" && command != "createfromdump") {
+        tfm::format(std::cerr, "The -dumpfile option can only be used with the \"dump\" and \"createfromdump\" commands.\n");
         return false;
     }
     if (args.IsArgSet("-descriptors") && command != "create") {
@@ -205,8 +165,7 @@ bool ExecuteWalletToolFunc(const ArgsManager& args, const std::string& command)
         DatabaseOptions options;
         ReadDatabaseArgs(args, options);
         options.require_existing = true;
-        // NOTE: We need to skip initialisation of the m_used flag, or else the address book count might be wrong
-        const std::shared_ptr<CWallet> wallet_instance = MakeWallet(name, path, options, CWallet::do_init_used_flag::Skip);
+        const std::shared_ptr<CWallet> wallet_instance = MakeWallet(name, path, options);
         if (!wallet_instance) return false;
         WalletShowInfo(wallet_instance.get());
         wallet_instance->Close();
@@ -232,14 +191,6 @@ bool ExecuteWalletToolFunc(const ArgsManager& args, const std::string& command)
         DatabaseOptions options;
         ReadDatabaseArgs(args, options);
         options.require_existing = true;
-
-        // Get the dumpfile
-        std::string dump_filename = args.GetArg("-dumpfile", "");
-        if (dump_filename.empty()) {
-            tfm::format(std::cerr, "No dump file provided. To use dump, -dumpfile=<filename> must be provided.\n");
-            return false;
-        }
-
         DatabaseStatus status;
 
         if (args.GetBoolArg("-withinternalbdb", false) && IsBDBFile(BDBDataFile(path))) {
@@ -253,67 +204,24 @@ bool ExecuteWalletToolFunc(const ArgsManager& args, const std::string& command)
             return false;
         }
 
-        if (database->Format().starts_with("bdb")) {
-            tfm::format(std::cerr, "dump: WARNING: BDB-backed wallets have a wallet id that is not currently dumped.\n");
-        }
-
-        bool ret = DumpWallet(*database, error, dump_filename);
+        bool ret = DumpWallet(args, *database, error);
         if (!ret && !error.empty()) {
             tfm::format(std::cerr, "%s\n", error.original);
             return ret;
         }
-        tfm::format(std::cerr, "The dumpfile may contain private keys. To ensure the safety of your Bitcoin, do not share the dumpfile.\n");
+        tfm::format(std::cout, "The dumpfile may contain private keys. To ensure the safety of your Bitcoin, do not share the dumpfile.\n");
         return ret;
     } else if (command == "createfromdump") {
         bilingual_str error;
         std::vector<bilingual_str> warnings;
         bool ret = CreateFromDump(args, name, path, error, warnings);
         for (const auto& warning : warnings) {
-            tfm::format(std::cerr, "%s\n", warning.original);
+            tfm::format(std::cout, "%s\n", warning.original);
         }
         if (!ret && !error.empty()) {
             tfm::format(std::cerr, "%s\n", error.original);
         }
         return ret;
-    } else if (command == "importfromcoldcard") {
-        tfm::format(std::cerr, "WARNING: The \"importfromcoldcard\" command is experimental and will likely be removed or changed incompatibly in a future version.\n");
-
-        std::string filename = gArgs.GetArg("-dumpfile", "");
-        if (filename.empty()) {
-            tfm::format(std::cerr, "To use importfromcoldcard, -dumpfile=<filename> must be provided.\n");
-            return false;
-        }
-
-        const fs::path import_file_path{fs::absolute(fs::PathFromString(filename))};
-        if (!fs::exists(import_file_path)) {
-            tfm::format(std::cerr, "File %s does not exist.\n", fs::PathToString(import_file_path));
-            return false;
-        }
-
-        UniValue descriptors;
-        if (!ReadAndParseColdcardFile(import_file_path, descriptors)) {
-            return false;
-        }
-
-        DatabaseOptions options;
-        options.require_create = true;
-        options.create_flags |= WALLET_FLAG_DESCRIPTORS;
-        options.create_flags |= WALLET_FLAG_DISABLE_PRIVATE_KEYS;
-        options.create_flags |= WALLET_FLAG_BLANK_WALLET;
-        options.require_format = DatabaseFormat::SQLITE;
-        std::shared_ptr<CWallet> wallet_instance = MakeWallet(name, path, options);
-        if (!wallet_instance) {
-            return false;
-        }
-
-        LOCK(wallet_instance->cs_wallet);
-        for (const UniValue& descriptor : descriptors.getValues()) {
-            const UniValue result = ProcessDescriptorImport(*wallet_instance, descriptor, 0);
-            tfm::format(std::cerr, "%s\n", result.write(2));
-        }
-
-        WalletShowInfo(wallet_instance.get());
-        wallet_instance->Close();
     } else {
         tfm::format(std::cerr, "Invalid command: %s\n", command);
         return false;
diff --git a/src/zmq/zmqabstractnotifier.cpp b/src/zmq/zmqabstractnotifier.cpp
index 920763067a..90aefb0018 100644
--- a/src/zmq/zmqabstractnotifier.cpp
+++ b/src/zmq/zmqabstractnotifier.cpp
@@ -42,7 +42,3 @@ bool CZMQAbstractNotifier::NotifyTransactionRemoval(const CTransaction &/*transa
 {
     return true;
 }
-
-bool CZMQAbstractNotifier::NotifyWalletTransaction(const CTransaction &transaction, const uint256 &hashBlock){
-    return true;
-}
diff --git a/src/zmq/zmqabstractnotifier.h b/src/zmq/zmqabstractnotifier.h
index 51ff88db1a..17fa7bbaa9 100644
--- a/src/zmq/zmqabstractnotifier.h
+++ b/src/zmq/zmqabstractnotifier.h
@@ -13,7 +13,6 @@
 class CBlockIndex;
 class CTransaction;
 class CZMQAbstractNotifier;
-class uint256;
 
 using CZMQNotifierFactory = std::function<std::unique_ptr<CZMQAbstractNotifier>()>;
 
@@ -57,7 +56,6 @@ public:
     virtual bool NotifyTransactionRemoval(const CTransaction &transaction, uint64_t mempool_sequence);
     // Notifies of transactions added to mempool or appearing in blocks
     virtual bool NotifyTransaction(const CTransaction &transaction);
-    virtual bool NotifyWalletTransaction(const CTransaction &transaction, const uint256 &hashBlock);
 
 protected:
     void* psocket{nullptr};
diff --git a/src/zmq/zmqnotificationinterface.cpp b/src/zmq/zmqnotificationinterface.cpp
index b2611ef539..44cbacda64 100644
--- a/src/zmq/zmqnotificationinterface.cpp
+++ b/src/zmq/zmqnotificationinterface.cpp
@@ -2,10 +2,6 @@
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
-#if defined(HAVE_CONFIG_H)
-#include <config/bitcoin-config.h>
-#endif
-
 #include <zmq/zmqnotificationinterface.h>
 
 #include <common/args.h>
@@ -28,10 +24,6 @@
 #include <utility>
 #include <vector>
 
-#ifdef ENABLE_WALLET
-#include <wallet/wallet.h>
-#endif
-
 CZMQNotificationInterface::CZMQNotificationInterface() = default;
 
 CZMQNotificationInterface::~CZMQNotificationInterface()
@@ -53,12 +45,10 @@ std::unique_ptr<CZMQNotificationInterface> CZMQNotificationInterface::Create(std
     std::map<std::string, CZMQNotifierFactory> factories;
     factories["pubhashblock"] = CZMQAbstractNotifier::Create<CZMQPublishHashBlockNotifier>;
     factories["pubhashtx"] = CZMQAbstractNotifier::Create<CZMQPublishHashTransactionNotifier>;
-    factories["pubhashwallettx"] = CZMQAbstractNotifier::Create<CZMQPublishHashWalletTransactionNotifier>;
     factories["pubrawblock"] = [&get_block_by_index]() -> std::unique_ptr<CZMQAbstractNotifier> {
         return std::make_unique<CZMQPublishRawBlockNotifier>(get_block_by_index);
     };
     factories["pubrawtx"] = CZMQAbstractNotifier::Create<CZMQPublishRawTransactionNotifier>;
-    factories["pubrawwallettx"] = CZMQAbstractNotifier::Create<CZMQPublishRawWalletTransactionNotifier>;
     factories["pubsequence"] = CZMQAbstractNotifier::Create<CZMQPublishSequenceNotifier>;
 
     std::list<std::unique_ptr<CZMQAbstractNotifier>> notifiers;
@@ -103,10 +93,6 @@ bool CZMQNotificationInterface::Initialize()
     LogPrint(BCLog::ZMQ, "Initialize notification interface\n");
     assert(!pcontext);
 
-#ifdef ENABLE_WALLET
-    m_wtx_added_connection = wallet::CWallet::TransactionAddedToWallet.connect(std::bind(&CZMQNotificationInterface::TransactionAddedToWallet, this, std::placeholders::_1, std::placeholders::_2));
-#endif
-
     pcontext = zmq_ctx_new();
 
     if (!pcontext)
@@ -131,11 +117,6 @@ bool CZMQNotificationInterface::Initialize()
 void CZMQNotificationInterface::Shutdown()
 {
     LogPrint(BCLog::ZMQ, "Shutdown notification interface\n");
-
-#ifdef ENABLE_WALLET
-    m_wtx_added_connection.disconnect();
-#endif
-
     if (pcontext)
     {
         for (auto& notifier : notifiers) {
@@ -153,9 +134,14 @@ namespace {
 template <typename Function>
 void TryForEachAndRemoveFailed(std::list<std::unique_ptr<CZMQAbstractNotifier>>& notifiers, const Function& func)
 {
-    for (auto i = notifiers.begin(); i != notifiers.end(); ++i) {
+    for (auto i = notifiers.begin(); i != notifiers.end(); ) {
         CZMQAbstractNotifier* notifier = i->get();
-        func(notifier);
+        if (func(notifier)) {
+            ++i;
+        } else {
+            notifier->Shutdown();
+            i = notifiers.erase(i);
+        }
     }
 }
 
@@ -223,12 +209,4 @@ void CZMQNotificationInterface::BlockDisconnected(const std::shared_ptr<const CB
     });
 }
 
-void CZMQNotificationInterface::TransactionAddedToWallet(const CTransactionRef& ptx, const uint256 &hashBlock) {
-    const CTransaction& tx = *ptx;
-
-    TryForEachAndRemoveFailed(notifiers, [&tx, &hashBlock](CZMQAbstractNotifier* notifier) {
-        return notifier->NotifyWalletTransaction(tx, hashBlock);
-    });
-}
-
 std::unique_ptr<CZMQNotificationInterface> g_zmq_notification_interface;
diff --git a/src/zmq/zmqnotificationinterface.h b/src/zmq/zmqnotificationinterface.h
index eb2ef19b65..c879fdd0dd 100644
--- a/src/zmq/zmqnotificationinterface.h
+++ b/src/zmq/zmqnotificationinterface.h
@@ -14,8 +14,6 @@
 #include <memory>
 #include <vector>
 
-#include <boost/signals2/connection.hpp>
-
 class CBlock;
 class CBlockIndex;
 class CZMQAbstractNotifier;
@@ -34,8 +32,6 @@ protected:
     bool Initialize();
     void Shutdown();
 
-    void TransactionAddedToWallet(const CTransactionRef& tx, const uint256 &hashBlock);
-
     // CValidationInterface
     void TransactionAddedToMempool(const NewMempoolTransactionInfo& tx, uint64_t mempool_sequence) override;
     void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) override;
@@ -48,7 +44,6 @@ private:
 
     void* pcontext{nullptr};
     std::list<std::unique_ptr<CZMQAbstractNotifier>> notifiers;
-    boost::signals2::connection m_wtx_added_connection;
 };
 
 extern std::unique_ptr<CZMQNotificationInterface> g_zmq_notification_interface;
diff --git a/src/zmq/zmqpublishnotifier.cpp b/src/zmq/zmqpublishnotifier.cpp
index 9da5d0b088..608870c489 100644
--- a/src/zmq/zmqpublishnotifier.cpp
+++ b/src/zmq/zmqpublishnotifier.cpp
@@ -42,12 +42,8 @@ static std::multimap<std::string, CZMQAbstractPublishNotifier*> mapPublishNotifi
 
 static const char *MSG_HASHBLOCK = "hashblock";
 static const char *MSG_HASHTX    = "hashtx";
-static const char *MSG_HASHWALLETTXMEMPOOL  = "hashwallettx-mempool";
-static const char *MSG_HASHWALLETTXBLOCK    = "hashwallettx-block";
 static const char *MSG_RAWBLOCK  = "rawblock";
 static const char *MSG_RAWTX     = "rawtx";
-static const char *MSG_RAWWALLETTXMEMPOOL   = "rawwallettx-mempool";
-static const char *MSG_RAWWALLETTXBLOCK     = "rawwallettx-block";
 static const char *MSG_SEQUENCE  = "sequence";
 
 // Internal function to send multipart message
@@ -243,30 +239,13 @@ bool CZMQPublishHashTransactionNotifier::NotifyTransaction(const CTransaction &t
     return SendZmqMessage(MSG_HASHTX, data, 32);
 }
 
-bool CZMQPublishHashWalletTransactionNotifier::NotifyWalletTransaction(const CTransaction &transaction, const uint256 &hashBlock){
-    uint256 hash = transaction.GetHash();
-    LogPrint(BCLog::ZMQ, "Publish hashwallettx %s to %s\n", hash.GetHex(), this->address);
-    uint8_t data[32];
-    for (unsigned int i = 0; i < 32; i++)
-        data[31 - i] = hash.begin()[i];
-
-    const char *command;
-
-    if (!hashBlock.IsNull())
-        command = MSG_HASHWALLETTXBLOCK;
-    else
-        command = MSG_HASHWALLETTXMEMPOOL;
-
-    return SendZmqMessage(command, data, 32);
-}
-
 bool CZMQPublishRawBlockNotifier::NotifyBlock(const CBlockIndex *pindex)
 {
     LogPrint(BCLog::ZMQ, "Publish rawblock %s to %s\n", pindex->GetBlockHash().GetHex(), this->address);
 
     std::vector<uint8_t> block{};
     if (!m_get_block_by_index(block, *pindex)) {
-        LogPrint(BCLog::ZMQ, "Error: Can't read block %s from disk\n", pindex->GetBlockHash().ToString());
+        zmqError("Can't read block from disk");
         return false;
     }
 
@@ -322,19 +301,3 @@ bool CZMQPublishSequenceNotifier::NotifyTransactionRemoval(const CTransaction &t
     LogPrint(BCLog::ZMQ, "Publish hashtx mempool removal %s to %s\n", hash.GetHex(), this->address);
     return SendSequenceMsg(*this, hash, /* Mempool (R)emoval */ 'R', mempool_sequence);
 }
-
-bool CZMQPublishRawWalletTransactionNotifier::NotifyWalletTransaction(const CTransaction &transaction, const uint256 &hashBlock){
-    uint256 hash = transaction.GetHash();
-    LogPrint(BCLog::ZMQ, "Publish rawwallettx %s to %s\n", hash.GetHex(), this->address);
-    DataStream ss;
-    ss << TX_WITH_WITNESS(transaction);
-
-    const char *command;
-
-    if (!hashBlock.IsNull())
-        command = MSG_RAWWALLETTXBLOCK;
-    else
-        command = MSG_RAWWALLETTXMEMPOOL;
-
-    return SendZmqMessage(command, &(*ss.begin()), ss.size());
-}
diff --git a/src/zmq/zmqpublishnotifier.h b/src/zmq/zmqpublishnotifier.h
index 6dad6eb904..cc941a899c 100644
--- a/src/zmq/zmqpublishnotifier.h
+++ b/src/zmq/zmqpublishnotifier.h
@@ -46,12 +46,6 @@ public:
     bool NotifyTransaction(const CTransaction &transaction) override;
 };
 
-class CZMQPublishHashWalletTransactionNotifier : public CZMQAbstractPublishNotifier
-{
-public:
-    bool NotifyWalletTransaction(const CTransaction &transaction, const uint256 &hashBlock) override;
-};
-
 class CZMQPublishRawBlockNotifier : public CZMQAbstractPublishNotifier
 {
 private:
@@ -69,12 +63,6 @@ public:
     bool NotifyTransaction(const CTransaction &transaction) override;
 };
 
-class CZMQPublishRawWalletTransactionNotifier : public CZMQAbstractPublishNotifier
-{
-public:
-    bool NotifyWalletTransaction(const CTransaction &transaction, const uint256 &hashBlock) override;
-};
-
 class CZMQPublishSequenceNotifier : public CZMQAbstractPublishNotifier
 {
 public:
diff --git a/test/config.ini.in b/test/config.ini.in
index 27fee040d3..291599da45 100644
--- a/test/config.ini.in
+++ b/test/config.ini.in
@@ -21,8 +21,6 @@ RPCAUTH=@abs_top_srcdir@/share/rpcauth/rpcauth.py
 @BUILD_BITCOIN_CLI_TRUE@ENABLE_CLI=true
 @BUILD_BITCOIN_UTIL_TRUE@ENABLE_BITCOIN_UTIL=true
 @BUILD_BITCOIN_WALLET_TRUE@ENABLE_WALLET_TOOL=true
-@BUILD_BITCOIN_TX_TRUE@ENABLE_UTIL_TX=true
-@BUILD_BITCOIN_UTIL_TRUE@ENABLE_UTIL_UTIL=true
 @BUILD_BITCOIND_TRUE@ENABLE_BITCOIND=true
 @ENABLE_FUZZ_BINARY_TRUE@ENABLE_FUZZ_BINARY=true
 @ENABLE_ZMQ_TRUE@ENABLE_ZMQ=true
diff --git a/test/functional/combine_logs.py b/test/functional/combine_logs.py
index 57fd0710b6..33c81bde13 100755
--- a/test/functional/combine_logs.py
+++ b/test/functional/combine_logs.py
@@ -79,12 +79,11 @@ def read_logs(tmp_dir):
     Delegates to generator function get_log_events() to provide individual log events
     for each of the input log files."""
 
-    # Find out what the folder is called that holds node 0's debug.log file
-    debug_logs = list(pathlib.Path(tmp_dir).glob('node0/**/debug.log'))
-    if len(debug_logs) > 0:
-        assert len(debug_logs) < 2, 'Max one debug.log is supported, ' \
-            'found several:\n\t' + '\n\t'.join([str(f) for f in debug_logs])
-        path = debug_logs[0]
+    # Find out what the folder is called that holds the debug.log file
+    glob = pathlib.Path(tmp_dir).glob('node0/**/debug.log')
+    path = next(glob, None)
+    if path:
+        assert next(glob, None) is None #  more than one debug.log, should never happen
         chain = re.search(r'node0/(.+?)/debug\.log$', path.as_posix()).group(1)  # extract the chain name
     else:
         chain = 'regtest'  # fallback to regtest (should only happen when none exists)
diff --git a/test/functional/data/completion/bitcoin-cli.footer.bash-completion b/test/functional/data/completion/bitcoin-cli.footer.bash-completion
deleted file mode 100644
index 03a4761742..0000000000
--- a/test/functional/data/completion/bitcoin-cli.footer.bash-completion
+++ /dev/null
@@ -1,47 +0,0 @@
-
-    case "$cur" in
-        -conf=*)
-            cur="${cur#*=}"
-            _filedir
-            return 0
-            ;;
-        -datadir=*)
-            cur="${cur#*=}"
-            _filedir -d
-            return 0
-            ;;
-        -*=*)	# prevent nonsense completions
-            return 0
-            ;;
-        *)
-            local helpopts commands
-
-            # only parse -help if senseful
-            if [[ -z "$cur" || "$cur" =~ ^- ]]; then
-                helpopts=$($bitcoin_cli -help 2>&1 | awk '$1 ~ /^-/ { sub(/=.*/, "="); print $1 }' )
-            fi
-
-            # only parse help if senseful
-            if [[ -z "$cur" || "$cur" =~ ^[a-z] ]]; then
-                commands=$(_bitcoin_rpc help 2>/dev/null | awk '$1 ~ /^[a-z]/ { print $1; }')
-            fi
-
-            COMPREPLY=( $( compgen -W "$helpopts $commands" -- "$cur" ) )
-
-            # Prevent space if an argument is desired
-            if [[ $COMPREPLY == *= ]]; then
-                compopt -o nospace
-            fi
-            return 0
-            ;;
-    esac
-} &&
-complete -F _bitcoin_cli bitcoin-cli
-
-# Local variables:
-# mode: shell-script
-# sh-basic-offset: 4
-# sh-indent-comment: t
-# indent-tabs-mode: nil
-# End:
-# ex: ts=4 sw=4 et filetype=sh
diff --git a/test/functional/data/completion/bitcoin-cli.header.bash-completion b/test/functional/data/completion/bitcoin-cli.header.bash-completion
deleted file mode 100644
index 875bb8da56..0000000000
--- a/test/functional/data/completion/bitcoin-cli.header.bash-completion
+++ /dev/null
@@ -1,29 +0,0 @@
-# Copyright (c) 2012-2024 The Bitcoin Core developers
-# Distributed under the MIT software license, see the accompanying
-# file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-# call $bitcoin-cli for RPC
-_bitcoin_rpc() {
-    # determine already specified args necessary for RPC
-    local rpcargs=()
-    for i in ${COMP_LINE}; do
-        case "$i" in
-            -conf=*|-datadir=*|-regtest|-rpc*|-testnet|-testnet4)
-                rpcargs=( "${rpcargs[@]}" "$i" )
-                ;;
-        esac
-    done
-    $bitcoin_cli "${rpcargs[@]}" "$@"
-}
-
-_bitcoin_cli() {
-    local cur prev words=() cword
-    local bitcoin_cli
-
-    # save and use original argument to invoke bitcoin-cli for -help, help and RPC
-    # as bitcoin-cli might not be in $PATH
-    bitcoin_cli="$1"
-
-    COMPREPLY=()
-    _get_comp_words_by_ref -n = cur prev words cword
-
diff --git a/test/functional/data/invalid_txs.py b/test/functional/data/invalid_txs.py
index d2d7202d86..2e4ca83bf0 100644
--- a/test/functional/data/invalid_txs.py
+++ b/test/functional/data/invalid_txs.py
@@ -263,17 +263,6 @@ def getDisabledOpcodeTemplate(opcode):
         'valid_in_block' : True
         })
 
-class NonStandardAndInvalid(BadTxTemplate):
-    """A non-standard transaction which is also consensus-invalid should return the consensus error."""
-    reject_reason = "mandatory-script-verify-flag-failed (OP_RETURN was encountered)"
-    expect_disconnect = True
-    valid_in_block = False
-
-    def get_tx(self):
-        return create_tx_with_script(
-            self.spend_tx, 0, script_sig=b'\x00' * 3 + b'\xab\x6a',
-            amount=(self.spend_avail // 2))
-
 # Disabled opcode tx templates (CVE-2010-5137)
 DisabledOpcodeTemplates = [getDisabledOpcodeTemplate(opcode) for opcode in [
     OP_CAT,
diff --git a/test/functional/feature_block.py b/test/functional/feature_block.py
index 1c74b860b6..384ca311c7 100755
--- a/test/functional/feature_block.py
+++ b/test/functional/feature_block.py
@@ -88,7 +88,6 @@ class FullBlockTest(BitcoinTestFramework):
         self.extra_args = [[
             '-acceptnonstdtxn=1',  # This is a consensus block test, we don't care about tx policy
             '-testactivationheight=bip34@2',
-            '-par=1', # Until https://github.com/bitcoin/bitcoin/issues/30960 is fixed
         ]]
 
     def run_test(self):
@@ -1266,7 +1265,7 @@ class FullBlockTest(BitcoinTestFramework):
         # Don't use v2transport for the large reorg, which is too slow with the unoptimized python ChaCha20 implementation
         if self.options.v2transport:
             self.nodes[0].disconnect_p2ps()
-            self.helper_peer = self.nodes[0].add_outbound_p2p_connection(P2PDataStore(), supports_v2_p2p=False, advertise_v2_p2p=False, p2p_idx=0)
+            self.helper_peer = self.nodes[0].add_p2p_connection(P2PDataStore(), supports_v2_p2p=False)
         self.log.info("Test a re-org of one week's worth of blocks (1088 blocks)")
 
         self.move_tip(88)
@@ -1413,7 +1412,7 @@ class FullBlockTest(BitcoinTestFramework):
         """Add a P2P connection to the node.
 
         Helper to connect and wait for version handshake."""
-        self.helper_peer = self.nodes[0].add_outbound_p2p_connection(P2PDataStore(), p2p_idx=0)
+        self.helper_peer = self.nodes[0].add_p2p_connection(P2PDataStore())
         # We need to wait for the initial getheaders from the peer before we
         # start populating our blockstore. If we don't, then we may run ahead
         # to the next subtest before we receive the getheaders. We'd then send
diff --git a/test/functional/feature_config_args.py b/test/functional/feature_config_args.py
index 08e3b38e07..bb20e2baa8 100755
--- a/test/functional/feature_config_args.py
+++ b/test/functional/feature_config_args.py
@@ -1,5 +1,5 @@
 #!/usr/bin/env python3
-# Copyright (c) 2017-present The Bitcoin Core developers
+# Copyright (c) 2017-2022 The Bitcoin Core developers
 # Distributed under the MIT software license, see the accompanying
 # file COPYING or http://www.opensource.org/licenses/mit-license.php.
 """Test various command line arguments and configuration file parameters."""
@@ -11,7 +11,6 @@ import re
 import tempfile
 import time
 
-from test_framework.netutil import UNREACHABLE_PROXY_ARG
 from test_framework.test_framework import BitcoinTestFramework
 from test_framework.test_node import ErrorMatch
 from test_framework import util
@@ -28,74 +27,9 @@ class ConfArgsTest(BitcoinTestFramework):
         self.wallet_names = []
         self.disable_autoconnect = False
 
-    # Overridden to avoid attempt to sync not yet started nodes.
-    def setup_network(self):
-        self.setup_nodes()
-
-    # Overridden to not start nodes automatically - doing so is the
-    # responsibility of each test function.
-    def setup_nodes(self):
-        self.add_nodes(self.num_nodes, self.extra_args)
-        # Ensure a log file exists as TestNode.assert_debug_log() expects it.
-        self.nodes[0].debug_log_path.parent.mkdir()
-        self.nodes[0].debug_log_path.touch()
-
-    def test_dir_config(self):
-        self.log.info('Error should be emitted if config file is a directory')
-        conf_path = self.nodes[0].datadir_path / 'bitcoin.conf'
-        os.rename(conf_path, conf_path.with_suffix('.confbkp'))
-        conf_path.mkdir()
-        self.stop_node(0)
-        self.nodes[0].assert_start_raises_init_error(
-            extra_args=['-regtest'],
-            expected_msg=f'Error: Error reading configuration file: Config file "{conf_path}" is a directory.',
-        )
-        conf_path.rmdir()
-        os.rename(conf_path.with_suffix('.confbkp'), conf_path)
-
-        self.log.debug('Verifying includeconf directive pointing to directory is caught')
-        with open(conf_path, 'a', encoding='utf-8') as conf:
-            conf.write(f'includeconf={self.nodes[0].datadir_path}\n')
-        self.nodes[0].assert_start_raises_init_error(
-            extra_args=['-regtest'],
-            expected_msg=f'Error: Error reading configuration file: Included config file "{self.nodes[0].datadir_path}" is a directory.',
-        )
-
-        self.nodes[0].replace_in_config([(f'includeconf={self.nodes[0].datadir_path}', '')])
-
-    def test_negated_config(self):
-        self.log.info('Disabling configuration via -noconf')
-
-        conf_path = self.nodes[0].datadir_path / 'bitcoin.conf'
-        with open(conf_path, encoding='utf-8') as conf:
-            settings = [f'-{line.rstrip()}' for line in conf if len(line) > 1 and line[0] != '[']
-        os.rename(conf_path, conf_path.with_suffix('.confbkp'))
-
-        self.log.debug('Verifying garbage in config can be detected')
-        with open(conf_path, 'a', encoding='utf-8') as conf:
-            conf.write(f'garbage\n')
-        self.nodes[0].assert_start_raises_init_error(
-            extra_args=['-regtest'],
-            expected_msg='Error: Error reading configuration file: parse error on line 1: garbage',
-        )
-
-        self.log.debug('Verifying that disabling of the config file means garbage inside of it does ' \
-            'not prevent the node from starting, and message about existing config file is logged')
-        ignored_file_message = [f'[InitConfig] Data directory "{self.nodes[0].datadir_path}" contains a "bitcoin.conf" file which is explicitly ignored using -noconf.']
-        with self.nodes[0].assert_debug_log(timeout=60, expected_msgs=ignored_file_message):
-            self.start_node(0, extra_args=settings + ['-noconf'])
-        self.stop_node(0)
-
-        self.log.debug('Verifying no message appears when removing config file')
-        os.remove(conf_path)
-        with self.nodes[0].assert_debug_log(timeout=60, expected_msgs=[], unexpected_msgs=ignored_file_message):
-            self.start_node(0, extra_args=settings + ['-noconf'])
-        self.stop_node(0)
-
-        os.rename(conf_path.with_suffix('.confbkp'), conf_path)
-
     def test_config_file_parser(self):
         self.log.info('Test config file parser')
+        self.stop_node(0)
 
         # Check that startup fails if conf= is set in bitcoin.conf or in an included conf file
         bad_conf_file_path = self.nodes[0].datadir_path / "bitcoin_bad.conf"
@@ -143,6 +77,9 @@ class ConfArgsTest(BitcoinTestFramework):
 
         main_conf_file_path = self.nodes[0].datadir_path / "bitcoin_main.conf"
         util.write_config(main_conf_file_path, n=0, chain='', extra_config=f'includeconf={inc_conf_file_path}\n')
+        with open(inc_conf_file_path, 'w', encoding='utf-8') as conf:
+            conf.write('acceptnonstdtxn=1\n')
+        self.nodes[0].assert_start_raises_init_error(extra_args=[f"-conf={main_conf_file_path}", "-allowignoredconf"], expected_msg='Error: acceptnonstdtxn is not currently supported for main chain')
 
         with open(inc_conf_file_path, 'w', encoding='utf-8') as conf:
             conf.write('nono\n')
@@ -218,11 +155,12 @@ class ConfArgsTest(BitcoinTestFramework):
         )
 
     def test_log_buffer(self):
-        with self.nodes[0].assert_debug_log(expected_msgs=['Warning: parsed potentially confusing double-negative -listen=0\n']):
-            self.start_node(0, extra_args=['-nolisten=0'])
         self.stop_node(0)
+        with self.nodes[0].assert_debug_log(expected_msgs=['Warning: parsed potentially confusing double-negative -connect=0\n']):
+            self.start_node(0, extra_args=['-noconnect=0'])
 
     def test_args_log(self):
+        self.stop_node(0)
         self.log.info('Test config args logging')
         with self.nodes[0].assert_debug_log(
                 expected_msgs=[
@@ -244,17 +182,17 @@ class ConfArgsTest(BitcoinTestFramework):
             self.start_node(0, extra_args=[
                 '-addnode=some.node',
                 '-rpcauth=alice:f7efda5c189b999524f151318c0c86$d5b51b3beffbc0',
+                '-rpcbind=127.1.1.1',
                 '-rpcbind=127.0.0.1',
                 "-rpcallowip=127.0.0.1",
                 '-rpcpassword=',
                 '-rpcuser=secret-rpcuser',
                 '-torpassword=secret-torpassword',
-                UNREACHABLE_PROXY_ARG,
             ])
-        self.stop_node(0)
 
     def test_networkactive(self):
         self.log.info('Test -networkactive option')
+        self.stop_node(0)
         with self.nodes[0].assert_debug_log(expected_msgs=['SetNetworkActive: true\n']):
             self.start_node(0)
 
@@ -277,12 +215,16 @@ class ConfArgsTest(BitcoinTestFramework):
         self.stop_node(0)
         with self.nodes[0].assert_debug_log(expected_msgs=['SetNetworkActive: false\n']):
             self.start_node(0, extra_args=['-nonetworkactive=1'])
-        self.stop_node(0)
 
     def test_seed_peers(self):
         self.log.info('Test seed peers')
         default_data_dir = self.nodes[0].datadir_path
         peer_dat = default_data_dir / 'peers.dat'
+        # Only regtest has no fixed seeds. To avoid connections to random
+        # nodes, regtest is the only network where it is safe to enable
+        # -fixedseeds in tests
+        util.assert_equal(self.nodes[0].getblockchaininfo()['chain'],'regtest')
+        self.stop_node(0)
 
         # No peers.dat exists and -dnsseed=1
         # We expect the node will use DNS Seeds, but Regtest mode does not have
@@ -298,13 +240,7 @@ class ConfArgsTest(BitcoinTestFramework):
                 ],
                 timeout=10,
         ):
-            self.start_node(0, extra_args=['-dnsseed=1', '-fixedseeds=1', f'-mocktime={start}', UNREACHABLE_PROXY_ARG])
-
-        # Only regtest has no fixed seeds. To avoid connections to random
-        # nodes, regtest is the only network where it is safe to enable
-        # -fixedseeds in tests
-        util.assert_equal(self.nodes[0].getblockchaininfo()['chain'],'regtest')
-
+            self.start_node(0, extra_args=['-dnsseed=1', '-fixedseeds=1', f'-mocktime={start}'])
         with self.nodes[0].assert_debug_log(expected_msgs=[
                 "Adding fixed seeds as 60 seconds have passed and addrman is empty",
         ]):
@@ -346,34 +282,34 @@ class ConfArgsTest(BitcoinTestFramework):
                 ],
                 timeout=10,
         ):
-            self.start_node(0, extra_args=['-dnsseed=0', '-fixedseeds=1', '-addnode=fakenodeaddr', f'-mocktime={start}', UNREACHABLE_PROXY_ARG])
+            self.start_node(0, extra_args=['-dnsseed=0', '-fixedseeds=1', '-addnode=fakenodeaddr', f'-mocktime={start}'])
         with self.nodes[0].assert_debug_log(expected_msgs=[
                 "Adding fixed seeds as 60 seconds have passed and addrman is empty",
         ]):
             self.nodes[0].setmocktime(start + 65)
-        self.stop_node(0)
 
     def test_connect_with_seednode(self):
         self.log.info('Test -connect with -seednode')
         seednode_ignored = ['-seednode is ignored when -connect is used\n']
         dnsseed_ignored = ['-dnsseed is ignored when -connect is used and -proxy is specified\n']
         addcon_thread_started = ['addcon thread start\n']
+        self.stop_node(0)
 
         # When -connect is supplied, expanding addrman via getaddr calls to ADDR_FETCH(-seednode)
         # nodes is irrelevant and -seednode is ignored.
         with self.nodes[0].assert_debug_log(expected_msgs=seednode_ignored):
-            self.start_node(0, extra_args=['-connect=fakeaddress1', '-seednode=fakeaddress2', UNREACHABLE_PROXY_ARG])
+            self.start_node(0, extra_args=['-connect=fakeaddress1', '-seednode=fakeaddress2'])
 
         # With -proxy, an ADDR_FETCH connection is made to a peer that the dns seed resolves to.
         # ADDR_FETCH connections are not used when -connect is used.
         with self.nodes[0].assert_debug_log(expected_msgs=dnsseed_ignored):
-            self.restart_node(0, extra_args=['-connect=fakeaddress1', '-dnsseed=1', UNREACHABLE_PROXY_ARG])
+            self.restart_node(0, extra_args=['-connect=fakeaddress1', '-dnsseed=1', '-proxy=1.2.3.4'])
 
         # If the user did not disable -dnsseed, but it was soft-disabled because they provided -connect,
         # they shouldn't see a warning about -dnsseed being ignored.
         with self.nodes[0].assert_debug_log(expected_msgs=addcon_thread_started,
                 unexpected_msgs=dnsseed_ignored):
-            self.restart_node(0, extra_args=['-connect=fakeaddress1', UNREACHABLE_PROXY_ARG])
+            self.restart_node(0, extra_args=['-connect=fakeaddress1', '-proxy=1.2.3.4'])
 
         # We have to supply expected_msgs as it's a required argument
         # The expected_msg must be something we are confident will be logged after the unexpected_msg
@@ -382,7 +318,6 @@ class ConfArgsTest(BitcoinTestFramework):
             with self.nodes[0].assert_debug_log(expected_msgs=addcon_thread_started,
                     unexpected_msgs=seednode_ignored):
                 self.restart_node(0, extra_args=[connect_arg, '-seednode=fakeaddress2'])
-        self.stop_node(0)
 
     def test_ignored_conf(self):
         self.log.info('Test error is triggered when the datadir in use contains a bitcoin.conf file that would be ignored '
@@ -481,13 +416,12 @@ class ConfArgsTest(BitcoinTestFramework):
         self.test_networkactive()
         self.test_connect_with_seednode()
 
-        self.test_dir_config()
-        self.test_negated_config()
         self.test_config_file_parser()
         self.test_config_file_log()
         self.test_invalid_command_line_options()
         self.test_ignored_conf()
         self.test_ignored_default_conf()
+        self.test_acceptstalefeeestimates_arg_support()
         self.test_testnet3_deprecation_msg()
 
         # Remove the -datadir argument so it doesn't override the config file
diff --git a/test/functional/feature_fee_estimates_persist.py b/test/functional/feature_fee_estimates_persist.py
deleted file mode 100755
index 0977eb0272..0000000000
--- a/test/functional/feature_fee_estimates_persist.py
+++ /dev/null
@@ -1,54 +0,0 @@
-#!/usr/bin/env python3
-# Copyright (c) 2014-2021 The Bitcoin Core developers
-# Distributed under the MIT software license, see the accompanying
-# file COPYING or http://www.opensource.org/licenses/mit-license.php.
-"""Test fee estimates persistence.
-
-By default, bitcoind will dump fee estimates on shutdown and
-then reload it on startup.
-
-Test is as follows:
-
-  - start node0
-  - call the savefeeestimates RPC and verify the RPC succeeds and
-    that the file exists
-  - make the file read only and attempt to call the savefeeestimates RPC
-    with the expecation that it will fail
-  - move the read only file and shut down the node, verify the node writes
-    on shutdown a file that is identical to the one we saved via the RPC
-
-"""
-
-import filecmp
-import os
-
-from test_framework.test_framework import BitcoinTestFramework
-from test_framework.util import assert_raises_rpc_error
-
-
-class FeeEstimatesPersistTest(BitcoinTestFramework):
-    def set_test_params(self):
-        self.num_nodes = 1
-
-    def run_test(self):
-        fee_estimatesdat = os.path.join(self.nodes[0].chain_path, 'fee_estimates.dat')
-        self.log.debug('Verify the fee_estimates.dat file does not exists on start up')
-        assert not os.path.isfile(fee_estimatesdat)
-        self.nodes[0].savefeeestimates()
-        self.log.debug('Verify the fee_estimates.dat file exists after calling savefeeestimates RPC')
-        assert os.path.isfile(fee_estimatesdat)
-        self.log.debug("Prevent bitcoind from writing fee_estimates.dat to disk. Verify that `savefeeestimates` fails")
-        fee_estimatesdatold = fee_estimatesdat + '.old'
-        os.rename(fee_estimatesdat, fee_estimatesdatold)
-        os.mkdir(fee_estimatesdat)
-        assert_raises_rpc_error(-1, "Unable to dump fee estimates to disk", self.nodes[0].savefeeestimates)
-        os.rmdir(fee_estimatesdat)
-        self.stop_nodes()
-        self.log.debug("Verify that fee_estimates are written on shutdown")
-        assert os.path.isfile(fee_estimatesdat)
-        self.log.debug("Verify that the fee estimates from a shutdown are identical from the ones from savefeeestimates")
-        assert filecmp.cmp(fee_estimatesdat, fee_estimatesdatold)
-
-
-if __name__ == "__main__":
-    FeeEstimatesPersistTest(__file__).main()
diff --git a/test/functional/feature_fee_estimation.py b/test/functional/feature_fee_estimation.py
index 5c2c261fb5..34b0fe890b 100755
--- a/test/functional/feature_fee_estimation.py
+++ b/test/functional/feature_fee_estimation.py
@@ -5,12 +5,9 @@
 """Test fee estimation code."""
 from copy import deepcopy
 from decimal import Decimal
-import http.client
-import json
 import os
 import random
 import time
-import urllib.parse
 
 from test_framework.messages import (
     COIN,
@@ -27,7 +24,6 @@ from test_framework.wallet import MiniWallet
 
 MAX_FILE_AGE = 60
 SECONDS_PER_HOUR = 60 * 60
-target_success_threshold = 0.8
 
 def small_txpuzzle_randfee(
     wallet, from_node, conflist, unconflist, amount, min_fee, fee_increment, batch_reqs
@@ -75,22 +71,6 @@ def small_txpuzzle_randfee(
     return (tx.get_vsize(), fee)
 
 
-def rest_getfee(url, mode, target, status=200):
-    rest_uri = '/rest/fee/%s/%s.json' % (mode, target)
-
-    url = urllib.parse.urlparse(url)
-    conn = http.client.HTTPConnection(url.hostname, url.port)
-    conn.request('GET', rest_uri)
-    resp = conn.getresponse()
-    data = resp.read()
-
-    assert_equal(resp.status, status)
-
-    if status == 200:
-        return json.loads(data.decode('utf-8'), parse_float=Decimal)
-    else:
-        return data
-
 def check_raw_estimates(node, fees_seen):
     """Call estimaterawfee and verify that the estimates meet certain invariants."""
 
@@ -115,8 +95,6 @@ def check_smart_estimates(node, fees_seen):
     mempoolMinFee = node.getmempoolinfo()["mempoolminfee"]
     minRelaytxFee = node.getmempoolinfo()["minrelaytxfee"]
     for i, e in enumerate(all_smart_estimates):  # estimate is for i+1
-        assert_equal(e, rest_getfee(node.url, 'unset', i+1))
-
         feerate = float(e["feerate"])
         assert_greater_than(feerate, 0)
         assert_greater_than_or_equal(feerate, float(mempoolMinFee))
@@ -157,22 +135,6 @@ def check_fee_estimates_btw_modes(node, expected_conservative, expected_economic
     assert_equal(fee_est_conservative, expected_conservative)
     assert_equal(fee_est_economical, expected_economical)
     assert_equal(fee_est_default, expected_economical)
-    assert_equal(fee_est_conservative, rest_getfee(node.url, 'conservative', 1)['feerate'])
-    assert_equal(fee_est_economical, rest_getfee(node.url, 'economical', 1)['feerate'])
-    assert_equal(fee_est_default, rest_getfee(node.url, 'unset', 1)['feerate'])
-
-
-def get_feerate_into_mempool(node, kB):
-    mempool_entries = list(node.getrawmempool(verbose=True).values())
-    for entry in mempool_entries:
-        entry['feerate_BTC/vB'] = entry['fees']['modified'] / entry['vsize']
-    mempool_entries.sort(key=lambda entry: entry['feerate_BTC/vB'], reverse=True)
-    bytes_remaining = kB * 1000
-    for entry in mempool_entries:
-        bytes_remaining -= entry['vsize']
-        if bytes_remaining <= 0:
-            return satoshi_round(entry['feerate_BTC/vB'] * 1000)
-    raise AssertionError('Entire mempool is smaller than %s kB' % (kB,))
 
 
 class EstimateFeeTest(BitcoinTestFramework):
@@ -181,8 +143,8 @@ class EstimateFeeTest(BitcoinTestFramework):
         # whitelist peers to speed up tx relay / mempool sync
         self.noban_tx_relay = True
         self.extra_args = [
-            ['-rest'],
-            ["-blockmaxweight=68000", "-rest"],
+            [],
+            ["-blockmaxweight=68000"],
             ["-blockmaxweight=32000"],
         ]
 
@@ -275,66 +237,9 @@ class EstimateFeeTest(BitcoinTestFramework):
         self.log.info("Final estimates after emptying mempools")
         check_estimates(self.nodes[1], self.fees_per_kb)
 
-    def test_feerate_dustrelayfee_common(self, node, multiplier, dust_mode, desc, expected_base):
-        dust_parameter = f"-dustdynamic={dust_mode}".replace('=3*', '=')
-        self.log.info(f"Test dust limit setting {dust_parameter} (fee estimation for {desc})")
-        self.restart_node(0, extra_args=[dust_parameter])
-        assert_equal(node.getmempoolinfo()['dustdynamic'], dust_mode)
-        with node.busy_wait_for_debug_log([b'Updating dust feerate']):
-            node.mockscheduler(SECONDS_PER_HOUR)
-        mempool_info = node.getmempoolinfo()
-        assert_equal(mempool_info['dustrelayfee'], satoshi_round(expected_base() * multiplier))
-        assert mempool_info['dustrelayfee'] > mempool_info['dustrelayfeefloor']
-
-    def test_feerate_dustrelayfee_target(self, node, multiplier, dustfee_target):
-        dust_mode = f"{multiplier}*target:{dustfee_target}"
-        self.test_feerate_dustrelayfee_common(node, multiplier, dust_mode, f'{dustfee_target} blocks', lambda: node.estimaterawfee(dustfee_target, target_success_threshold)['long']['feerate'])
-
-    def test_feerate_dustrelayfee_mempool(self, node, multiplier, dustfee_kB):
-        dust_mode = f"{multiplier}*mempool:{dustfee_kB}"
-        self.test_feerate_dustrelayfee_common(node, multiplier, dust_mode, f'{dustfee_kB} kB into mempool', lambda: get_feerate_into_mempool(node, dustfee_kB))
-
-    def test_feerate_dustrelayfee(self):
-        node = self.nodes[0]
-
-        # test dustdynamic=target:<blocks>
-        for dustfee_target in (2, 8, 1008):
-            for multiplier in (Decimal('0.5'), 1, 3, Decimal('3.3'), 10, Decimal('10.001')):
-                self.test_feerate_dustrelayfee_target(node, multiplier, dustfee_target)
-
-        # Fill mempool up
-        mempool_size = 0
-        batch_sendtx_reqs = []
-        min_fee = Decimal("0.00001")
-        while mempool_size < 52000:
-            (tx_bytes, fee) = small_txpuzzle_randfee(
-                self.wallet,
-                self.nodes[0],
-                self.confutxo,
-                self.memutxo,
-                Decimal("0.005"),
-                min_fee,
-                min_fee,
-                batch_sendtx_reqs,
-            )
-            mempool_size += tx_bytes
-        node.batch(batch_sendtx_reqs)
-
-        # test dustdynamic=mempool:<kB>
-        for dustfee_kB in (1, 10, 50):
-            for multiplier in (Decimal('0.5'), 1, 3, Decimal('3.3'), 10, Decimal('10.001')):
-                self.test_feerate_dustrelayfee_mempool(node, multiplier, dustfee_kB)
-
-        # Restore nodes to a normal state, wiping the mempool
-        self.stop_node(0)
-        (self.nodes[0].chain_path / 'mempool.dat').unlink()
-        self.start_node(0)
-        self.connect_nodes(1, 0)
-        self.connect_nodes(0, 2)
-
     def test_feerate_mempoolminfee(self):
         high_val = 3 * self.nodes[1].estimatesmartfee(1)["feerate"]
-        self.restart_node(1, extra_args=[f"-minrelaytxfee={high_val}", '-rest'])
+        self.restart_node(1, extra_args=[f"-minrelaytxfee={high_val}"])
         check_estimates(self.nodes[1], self.fees_per_kb)
         self.restart_node(1)
 
@@ -546,8 +451,6 @@ class EstimateFeeTest(BitcoinTestFramework):
         self.log.info("Test fee_estimates.dat is flushed periodically")
         self.test_estimate_dat_is_flushed_periodically()
 
-        self.test_feerate_dustrelayfee()
-
         # check that the effective feerate is greater than or equal to the mempoolminfee even for high mempoolminfee
         self.log.info(
             "Test fee rate estimation after restarting node with high MempoolMinFee"
@@ -575,13 +478,6 @@ class EstimateFeeTest(BitcoinTestFramework):
             -32603, "Fee estimation disabled", self.nodes[0].estimatesmartfee, 2
         )
 
-        self.log.info("Bad REST requests")
-        assert rest_getfee(self.nodes[1].url, 'foobar', 2, 400).startswith(b'<MODE> must be one of <unset|economical|conservative>')
-        assert rest_getfee(self.nodes[1].url, 'conservative', -1, 400).startswith(b'Unable to parse confirmation target to int')
-        assert rest_getfee(self.nodes[1].url, 'conservative', 'abc', 400).startswith(b'Unable to parse confirmation target to int')
-        assert rest_getfee(self.nodes[1].url, 'conservative', 2**65, 400).startswith(b'Unable to parse confirmation target to int')
-        assert rest_getfee(self.nodes[1].url, 'conservative', 0, 400).startswith(b'Invalid confirmation target, must be in between ')
-
 
 if __name__ == "__main__":
     EstimateFeeTest(__file__).main()
diff --git a/test/functional/feature_filelock.py b/test/functional/feature_filelock.py
index c1f7e04276..e71871114d 100755
--- a/test/functional/feature_filelock.py
+++ b/test/functional/feature_filelock.py
@@ -25,17 +25,11 @@ class FilelockTest(BitcoinTestFramework):
     def run_test(self):
         datadir = self.nodes[0].chain_path
         self.log.info(f"Using datadir {datadir}")
-        blocksdir = self.nodes[0].blocks_path
-        self.log.info(f"Using blocksdir {blocksdir}")
 
         self.log.info("Check that we can't start a second bitcoind instance using the same datadir")
         expected_msg = f"Error: Cannot obtain a lock on data directory {datadir}. {self.config['environment']['PACKAGE_NAME']} is probably already running."
         self.nodes[1].assert_start_raises_init_error(extra_args=[f'-datadir={self.nodes[0].datadir_path}', '-noserver'], expected_msg=expected_msg)
 
-        self.log.info("Check that we can't start a second bitcoind instance using the same blocksdir")
-        expected_msg = f"Error: Cannot obtain a lock on data directory {blocksdir}. {self.config['environment']['PACKAGE_NAME']} is probably already running."
-        self.nodes[1].assert_start_raises_init_error(extra_args=[f'-blocksdir={self.nodes[0].datadir_path}', '-noserver'], expected_msg=expected_msg)
-
         self.log.info("Check that cookie and PID file are not deleted when attempting to start a second bitcoind using the same datadir")
         cookie_file = datadir / ".cookie"
         assert cookie_file.exists()  # should not be deleted during the second bitcoind instance shutdown
diff --git a/test/functional/feature_includeconf.py b/test/functional/feature_includeconf.py
index 4a9c9ccebe..ee484e7ec5 100755
--- a/test/functional/feature_includeconf.py
+++ b/test/functional/feature_includeconf.py
@@ -36,7 +36,7 @@ class IncludeConfTest(BitcoinTestFramework):
         self.log.info("-includeconf works from config file. subversion should end with 'main; relative)/'")
 
         subversion = self.nodes[0].getnetworkinfo()["subversion"]
-        assert "main; relative)" in subversion
+        assert subversion.endswith("main; relative)/")
 
         self.log.info("-includeconf cannot be used as command-line arg")
         self.stop_node(0)
@@ -55,7 +55,7 @@ class IncludeConfTest(BitcoinTestFramework):
         self.start_node(0)
 
         subversion = self.nodes[0].getnetworkinfo()["subversion"]
-        assert "main; relative)" in subversion
+        assert subversion.endswith("main; relative)/")
         self.stop_node(0, expected_stderr="warning: -includeconf cannot be used from included files; ignoring -includeconf=relative2.conf")
 
         self.log.info("-includeconf cannot contain invalid arg")
@@ -80,7 +80,7 @@ class IncludeConfTest(BitcoinTestFramework):
         self.start_node(0)
 
         subversion = self.nodes[0].getnetworkinfo()["subversion"]
-        assert "main; relative; relative2)" in subversion
+        assert subversion.endswith("main; relative; relative2)/")
 
 if __name__ == '__main__':
     IncludeConfTest(__file__).main()
diff --git a/test/functional/feature_index_prune.py b/test/functional/feature_index_prune.py
index 063aa7978d..030bf51ed8 100755
--- a/test/functional/feature_index_prune.py
+++ b/test/functional/feature_index_prune.py
@@ -70,7 +70,7 @@ class FeatureIndexPruneTest(BitcoinTestFramework):
 
         self.log.info("prune some blocks")
         for node in self.nodes[:2]:
-            with node.assert_debug_log(['Prune: UnlinkPrunedFiles deleted blk/rev (00000)']):
+            with node.assert_debug_log(['limited pruning to height 689']):
                 pruneheight_new = node.pruneblockchain(400)
                 # the prune heights used here and below are magic numbers that are determined by the
                 # thresholds at which block files wrap, so they depend on disk serialization and default block file size.
@@ -143,7 +143,7 @@ class FeatureIndexPruneTest(BitcoinTestFramework):
         self.sync_index(height=2500)
 
         for node in self.nodes[:2]:
-            with node.assert_debug_log(['Prune: UnlinkPrunedFiles deleted blk/rev (00007)']):
+            with node.assert_debug_log(['limited pruning to height 2489']):
                 pruneheight_new = node.pruneblockchain(2500)
                 assert_equal(pruneheight_new, 2005)
 
diff --git a/test/functional/feature_notifications.py b/test/functional/feature_notifications.py
index da6e1edc8a..79e8df4b5e 100755
--- a/test/functional/feature_notifications.py
+++ b/test/functional/feature_notifications.py
@@ -15,13 +15,13 @@ from test_framework.util import (
 
 # Linux allow all characters other than \x00
 # Windows disallow control characters (0-31) and /\?%:|"<>
-FILE_CHAR_START = 43 if platform.system() == 'Windows' else 1
+FILE_CHAR_START = 32 if platform.system() == 'Windows' else 1
 FILE_CHAR_END = 128
-FILE_CHARS_DISALLOWED = '/:;<>?@[\\]^`{|}' if platform.system() == 'Windows' else '/'
+FILE_CHARS_DISALLOWED = '/\\?%*:|"<>' if platform.system() == 'Windows' else '/'
 UNCONFIRMED_HASH_STRING = 'unconfirmed'
 
 def notify_outputname(walletname, txid):
-    return f'{walletname}_{txid}'
+    return txid if platform.system() == 'Windows' else f'{walletname}_{txid}'
 
 
 class NotificationsTest(BitcoinTestFramework):
@@ -33,7 +33,7 @@ class NotificationsTest(BitcoinTestFramework):
         self.setup_clean_chain = True
 
     def setup_network(self):
-        self.wallet = 'wallet' + ''.join(chr(i) for i in range(FILE_CHAR_START, FILE_CHAR_END) if chr(i) not in FILE_CHARS_DISALLOWED)
+        self.wallet = ''.join(chr(i) for i in range(FILE_CHAR_START, FILE_CHAR_END) if chr(i) not in FILE_CHARS_DISALLOWED)
         self.alertnotify_dir = os.path.join(self.options.tmpdir, "alertnotify")
         self.blocknotify_dir = os.path.join(self.options.tmpdir, "blocknotify")
         self.walletnotify_dir = os.path.join(self.options.tmpdir, "walletnotify")
@@ -50,7 +50,6 @@ class NotificationsTest(BitcoinTestFramework):
             f"-blocknotify=echo > {os.path.join(self.blocknotify_dir, '%s')}",
             f"-shutdownnotify=echo > {self.shutdownnotify_file}",
         ], [
-            "-blockversion=211",
             f"-walletnotify=echo %h_%b > {os.path.join(self.walletnotify_dir, notify_outputname('%w', '%s'))}",
         ]]
         self.wallet_names = [self.default_wallet_name, self.wallet]
@@ -165,22 +164,6 @@ class NotificationsTest(BitcoinTestFramework):
 
         # TODO: add test for `-alertnotify` large fork notifications
 
-        # Mine 51 unknown-version blocks. -alertnotify should trigger on the 51st.
-        self.log.info("test -alertnotify")
-        self.generatetoaddress(self.nodes[1], 51, ADDRESS_BCRT1_UNSPENDABLE)
-
-        # Give bitcoind 10 seconds to write the alert notification
-        self.wait_until(lambda: len(os.listdir(self.alertnotify_dir)), timeout=10)
-
-        for notify_file in os.listdir(self.alertnotify_dir):
-            os.remove(os.path.join(self.alertnotify_dir, notify_file))
-
-        # Mine more up-version blocks, should not get more alerts:
-        self.generatetoaddress(self.nodes[1], 2, ADDRESS_BCRT1_UNSPENDABLE)
-
-        self.log.info("-alertnotify should not continue notifying for more unknown version blocks")
-        assert_equal(len(os.listdir(self.alertnotify_dir)), 0)
-
         self.log.info("test -shutdownnotify")
         self.stop_nodes()
         self.wait_until(lambda: os.path.isfile(self.shutdownnotify_file), timeout=10)
diff --git a/test/functional/feature_pruning.py b/test/functional/feature_pruning.py
index 5cedf2a78f..8d924282cf 100755
--- a/test/functional/feature_pruning.py
+++ b/test/functional/feature_pruning.py
@@ -325,17 +325,6 @@ class PruneTest(BitcoinTestFramework):
         node.pruneblockchain(height(0))
         assert has_block(0), "blk00000.dat is missing when should still be there"
 
-        # height=500 shouldn't prune first file if there's a prune lock
-        node.setprunelock("test", {
-            "desc": "Testing",
-            "height": [2, 2],
-        })
-        assert_equal(node.listprunelocks(), {'prune_locks': [{'id': 'test', 'desc': 'Testing', 'height': [2, 2], 'temporary': False}]})
-        prune(500)
-        assert has_block(0), "blk00000.dat is missing when should still be there"
-        node.setprunelock("test", {})  # delete prune lock
-        assert_equal(node.listprunelocks(), {'prune_locks': []})
-
         # height=500 should prune first file
         prune(500)
         assert not has_block(0), "blk00000.dat is still there, should be pruned by now"
diff --git a/test/functional/feature_rbf.py b/test/functional/feature_rbf.py
index 1bc77d71e5..b660b96935 100755
--- a/test/functional/feature_rbf.py
+++ b/test/functional/feature_rbf.py
@@ -25,7 +25,7 @@ class ReplaceByFeeTest(BitcoinTestFramework):
         self.add_wallet_options(parser)
 
     def set_test_params(self):
-        self.num_nodes = 4
+        self.num_nodes = 2
         # both nodes disable full-rbf to test BIP125 signaling
         self.extra_args = [
             [
@@ -34,47 +34,17 @@ class ReplaceByFeeTest(BitcoinTestFramework):
                 "-limitancestorsize=101",
                 "-limitdescendantcount=200",
                 "-limitdescendantsize=101",
-                "-mempooltruc=accept",
-                "-paytxfee=0.00001",  # this test confuses the fee estimator into nearly 1 BTC fees
             ],
             # second node has default mempool parameters, besides mempoolfullrbf being disabled
             [
                 "-mempoolfullrbf=0",
             ],
-            [
-                "-acceptnonstdtxn=1",
-                "-mempoolreplacement=0",
-            ],
         ]
-        self.extra_args.append(
-            [
-                *self.extra_args[0],
-                "-mempoolreplacement=fee,-optin",
-            ],
-        )
         self.supports_cli = False
 
     def run_test(self):
         self.wallet = MiniWallet(self.nodes[0])
 
-        self.log.info("Running test RPC rbf_policy")
-        def test_rpc_rbf_policy():
-            assert_equal(self.nodes[0].getmempoolinfo()["rbf_policy"], 'optin')
-            assert_equal(self.nodes[1].getmempoolinfo()["rbf_policy"], 'optin')
-            assert_equal(self.nodes[2].getmempoolinfo()["rbf_policy"], 'never')
-            assert_equal(self.nodes[3].getmempoolinfo()["rbf_policy"], 'always')
-        test_rpc_rbf_policy()
-
-        self.log.info("Running test service flag")
-        def test_service_flag():
-            NODE_REPLACE_BY_FEE = (1 << 26)
-            for i in range(3):
-                assert not (int(self.nodes[i].getnetworkinfo()['localservices'], 0x10) & NODE_REPLACE_BY_FEE)
-                assert 'REPLACE_BY_FEE?' not in self.nodes[i].getnetworkinfo()['localservicesnames']
-            assert int(self.nodes[3].getnetworkinfo()['localservices'], 0x10) & NODE_REPLACE_BY_FEE
-            assert 'REPLACE_BY_FEE?' in self.nodes[3].getnetworkinfo()['localservicesnames']
-        test_service_flag()
-
         self.log.info("Running test simple doublespend...")
         self.test_simple_doublespend()
 
@@ -100,12 +70,7 @@ class ReplaceByFeeTest(BitcoinTestFramework):
         self.test_too_many_replacements_with_default_mempool_params()
 
         self.log.info("Running test opt-in...")
-        self.test_opt_in(fullrbf=False)
-        self.test_opt_in(fullrbf=False, use_truc=True)
-        self.nodes[0], self.nodes[-1] = self.nodes[-1], self.nodes[0]
-        self.test_opt_in(fullrbf=True)
-        self.test_opt_in(fullrbf=True, use_truc=True)
-        self.nodes[0], self.nodes[-1] = self.nodes[-1], self.nodes[0]
+        self.test_opt_in()
 
         self.log.info("Running test RPC...")
         self.test_rpc()
@@ -149,24 +114,17 @@ class ReplaceByFeeTest(BitcoinTestFramework):
         # we use MiniWallet to create a transaction template with inputs correctly set,
         # and modify the output (amount, scriptPubKey) according to our needs
         tx = self.wallet.create_self_transfer()["tx"]
-        tx1a_hex = tx.serialize().hex()
-        tx1a_txid = self.nodes[0].sendrawtransaction(tx1a_hex)
-        assert_equal(tx1a_txid, self.nodes[2].sendrawtransaction(tx1a_hex))
+        tx1a_txid = self.nodes[0].sendrawtransaction(tx.serialize().hex())
 
         # Should fail because we haven't changed the fee
         tx.vout[0].scriptPubKey[-1] ^= 1
 
         # This will raise an exception due to insufficient fee
-        tx1b_hex = tx.serialize().hex()
-        assert_raises_rpc_error(-26, "insufficient fee", self.nodes[0].sendrawtransaction, tx1b_hex, 0)
-        # This will raise an exception due to transaction replacement being disabled
-        assert_raises_rpc_error(-26, "txn-mempool-conflict", self.nodes[2].sendrawtransaction, tx1b_hex, 0)
+        assert_raises_rpc_error(-26, "insufficient fee", self.nodes[0].sendrawtransaction, tx.serialize().hex(), 0)
 
         # Extra 0.1 BTC fee
         tx.vout[0].nValue -= int(0.1 * COIN)
         tx1b_hex = tx.serialize().hex()
-        # Replacement still disabled even with "enough fee"
-        assert_raises_rpc_error(-26, "txn-mempool-conflict", self.nodes[2].sendrawtransaction, tx1b_hex, 0)
         # Works when enabled
         tx1b_txid = self.nodes[0].sendrawtransaction(tx1b_hex, 0)
 
@@ -177,11 +135,6 @@ class ReplaceByFeeTest(BitcoinTestFramework):
 
         assert_equal(tx1b_hex, self.nodes[0].getrawtransaction(tx1b_txid))
 
-        # Third node is running mempoolreplacement=0, will not replace originally-seen txn
-        mempool = self.nodes[2].getrawmempool()
-        assert tx1a_txid in mempool
-        assert tx1b_txid not in mempool
-
     def test_doublespend_chain(self):
         """Doublespend of a long chain"""
 
@@ -517,7 +470,7 @@ class ReplaceByFeeTest(BitcoinTestFramework):
         self.generate(normal_node, 1)
         self.wallet.rescan_utxos()
 
-    def test_opt_in(self, fullrbf, use_truc=False):
+    def test_opt_in(self):
         """Replacing should only work if orig tx opted in"""
         tx0_outpoint = self.make_utxo(self.nodes[0], int(1.1 * COIN))
 
@@ -533,19 +486,14 @@ class ReplaceByFeeTest(BitcoinTestFramework):
         assert_equal(self.nodes[0].getmempoolentry(tx1a_utxo["txid"])['bip125-replaceable'], False)
 
         # Shouldn't be able to double-spend
-        tx1b_st = self.wallet.create_self_transfer(
+        tx1b_hex = self.wallet.create_self_transfer(
             utxo_to_spend=tx0_outpoint,
             sequence=0,
             fee=Decimal("0.2"),
-        )
-        tx1b_hex = tx1b_st["hex"]
+        )["hex"]
 
-        if fullrbf:
-            self.nodes[0].sendrawtransaction(tx1b_hex, 0)
-            tx1a_utxo = tx1b_st["new_utxo"]
-        else:
-            # This will raise an exception
-            assert_raises_rpc_error(-26, "txn-mempool-conflict", self.nodes[0].sendrawtransaction, tx1b_hex, 0)
+        # This will raise an exception
+        assert_raises_rpc_error(-26, "txn-mempool-conflict", self.nodes[0].sendrawtransaction, tx1b_hex, 0)
 
         tx1_outpoint = self.make_utxo(self.nodes[0], int(1.1 * COIN))
 
@@ -558,42 +506,28 @@ class ReplaceByFeeTest(BitcoinTestFramework):
         )["new_utxo"]
 
         # Still shouldn't be able to double-spend
-        tx2b_st = self.wallet.create_self_transfer(
+        tx2b_hex = self.wallet.create_self_transfer(
             utxo_to_spend=tx1_outpoint,
             sequence=0,
             fee=Decimal("0.2"),
-        )
-        tx2b_hex = tx2b_st["hex"]
+        )["hex"]
 
-        if fullrbf:
-            self.nodes[0].sendrawtransaction(tx2b_hex, 0)
-            tx2a_utxo = tx2b_st["new_utxo"]
-        else:
-            # This will raise an exception
-            assert_raises_rpc_error(-26, "txn-mempool-conflict", self.nodes[0].sendrawtransaction, tx2b_hex, 0)
+        # This will raise an exception
+        assert_raises_rpc_error(-26, "txn-mempool-conflict", self.nodes[0].sendrawtransaction, tx2b_hex, 0)
 
         # Now create a new transaction that spends from tx1a and tx2a
         # opt-in on one of the inputs
         # Transaction should be replaceable on either input
 
-        self.generate(self.nodes[0], 1)  # clean mempool so parent txs don't trigger BIP125
-        if use_truc:
-            kwargs = {'sequence': SEQUENCE_FINAL, 'version': 3}
-        else:
-            kwargs = {'sequence': [SEQUENCE_FINAL, 0xfffffffd]}
-
         tx3a_txid = self.wallet.send_self_transfer_multi(
             from_node=self.nodes[0],
             utxos_to_spend=[tx1a_utxo, tx2a_utxo],
+            sequence=[SEQUENCE_FINAL, 0xfffffffd],
             fee_per_output=int(0.1 * COIN),
-            **kwargs
         )["txid"]
 
         # This transaction is shown as replaceable
-        if use_truc:
-            assert_equal(self.nodes[0].getmempoolentry(tx3a_txid)['bip125-replaceable'], False)
-        else:
-            assert_equal(self.nodes[0].getmempoolentry(tx3a_txid)['bip125-replaceable'], True)
+        assert_equal(self.nodes[0].getmempoolentry(tx3a_txid)['bip125-replaceable'], True)
 
         self.wallet.send_self_transfer(
             from_node=self.nodes[0],
@@ -611,8 +545,6 @@ class ReplaceByFeeTest(BitcoinTestFramework):
             fee=Decimal("0.4"),
         )
 
-        self.generate(self.nodes[0], 1)  # clean mempool
-
     def test_prioritised_transactions(self):
         # Ensure that fee deltas used via prioritisetransaction are
         # correctly used by replacement logic
@@ -774,7 +706,6 @@ class ReplaceByFeeTest(BitcoinTestFramework):
         confirmed_utxo = self.make_utxo(self.nodes[0], int(2 * COIN))
         self.restart_node(0, extra_args=["-mempoolfullrbf=1"])
         assert self.nodes[0].getmempoolinfo()["fullrbf"]
-        assert_equal(self.nodes[0].getmempoolinfo()["rbf_policy"], 'always')
 
         # Create an explicitly opt-out transaction
         optout_tx = self.wallet.send_self_transfer(
diff --git a/test/functional/feature_segwit.py b/test/functional/feature_segwit.py
index a3995673ed..f98f326e8f 100755
--- a/test/functional/feature_segwit.py
+++ b/test/functional/feature_segwit.py
@@ -43,7 +43,6 @@ from test_framework.script_util import (
 )
 from test_framework.test_framework import BitcoinTestFramework
 from test_framework.util import (
-    assert_approx,
     assert_equal,
     assert_greater_than_or_equal,
     assert_is_hex_string,
@@ -267,8 +266,7 @@ class SegWitTest(BitcoinTestFramework):
         tx1_hex = self.nodes[0].gettransaction(txid1)['hex']
         tx1 = tx_from_hex(tx1_hex)
 
-        # Check that hash and wtxid are properly reported in mempool entry (txid1)
-        assert_equal(int(self.nodes[0].getmempoolentry(txid1)["hash"], 16), tx1.calc_sha256(True))
+        # Check that wtxid is properly reported in mempool entry (txid1)
         assert_equal(int(self.nodes[0].getmempoolentry(txid1)["wtxid"], 16), tx1.calc_sha256(True))
 
         # Check that weight and vsize are properly reported in mempool entry (txid1)
@@ -284,8 +282,7 @@ class SegWitTest(BitcoinTestFramework):
         tx = tx_from_hex(tx2_hex)
         assert not tx.wit.is_null()
 
-        # Check that hash and wtxid are properly reported in mempool entry (txid2)
-        assert_equal(int(self.nodes[0].getmempoolentry(txid2)["hash"], 16), tx.calc_sha256(True))
+        # Check that wtxid is properly reported in mempool entry (txid2)
         assert_equal(int(self.nodes[0].getmempoolentry(txid2)["wtxid"], 16), tx.calc_sha256(True))
 
         # Check that weight and vsize are properly reported in mempool entry (txid2)
@@ -308,8 +305,7 @@ class SegWitTest(BitcoinTestFramework):
         assert txid2 in template_txids
         assert txid3 in template_txids
 
-        # Check that hash and wtxid are properly reported in mempool entry (txid3)
-        assert_equal(int(self.nodes[0].getmempoolentry(txid3)["hash"], 16), tx.calc_sha256(True))
+        # Check that wtxid is properly reported in mempool entry (txid3)
         assert_equal(int(self.nodes[0].getmempoolentry(txid3)["wtxid"], 16), tx.calc_sha256(True))
 
         # Check that weight and vsize are properly reported in mempool entry (txid3)
@@ -319,32 +315,6 @@ class SegWitTest(BitcoinTestFramework):
         # Mine a block to clear the gbt cache again.
         self.generate(self.nodes[0], 1)
 
-        self.log.info("Signing with all-segwit inputs reveals fee rate")
-        addr = self.nodes[0].getnewaddress(address_type='p2sh-segwit')
-        txid = self.nodes[0].sendtoaddress(addr, 1)
-        tx = self.nodes[0].getrawtransaction(txid, True)
-        n = -1
-        value = -1
-        for o in tx["vout"]:
-            if o["scriptPubKey"]["address"] == addr:
-                n = o["n"]
-                value = Decimal(o["value"])
-                break
-        assert n > -1 # failure means we could not find the address in the outputs despite sending to it
-        assert_equal(value, 1) # failure means we got an unexpected amount of coins, despite trying to send 1
-        fee = Decimal("0.00010000")
-        value_out = value - fee
-        self.generatetoaddress(self.nodes[0], 1, self.nodes[0].getnewaddress())
-        raw = self.nodes[0].createrawtransaction([{"txid" : txid, "vout" : n}], [{self.nodes[0].getnewaddress() : value_out}])
-        signed = self.nodes[0].signrawtransactionwithwallet(raw)
-        assert_equal(signed["complete"], True)
-        txsize = self.nodes[0].decoderawtransaction(signed['hex'])['vsize']
-        exp_feerate = 1000 * fee / Decimal(txsize)
-        assert_approx(signed["feerate"], exp_feerate, Decimal("0.00000010"))
-        # discrepancy = 100000000 * (exp_feerate - signed["feerate"])
-        # assert -10 < discrepancy < 10
-        assert_equal(Decimal(signed["fee"]), fee)
-
         if not self.options.descriptors:
             self.log.info("Verify behaviour of importaddress and listunspent")
 
diff --git a/test/functional/feature_signet.py b/test/functional/feature_signet.py
index 63091b3ee8..b648266cae 100755
--- a/test/functional/feature_signet.py
+++ b/test/functional/feature_signet.py
@@ -9,8 +9,6 @@ from decimal import Decimal
 from test_framework.test_framework import BitcoinTestFramework
 from test_framework.util import assert_equal
 
-SIGNET_DEFAULT_CHALLENGE = '512103ad5e0edad18cb1f0fc0d28a3d4f1f3e445640337489abb10404f2d1e086be430210359ef5021964fe22d6f8e05b2463c9540ce96883fe3b278760f048f5189f2e6c452ae'
-
 signet_blocks = [
     '00000020f61eee3b63a380a477a063af32b2bbc97c9ff9f01f2c4225e973988108000000f575c83235984e7dc4afc1f30944c170462e84437ab6f2d52e16878a79e4678bd1914d5fae77031eccf4070001010000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff025151feffffff0200f2052a010000001600149243f727dd5343293eb83174324019ec16c2630f0000000000000000776a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf94c4fecc7daa2490047304402205e423a8754336ca99dbe16509b877ef1bf98d008836c725005b3c787c41ebe46022047246e4467ad7cc7f1ad98662afcaf14c115e0095a227c7b05c5182591c23e7e01000120000000000000000000000000000000000000000000000000000000000000000000000000',
     '00000020533b53ded9bff4adc94101d32400a144c54edc5ed492a3b26c63b2d686000000b38fef50592017cfafbcab88eb3d9cf50b2c801711cad8299495d26df5e54812e7914d5fae77031ecfdd0b0001010000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff025251feffffff0200f2052a01000000160014fd09839740f0e0b4fc6d5e2527e4022aa9b89dfa0000000000000000776a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf94c4fecc7daa24900473044022031d64a1692cdad1fc0ced69838169fe19ae01be524d831b95fcf5ea4e6541c3c02204f9dea0801df8b4d0cd0857c62ab35c6c25cc47c930630dc7fe723531daa3e9b01000120000000000000000000000000000000000000000000000000000000000000000000000000',
@@ -24,31 +22,21 @@ signet_blocks = [
     '00000020a868e8514be5e46dabd6a122132f423f36a43b716a40c394e2a8d063e1010000f4c6c717e99d800c699c25a2006a75a0c5c09f432a936f385e6fce139cdbd1a5e9964d5fae77031e7d026e0001010000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff025a51feffffff0200f2052a01000000160014aaa671c82b138e3b8f510cd801e5f2bd0aa305940000000000000000776a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf94c4fecc7daa24900473044022042309f4c3c7a1a2ac8c24f890f962df1c0086cec10be0868087cfc427520cb2702201dafee8911c269b7e786e242045bb57cef3f5b0f177010c6159abae42f646cc501000120000000000000000000000000000000000000000000000000000000000000000000000000',
 ]
 
-class SignetParams:
-    def __init__(self, challenge=None):
-        if challenge is None:
-            self.challenge = SIGNET_DEFAULT_CHALLENGE
-            self.shared_args = []
-        else:
-            self.challenge = challenge
-            self.shared_args = [f"-signetchallenge={challenge}"]
 
 class SignetBasicTest(BitcoinTestFramework):
     def set_test_params(self):
         self.chain = "signet"
         self.num_nodes = 6
         self.setup_clean_chain = True
-        self.signets = [
-            SignetParams(challenge='51'), # OP_TRUE
-            SignetParams(), # default challenge
-            # default challenge as a 2-of-2, which means it should fail
-            SignetParams(challenge='522103ad5e0edad18cb1f0fc0d28a3d4f1f3e445640337489abb10404f2d1e086be430210359ef5021964fe22d6f8e05b2463c9540ce96883fe3b278760f048f5189f2e6c452ae')
-        ]
+        shared_args1 = ["-signetchallenge=51"]  # OP_TRUE
+        shared_args2 = []  # default challenge
+        # we use the exact same challenge except we do it as a 2-of-2, which means it should fail
+        shared_args3 = ["-signetchallenge=522103ad5e0edad18cb1f0fc0d28a3d4f1f3e445640337489abb10404f2d1e086be430210359ef5021964fe22d6f8e05b2463c9540ce96883fe3b278760f048f5189f2e6c452ae"]
 
         self.extra_args = [
-            self.signets[0].shared_args, self.signets[0].shared_args,
-            self.signets[1].shared_args, self.signets[1].shared_args,
-            self.signets[2].shared_args, self.signets[2].shared_args,
+            shared_args1, shared_args1,
+            shared_args2, shared_args2,
+            shared_args3, shared_args3,
         ]
 
     def setup_network(self):
@@ -62,28 +50,14 @@ class SignetBasicTest(BitcoinTestFramework):
     def run_test(self):
         self.log.info("basic tests using OP_TRUE challenge")
 
-        self.log.info('getblockchaininfo')
-        def check_getblockchaininfo(node_idx, signet_idx):
-            blockchain_info = self.nodes[node_idx].getblockchaininfo()
-            assert_equal(blockchain_info['chain'], 'signet')
-            assert_equal(blockchain_info['signet_challenge'], self.signets[signet_idx].challenge)
-        check_getblockchaininfo(node_idx=1, signet_idx=0)
-        check_getblockchaininfo(node_idx=2, signet_idx=1)
-        check_getblockchaininfo(node_idx=5, signet_idx=2)
-
         self.log.info('getmininginfo')
-        def check_getmininginfo(node_idx, signet_idx):
-            mining_info = self.nodes[node_idx].getmininginfo()
-            assert_equal(mining_info['blocks'], 0)
-            assert_equal(mining_info['chain'], 'signet')
-            assert 'currentblocktx' not in mining_info
-            assert 'currentblockweight' not in mining_info
-            assert_equal(mining_info['networkhashps'], Decimal('0'))
-            assert_equal(mining_info['pooledtx'], 0)
-            assert_equal(mining_info['signet_challenge'], self.signets[signet_idx].challenge)
-        check_getmininginfo(node_idx=0, signet_idx=0)
-        check_getmininginfo(node_idx=3, signet_idx=1)
-        check_getmininginfo(node_idx=4, signet_idx=2)
+        mining_info = self.nodes[0].getmininginfo()
+        assert_equal(mining_info['blocks'], 0)
+        assert_equal(mining_info['chain'], 'signet')
+        assert 'currentblocktx' not in mining_info
+        assert 'currentblockweight' not in mining_info
+        assert_equal(mining_info['networkhashps'], Decimal('0'))
+        assert_equal(mining_info['pooledtx'], 0)
 
         self.generate(self.nodes[0], 1, sync_fun=self.no_op)
 
diff --git a/test/functional/feature_sync_coins_tip_after_chain_sync.py b/test/functional/feature_sync_coins_tip_after_chain_sync.py
deleted file mode 100755
index 6938c83292..0000000000
--- a/test/functional/feature_sync_coins_tip_after_chain_sync.py
+++ /dev/null
@@ -1,145 +0,0 @@
-#!/usr/bin/env python3
-# Copyright (c) 2024- The Bitcoin Core developers
-# Distributed under the MIT software license, see the accompanying
-# file COPYING or http://www.opensource.org/licenses/mit-license.php.
-"""
-Test SyncCoinsTipAfterChainSync logic
-"""
-
-
-from test_framework.blocktools import create_block, create_coinbase
-from test_framework.messages import (
-    MSG_BLOCK,
-    MSG_TYPE_MASK,
-)
-from test_framework.p2p import (
-    CBlockHeader,
-    msg_block,
-    msg_headers,
-    P2PDataStore,
-)
-from test_framework.test_framework import BitcoinTestFramework
-from test_framework.util import (
-    assert_equal,
-)
-
-
-class P2PBlockDelay(P2PDataStore):
-    def __init__(self, delay_block):
-        self.delay_block = delay_block
-        super().__init__()
-
-    def on_getdata(self, message):
-        for inv in message.inv:
-            self.getdata_requests.append(inv.hash)
-            if (inv.type & MSG_TYPE_MASK) == MSG_BLOCK:
-                if inv.hash != self.delay_block:
-                    self.send_message(msg_block(self.block_store[inv.hash]))
-
-    def on_getheaders(self, message):
-        pass
-
-    def send_delayed(self):
-        self.send_message(msg_block(self.block_store[self.delay_block]))
-
-
-SYNC_CHECK_INTERVAL = 30
-
-
-class SyncCoinsTipAfterChainSyncTest(BitcoinTestFramework):
-    def set_test_params(self):
-        self.setup_clean_chain = True
-        self.num_nodes = 1
-        # Set maxtipage to 1 to get us out of IBD after 1 block past our mocktime
-        self.extra_args = [[f"-maxtipage=1"]]
-
-    def run_test(self):
-        NUM_BLOCKS = 3
-        node = self.nodes[0]
-        tip = int(node.getbestblockhash(), 16)
-        blocks = []
-        height = 1
-        block_time = node.getblock(node.getbestblockhash())["time"] + 1
-        # Set mock time to 2 past block time, so second block will exit IBD
-        node.setmocktime(block_time + 2)
-
-        # Prepare blocks without sending them to the node
-        block_dict = {}
-        for _ in range(NUM_BLOCKS):
-            blocks.append(create_block(tip, create_coinbase(height), block_time))
-            blocks[-1].solve()
-            tip = blocks[-1].sha256
-            block_time += 1
-            height += 1
-            block_dict[blocks[-1].sha256] = blocks[-1]
-        delay_block = blocks[-1].sha256
-
-        # Create peer which will not automatically send last block
-        peer = node.add_outbound_p2p_connection(
-            P2PBlockDelay(delay_block),
-            p2p_idx=1,
-            connection_type="outbound-full-relay",
-        )
-        peer.block_store = block_dict
-
-        self.log.info(
-            "Send headers message for first block, verify it won't sync because node is still in IBD"
-        )
-        headers_message = msg_headers()
-        headers_message.headers = [CBlockHeader(blocks[0])]
-        peer.send_message(headers_message)
-        peer.sync_with_ping()
-        assert_equal(node.getblockchaininfo()["initialblockdownload"], True)
-        with node.assert_debug_log(
-            ["Node is still in IBD, rescheduling post-IBD chainstate disk sync..."]
-        ):
-            node.mockscheduler(SYNC_CHECK_INTERVAL)
-
-        self.log.info(
-            "Send headers message for second block, verify it won't sync because node height has changed"
-        )
-        headers_message.headers = [CBlockHeader(blocks[1])]
-        peer.send_message(headers_message)
-        peer.sync_with_ping()
-        assert_equal(node.getblockchaininfo()["initialblockdownload"], False)
-        with node.assert_debug_log(
-            [
-                "Chain height updated since last check, rescheduling post-IBD chainstate disk sync..."
-            ]
-        ):
-            node.mockscheduler(SYNC_CHECK_INTERVAL)
-
-        self.log.info(
-            "Send headers message for last block, verify it won't sync because node is still downloading the block"
-        )
-        headers_message.headers = [CBlockHeader(blocks[2])]
-        peer.send_message(headers_message)
-        peer.sync_with_ping()
-        with node.assert_debug_log(
-            [
-                "Still downloading blocks from peers, rescheduling post-IBD chainstate disk sync..."
-            ]
-        ):
-            node.mockscheduler(SYNC_CHECK_INTERVAL)
-
-        self.log.info(
-            "Send last block, verify it won't sync because node height has changed"
-        )
-        peer.send_delayed()
-        peer.sync_with_ping()
-        with node.assert_debug_log(
-            [
-                "Chain height updated since last check, rescheduling post-IBD chainstate disk sync..."
-            ]
-        ):
-            node.mockscheduler(SYNC_CHECK_INTERVAL)
-
-        self.log.info("Verify node syncs chainstate to disk on next scheduler update")
-        with node.assert_debug_log(
-            ["Finished syncing to tip, syncing chainstate to disk"]
-        ):
-            node.mockscheduler(SYNC_CHECK_INTERVAL)
-
-
-if __name__ == "__main__":
-    SyncCoinsTipAfterChainSyncTest(__file__).main()
diff --git a/test/functional/feature_taproot.py b/test/functional/feature_taproot.py
index e2267cdd4c..443c1c33da 100755
--- a/test/functional/feature_taproot.py
+++ b/test/functional/feature_taproot.py
@@ -738,7 +738,7 @@ def spenders_taproot_active():
         scripts = [
             ("pk_codesep", CScript(random_checksig_style(pubs[1]) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig
             ("codesep_pk", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pubs[1]))),  # codesep before checksig
-            ("branched_codesep", CScript([random.randbytes(random.randrange(2, 75)), OP_DROP, OP_IF, OP_CODESEPARATOR, pubs[0], OP_ELSE, OP_CODESEPARATOR, pubs[1], OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep
+            ("branched_codesep", CScript([random.randbytes(random.randrange(2, 511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pubs[0], OP_ELSE, OP_CODESEPARATOR, pubs[1], OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep
             # Note that the first data push in the "branched_codesep" script has the purpose of
             # randomizing the sighash, both by varying script size and content. In order to
             # avoid MINIMALDATA script verification errors caused by not-minimal-encoded data
@@ -1044,7 +1044,7 @@ def spenders_taproot_active():
     # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.
     add_spender(spenders, "tapscript/1000inputs", leaf="t23", **common, inputs=[getter("sign")] + [b'' for _ in range(999)], failure={"leaf": "t24", "inputs": [getter("sign")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)
     # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.
-    add_spender(spenders, "tapscript/pushmaxlimit", standard=False, leaf="t25", **common, **SINGLE_SIG, failure={"leaf": "t26"}, **ERR_PUSH_LIMIT)
+    add_spender(spenders, "tapscript/pushmaxlimit", leaf="t25", **common, **SINGLE_SIG, failure={"leaf": "t26"}, **ERR_PUSH_LIMIT)
     # Test that 999-of-999 multisig works (but 1000-of-1000 triggers stack size limits)
     add_spender(spenders, "tapscript/bigmulti", leaf="t33", **common, inputs=big_spend_inputs, num=999, failure={"leaf": "t34", "num": 1000}, **ERR_STACK_SIZE)
     # Test that the CLEANSTACK rule is consensus critical in tapscript
@@ -1285,7 +1285,7 @@ class TaprootTest(BitcoinTestFramework):
     def set_test_params(self):
         self.num_nodes = 1
         self.setup_clean_chain = True
-        self.extra_args = [["-par=1", "-datacarrierfullcount"]]
+        self.extra_args = [["-par=1"]]
 
     def block_submit(self, node, txs, msg, err_msg, cb_pubkey=None, fees=0, sigops_weight=0, witness=False, accept=False):
 
diff --git a/test/functional/feature_uacomment.py b/test/functional/feature_uacomment.py
index 7efad19f43..fc372f543d 100755
--- a/test/functional/feature_uacomment.py
+++ b/test/functional/feature_uacomment.py
@@ -18,12 +18,12 @@ class UacommentTest(BitcoinTestFramework):
 
     def run_test(self):
         self.log.info("test multiple -uacomment")
-        test_uacomment = self.nodes[0].getnetworkinfo()["subversion"]
-        assert "(testnode0)" in test_uacomment
+        test_uacomment = self.nodes[0].getnetworkinfo()["subversion"][-12:-1]
+        assert_equal(test_uacomment, "(testnode0)")
 
         self.restart_node(0, ["-uacomment=foo"])
-        foo_uacomment = self.nodes[0].getnetworkinfo()["subversion"]
-        assert "(testnode0; foo)" in foo_uacomment
+        foo_uacomment = self.nodes[0].getnetworkinfo()["subversion"][-17:-1]
+        assert_equal(foo_uacomment, "(testnode0; foo)")
 
         self.log.info("test -uacomment max length")
         self.stop_node(0)
@@ -35,13 +35,6 @@ class UacommentTest(BitcoinTestFramework):
             expected = r"Error: User Agent comment \(" + re.escape(unsafe_char) + r"\) contains unsafe characters."
             self.nodes[0].assert_start_raises_init_error(["-uacomment=" + unsafe_char], expected, match=ErrorMatch.FULL_REGEX)
 
-        self.log.info("test -uaappend")
-        self.restart_node(0, ["-uaappend=foo:0"])
-        assert_equal(self.nodes[0].getnetworkinfo()["subversion"][-7:], '/foo:0/')
-
-        self.restart_node(0, ["-uaappend=foo:9/"])
-        assert_equal(self.nodes[0].getnetworkinfo()["subversion"][-7:], '/foo:9/')
-
 
 if __name__ == '__main__':
     UacommentTest(__file__).main()
diff --git a/test/functional/feature_versionbits_warning.py b/test/functional/feature_versionbits_warning.py
index bce59177bb..dc25ce6c83 100755
--- a/test/functional/feature_versionbits_warning.py
+++ b/test/functional/feature_versionbits_warning.py
@@ -18,20 +18,10 @@ from test_framework.test_framework import BitcoinTestFramework
 VB_PERIOD = 144           # versionbits period length for regtest
 VB_THRESHOLD = 108        # versionbits activation threshold for regtest
 VB_TOP_BITS = 0x20000000
-VB_UNKNOWN_BIT = 12       # Choose a bit unassigned to any deployment
+VB_UNKNOWN_BIT = 27       # Choose a bit unassigned to any deployment
 VB_UNKNOWN_VERSION = VB_TOP_BITS | (1 << VB_UNKNOWN_BIT)
-VB_BIP320_BIT = 13
-VB_BIP320_VERSION = VB_TOP_BITS | (1 << VB_BIP320_BIT)
-VB_BIP320_THRESHOLD = 76
-UNKNOWN_VERSION_SCHEMA = 0x60000000
-UNKNOWN_VERSION_SCHEMA_THRESHOLD = 51
-
-WARN_UNKNOWN_RULES_MINED = "Warning: Unrecognised block version (0x%08x) is being mined! Unknown rules may or may not be in effect" % (UNKNOWN_VERSION_SCHEMA,)
-WARN_UNKNOWN_BIT_MINED = f"Warning: Miners are attempting to activate unknown new rules (bit {VB_UNKNOWN_BIT})"
-# NOTE: WARN_BIP320_BIT_MINED includes VB_UNKNOWN_BIT because it persists from the earlier check
-WARN_BIP320_BIT_MINED = f"Warning: Miners are attempting to activate unknown new rules (bit {VB_UNKNOWN_BIT}, {VB_BIP320_BIT})"
+
 WARN_UNKNOWN_RULES_ACTIVE = f"Unknown new rules activated (versionbit {VB_UNKNOWN_BIT})"
-WARN_BIP320_BLOCK = "Miner violated version bit protocol"
 VB_PATTERN = re.compile("Unknown new rules activated.*versionbit")
 
 class VersionBitsWarningTest(BitcoinTestFramework):
@@ -86,58 +76,10 @@ class VersionBitsWarningTest(BitcoinTestFramework):
         assert not VB_PATTERN.match(",".join(node.getmininginfo()["warnings"]))
         assert not VB_PATTERN.match(",".join(node.getnetworkinfo()["warnings"]))
 
-        self.log.info("Check that there is a warning if >50 blocks in the last 100 were an unknown version schema")
-        # Build UNKNOWN_VERSION_SCHEMA_THRESHOLD blocks signaling some unknown schema
-        self.send_blocks_with_version(peer, UNKNOWN_VERSION_SCHEMA_THRESHOLD, UNKNOWN_VERSION_SCHEMA)
-        # Check that get*info() shows the 51/100 unknown block version warning
-        assert(WARN_UNKNOWN_RULES_MINED in ",".join(node.getmininginfo()["warnings"]))
-        assert(WARN_UNKNOWN_RULES_MINED in ",".join(node.getnetworkinfo()["warnings"]))
-        # Close the period normally
-        self.generatetoaddress(node, VB_PERIOD - UNKNOWN_VERSION_SCHEMA_THRESHOLD, node_deterministic_address)
-        # Make sure the warning remains
-        assert(WARN_UNKNOWN_RULES_MINED in ",".join(node.getmininginfo()["warnings"]))
-        assert(WARN_UNKNOWN_RULES_MINED in ",".join(node.getnetworkinfo()["warnings"]))
-
-        # Stop-start the node, and make sure the warning is gone
-        self.restart_node(0)
-        assert(WARN_UNKNOWN_RULES_MINED not in ",".join(node.getmininginfo()["warnings"]))
-        assert(WARN_UNKNOWN_RULES_MINED not in ",".join(node.getnetworkinfo()["warnings"]))
-        peer = node.add_p2p_connection(P2PInterface())
-
-        self.log.info("Check that there is a warning if >50 blocks in the last 100 were an unknown version")
         # Build one period of blocks with VB_THRESHOLD blocks signaling some unknown bit
         self.send_blocks_with_version(peer, VB_THRESHOLD, VB_UNKNOWN_VERSION)
         self.generatetoaddress(node, VB_PERIOD - VB_THRESHOLD, node_deterministic_address)
 
-        # Check that get*info() shows the 51/100 unknown block version warning
-        assert(WARN_UNKNOWN_BIT_MINED in ",".join(node.getmininginfo()["warnings"]))
-        assert(WARN_UNKNOWN_BIT_MINED in ",".join(node.getnetworkinfo()["warnings"]))
-
-        self.log.info("Check that there is a warning if BIP320 is used, and a second persistent warning if >75 blocks in the last 100 were a BIP320 version")
-        with node.busy_wait_for_debug_log([WARN_BIP320_BLOCK.encode('ascii')]):
-            self.send_blocks_with_version(peer, VB_BIP320_THRESHOLD - 1, VB_BIP320_VERSION)
-        # Check that get*info() doesn't shows the 76/100 unknown block version warning yet.
-        assert(WARN_BIP320_BIT_MINED not in ",".join(node.getmininginfo()["warnings"]))
-        assert(WARN_BIP320_BIT_MINED not in ",".join(node.getnetworkinfo()["warnings"]))
-        # ...and it shouldn't show the BIP320-specific warning
-        assert(WARN_BIP320_BLOCK not in node.getmininginfo()["warnings"])
-        assert(WARN_BIP320_BLOCK not in node.getnetworkinfo()["warnings"])
-        with node.busy_wait_for_debug_log([WARN_BIP320_BLOCK.encode('ascii'), b'Enqueuing UpdatedBlockTip']):
-            self.send_blocks_with_version(peer, 1, VB_BIP320_VERSION)
-        # Check that get*info() shows the 76/100 unknown block version warning.
-        assert(WARN_BIP320_BIT_MINED in ",".join(node.getmininginfo()["warnings"]))
-        assert(WARN_BIP320_BIT_MINED in ",".join(node.getnetworkinfo()["warnings"]))
-        assert(WARN_BIP320_BLOCK not in node.getmininginfo()["warnings"])
-        assert(WARN_BIP320_BLOCK not in node.getnetworkinfo()["warnings"])
-        with node.busy_wait_for_debug_log([b'Enqueuing UpdatedBlockTip'], forbid_msgs=[WARN_BIP320_BLOCK.encode('ascii')]):
-            self.generatetoaddress(node, 1, node_deterministic_address)
-        # Only the 76/100 should persist
-        assert(WARN_BIP320_BIT_MINED in ",".join(node.getmininginfo()["warnings"]))
-        assert(WARN_BIP320_BIT_MINED in ",".join(node.getnetworkinfo()["warnings"]))
-        assert(WARN_BIP320_BLOCK not in node.getmininginfo()["warnings"])
-        assert(WARN_BIP320_BLOCK not in node.getnetworkinfo()["warnings"])
-        self.generatetoaddress(node, VB_PERIOD - VB_BIP320_THRESHOLD - 1, node_deterministic_address)
-
         self.log.info("Check that there is a warning if previous VB_BLOCKS have >=VB_THRESHOLD blocks with unknown versionbits version.")
         # Mine a period worth of expected blocks so the generic block-version warning
         # is cleared. This will move the versionbit state to ACTIVE.
diff --git a/test/functional/interface_bitcoin_cli.py b/test/functional/interface_bitcoin_cli.py
index c394d445ef..e7113f8335 100755
--- a/test/functional/interface_bitcoin_cli.py
+++ b/test/functional/interface_bitcoin_cli.py
@@ -15,7 +15,6 @@ from test_framework.util import (
     assert_greater_than_or_equal,
     assert_raises_process_error,
     assert_raises_rpc_error,
-    assert_scale,
     get_auth_cookie,
     rpc_port,
 )
@@ -31,12 +30,7 @@ JSON_PARSING_ERROR = 'error: Error parsing JSON: foo'
 BLOCKS_VALUE_OF_ZERO = 'error: the first argument (number of blocks to generate, default: 1) must be an integer value greater than zero'
 TOO_MANY_ARGS = 'error: too many arguments (maximum 2 for nblocks and maxtries)'
 WALLET_NOT_LOADED = 'Requested wallet does not exist or is not loaded'
-WALLET_NOT_SPECIFIED = (
-    "Multiple wallets are loaded. Please select which wallet to use by requesting the RPC "
-    "through the /wallet/<walletname> URI path. Or for the CLI, specify the \"-rpcwallet=<walletname>\" "
-    "option before the command (run \"bitcoin-cli -h\" for help or \"bitcoin-cli listwallets\" to see "
-    "which wallets are currently loaded)."
-)
+WALLET_NOT_SPECIFIED = 'Wallet file not specified'
 
 
 def cli_get_info_string_to_dict(cli_get_info_string):
@@ -89,8 +83,9 @@ class TestBitcoinCli(BitcoinTestFramework):
         self.generate(self.nodes[0], BLOCKS)
 
         self.log.info("Compare responses from getblockchaininfo RPC and `bitcoin-cli getblockchaininfo`")
-        blockchain_info = self.nodes[0].getblockchaininfo()
-        assert_equal(blockchain_info, self.nodes[0].cli.getblockchaininfo())
+        cli_response = self.nodes[0].cli.getblockchaininfo()
+        rpc_response = self.nodes[0].getblockchaininfo()
+        assert_equal(cli_response, rpc_response)
 
         self.log.info("Test named arguments")
         assert_equal(self.nodes[0].cli.echo(0, 1, arg3=3, arg5=5), ['0', '1', None, '3', None, '5'])
@@ -164,9 +159,6 @@ class TestBitcoinCli(BitcoinTestFramework):
         self.log.info("Test connecting with non-existing RPC cookie file")
         assert_raises_process_error(1, "Could not locate RPC credentials", self.nodes[0].cli('-rpccookiefile=does-not-exist', '-rpcpassword=').echo)
 
-        self.log.info("Test connecting without RPC cookie file and with password arg")
-        assert_equal(BLOCKS, self.nodes[0].cli('-norpccookiefile', f'-rpcuser={user}', f'-rpcpassword={password}').getblockcount())
-
         self.log.info("Test -getinfo with arguments fails")
         assert_raises_process_error(1, "-getinfo takes no arguments", self.nodes[0].cli('-getinfo').help)
 
@@ -179,22 +171,6 @@ class TestBitcoinCli(BitcoinTestFramework):
         self.log.info("Test -getinfo with invalid value for -color option")
         assert_raises_process_error(1, "Invalid value for -color option. Valid values: always, auto, never.", self.nodes[0].cli('-getinfo', '-color=foo').send_cli)
 
-        self.log.info("Test -getinfo command parsing")
-
-        self.log.debug("Test -getinfo=1 and -getinfo=-1 both succeed")
-        for cmd in ['-getinfo=1', '-getinfo=-1']:
-            assert_equal(str(blockchain_info['blocks']), cli_get_info_string_to_dict(self.nodes[0].cli(cmd).send_cli())['Blocks'])
-
-        self.log.debug("Test -getinfo=0 and -nogetinfo both raise 'too few parameters'")
-        err_msg = "error: too few parameters (need at least command)"
-        for cmd in ['-getinfo=0', '-nogetinfo']:
-            assert_raises_process_error(1, err_msg, self.nodes[0].cli(cmd).send_cli)
-
-        self.log.debug("Test -igetinfo and -getinfos both raise 'Invalid parameter'")
-        err_msg = "Error parsing command line arguments: Invalid parameter"
-        for cmd in ['-igetinfo', '-getinfos']:
-            assert_raises_process_error(1, "{} {}".format(err_msg, cmd), self.nodes[0].cli(cmd).send_cli)
-
         self.log.info("Test -getinfo returns expected network and blockchain info")
         if self.is_specified_wallet_compiled():
             self.import_deterministic_coinbase_privkeys()
@@ -203,7 +179,7 @@ class TestBitcoinCli(BitcoinTestFramework):
         cli_get_info = cli_get_info_string_to_dict(cli_get_info_string)
 
         network_info = self.nodes[0].getnetworkinfo()
-        assert_equal(cli_get_info['Chain'], self.chain)
+        blockchain_info = self.nodes[0].getblockchaininfo()
         assert_equal(int(cli_get_info['Version']), network_info['version'])
         assert_equal(cli_get_info['Verification progress'], "%.4f%%" % (blockchain_info['verificationprogress'] * 100))
         assert_equal(int(cli_get_info['Blocks']), blockchain_info['blocks'])
@@ -214,10 +190,6 @@ class TestBitcoinCli(BitcoinTestFramework):
         assert_equal(cli_get_info['Proxies'], network_info['networks'][0]['proxy'])
         assert_equal(Decimal(cli_get_info['Difficulty']), blockchain_info['difficulty'])
         assert_equal(cli_get_info['Chain'], blockchain_info['chain'])
-        for field in ['Blocks', 'Headers', 'Time offset (s)', 'Version']:
-            assert_scale(int(cli_get_info[field]), expected_scale=0)
-        for field in ('connections_in', 'connections_out', 'connections'):
-            assert_scale(network_info[field], expected_scale=0)
 
         self.log.info("Test -getinfo and bitcoin-cli return all proxies")
         self.restart_node(0, extra_args=["-proxy=127.0.0.1:9050", "-i2psam=127.0.0.1:7656"])
@@ -233,17 +205,12 @@ class TestBitcoinCli(BitcoinTestFramework):
             self.restart_node(0, extra_args=["-addresstype=bech32", "-changetype=bech32"])
             assert_equal(Decimal(cli_get_info['Balance']), BALANCE)
             assert 'Balances' not in cli_get_info_string
-            assert 'Total balance' not in cli_get_info.keys()
             wallet_info = self.nodes[0].getwalletinfo()
             assert_equal(int(cli_get_info['Keypool size']), wallet_info['keypoolsize'])
             assert_equal(int(cli_get_info['Unlocked until']), wallet_info['unlocked_until'])
             assert_equal(Decimal(cli_get_info['Transaction fee rate (-paytxfee) (BTC/kvB)']), wallet_info['paytxfee'])
             assert_equal(Decimal(cli_get_info['Min tx relay fee rate (BTC/kvB)']), network_info['relayfee'])
             assert_equal(self.nodes[0].cli.getwalletinfo(), wallet_info)
-            for field in ['Keypool size', 'Time offset (s)', 'Unlocked until']:
-                assert_scale(cli_get_info[field], expected_scale=0)
-            for field in ['Balance', 'Transaction fee rate (-paytxfee) (BTC/kvB)', 'Min tx relay fee rate (BTC/kvB)']:
-                assert_scale(cli_get_info[field])
 
             # Setup to test -getinfo, -generate, and -rpcwallet= with multiple wallets.
             wallets = [self.default_wallet_name, 'Encrypted', 'secret']
@@ -268,16 +235,13 @@ class TestBitcoinCli(BitcoinTestFramework):
                 cli_get_info_string = self.nodes[0].cli('-getinfo', f'-rpcwallet={wallets[i]}').send_cli()
                 cli_get_info = cli_get_info_string_to_dict(cli_get_info_string)
                 assert 'Balances' not in cli_get_info_string
-                assert 'Total balance' not in cli_get_info.keys()
                 assert_equal(cli_get_info["Wallet"], wallets[i])
                 assert_equal(Decimal(cli_get_info['Balance']), amounts[i])
-                assert_scale(Decimal(cli_get_info['Balance']))
 
             self.log.info("Test -getinfo with multiple wallets and -rpcwallet=non-existing-wallet returns no balances")
             cli_get_info_string = self.nodes[0].cli('-getinfo', '-rpcwallet=does-not-exist').send_cli()
             assert 'Balance' not in cli_get_info_string
             assert 'Balances' not in cli_get_info_string
-            assert 'Total balance' not in cli_get_info.keys()
 
             self.log.info("Test -getinfo with multiple wallets returns all loaded wallet names and balances")
             assert_equal(set(self.nodes[0].listwallets()), set(wallets))
@@ -286,9 +250,6 @@ class TestBitcoinCli(BitcoinTestFramework):
             assert 'Balance' not in cli_get_info
             for k, v in zip(wallets, amounts):
                 assert_equal(Decimal(cli_get_info['Balances'][k]), v)
-                assert_scale(Decimal(cli_get_info['Balances'][k]))
-            assert_equal(Decimal(cli_get_info['Total balance']), sum(amounts))
-            assert_scale(cli_get_info['Total balance'])
 
             # Unload the default wallet and re-verify.
             self.nodes[0].unloadwallet(wallets[0])
@@ -300,8 +261,6 @@ class TestBitcoinCli(BitcoinTestFramework):
             for k, v in zip(wallets[1:], amounts[1:]):
                 assert_equal(Decimal(cli_get_info['Balances'][k]), v)
             assert wallets[0] not in cli_get_info
-            assert_equal(Decimal(cli_get_info['Total balance']), sum(amounts[1:]))
-            assert_scale(cli_get_info['Total balance'])
 
             self.log.info("Test -getinfo after unloading all wallets except a non-default one returns its balance")
             self.nodes[0].unloadwallet(wallets[2])
@@ -309,16 +268,13 @@ class TestBitcoinCli(BitcoinTestFramework):
             cli_get_info_string = self.nodes[0].cli('-getinfo').send_cli()
             cli_get_info = cli_get_info_string_to_dict(cli_get_info_string)
             assert 'Balances' not in cli_get_info_string
-            assert 'Total balance' not in cli_get_info.keys()
             assert_equal(cli_get_info['Wallet'], wallets[1])
             assert_equal(Decimal(cli_get_info['Balance']), amounts[1])
-            assert_scale(Decimal(cli_get_info['Balance']))
 
             self.log.info("Test -getinfo with -rpcwallet=remaining-non-default-wallet returns only its balance")
             cli_get_info_string = self.nodes[0].cli('-getinfo', rpcwallet2).send_cli()
             cli_get_info = cli_get_info_string_to_dict(cli_get_info_string)
             assert 'Balances' not in cli_get_info_string
-            assert 'Total balance' not in cli_get_info.keys()
             assert_equal(cli_get_info['Wallet'], wallets[1])
             assert_equal(Decimal(cli_get_info['Balance']), amounts[1])
 
@@ -327,7 +283,6 @@ class TestBitcoinCli(BitcoinTestFramework):
             cli_get_info_keys = cli_get_info_string_to_dict(cli_get_info_string)
             assert 'Balance' not in cli_get_info_keys
             assert 'Balances' not in cli_get_info_string
-            assert 'Total balance' not in cli_get_info.keys()
 
             # Test bitcoin-cli -generate.
             n1 = 3
@@ -376,10 +331,6 @@ class TestBitcoinCli(BitcoinTestFramework):
             n4 = 10
             blocks = self.nodes[0].getblockcount()
 
-            self.log.info('Test -generate -rpcwallet=<filename> raise RPC error')
-            wallet2_path = f'-rpcwallet={self.nodes[0].wallets_path / wallets[2] / self.wallet_data_filename}'
-            assert_raises_rpc_error(-18, WALLET_NOT_LOADED, self.nodes[0].cli(wallet2_path, '-generate').echo)
-
             self.log.info('Test -generate -rpcwallet with no args')
             generate = self.nodes[0].cli(rpcwallet2, '-generate').send_cli()
             assert_equal(set(generate.keys()), {'address', 'blocks'})
diff --git a/test/functional/interface_rest.py b/test/functional/interface_rest.py
index 07020b4431..ba6e960476 100755
--- a/test/functional/interface_rest.py
+++ b/test/functional/interface_rest.py
@@ -49,9 +49,6 @@ def filter_output_indices_by_value(vouts, value):
             yield vout['n']
 
 class RESTTest (BitcoinTestFramework):
-    def add_options(self, parser):
-        self.add_wallet_options(parser)
-
     def set_test_params(self):
         self.num_nodes = 2
         self.extra_args = [["-rest", "-blockfilterindex=1"], []]
@@ -348,9 +345,6 @@ class RESTTest (BitcoinTestFramework):
         for obj in [json_obj, mempool_info]:
             obj.pop("unbroadcastcount")
         assert_equal(json_obj, mempool_info)
-        json_obj = self.test_rest_request("/mempool/info/with_fee_histogram")
-        mempool_info = self.nodes[0].getmempoolinfo(with_fee_histogram=True)
-        assert_equal(json_obj, mempool_info)
 
         # Check that there are our submitted transactions in the TX memory pool
         json_obj = self.test_rest_request("/mempool/contents")
@@ -446,23 +440,5 @@ class RESTTest (BitcoinTestFramework):
         resp = self.test_rest_request(f"/deploymentinfo/{INVALID_PARAM}", ret_type=RetType.OBJ, status=400)
         assert_equal(resp.read().decode('utf-8').rstrip(), f"Invalid hash: {INVALID_PARAM}")
 
-        if self.is_wallet_compiled():
-            self.import_deterministic_coinbase_privkeys()
-
-            # Random address so node1's balance doesn't increase
-            not_related_address = "2MxqoHEdNQTyYeX1mHcbrrpzgojbosTpCvJ"
-
-            # Prepare for Fee estimation
-            for i in range(18):
-                self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.1)
-                self.sync_all()
-                self.generatetoaddress(self.nodes[1], 1, not_related_address)
-            self.sync_all()
-
-            json_obj = self.test_rest_request("/fee/conservative/1")
-            assert_greater_than(float(json_obj["feerate"]), 0)
-            assert_greater_than(int(json_obj["blocks"]), 0)
-
-
 if __name__ == '__main__':
     RESTTest(__file__).main()
diff --git a/test/functional/interface_rpc.py b/test/functional/interface_rpc.py
index 0ae85578f3..9074f0a2d9 100755
--- a/test/functional/interface_rpc.py
+++ b/test/functional/interface_rpc.py
@@ -172,13 +172,10 @@ class RPCInterfaceTest(BitcoinTestFramework):
         self.log.info("Testing nonstandard jsonrpc 1.0 version number is accepted...")
         self.test_batch_request(lambda idx: BatchOptions(request_fields={"jsonrpc": "1.0"}))
 
-        self.log.info("Testing nonstandard jsonrpc 1.0 version number is accepted as a Number...")
-        self.test_batch_request(lambda idx: BatchOptions(request_fields={"jsonrpc": 1.0}))
-
-        self.log.info("Testing unrecognized jsonrpc version number is accepted as if 1.0...")
+        self.log.info("Testing unrecognized jsonrpc version number is rejected...")
         self.test_batch_request(lambda idx: BatchOptions(
             request_fields={"jsonrpc": "2.1"},
-            ))
+            response_fields={"result": None, "error": {"code": RPC_INVALID_REQUEST, "message": "JSON-RPC version not supported"}}))
 
     def test_http_status_codes(self):
         self.log.info("Testing HTTP status codes for JSON-RPC 1.1 requests...")
@@ -204,11 +201,11 @@ class RPCInterfaceTest(BitcoinTestFramework):
         expect_http_rpc_status(200, RPC_INVALID_PARAMETER,  self.nodes[0], "getblockhash", [42], 2, False)
         # force-send invalidly formatted requests
         response, status = send_json_rpc(self.nodes[0], {"jsonrpc": 2, "method": "getblockcount"})
-        assert_equal(response, {"result": 0, "error": None})
-        assert_equal(status, 200)
+        assert_equal(response, {"result": None, "error": {"code": RPC_INVALID_REQUEST, "message": "jsonrpc field must be a string"}})
+        assert_equal(status, 400)
         response, status = send_json_rpc(self.nodes[0], {"jsonrpc": "3.0", "method": "getblockcount"})
-        assert_equal(response, {"result": 0, "error": None})
-        assert_equal(status, 200)
+        assert_equal(response, {"result": None, "error": {"code": RPC_INVALID_REQUEST, "message": "JSON-RPC version not supported"}})
+        assert_equal(status, 400)
 
         self.log.info("Testing HTTP status codes for JSON-RPC 2.0 notifications...")
         # Not notification: id exists
diff --git a/test/functional/interface_zmq.py b/test/functional/interface_zmq.py
index 5225022f41..b960f40ccc 100755
--- a/test/functional/interface_zmq.py
+++ b/test/functional/interface_zmq.py
@@ -3,8 +3,6 @@
 # Distributed under the MIT software license, see the accompanying
 # file COPYING or http://www.opensource.org/licenses/mit-license.php.
 """Test the ZMQ notification interface."""
-
-import io
 import os
 import struct
 import tempfile
@@ -25,7 +23,6 @@ from test_framework.messages import (
     CBlock,
     hash256,
     tx_from_hex,
-    CTransaction,
 )
 from test_framework.util import (
     assert_equal,
@@ -56,12 +53,10 @@ class ZMQSubscriber:
         self.socket.setsockopt(zmq.SUBSCRIBE, self.topic)
 
     # Receive message from publisher and verify that topic and sequence match
-    def _receive_from_publisher_and_check(self, specific_topic = None):
-        expected_topic = specific_topic if specific_topic else self.topic
-
+    def _receive_from_publisher_and_check(self):
         topic, body, seq = self.socket.recv_multipart()
         # Topic should match the subscriber topic.
-        assert_equal(topic, expected_topic)
+        assert_equal(topic, self.topic)
         # Sequence should be incremental.
         received_seq = struct.unpack('<I', seq)[-1]
         if self.sequence is None:
@@ -71,8 +66,8 @@ class ZMQSubscriber:
         self.sequence += 1
         return body
 
-    def receive(self, specific_topic = None):
-        return self._receive_from_publisher_and_check(specific_topic)
+    def receive(self):
+        return self._receive_from_publisher_and_check()
 
     def receive_sequence(self):
         body = self._receive_from_publisher_and_check()
@@ -95,10 +90,7 @@ class ZMQTestSetupBlock:
     raw transaction data.
     """
     def __init__(self, test_framework, node):
-        if test_framework.is_wallet_compiled():
-            self.block_hash = test_framework.generatetoaddress(node, nblocks=1, address=node.getnewaddress(), maxtries=1000000, sync_fun=test_framework.no_op)[0]
-        else:
-            self.block_hash = test_framework.generate(node, 1, sync_fun=test_framework.no_op)[0]
+        self.block_hash = test_framework.generate(node, 1, sync_fun=test_framework.no_op)[0]
         coinbase = node.getblock(self.block_hash, 2)['tx'][0]
         self.tx_hash = coinbase['txid']
         self.raw_tx = coinbase['hex']
@@ -114,16 +106,11 @@ class ZMQTestSetupBlock:
 
 
 class ZMQTest (BitcoinTestFramework):
-    def add_options(self, parser):
-        self.add_wallet_options(parser)
-
     def set_test_params(self):
         self.num_nodes = 2
         # whitelist peers to speed up tx relay / mempool sync
         self.noban_tx_relay = True
         self.zmq_port_base = p2p_port(self.num_nodes + 1)
-        if self.is_wallet_compiled():
-            self.skip_if_no_wallet()
 
     def skip_test_if_missing_module(self):
         self.skip_if_no_py3_zmq()
@@ -176,10 +163,7 @@ class ZMQTest (BitcoinTestFramework):
             recv_failed = False
             for sub in subscribers:
                 try:
-                    specific_topic = sub.topic
-                    if b'wallet' in sub.topic:
-                        specific_topic += b"-block"
-                    while not test_block.caused_notification(sub.receive(specific_topic=specific_topic).hex()):
+                    while not test_block.caused_notification(sub.receive().hex()):
                         self.log.debug("Ignoring sync-up notification for previously generated block.")
                 except zmq.error.Again:
                     self.log.debug("Didn't receive sync-up notification, trying again.")
@@ -211,36 +195,16 @@ class ZMQTest (BitcoinTestFramework):
             socket_path = tempfile.NamedTemporaryFile().name
             address = f"ipc://{socket_path}"
 
-        services = ["hashblock", "hashtx", "rawblock", "rawtx"]
-        if self.is_wallet_compiled():
-            services += ["hashwallettx", "rawwallettx"]
-        subs = self.setup_zmq_test([(topic, address) for topic in services])
+        subs = self.setup_zmq_test([(topic, address) for topic in ["hashblock", "hashtx", "rawblock", "rawtx"]])
 
         hashblock = subs[0]
         hashtx = subs[1]
         rawblock = subs[2]
         rawtx = subs[3]
-        if self.is_wallet_compiled():
-            hashwallettx = subs[-2]
-            rawwallettx = subs[-1]
-
-            self.sync_all()
-            # Flush initial wallettx events before we begin
-            while True:
-                try:
-                    topic, body, seq = hashwallettx.socket.recv_multipart()
-                except zmq.ZMQError:
-                    break
-                subscriber = {b'hashwallettx-block': hashwallettx, b'rawwallettx-block': rawwallettx}[topic]
-                assert_equal(struct.unpack('<I', seq)[-1], subscriber.sequence)
-                subscriber.sequence += 1
 
         num_blocks = 5
         self.log.info(f"Generate {num_blocks} blocks (and {num_blocks} coinbase txes)")
-        if self.is_wallet_compiled():
-            genhashes = self.generate(self.nodes[0], num_blocks)
-        else:
-            genhashes = self.generatetoaddress(self.nodes[0], num_blocks, ADDRESS_BCRT1_UNSPENDABLE)
+        genhashes = self.generatetoaddress(self.nodes[0], num_blocks, ADDRESS_BCRT1_UNSPENDABLE)
 
         for x in range(num_blocks):
             # Should receive the coinbase txid.
@@ -260,15 +224,6 @@ class ZMQTest (BitcoinTestFramework):
             assert_equal(len(block.vtx), 1)
             assert_equal(genhashes[x], hash256_reversed(hex[:80]).hex())
 
-            if self.is_wallet_compiled():
-                # Should receive wallet tx
-                wallettxid = hashwallettx.receive(b"hashwallettx-block")
-                wallethex = rawwallettx.receive(b"rawwallettx-block")
-                wallettx = CTransaction()
-                wallettx.deserialize(io.BytesIO(wallethex))
-                wallettx.calc_sha256()
-                assert_equal(wallettx.hash, wallettxid.hex())
-
             # Should receive the generated block hash.
             hash = hashblock.receive().hex()
             assert_equal(genhashes[x], hash)
@@ -277,12 +232,8 @@ class ZMQTest (BitcoinTestFramework):
 
 
         self.log.info("Wait for tx from second node")
-        if self.is_wallet_compiled():
-            payment_txid = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)
-            payment_tx = {'wtxid': self.nodes[1].getrawtransaction(payment_txid, 1)['hash']}
-        else:
-            payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])
-            payment_txid = payment_tx['txid']
+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])
+        payment_txid = payment_tx['txid']
         self.sync_all()
         # Should receive the broadcasted txid.
         txid = hashtx.receive()
@@ -299,22 +250,13 @@ class ZMQTest (BitcoinTestFramework):
         txid = hashtx.receive()
         assert_equal(payment_txid, txid.hex())
 
-        if self.is_wallet_compiled():
-            wallettxid = hashwallettx.receive(b"hashwallettx-mempool")
-            wallethex = rawwallettx.receive(b"rawwallettx-mempool")
-            wallettx = CTransaction()
-            wallettx.deserialize(io.BytesIO(wallethex))
-            wallettx.calc_sha256()
-            assert_equal(wallettx.hash, wallettxid.hex())
 
         self.log.info("Test the getzmqnotifications RPC")
         assert_equal(self.nodes[0].getzmqnotifications(), [
             {"type": "pubhashblock", "address": address, "hwm": 1000},
             {"type": "pubhashtx", "address": address, "hwm": 1000},
-            ] + ([{"type": "pubhashwallettx", "address": address, "hwm": 1000}] if self.is_wallet_compiled() else []) + [
             {"type": "pubrawblock", "address": address, "hwm": 1000},
             {"type": "pubrawtx", "address": address, "hwm": 1000},
-            ] + ([{"type": "pubrawwallettx", "address": address, "hwm": 1000}] if self.is_wallet_compiled() else []) + [
         ])
 
         assert_equal(self.nodes[1].getzmqnotifications(), [])
diff --git a/test/functional/mempool_accept.py b/test/functional/mempool_accept.py
index 0150150276..4d08575255 100755
--- a/test/functional/mempool_accept.py
+++ b/test/functional/mempool_accept.py
@@ -405,7 +405,7 @@ class MempoolAcceptanceTest(BitcoinTestFramework):
         anchor_nonempty_wit_spend.rehash()
 
         self.check_mempool_result(
-            result_expected=[{'txid': anchor_nonempty_wit_spend.rehash(), 'allowed': False, 'reject-reason': 'bad-witness-anchor-not-empty'}],
+            result_expected=[{'txid': anchor_nonempty_wit_spend.rehash(), 'allowed': False, 'reject-reason': 'bad-witness-nonstandard'}],
             rawtxs=[anchor_nonempty_wit_spend.serialize().hex()],
             maxfeerate=0,
         )
diff --git a/test/functional/mempool_fee_histogram.py b/test/functional/mempool_fee_histogram.py
deleted file mode 100755
index 47ccc16886..0000000000
--- a/test/functional/mempool_fee_histogram.py
+++ /dev/null
@@ -1,221 +0,0 @@
-#!/usr/bin/env python3
-# Copyright (c) 2023 The Bitcoin Core developers
-# Distributed under the MIT software license, see the accompanying
-# file COPYING or http://www.opensource.org/licenses/mit-license.php.
-"""Test mempool fee histogram."""
-
-from decimal import Decimal
-
-from test_framework.blocktools import COINBASE_MATURITY
-from test_framework.messages import (
-    COIN,
-)
-from test_framework.test_framework import BitcoinTestFramework
-from test_framework.util import (
-    assert_equal,
-    assert_greater_than,
-    assert_greater_than_or_equal,
-)
-
-def get_actual_fee_rate(fee_in_satoshis, vsize):
-    # NOTE: Must round down, unlike ceildiv/get_fee
-    fee_rate = fee_in_satoshis // vsize
-    return str(fee_rate)
-
-def get_tx_details(node, txid):
-    info = node.gettransaction(txid=txid)
-    info.update(node.getrawtransaction(txid=txid, verbose=True))
-    info['fee'] = int(-info['fee'] * COIN)  # convert to satoshis
-    info['feerate'] = get_actual_fee_rate(info['fee'], info['vsize'])
-    return info
-
-class MempoolFeeHistogramTest(BitcoinTestFramework):
-    def add_options(self, parser):
-        self.add_wallet_options(parser)
-
-    def set_test_params(self):
-        self.setup_clean_chain = True
-        self.num_nodes = 1
-
-    def skip_test_if_missing_module(self):
-        self.skip_if_no_wallet()
-
-    def run_test(self):
-        node = self.nodes[0]
-        self.generate(self.nodes[0], COINBASE_MATURITY + 2, sync_fun=self.no_op)
-
-        # We have two UTXOs (utxo_1 and utxo_2) and we create three changeless transactions:
-        # - tx1 (5 sat/vB): spending utxo_1
-        # - tx2 (14 sat/vB): spending output from tx1
-        # - tx3 (6 sat/vB): spending utxo_2 and the output from tx2
-
-        self.log.info("Test getmempoolinfo does not return fee histogram by default")
-        assert ("fee_histogram" not in node.getmempoolinfo())
-
-        self.log.info("Test getmempoolinfo returns empty fee histogram when mempool is empty")
-        info = node.getmempoolinfo([1, 2, 3])
-
-        (non_empty_groups, empty_groups, total_fees) = self.histogram_stats(info['fee_histogram'])
-        assert_equal(0, non_empty_groups)
-        assert_equal(3, empty_groups)
-        assert_equal(0, total_fees)
-
-        for i in ['1', '2', '3']:
-            assert_equal(0, info['fee_histogram'][i]['sizes'])
-            assert_equal(0, info['fee_histogram'][i]['count'])
-            assert_equal(0, info['fee_histogram'][i]['fees'])
-            assert_equal(int(i), info['fee_histogram'][i]['from_feerate'])
-
-        self.log.info("Test that we have two spendable UTXOs and lock the second one")
-        utxos = node.listunspent()
-        assert_equal(2, len(utxos))
-        node.lockunspent(False, [{"txid": utxos[1]["txid"], "vout": utxos[1]["vout"]}])
-
-        self.log.info("Send tx1 transaction with 5 sat/vB fee rate")
-        tx1_txid = node.sendtoaddress(address=node.getnewaddress(), amount=Decimal("50.0"), fee_rate=5, subtractfeefromamount=True)
-        tx1_info = get_tx_details(node, tx1_txid)
-
-        self.log.info(f"Test fee rate histogram when mempool contains 1 transaction (tx1: {tx1_info['feerate']} sat/vB)")
-        info = node.getmempoolinfo([1, 3, 5, 10])
-        (non_empty_groups, empty_groups, total_fees) = self.histogram_stats(info['fee_histogram'])
-        assert_equal(1, non_empty_groups)
-        assert_equal(3, empty_groups)
-        assert_equal(1, info['fee_histogram'][tx1_info['feerate']]['count'])
-        assert_equal(total_fees, info['fee_histogram']['total_fees'])
-
-        assert_equal(0, info['fee_histogram']['1']['sizes'])
-        assert_equal(0, info['fee_histogram']['1']['count'])
-        assert_equal(0, info['fee_histogram']['1']['fees'])
-        assert_equal(1, info['fee_histogram']['1']['from_feerate'])
-
-        assert_equal(0, info['fee_histogram']['3']['sizes'])
-        assert_equal(0, info['fee_histogram']['3']['count'])
-        assert_equal(0, info['fee_histogram']['3']['fees'])
-        assert_equal(3, info['fee_histogram']['3']['from_feerate'])
-
-        assert_equal(tx1_info['vsize'], info['fee_histogram']['5']['sizes'])
-        assert_equal(1, info['fee_histogram']['5']['count'])
-        assert_equal(tx1_info['fee'], info['fee_histogram']['5']['fees'])
-        assert_equal(5, info['fee_histogram']['5']['from_feerate'])
-
-        assert_equal(0, info['fee_histogram']['10']['sizes'])
-        assert_equal(0, info['fee_histogram']['10']['count'])
-        assert_equal(0, info['fee_histogram']['10']['fees'])
-        assert_equal(10, info['fee_histogram']['10']['from_feerate'])
-
-        self.log.info("Send tx2 transaction with 14 sat/vB fee rate (spends tx1 UTXO)")
-        tx2_txid = node.sendtoaddress(address=node.getnewaddress(), amount=Decimal("25.0"), fee_rate=14, subtractfeefromamount=True)
-        tx2_info = get_tx_details(node, tx2_txid)
-
-        self.log.info(f"Test fee rate histogram when mempool contains 2 transactions (tx1: {tx1_info['feerate']} sat/vB, tx2: {tx2_info['feerate']} sat/vB)")
-        info = node.getmempoolinfo([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])
-
-        # Verify that both tx1 and tx2 are reported in 8 sat/vB fee rate group
-        (non_empty_groups, empty_groups, total_fees) = self.histogram_stats(info['fee_histogram'])
-        tx1p2_feerate = get_actual_fee_rate(tx1_info['fee'] + tx2_info['fee'], tx1_info['vsize'] + tx2_info['vsize'])
-        assert_equal(1, non_empty_groups)
-        assert_equal(14, empty_groups)
-        assert_equal(2, info['fee_histogram'][tx1p2_feerate]['count'])
-        assert_equal(total_fees, info['fee_histogram']['total_fees'])
-
-        # Unlock the second UTXO which we locked
-        node.lockunspent(True, [{"txid": utxos[1]["txid"], "vout": utxos[1]["vout"]}])
-
-        self.log.info("Send tx3 transaction with 6 sat/vB fee rate (spends all available UTXOs)")
-        tx3_txid = node.sendtoaddress(address=node.getnewaddress(), amount=Decimal("99.9"), fee_rate=6, subtractfeefromamount=True)
-        tx3_info = get_tx_details(node, tx3_txid)
-
-        self.log.info(f"Test fee rate histogram when mempool contains 3 transactions (tx1: {tx1_info['feerate']} sat/vB, tx2: {tx2_info['feerate']} sat/vB, tx3: {tx3_info['feerate']} sat/vB)")
-        info = node.getmempoolinfo([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])
-
-        # Verify that each of 6, 8 and 9 sat/vB fee rate groups contain one transaction
-        # tx1 should be grouped with tx2 + tx3 (descendants)
-        # tx2 should be grouped with tx1 (ancestors only)
-        # tx3 should be alone
-        expected_histogram = dict(
-            tuple(
-                (str(n), {
-                    'from_feerate': n,
-                    'to_feerate': n + 1,
-                    'count': 0,
-                    'fees': 0,
-                    'sizes': 0,
-                }) for n in range(1, 16)
-            ) + (
-                ('total_fees', tx1_info['fee'] + tx2_info['fee'] + tx3_info['fee']),
-            )
-        )
-        expected_frg = expected_histogram
-        expected_frg['15']['to_feerate'] = 9223372036854775807
-        tx1p2p3_feerate = get_actual_fee_rate(expected_histogram['total_fees'], tx1_info['vsize'] + tx2_info['vsize'] + tx3_info['vsize'])
-        def inc_expected(feerate, txinfo):
-            this_frg = expected_frg[feerate]
-            this_frg['count'] += 1
-            this_frg['fees'] += txinfo['fee']
-            this_frg['sizes'] += txinfo['vsize']
-        inc_expected(tx1p2p3_feerate, tx1_info)
-        inc_expected(tx1p2_feerate, tx2_info)
-        inc_expected(tx3_info['feerate'], tx3_info)
-
-        assert_equal(expected_histogram, info['fee_histogram'])
-
-        self.log.info("Test fee rate histogram with default groups")
-        info = node.getmempoolinfo(with_fee_histogram=True)
-
-        # Verify that the 6 sat/vB fee rate group has one transaction, and the 8-9 sat/vB fee rate group has two
-        for collapse_n in (9, 11, 13, 15):
-            for field in ('count', 'sizes', 'fees'):
-                expected_frg[str(collapse_n - 1)][field] += expected_frg[str(collapse_n)][field]
-            expected_frg[str(collapse_n - 1)]['to_feerate'] += 1
-            del expected_frg[str(collapse_n)]
-        expected_frg['14']['to_feerate'] += 1  # 16 is also skipped
-
-        for new_n in (17, 20, 25) + tuple(range(30, 90, 10)) + (100, 120, 140, 170, 200, 250) + tuple(range(300, 900, 100)) + (1000, 1200, 1400, 1700, 2000, 2500) + tuple(range(3000, 9000, 1000)) + (10000,):
-            frinfo = info['fee_histogram'][str(new_n)]
-            assert frinfo['to_feerate'] > frinfo['from_feerate']
-            del frinfo['to_feerate']
-            assert_equal(frinfo, {
-                'from_feerate': new_n,
-                'count': 0,
-                'fees': 0,
-                'sizes': 0,
-            })
-            del info['fee_histogram'][str(new_n)]
-        assert_equal(expected_histogram, info['fee_histogram'])
-
-        self.log.info("Test getmempoolinfo(with_fee_histogram=False) does not return fee histogram")
-        assert('fee_histogram' not in node.getmempoolinfo(with_fee_histogram=False))
-
-    def histogram_stats(self, histogram):
-        total_fees = 0
-        empty_count = 0
-        non_empty_count = 0
-
-        for key, bin in histogram.items():
-            if key == 'total_fees':
-                continue
-            assert_equal(int(key), bin['from_feerate'])
-            if bin['fees'] > 0:
-                assert_greater_than(bin['count'], 0)
-            else:
-                assert_equal(bin['count'], 0)
-            assert_greater_than_or_equal(bin['fees'], 0)
-            assert_greater_than_or_equal(bin['sizes'], 0)
-            if bin['to_feerate'] is not None:
-                assert_greater_than_or_equal(bin['to_feerate'], bin['from_feerate'])
-                for next_key in sorted((*(int(a) for a in histogram.keys() if a != 'total_fees'), 0x7fffffffffffffff)):
-                    if int(next_key) <= int(key):
-                        continue
-                    assert_equal(bin['to_feerate'], int(next_key))
-                    break
-            total_fees += bin['fees']
-
-            if bin['count'] == 0:
-                empty_count += 1
-            else:
-                non_empty_count += 1
-
-        return (non_empty_count, empty_count, total_fees)
-
-if __name__ == '__main__':
-    MempoolFeeHistogramTest(__file__).main()
diff --git a/test/functional/mempool_truc.py b/test/functional/mempool_truc.py
index 6082f87973..28f3256ef1 100755
--- a/test/functional/mempool_truc.py
+++ b/test/functional/mempool_truc.py
@@ -57,7 +57,7 @@ class MempoolTRUC(BitcoinTestFramework):
         self.log.info("Test TRUC-specific maximum transaction vsize")
         tx_v3_heavy = self.wallet.create_self_transfer(target_weight=(TRUC_MAX_VSIZE + 1) * WITNESS_SCALE_FACTOR, version=3)
         assert_greater_than_or_equal(tx_v3_heavy["tx"].get_vsize(), TRUC_MAX_VSIZE)
-        expected_error_heavy = f"truc-vsize-toobig, version=3 tx {tx_v3_heavy['txid']} (wtxid={tx_v3_heavy['wtxid']}) is too big"
+        expected_error_heavy = f"TRUC-violation, version=3 tx {tx_v3_heavy['txid']} (wtxid={tx_v3_heavy['wtxid']}) is too big"
         assert_raises_rpc_error(-26, expected_error_heavy, node.sendrawtransaction, tx_v3_heavy["hex"])
         self.check_mempool([])
 
@@ -77,7 +77,7 @@ class MempoolTRUC(BitcoinTestFramework):
             version=3
         )
         assert_greater_than_or_equal(tx_v3_child_heavy["tx"].get_vsize(), 1000)
-        expected_error_child_heavy = f"truc-child-toobig, version=3 child tx {tx_v3_child_heavy['txid']} (wtxid={tx_v3_child_heavy['wtxid']}) is too big"
+        expected_error_child_heavy = f"TRUC-violation, version=3 child tx {tx_v3_child_heavy['txid']} (wtxid={tx_v3_child_heavy['wtxid']}) is too big"
         assert_raises_rpc_error(-26, expected_error_child_heavy, node.sendrawtransaction, tx_v3_child_heavy["hex"])
         self.check_mempool([tx_v3_parent_normal["txid"]])
         # tx has no descendants
@@ -157,7 +157,7 @@ class MempoolTRUC(BitcoinTestFramework):
             utxo_to_spend=tx_v3_parent["new_utxo"],
             version=2
         )
-        expected_error_v2_v3 = f"truc-spent-by-nontruc, non-version=3 tx {tx_v3_child_rbf_v2['txid']} (wtxid={tx_v3_child_rbf_v2['wtxid']}) cannot spend from version=3 tx {tx_v3_parent['txid']} (wtxid={tx_v3_parent['wtxid']})"
+        expected_error_v2_v3 = f"TRUC-violation, non-version=3 tx {tx_v3_child_rbf_v2['txid']} (wtxid={tx_v3_child_rbf_v2['wtxid']}) cannot spend from version=3 tx {tx_v3_parent['txid']} (wtxid={tx_v3_parent['wtxid']})"
         assert_raises_rpc_error(-26, expected_error_v2_v3, node.sendrawtransaction, tx_v3_child_rbf_v2["hex"])
         self.check_mempool([tx_v3_bip125_rbf_v2["txid"], tx_v3_parent["txid"], tx_v3_child["txid"]])
 
@@ -289,20 +289,20 @@ class MempoolTRUC(BitcoinTestFramework):
 
         self.check_mempool([])
         result = node.submitpackage([tx_v3_parent_normal["hex"], tx_v3_parent_2_normal["hex"], tx_v3_child_multiparent["hex"]])
-        assert_equal(result['package_msg'], f"truc-ancestors-toomany, tx {tx_v3_child_multiparent['txid']} (wtxid={tx_v3_child_multiparent['wtxid']}) would have too many ancestors")
+        assert_equal(result['package_msg'], f"TRUC-violation, tx {tx_v3_child_multiparent['txid']} (wtxid={tx_v3_child_multiparent['wtxid']}) would have too many ancestors")
         self.check_mempool([])
 
         self.check_mempool([])
         result = node.submitpackage([tx_v3_parent_normal["hex"], tx_v3_child_heavy["hex"]])
         # tx_v3_child_heavy is heavy based on weight, not sigops.
-        assert_equal(result['package_msg'], f"truc-child-toobig, version=3 child tx {tx_v3_child_heavy['txid']} (wtxid={tx_v3_child_heavy['wtxid']}) is too big: {tx_v3_child_heavy['tx'].get_vsize()} > 1000 virtual bytes")
+        assert_equal(result['package_msg'], f"TRUC-violation, version=3 child tx {tx_v3_child_heavy['txid']} (wtxid={tx_v3_child_heavy['wtxid']}) is too big: {tx_v3_child_heavy['tx'].get_vsize()} > 1000 virtual bytes")
         self.check_mempool([])
 
         tx_v3_parent = self.wallet.create_self_transfer(version=3)
         tx_v3_child = self.wallet.create_self_transfer(utxo_to_spend=tx_v3_parent["new_utxo"], version=3)
         tx_v3_grandchild = self.wallet.create_self_transfer(utxo_to_spend=tx_v3_child["new_utxo"], version=3)
         result = node.testmempoolaccept([tx_v3_parent["hex"], tx_v3_child["hex"], tx_v3_grandchild["hex"]])
-        assert all([txresult["package-error"] == f"truc-parent-and-child-both, tx {tx_v3_grandchild['txid']} (wtxid={tx_v3_grandchild['wtxid']}) would have too many ancestors" for txresult in result])
+        assert all([txresult["package-error"] == f"TRUC-violation, tx {tx_v3_grandchild['txid']} (wtxid={tx_v3_grandchild['wtxid']}) would have too many ancestors" for txresult in result])
 
     @cleanup(extra_args=None)
     def test_truc_ancestors_package_and_mempool(self):
@@ -331,7 +331,7 @@ class MempoolTRUC(BitcoinTestFramework):
 
         # submitpackage(B, C) should fail
         result = node.submitpackage([tx_0fee_parent["hex"], tx_child_violator["hex"]])
-        assert_equal(result['package_msg'], f"truc-parent-and-child-both, tx {tx_child_violator['txid']} (wtxid={tx_child_violator['wtxid']}) would have too many ancestors")
+        assert_equal(result['package_msg'], f"TRUC-violation, tx {tx_child_violator['txid']} (wtxid={tx_child_violator['wtxid']}) would have too many ancestors")
         self.check_mempool([tx_in_mempool["txid"]])
 
     @cleanup(extra_args=None)
@@ -384,17 +384,17 @@ class MempoolTRUC(BitcoinTestFramework):
         # Fails with another non-related transaction via testmempoolaccept
         tx_unrelated = self.wallet.create_self_transfer(version=3)
         result_test_unrelated = node.testmempoolaccept([tx_sibling_1["hex"], tx_unrelated["hex"]])
-        assert_equal(result_test_unrelated[0]["reject-reason"], "truc-descendants-toomany")
+        assert_equal(result_test_unrelated[0]["reject-reason"], "TRUC-violation")
 
         # Fails in a package via testmempoolaccept
         result_test_1p1c = node.testmempoolaccept([tx_sibling_1["hex"], tx_has_mempool_uncle["hex"]])
-        assert_equal(result_test_1p1c[0]["reject-reason"], "truc-descendants-toomany")
+        assert_equal(result_test_1p1c[0]["reject-reason"], "TRUC-violation")
 
         # Allowed when tx is submitted in a package and evaluated individually.
         # Note that the child failed since it would be the 3rd generation.
         result_package_indiv = node.submitpackage([tx_sibling_1["hex"], tx_has_mempool_uncle["hex"]])
         self.check_mempool([tx_mempool_parent["txid"], tx_sibling_1["txid"]])
-        expected_error_gen3 = f"truc-ancestors-toomany, tx {tx_has_mempool_uncle['txid']} (wtxid={tx_has_mempool_uncle['wtxid']}) would have too many ancestors"
+        expected_error_gen3 = f"TRUC-violation, tx {tx_has_mempool_uncle['txid']} (wtxid={tx_has_mempool_uncle['wtxid']}) would have too many ancestors"
 
         assert_equal(result_package_indiv["tx-results"][tx_has_mempool_uncle['wtxid']]['error'], expected_error_gen3)
 
@@ -405,7 +405,7 @@ class MempoolTRUC(BitcoinTestFramework):
         # Child cannot pay for sibling eviction for parent, as it violates TRUC topology limits
         result_package_cpfp = node.submitpackage([tx_sibling_3["hex"], tx_bumps_parent_with_sibling["hex"]])
         self.check_mempool([tx_mempool_parent["txid"], tx_sibling_2["txid"]])
-        expected_error_cpfp = f"truc-descendants-toomany, tx {tx_mempool_parent['txid']} (wtxid={tx_mempool_parent['wtxid']}) would exceed descendant count limit"
+        expected_error_cpfp = f"TRUC-violation, tx {tx_mempool_parent['txid']} (wtxid={tx_mempool_parent['wtxid']}) would exceed descendant count limit"
 
         assert_equal(result_package_cpfp["tx-results"][tx_sibling_3['wtxid']]['error'], expected_error_cpfp)
 
@@ -426,7 +426,7 @@ class MempoolTRUC(BitcoinTestFramework):
         )
         self.check_mempool([])
         result = node.submitpackage([tx_v3_parent["hex"], tx_v2_child["hex"]])
-        assert_equal(result['package_msg'], f"truc-spent-by-nontruc, non-version=3 tx {tx_v2_child['txid']} (wtxid={tx_v2_child['wtxid']}) cannot spend from version=3 tx {tx_v3_parent['txid']} (wtxid={tx_v3_parent['wtxid']})")
+        assert_equal(result['package_msg'], f"TRUC-violation, non-version=3 tx {tx_v2_child['txid']} (wtxid={tx_v2_child['wtxid']}) cannot spend from version=3 tx {tx_v3_parent['txid']} (wtxid={tx_v3_parent['wtxid']})")
         self.check_mempool([])
 
     @cleanup(extra_args=None)
@@ -447,11 +447,11 @@ class MempoolTRUC(BitcoinTestFramework):
         assert all([result["allowed"] for result in test_accept_v2_and_v3])
 
         test_accept_v3_from_v2 = node.testmempoolaccept([tx_v2["hex"], tx_v3_from_v2["hex"]])
-        expected_error_v3_from_v2 = f"truc-spends-nontruc, version=3 tx {tx_v3_from_v2['txid']} (wtxid={tx_v3_from_v2['wtxid']}) cannot spend from non-version=3 tx {tx_v2['txid']} (wtxid={tx_v2['wtxid']})"
+        expected_error_v3_from_v2 = f"TRUC-violation, version=3 tx {tx_v3_from_v2['txid']} (wtxid={tx_v3_from_v2['wtxid']}) cannot spend from non-version=3 tx {tx_v2['txid']} (wtxid={tx_v2['wtxid']})"
         assert all([result["package-error"] == expected_error_v3_from_v2 for result in test_accept_v3_from_v2])
 
         test_accept_v2_from_v3 = node.testmempoolaccept([tx_v3["hex"], tx_v2_from_v3["hex"]])
-        expected_error_v2_from_v3 = f"truc-spent-by-nontruc, non-version=3 tx {tx_v2_from_v3['txid']} (wtxid={tx_v2_from_v3['wtxid']}) cannot spend from version=3 tx {tx_v3['txid']} (wtxid={tx_v3['wtxid']})"
+        expected_error_v2_from_v3 = f"TRUC-violation, non-version=3 tx {tx_v2_from_v3['txid']} (wtxid={tx_v2_from_v3['wtxid']}) cannot spend from version=3 tx {tx_v3['txid']} (wtxid={tx_v3['wtxid']})"
         assert all([result["package-error"] == expected_error_v2_from_v3 for result in test_accept_v2_from_v3])
 
         test_accept_pairs = node.testmempoolaccept([tx_v2["hex"], tx_v3["hex"], tx_v2_from_v2["hex"], tx_v3_from_v3["hex"]])
@@ -463,7 +463,7 @@ class MempoolTRUC(BitcoinTestFramework):
         tx_v3_child_1 = self.wallet.create_self_transfer(utxo_to_spend=tx_v3_parent["new_utxos"][0], version=3)
         tx_v3_child_2 = self.wallet.create_self_transfer(utxo_to_spend=tx_v3_parent["new_utxos"][1], version=3)
         test_accept_2children = node.testmempoolaccept([tx_v3_parent["hex"], tx_v3_child_1["hex"], tx_v3_child_2["hex"]])
-        expected_error_2children = f"truc-sibling-known, tx {tx_v3_parent['txid']} (wtxid={tx_v3_parent['wtxid']}) would exceed descendant count limit"
+        expected_error_2children = f"TRUC-violation, tx {tx_v3_parent['txid']} (wtxid={tx_v3_parent['wtxid']}) would exceed descendant count limit"
         assert all([result["package-error"] == expected_error_2children for result in test_accept_2children])
 
         # Extra TRUC transaction does not get incorrectly marked as extra descendant
@@ -472,7 +472,7 @@ class MempoolTRUC(BitcoinTestFramework):
 
         # Extra TRUC transaction does not make us ignore the extra descendant
         test_accept_2children_with_exra = node.testmempoolaccept([tx_v3_parent["hex"], tx_v3_child_1["hex"], tx_v3_child_2["hex"], tx_v3_independent["hex"]])
-        expected_error_extra = f"truc-sibling-known, tx {tx_v3_parent['txid']} (wtxid={tx_v3_parent['wtxid']}) would exceed descendant count limit"
+        expected_error_extra = f"TRUC-violation, tx {tx_v3_parent['txid']} (wtxid={tx_v3_parent['wtxid']}) would exceed descendant count limit"
         assert all([result["package-error"] == expected_error_extra for result in test_accept_2children_with_exra])
         # Same result if the parent is already in mempool
         node.sendrawtransaction(tx_v3_parent["hex"])
@@ -609,7 +609,7 @@ class MempoolTRUC(BitcoinTestFramework):
             utxo_to_spend=tx_with_multi_children["new_utxos"][2],
             fee_rate=DEFAULT_FEE*50
         )
-        expected_error_2siblings = f"truc-descendants-toomany, tx {tx_with_multi_children['txid']} (wtxid={tx_with_multi_children['wtxid']}) would exceed descendant count limit"
+        expected_error_2siblings = f"TRUC-violation, tx {tx_with_multi_children['txid']} (wtxid={tx_with_multi_children['wtxid']}) would exceed descendant count limit"
         assert_raises_rpc_error(-26, expected_error_2siblings, node.sendrawtransaction, tx_with_sibling3["hex"])
 
         # However, an RBF (with conflicting inputs) is possible even if the resulting cluster size exceeds 2
diff --git a/test/functional/mining_basic.py b/test/functional/mining_basic.py
index 4cd7f8efb7..aca71933ec 100755
--- a/test/functional/mining_basic.py
+++ b/test/functional/mining_basic.py
@@ -16,7 +16,6 @@ from test_framework.blocktools import (
     get_witness_script,
     NORMAL_GBT_REQUEST_PARAMS,
     TIME_GENESIS_BLOCK,
-    WITNESS_SCALE_FACTOR,
 )
 from test_framework.messages import (
     BLOCK_HEADER_SIZE,
@@ -33,18 +32,15 @@ from test_framework.util import (
     assert_raises_rpc_error,
     get_fee,
 )
-from test_framework.wallet import MiniWallet, MiniWalletMode
+from test_framework.wallet import MiniWallet
 
 
 DIFFICULTY_ADJUSTMENT_INTERVAL = 144
 MAX_FUTURE_BLOCK_TIME = 2 * 3600
 MAX_TIMEWARP = 600
-ASSUMED_BLOCK_OVERHEAD_SIZE = 1000
-ASSUMED_BLOCK_OVERHEAD_WEIGHT = ASSUMED_BLOCK_OVERHEAD_SIZE * WITNESS_SCALE_FACTOR
 VERSIONBITS_TOP_BITS = 0x20000000
 VERSIONBITS_DEPLOYMENT_TESTDUMMY_BIT = 28
 DEFAULT_BLOCK_MIN_TX_FEE = 1000  # default `-blockmintxfee` setting [sat/kvB]
-MAX_SIGOP_COST = 80000
 
 
 def assert_template(node, block, expect, rehash=True):
@@ -73,7 +69,6 @@ class MiningTest(BitcoinTestFramework):
         assert_equal(mining_info['blocks'], 200)
         assert_equal(mining_info['currentblocktx'], 0)
         assert_equal(mining_info['currentblockweight'], 4000)
-        assert 'currentblocksize' not in mining_info
 
         self.log.info('test blockversion')
         self.restart_node(0, extra_args=[f'-mocktime={t}', '-blockversion=1337'])
@@ -85,21 +80,15 @@ class MiningTest(BitcoinTestFramework):
         self.restart_node(0)
         self.connect_nodes(0, 1)
 
-    def test_blockmintxfee_parameter(self, *, use_rpc=False):
-        if not use_rpc:
-            self.log.info("Test -blockmintxfee setting")
+    def test_blockmintxfee_parameter(self):
+        self.log.info("Test -blockmintxfee setting")
         self.restart_node(0, extra_args=['-minrelaytxfee=0', '-persistmempool=0'])
         node = self.nodes[0]
 
         # test default (no parameter), zero and a bunch of arbitrary blockmintxfee rates [sat/kvB]
         for blockmintxfee_sat_kvb in (DEFAULT_BLOCK_MIN_TX_FEE, 0, 50, 100, 500, 2500, 5000, 21000, 333333, 2500000):
             blockmintxfee_btc_kvb = blockmintxfee_sat_kvb / Decimal(COIN)
-            if use_rpc:
-                blockmintxfee_sat_vb = blockmintxfee_sat_kvb / 1000
-                self.log.info(f"-> Test RPC param minfeerate={blockmintxfee_sat_vb} ({blockmintxfee_sat_kvb} sat/kvB)...")
-                self.restart_node(0, extra_args=['-minrelaytxfee=0', '-persistmempool=0'])
-                self.wallet.rescan_utxos()  # to avoid spending outputs of txs that are not in mempool anymore after restart
-            elif blockmintxfee_sat_kvb == DEFAULT_BLOCK_MIN_TX_FEE:
+            if blockmintxfee_sat_kvb == DEFAULT_BLOCK_MIN_TX_FEE:
                 self.log.info(f"-> Default -blockmintxfee setting ({blockmintxfee_sat_kvb} sat/kvB)...")
             else:
                 blockmintxfee_parameter = f"-blockmintxfee={blockmintxfee_btc_kvb:.8f}"
@@ -119,124 +108,16 @@ class MiningTest(BitcoinTestFramework):
                 node.prioritisetransaction(tx_below_min_feerate["txid"], 0, -1)
 
             # check that tx below specified fee-rate is neither in template nor in the actual block
-            req = NORMAL_GBT_REQUEST_PARAMS
-            if use_rpc:
-                req = copy.deepcopy(req)
-                req['minfeerate'] = blockmintxfee_sat_vb
-            block_template = node.getblocktemplate(req)
+            block_template = node.getblocktemplate(NORMAL_GBT_REQUEST_PARAMS)
             block_template_txids = [tx['txid'] for tx in block_template['transactions']]
             self.generate(self.wallet, 1, sync_fun=self.no_op)
             block = node.getblock(node.getbestblockhash(), verbosity=2)
             block_txids = [tx['txid'] for tx in block['tx']]
 
             assert tx_with_min_feerate['txid'] in block_template_txids
+            assert tx_with_min_feerate['txid'] in block_txids
             assert tx_below_min_feerate['txid'] not in block_template_txids
-
-            if not use_rpc:
-                assert tx_with_min_feerate['txid'] in block_txids
-                assert tx_below_min_feerate['txid'] not in block_txids
-
-    def test_rpc_params(self):
-        self.log.info("Test minfeerate RPC param")
-        self.test_blockmintxfee_parameter(use_rpc=True)
-
-        node = self.nodes[0]
-
-        self.log.info("Preparing mempool")
-        self.restart_node(0, extra_args=['-limitancestorcount=1000', '-limitancestorsize=7000', '-limitdescendantcount=1000', '-limitdescendantsize=7000'])
-
-        # Fill the mempool
-        target_mempool_size = 200000
-        last_tx_size = 0
-        utxo = self.wallet.get_utxo()  # save for small coins
-        while node.getmempoolinfo()['bytes'] < target_mempool_size - last_tx_size:
-            tx = self.wallet.send_self_transfer_multi(
-                from_node=self.nodes[0],
-                num_outputs=1000,
-            )
-            last_tx_size = len(tx['hex']) / 2
-        while node.getmempoolinfo()['bytes'] < 200000:
-            tx = self.wallet.send_self_transfer_multi(
-                utxos_to_spend=[utxo],
-                from_node=node,
-                num_outputs=1,
-            )
-            utxo = tx['new_utxos'][0]
-
-        self.log.info("Test blockmaxsize RPC param")
-        req = copy.deepcopy(NORMAL_GBT_REQUEST_PARAMS)
-        normal_size = ASSUMED_BLOCK_OVERHEAD_SIZE + (sum(len(tx['data']) for tx in self.nodes[0].getblocktemplate(req)['transactions']) // 2)
-        last_size = ASSUMED_BLOCK_OVERHEAD_SIZE
-        for target_size in (50000, 100000, 150000):
-            self.log.info(f"-> Test RPC param blockmaxsize={target_size}...")
-            req['blockmaxsize'] = target_size
-            tmpl = self.nodes[0].getblocktemplate(req)
-            blk_size = ASSUMED_BLOCK_OVERHEAD_SIZE + (sum(len(tx['data']) for tx in tmpl['transactions']) // 2)
-            assert blk_size < normal_size
-            assert blk_size < target_size
-            assert blk_size > last_size
-            last_size = blk_size
-
-        self.log.info("Test blockreservedsize RPC param")
-        req = copy.deepcopy(NORMAL_GBT_REQUEST_PARAMS)
-        req['blockmaxsize'] = 150000
-        normal_size = (sum(len(tx['data']) for tx in self.nodes[0].getblocktemplate(req)['transactions']) // 2)
-        last_size = 0
-        for reserved_size in (100000, 10000, 100):
-            self.log.info(f"-> Test RPC param blockreservedsize={reserved_size}...")
-            req['blockreservedsize'] = reserved_size
-            tmpl = self.nodes[0].getblocktemplate(req)
-            blk_size = (sum(len(tx['data']) for tx in tmpl['transactions']) // 2)
-            assert blk_size < normal_size if reserved_size > 1000 else blk_size > normal_size
-            assert blk_size + reserved_size <= req['blockmaxsize']
-            assert blk_size > last_size
-            last_size = blk_size
-
-        self.log.info("Test blockmaxweight RPC param")
-        req = copy.deepcopy(NORMAL_GBT_REQUEST_PARAMS)
-        normal_weight = ASSUMED_BLOCK_OVERHEAD_WEIGHT + sum(tx['weight'] for tx in self.nodes[0].getblocktemplate(req)['transactions'])
-        last_weight = ASSUMED_BLOCK_OVERHEAD_WEIGHT
-        for target_weight in (200000, 400000, 600000):
-            self.log.info(f"-> Test RPC param blockmaxweight={target_weight}...")
-            req['blockmaxweight'] = target_weight
-            tmpl = self.nodes[0].getblocktemplate(req)
-            blk_weight = ASSUMED_BLOCK_OVERHEAD_WEIGHT + sum(tx['weight'] for tx in tmpl['transactions'])
-            assert blk_weight < normal_weight
-            assert blk_weight < target_weight
-            assert blk_weight > last_weight
-            last_weight = blk_weight
-
-        self.log.info("Test blockreservedweight RPC param")
-        req = copy.deepcopy(NORMAL_GBT_REQUEST_PARAMS)
-        req['blockmaxweight'] = 600000
-        normal_weight = sum(tx['weight'] for tx in self.nodes[0].getblocktemplate(req)['transactions'])
-        last_weight = 0
-        for reserved_weight in (400000, 40000, 400):
-            self.log.info(f"-> Test RPC param blockreservedweight={reserved_weight}...")
-            req['blockreservedweight'] = reserved_weight
-            tmpl = self.nodes[0].getblocktemplate(req)
-            blk_weight = sum(tx['weight'] for tx in tmpl['transactions'])
-            assert blk_weight < normal_weight if reserved_weight > 4000 else blk_weight > normal_weight
-            assert blk_weight + reserved_weight <= req['blockmaxweight']
-            assert blk_weight > last_weight
-            last_weight = blk_weight
-
-        self.log.info("Test blockreservedsigops RPC param")
-        req = copy.deepcopy(NORMAL_GBT_REQUEST_PARAMS)
-        normal_sigops = sum(tx['sigops'] for tx in self.nodes[0].getblocktemplate(req)['transactions'])
-        assert normal_sigops
-        last_sigops = 0
-        baseline_sigops = MAX_SIGOP_COST - normal_sigops
-        for reserved_sigops in (800, 400, 100):
-            reserved_sigops += baseline_sigops
-            self.log.info(f"-> Test RPC param blockreservedsigops={reserved_sigops}...")
-            req['blockreservedsigops'] = reserved_sigops
-            tmpl = self.nodes[0].getblocktemplate(req)
-            blk_sigops = sum(tx['sigops'] for tx in tmpl['transactions'])
-            assert blk_sigops < normal_sigops if reserved_sigops > 400 else blk_sigops > normal_sigops
-            assert blk_sigops + reserved_sigops <= MAX_SIGOP_COST
-            assert blk_sigops > last_sigops
-            last_sigops = blk_sigops
+            assert tx_below_min_feerate['txid'] not in block_txids
 
     def test_timewarp(self):
         self.log.info("Test timewarp attack mitigation (BIP94)")
@@ -289,7 +170,7 @@ class MiningTest(BitcoinTestFramework):
 
     def run_test(self):
         node = self.nodes[0]
-        self.wallet = MiniWallet(node, mode=MiniWalletMode.RAW_P2PK)
+        self.wallet = MiniWallet(node)
         self.mine_chain()
 
         def assert_submitblock(block, result_str_1, result_str_2=None):
@@ -304,7 +185,6 @@ class MiningTest(BitcoinTestFramework):
         assert_equal(mining_info['chain'], self.chain)
         assert 'currentblocktx' not in mining_info
         assert 'currentblockweight' not in mining_info
-        assert 'currentblocksize' not in mining_info
         assert_equal(mining_info['difficulty'], Decimal('4.656542373906925E-10'))
         assert_equal(mining_info['networkhashps'], Decimal('0.003333333333333334'))
         assert_equal(mining_info['pooledtx'], 0)
@@ -495,7 +375,6 @@ class MiningTest(BitcoinTestFramework):
         assert_equal(node.submitblock(hexdata=block.serialize().hex()), 'duplicate')  # valid
 
         self.test_blockmintxfee_parameter()
-        self.test_rpc_params()
         self.test_timewarp()
 
 
diff --git a/test/functional/mining_coin_age_priority.py b/test/functional/mining_coin_age_priority.py
deleted file mode 100755
index a063f7673f..0000000000
--- a/test/functional/mining_coin_age_priority.py
+++ /dev/null
@@ -1,191 +0,0 @@
-#!/usr/bin/env python3
-# Copyright (c) 2016 The Bitcoin Core developers
-# Distributed under the MIT/X11 software license, see the accompanying
-# file COPYING or http://www.opensource.org/licenses/mit-license.php.
-#
-
-from test_framework.blocktools import create_block
-from test_framework.test_framework import BitcoinTestFramework
-from test_framework.util import assert_equal
-
-from binascii import b2a_hex
-from decimal import Decimal
-
-def find_unspent(node, txid, amount):
-    for utxo in node.listunspent(0):
-        if utxo['txid'] != txid:
-            continue
-        if utxo['amount'] != amount:
-            continue
-        return {'txid': utxo['txid'], 'vout': utxo['vout']}
-
-def solve_template_hex(tmpl, txlist):
-    block = create_block(tmpl=tmpl, txlist=txlist)
-    block.solve()
-    b = block.serialize()
-    x = b2a_hex(b).decode('ascii')
-    return x
-
-def get_modified_size(node, txdata):
-    decoded = node.decoderawtransaction(txdata)
-    size = decoded['vsize']
-    for inp in decoded['vin']:
-        offset = 41 + min(len(inp['scriptSig']['hex']) // 2, 110)
-        if offset <= size:
-            size -= offset
-    return size
-
-def assert_approximate(a, b):
-    assert_equal(int(a), int(b))
-
-BTC = Decimal('100000000')
-
-class PriorityTest(BitcoinTestFramework):
-    def add_options(self, parser):
-        self.add_wallet_options(parser)
-
-    def set_test_params(self):
-        self.num_nodes = 3
-        self.testmsg_num = 0
-
-    def setup_nodes(self):
-        self.extra_args = [
-            ['-blockmaxsize=0'],
-            ['-blockprioritysize=1000000', '-blockmaxsize=1000000', '-printpriority'],
-            ['-blockmaxsize=0'],
-        ]
-
-        super().setup_nodes()
-
-    def assert_prio(self, txid, starting, current):
-        node = self.nodes[1]
-
-        tmpl = node.getblocktemplate({'rules':('segwit',)})
-        tmplentry = None
-        for tx in tmpl['transactions']:
-            if tx['txid'] == txid:
-                tmplentry = tx
-                break
-        # GBT does not expose starting priority, so we don't check that
-        assert_approximate(tmplentry['priority'], current)
-
-        mempoolentry = node.getrawmempool(True)[txid]
-        assert_approximate(mempoolentry['startingpriority'], starting)
-        assert_approximate(mempoolentry['currentpriority'], current)
-
-    def testmsg(self, msg):
-        self.testmsg_num += 1
-        self.log.info('Test %d: %s' % (self.testmsg_num, msg))
-
-    def skip_test_if_missing_module(self):
-        self.skip_if_no_wallet()
-
-    def run_test(self):
-        node = self.nodes[0]
-        miner = self.nodes[1]
-
-        self.generate(node, 50)
-        self.generate(miner, 101)
-
-        fee = Decimal('0.0001')
-        amt = Decimal('11')
-
-        txid_a = node.sendtoaddress(node.getnewaddress(), amt)
-        txdata_b = node.createrawtransaction([find_unspent(node, txid_a, amt)], {node.getnewaddress(): amt - fee})
-        txdata_b = node.signrawtransactionwithwallet(txdata_b)['hex']
-        txmodsize_b = get_modified_size(node, txdata_b)
-        txid_b = node.sendrawtransaction(txdata_b)
-        self.sync_all()
-
-        self.testmsg('priority starts at 0 with all unconfirmed inputs')
-        self.assert_prio(txid_b, 0, 0)
-
-        self.testmsg('priority increases correctly when that input is mined')
-
-        # Mine only the sendtoaddress transaction
-        tmpl = node.getblocktemplate({'rules':('segwit',)})
-        rawblock = solve_template_hex(tmpl, [node.getrawtransaction(txid_a)])
-        assert_equal(node.submitblock(rawblock), None)
-        self.sync_all()
-
-        self.assert_prio(txid_b, 0, amt * BTC / txmodsize_b)
-
-        self.testmsg('priority continues to increase the deeper the block confirming its inputs gets buried')
-
-        self.generate(node, 2)
-
-        self.assert_prio(txid_b, 0, amt * BTC * 3 / txmodsize_b)
-
-        self.testmsg('with a confirmed input, the initial priority is calculated correctly')
-
-        self.generate(miner, 4)
-
-        amt_c = (amt - fee) / 2
-        amt_c2 = amt_c - fee
-        txdata_c = node.createrawtransaction([find_unspent(node, txid_b, amt - fee)], {node.getnewaddress(): amt_c, node.getnewaddress(): amt_c2})
-        txdata_c = node.signrawtransactionwithwallet(txdata_c)['hex']
-        txmodsize_c = get_modified_size(node, txdata_c)
-        txid_c = node.sendrawtransaction(txdata_c)
-        self.sync_all()
-
-        txid_c_starting_prio = (amt - fee) * BTC * 4 / txmodsize_c
-        self.assert_prio(txid_c, txid_c_starting_prio, txid_c_starting_prio)
-
-        self.testmsg('with an input confirmed prior to the transaction, the priority gets incremented correctly as it gets buried deeper')
-
-        self.generate(node, 1)
-
-        self.assert_prio(txid_c, txid_c_starting_prio, (amt - fee) * BTC * 5 / txmodsize_c)
-
-        self.testmsg('with an input confirmed prior to the transaction, the priority gets incremented correctly as it gets buried deeper and deeper')
-
-        self.generate(node, 2)
-
-        self.assert_prio(txid_c, txid_c_starting_prio, (amt - fee) * BTC * 7 / txmodsize_c)
-
-        self.log.info('(preparing for reorg test)')
-
-        self.generate(miner, 1)
-
-        self.split_network()
-        node = self.nodes[0]
-        miner = self.nodes[1]
-        competing_miner = self.nodes[2]
-
-        txdata_d = node.createrawtransaction([find_unspent(node, txid_c, amt_c)], {node.getnewaddress(): amt_c - fee})
-        txdata_d = node.signrawtransactionwithwallet(txdata_d)['hex']
-        get_modified_size(node, txdata_d)
-        txid_d = node.sendrawtransaction(txdata_d)
-        self.sync_all(self.nodes[:2])
-        self.sync_all(self.nodes[2:])
-
-        self.generate(miner, 1, sync_fun=self.no_op)
-        self.sync_all(self.nodes[:2])
-        self.sync_all(self.nodes[2:])
-
-        txdata_e = node.createrawtransaction([find_unspent(node, txid_d, amt_c - fee), find_unspent(node, txid_c, amt_c2)], {node.getnewaddress(): (amt_c - fee) + amt_c2 - fee})
-        txdata_e = node.signrawtransactionwithwallet(txdata_e)['hex']
-        txmodsize_e = get_modified_size(node, txdata_e)
-        txid_e = node.sendrawtransaction(txdata_e)
-        self.sync_all(self.nodes[:2])
-        self.sync_all(self.nodes[2:])
-
-        txid_e_starting_prio = (((amt_c - fee) * BTC) + (amt_c2 * BTC * 2)) / txmodsize_e
-        self.assert_prio(txid_e, txid_e_starting_prio, txid_e_starting_prio)  # Sanity check 1
-
-        self.generate(competing_miner, 5, sync_fun=self.no_op)
-        self.sync_all(self.nodes[:2])
-        self.sync_all(self.nodes[2:])
-
-        self.assert_prio(txid_e, txid_e_starting_prio, txid_e_starting_prio)  # Sanity check 2
-
-        self.testmsg('priority is updated correctly when input-confirming block is reorganised out')
-
-        self.connect_nodes(1, 2)
-        self.sync_blocks()
-
-        txid_e_reorg_prio = (amt_c2 * BTC * 6) / txmodsize_e
-        self.assert_prio(txid_e, txid_e_starting_prio, txid_e_reorg_prio)
-
-if __name__ == '__main__':
-    PriorityTest(__file__).main()
diff --git a/test/functional/mining_prioritisetransaction.py b/test/functional/mining_prioritisetransaction.py
index b3b5640c37..eb55202e16 100755
--- a/test/functional/mining_prioritisetransaction.py
+++ b/test/functional/mining_prioritisetransaction.py
@@ -146,6 +146,8 @@ class PrioritiseTransactionTest(BitcoinTestFramework):
 
         # Test `prioritisetransaction` required parameters
         assert_raises_rpc_error(-1, "prioritisetransaction", self.nodes[0].prioritisetransaction)
+        assert_raises_rpc_error(-1, "prioritisetransaction", self.nodes[0].prioritisetransaction, '')
+        assert_raises_rpc_error(-1, "prioritisetransaction", self.nodes[0].prioritisetransaction, '', 0)
 
         # Test `prioritisetransaction` invalid extra parameters
         assert_raises_rpc_error(-1, "prioritisetransaction", self.nodes[0].prioritisetransaction, '', 0, 0, 0)
@@ -158,9 +160,10 @@ class PrioritiseTransactionTest(BitcoinTestFramework):
         assert_raises_rpc_error(-8, "txid must be of length 64 (not 3, for 'foo')", self.nodes[0].prioritisetransaction, txid='foo', fee_delta=0)
         assert_raises_rpc_error(-8, "txid must be hexadecimal string (not 'Zd1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000')", self.nodes[0].prioritisetransaction, txid='Zd1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000', fee_delta=0)
 
-        # Test `prioritisetransaction` invalid `priority_delta`
+        # Test `prioritisetransaction` invalid `dummy`
         txid = '1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000'
         assert_raises_rpc_error(-3, "JSON value of type string is not of expected type number", self.nodes[0].prioritisetransaction, txid, 'foo', 0)
+        assert_raises_rpc_error(-8, "Priority is no longer supported, dummy argument to prioritisetransaction must be 0.", self.nodes[0].prioritisetransaction, txid, 1, 0)
 
         # Test `prioritisetransaction` invalid `fee_delta`
         assert_raises_rpc_error(-3, "JSON value of type string is not of expected type number", self.nodes[0].prioritisetransaction, txid=txid, fee_delta='foo')
diff --git a/test/functional/p2p_disconnect_ban.py b/test/functional/p2p_disconnect_ban.py
index b61b3ad917..94be86475e 100755
--- a/test/functional/p2p_disconnect_ban.py
+++ b/test/functional/p2p_disconnect_ban.py
@@ -10,7 +10,6 @@ from test_framework.test_framework import BitcoinTestFramework
 from test_framework.util import (
     assert_equal,
     assert_raises_rpc_error,
-    p2p_port,
 )
 
 class DisconnectBanTest(BitcoinTestFramework):
@@ -130,12 +129,8 @@ class DisconnectBanTest(BitcoinTestFramework):
         self.log.info("disconnectnode: fail to disconnect when calling with junk address")
         assert_raises_rpc_error(-29, "Node not found in connected nodes", self.nodes[0].disconnectnode, address="221B Baker Street")
 
-        self.log.info("disconnectnode: fail to disconnect when calling with invalid subnet")
-        assert_raises_rpc_error(-8, "Invalid subnet", self.nodes[0].disconnectnode, address="1.2.3.0/24\0")
-
-        self.log.info("disconnectnode: successfully disconnect node by address and port")
-        address1 = "127.0.0.1:" + str(p2p_port(1))
-        assert [node for node in self.nodes[0].getpeerinfo() if node['addr'] == address1]
+        self.log.info("disconnectnode: successfully disconnect node by address")
+        address1 = self.nodes[0].getpeerinfo()[0]['addr']
         self.nodes[0].disconnectnode(address=address1)
         self.wait_until(lambda: len(self.nodes[1].getpeerinfo()) == 1, timeout=10)
         assert not [node for node in self.nodes[0].getpeerinfo() if node['addr'] == address1]
@@ -145,27 +140,11 @@ class DisconnectBanTest(BitcoinTestFramework):
         assert_equal(len(self.nodes[0].getpeerinfo()), 2)
         assert [node for node in self.nodes[0].getpeerinfo() if node['addr'] == address1]
 
-        self.log.info("disconnectnode: successfully disconnect node by address (no port)")
-        nodes = self.nodes[0].getpeerinfo()
-        assert nodes and all(node['addr'].startswith('127.0.0.') for node in nodes)
-        self.nodes[0].disconnectnode(address='127.0.0.1')
-        self.wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 0, timeout=10)
-        # reconnect the nodes
-        self.connect_nodes(0, 1)
-        self.connect_nodes(1, 0)
-
         self.log.info("disconnectnode: successfully disconnect node by node id")
-        id1 = [node for node in self.nodes[0].getpeerinfo() if node['addr'] == address1][0]['id']
+        id1 = self.nodes[0].getpeerinfo()[0]['id']
         self.nodes[0].disconnectnode(nodeid=id1)
         self.wait_until(lambda: len(self.nodes[1].getpeerinfo()) == 1, timeout=10)
         assert not [node for node in self.nodes[0].getpeerinfo() if node['id'] == id1]
-        self.connect_nodes(0, 1)  # reconnect the node
-
-        self.log.info("disconnectnode: successfully disconnect node by subnet")
-        nodes = self.nodes[0].getpeerinfo()
-        assert nodes and all(node['addr'].startswith('127.0.0.') for node in nodes)
-        self.nodes[0].disconnectnode(address='127.0.0.1/24')
-        self.wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 0, timeout=10)
 
 if __name__ == '__main__':
     DisconnectBanTest(__file__).main()
diff --git a/test/functional/p2p_dns_seeds.py b/test/functional/p2p_dns_seeds.py
index 89a29c0ebd..a2d4ea110f 100755
--- a/test/functional/p2p_dns_seeds.py
+++ b/test/functional/p2p_dns_seeds.py
@@ -6,7 +6,6 @@
 
 import itertools
 
-from test_framework.netutil import UNREACHABLE_PROXY_ARG
 from test_framework.p2p import P2PInterface
 from test_framework.test_framework import BitcoinTestFramework
 
@@ -15,7 +14,7 @@ class P2PDNSSeeds(BitcoinTestFramework):
     def set_test_params(self):
         self.setup_clean_chain = True
         self.num_nodes = 1
-        self.extra_args = [["-dnsseed=1", UNREACHABLE_PROXY_ARG]]
+        self.extra_args = [["-dnsseed=1"]]
 
     def run_test(self):
         self.init_arg_tests()
@@ -30,11 +29,11 @@ class P2PDNSSeeds(BitcoinTestFramework):
         self.log.info("Check that setting -connect disables -dnsseed by default")
         self.nodes[0].stop_node()
         with self.nodes[0].assert_debug_log(expected_msgs=["DNS seeding disabled"]):
-            self.start_node(0, extra_args=[f"-connect={fakeaddr}", UNREACHABLE_PROXY_ARG])
+            self.start_node(0, [f"-connect={fakeaddr}"])
 
         self.log.info("Check that running -connect and -dnsseed means DNS logic runs.")
         with self.nodes[0].assert_debug_log(expected_msgs=["Loading addresses from DNS seed"], timeout=12):
-            self.restart_node(0, extra_args=[f"-connect={fakeaddr}", "-dnsseed=1", UNREACHABLE_PROXY_ARG])
+            self.restart_node(0, [f"-connect={fakeaddr}", "-dnsseed=1"])
 
         self.log.info("Check that running -forcednsseed and -dnsseed=0 throws an error.")
         self.nodes[0].stop_node()
@@ -89,7 +88,7 @@ class P2PDNSSeeds(BitcoinTestFramework):
         with self.nodes[0].assert_debug_log(expected_msgs=["Loading addresses from DNS seed"], timeout=12):
             # -dnsseed defaults to 1 in bitcoind, but 0 in the test framework,
             # so pass it explicitly here
-            self.restart_node(0, ["-forcednsseed", "-dnsseed=1", UNREACHABLE_PROXY_ARG])
+            self.restart_node(0, ["-forcednsseed", "-dnsseed=1"])
 
         # Restore default for subsequent tests
         self.restart_node(0)
diff --git a/test/functional/p2p_dos_header_tree.py b/test/functional/p2p_dos_header_tree.py
index 86eecd8762..fbb5d716f5 100755
--- a/test/functional/p2p_dos_header_tree.py
+++ b/test/functional/p2p_dos_header_tree.py
@@ -47,7 +47,7 @@ class RejectLowDifficultyHeadersTest(BitcoinTestFramework):
         self.headers_fork = [from_hex(CBlockHeader(), h) for h in self.headers_fork]
 
         self.log.info("Feed all non-fork headers, including and up to the first checkpoint")
-        peer_checkpoint = self.nodes[0].add_outbound_p2p_connection(P2PInterface(), p2p_idx=0)
+        peer_checkpoint = self.nodes[0].add_p2p_connection(P2PInterface())
         peer_checkpoint.send_and_ping(msg_headers(self.headers))
         assert {
             'height': 546,
@@ -64,7 +64,7 @@ class RejectLowDifficultyHeadersTest(BitcoinTestFramework):
         self.log.info("Feed all fork headers (succeeds without checkpoint)")
         # On node 0 it succeeds because checkpoints are disabled
         self.restart_node(0, extra_args=['-nocheckpoints', "-minimumchainwork=0x0", '-prune=550'])
-        peer_no_checkpoint = self.nodes[0].add_outbound_p2p_connection(P2PInterface(), p2p_idx=0)
+        peer_no_checkpoint = self.nodes[0].add_p2p_connection(P2PInterface())
         peer_no_checkpoint.send_and_ping(msg_headers(self.headers_fork))
         assert {
             "height": 2,
@@ -74,7 +74,7 @@ class RejectLowDifficultyHeadersTest(BitcoinTestFramework):
         } in self.nodes[0].getchaintips()
 
         # On node 1 it succeeds because no checkpoint has been reached yet by a chain tip
-        peer_before_checkpoint = self.nodes[1].add_outbound_p2p_connection(P2PInterface(), p2p_idx=1)
+        peer_before_checkpoint = self.nodes[1].add_p2p_connection(P2PInterface())
         peer_before_checkpoint.send_and_ping(msg_headers(self.headers_fork))
         assert {
             "height": 2,
@@ -83,162 +83,6 @@ class RejectLowDifficultyHeadersTest(BitcoinTestFramework):
             "status": "headers-only",
         } in self.nodes[1].getchaintips()
 
-        self.log.info("Feed checkpoint-violating block (succeeds up until the checkpoint mismatch, then fails)")
-        block = CBlockHeader(self.headers_fork[-1])
-        headers_fork2 = []
-        for time_offset, nonce in (
-            (3,0x023ec36d),(3,0x9e4f929b),(0,0x8bb04400),(3,0x31bbae20),
-            (0,0xd53e5028),(2,0x7841f4e3),(5,0x7a8990a4),(2,0x489e28a1),
-            (1,0x68bdb61a),(-1,0xf6d2a9fb),(5,0x487dcf25),(3,0x546da3d4),
-            (4,0xc1f844d2),(3,0x0c086f6f),(0,0xc2321e55),(6,0xde1aa13c),
-            (0,0x05227358),(4,0x5e021e88),(1,0xab2a18ae),(8,0x80c58047),
-            (5,0xfaed66b9),(4,0x85e64899),(6,0x3a0de669),(1,0x5c519d58),
-            (4,0x992f74d0),(4,0xf9eb3bef),(4,0x07673e35),(5,0x21b99d08),
-            (3,0xef38d256),(2,0xa4f1dc1b),(1,0x2c8a4530),(0,0x2b5ea5b4),
-            (6,0xf2284fc5),(0,0x1dfbd513),(0,0x0b17a886),(2,0x0bc3f397),
-            (0,0x22cc4db0),(9,0x297d6621),(1,0xa6ae996b),(0,0x48749a3f),
-            (0,0x989bf1a2),(6,0xa052d387),(1,0x9e2f6137),(3,0x6a0be10c),
-            (1,0xef64e362),(4,0xce516de6),(0,0x2d077f41),(1,0x6188fb5d),
-            (3,0xa72b0388),(2,0xd1065e3b),(0,0x73641cc7),(4,0xa667e807),
-            (3,0x343f4941),(2,0xe62c5e97),(2,0x64ccbe3f),(2,0x891494ce),
-            (2,0x1a1593ba),(1,0x7fb3165c),(3,0x9210c30b),(0,0x221e0eb6),
-            (2,0x9e80023b),(5,0xb8981525),(4,0xa9eb35ed),(0,0x0cfe8f68),
-            (4,0x31868c9d),(0,0xbc0fa60e),(5,0xcca64b21),(0,0x28a1f860),
-            (2,0xbf629fb5),(2,0x4e0673ab),(0,0x8271fd15),(2,0x1d1ba6fd),
-            (1,0xf8552431),(1,0x4a5847a3),(2,0x60e70a8b),(0,0x28e05674),
-            (1,0x3a52baa0),(4,0x93cc4193),(1,0xb9e83452),(-1,0x02578099),
-            (6,0xf1deecdb),(3,0xbfc713f0),(1,0xd42411c2),(3,0x2ff09457),
-            (4,0xca26349a),(5,0x11e45b8a),(2,0x21861128),(0,0xc2f0cf4d),
-            (4,0x8934b604),(0,0xcc822981),(4,0xef67ee2c),(2,0x940a8496),
-            (2,0xd67ea903),(3,0xd6975b4c),(1,0x39d3775b),(3,0x33e2a45a),
-            (0,0x43452dd5),(5,0xf0221dda),(2,0x24440716),(1,0x9c160e08),
-            (4,0xd0e7252a),(1,0x447411d2),(3,0x958eaa10),(-3,0xb9c956ec),
-            (1,0x5cd63c9c),(1,0x4af69deb),(3,0x90b93454),(2,0x17959b09),
-            (3,0xb05154ec),(0,0x058f9e11),(1,0x227d9c1e),(4,0xacb7701f),
-            (4,0x9542721f),(2,0x1e05aa42),(1,0x933d4365),(1,0xb5c3a67e),
-            (0,0xac9cc6a6),(1,0x4a76055a),(2,0x7721afe9),(5,0xe12b457e),
-            (1,0xaecdc119),(0,0xe8e4ca43),(1,0x6e42e836),(1,0x1d4dec49),
-            (1,0xf8056d54),(1,0x584bccb8),(1,0x1932259b),(0,0xdf53ee37),
-            (0,0x74e1f913),(1,0xc7d3a7e2),(4,0xef483c04),(0,0x60ad07f0),
-            (3,0x89c790ea),(0,0xb7cadd7e),(2,0x38a82398),(1,0xfb93ea07),
-            (0,0x200d8ecd),(0,0xf1339a41),(3,0x6af69ec7),(3,0xaffa785f),
-            (2,0x67552c61),(3,0xec447684),(0,0xa28c3c1b),(0,0x1a3218f3),
-            (3,0xc291da2c),(0,0x497d588f),(3,0x9fc4f865),(0,0x68070cc7),
-            (4,0x9b7c0842),(3,0x3ea910ac),(0,0x5c793e79),(3,0x839fca4c),
-            (1,0x16a801e7),(0,0x26ad46a3),(2,0x7709be6c),(2,0xc57d1b58),
-            (4,0x9a4a49c1),(4,0xd59ee673),(7,0x8d1ded67),(1,0x9ddc3594),
-            (0,0xf3af3d45),(3,0xbbb210be),(0,0xec262c80),(4,0x6731951b),
-            (0,0xdc36282b),(2,0xae470ed2),(1,0x22c57186),(1,0xde307b71),
-            (4,0x3d185e05),(-3,0x58d53609),(1,0xb25fc17d),(2,0x6c490b64),
-            (5,0x03d05d9b),(2,0x3e84e2ce),(0,0x2c38303d),(1,0x487c092c),
-            (1,0x23a3da6e),(3,0x2854a040),(1,0xa546be54),(1,0x50bfd84d),
-            (1,0x6795f353),(0,0x82e77285),(1,0x24dd5aa3),(1,0x0563f0ea),
-            (2,0xb2b9be8d),(1,0x54e70019),(0,0xb4a31d38),(0,0xfd3c816d),
-            (4,0x84bfd3a7),(3,0x47ecc30d),(2,0x6e1caa0c),(1,0x47097b3e),
-            (0,0x30316532),(0,0xca42b48d),(6,0xb5f05a80),(5,0xcf1f9c0f),
-            (1,0xc7c9c0a0),(7,0xdce826fa),(2,0x92478133),(0,0xdeff31ab),
-            (2,0xfeba362f),(2,0x143b78db),(0,0x48dfb442),(1,0x7b660255),
-            (0,0x9b2d9613),(0,0xc81a0b46),(5,0xfa0257c2),(0,0xcb799eac),
-            (3,0xe66885b5),(0,0xb7523b87),(3,0x80ec766e),(0,0xd3117846),
-            (4,0x44d9d213),(3,0xf3540f37),(0,0x838a3b64),(4,0xd221d138),
-            (3,0xa96e0947),(1,0xd09222da),(1,0x72071fec),(0,0x5424ae38),
-            (4,0xbd5c3d49),(4,0x2d1be9ef),(3,0x31d8521d),(3,0x5f0ac290),
-            (0,0x27710324),(3,0xc1cc6b58),(0,0xb1256275),(0,0x5473ced1),
-            (1,0x35293898),(0,0x062a003f),(3,0xee177b2e),(4,0xbbb9235a),
-            (1,0x183cebbe),(3,0xced4e55b),(2,0x8050c0fc),(7,0xe46e0207),
-            (2,0xf23c4b96),(-2,0x2d7ec1f1),(1,0x90161c6d),(8,0x62d4b92f),
-            (1,0x20086401),(2,0x2ce864a0),(4,0x317da57e),(2,0x2cc9250b),
-            (0,0xf41ea979),(1,0xa50ca905),(0,0x4c0916bb),(6,0x45becd84),
-            (3,0xdac6c807),(0,0xc88954d5),(2,0xf1ebf2b6),(2,0xa1e8f013),
-            (1,0xb86af5b1),(1,0xc864d9f1),(4,0x5e91821b),(5,0x9b3ae958),
-            (0,0x5c37debb),(4,0xf85e2180),(1,0x9de6eb5c),(1,0x51ec9650),
-            (0,0xf3d31a0d),(0,0x127a4cad),(2,0x7698ee29),(1,0x63297ce6),
-            (1,0xf9952a56),(0,0xb2bcdb59),(2,0xd904198f),(1,0xe0ceed57),
-            (2,0xe883801f),(0,0x9c48eff1),(2,0x69bd1c00),(0,0xefb5c46c),
-            (1,0x0ee6d904),(0,0xa01e4f15),(0,0xe50170fc),(3,0x1a057766),
-            (2,0xffddd03e),(1,0x9842404d),(0,0xff3c892c),(3,0x468f2c36),
-            (2,0xef3c2e4e),(0,0x72c0ea16),(4,0x815c722e),(1,0xe77dee42),
-            (0,0xddd8b502),(5,0xf4d60169),(0,0x86b593af),(0,0x08cca2a5),
-            (4,0x07652fb5),(2,0x19ead298),(0,0x94af6d52),(2,0x67955b19),
-            (0,0xf579c469),(0,0x4b010360),(0,0x67bbba31),(5,0x2e47930e),
-            (1,0xbc6872d8),(3,0x645621b8),(1,0xe2c5120b),(0,0xf3c50807),
-            (1,0x6dcf4d07),(1,0xaeb4237d),(1,0x2a5f46a0),(2,0x4e8d3883),
-            (0,0x48268869),(0,0x3bd2401a),(6,0x0bec238c),(0,0x262c5697),
-            (1,0xbbf9572d),(2,0x37df6e6f),(3,0x2ce9e7f3),(2,0x9c0741b1),
-            (0,0x8158c135),(2,0x007c8856),(1,0x6c59cc11),(1,0x2d77e50c),
-            (0,0x43b85637),(1,0x37440748),(4,0x418b2692),(4,0x3bc8200e),
-            (3,0x42e28d55),(1,0xadd84676),(0,0x2f58d608),(4,0xa252bf4e),
-            (5,0x36365c0e),(3,0x22736e12),(2,0xac0e0e83),(1,0x30316f60),
-            (4,0xedb2b98e),(1,0x46cd60ed),(3,0x8404d922),(2,0x0e230e16),
-            (1,0xf2b50134),(-1,0x8e256fff),(0,0x80199c4d),(1,0x56e07a97),
-            (1,0x2f9eed9a),(0,0xfb8a7055),(3,0xe3d02c6b),(3,0xd9b43b13),
-            (1,0xe4faa52a),(2,0x270801f7),(0,0x5fa6a206),(4,0xa151f071),
-            (3,0xd2848896),(0,0x3d5f905f),(5,0x499ae522),(1,0xc61d9839),
-            (5,0xdd2f28b4),(0,0x7dc21c39),(0,0x57e1ab56),(0,0x42027d5a),
-            (6,0x242a8813),(4,0x69fdcc57),(3,0xff7bd13a),(2,0x9a3b2839),
-            (5,0x4af325ee),(2,0x58dea930),(2,0x202b57a4),(764,0xa39c30f0),
-            (3,0x1ac08e2c),(7,0xa9263507),(1,0xb1c5602a),(0,0xf9716695),
-            (2,0x8ce36f1c),(1,0xddf12292),(4,0xa22e830d),(1,0xb84c2e51),
-            (2,0x3f6eb08c),(0,0x185ae643),(0,0x3b3ee340),(5,0x2f0bce41),
-            (5,0x2c915d7c),(4,0xe0169c60),(5,0xc5b08211),(0,0x3f123b19),
-            (2,0x443baa3f),(0,0x86e5bd6b),(1,0x728af7ae),(2,0x34cd4af0),
-            (1,0x773b28fc),(4,0xb42fcf79),(2,0xcf4cddcd),(3,0x472c939d),
-            (1,0xa2f66937),(3,0x9202dd5a),(13,0x87b4cbd0),(16,0x8d74ed44),
-            (1,0xab0ec370),(0,0x4345bc72),(3,0x1663d4e8),(54,0x53304a20),
-            (14,0xf3c7c0b5),(1,0xa755c4d5),(0,0xb4a4246d),(3,0xb55800f7),
-            (14,0x80d85102),(0,0x98d4e5ac),(1,0x6f245269),(13,0x038c57c4),
-            (0,0x86e5ac2e),(1,0x6c1963c6),(0,0x1adc14a1),(3,0x8f37ac31),
-            (18,0x16fd4d32),(15,0xee5bbf16),(13,0xfba44c88),(13,0x4f6b4e47),
-            (14,0xf9d7fe91),(1,0xe5e66769),(1,0x7ff9be17),(1,0xd53b2c20),
-            (3,0xa48129e8),(1,0xca7692d9),(1,0x55067b69),(0,0xbae33993),
-            (0,0x789a395c),(0,0xb2617974),(1,0xa49ae3ae),(0,0x52c934ba),
-            (4,0x6ee4bde6),(0,0x083b4807),(4,0x382b6a26),(1,0x17f2e8d3),
-            (4,0x70d17e03),(4,0x48bb565b),(2,0x437d655f),(2,0xece43c5f),
-            (0,0xc06407f0),(4,0xabc4d27a),(4,0xf7162b9f),(5,0x97dc4313),
-            (4,0x7c9578fa),(4,0xd38229e0),(4,0xc61a6e08),(0,0xc821347c),
-            (5,0xbb37d0ab),(4,0x3e93a911),(5,0x3c03d85e),(4,0xb289102e),
-            (5,0x5e42768e),(4,0x4c574f91),(0,0xc3531db9),(5,0x8ebbfe1b),
-            (2,0x62de7520),(4,0x11def7c6),(0,0xd12a5839),(4,0xd60eb230),
-            (0,0xfb6d0844),(2,0x701a5c56),(1,0x48998570),(4,0xcc786b3e),
-            (1,0x8973807a),(4,0x77151b83),(3,0xb9b223a4),(4,0x7d213a8e),
-            (0,0xe627ba6e),(1,0x2de15b60),(0,0x382c67c4),(6,0x43701b8e),
-            (8,0x5f41b027),(1,0x09c5d515),(1,0x7fdaaf68),(4,0x8bf79290),
-            (3,0x1a7c0271),(0,0x3562b3a1),(4,0x079aa703),(1,0x8fb1aace),
-            (4,0xb02b8935),(4,0x939d1697),(0,0x7b2d7a80),(4,0x351c3288),
-            (5,0x5f3dd388),(1,0xe865101a),(0,0x57871387),(0,0xd4fd6955),
-            (4,0x86fe1cbb),(0,0x21296c24),(4,0x68f6d66d),(3,0x9ac3b10b),
-            (8,0x659ebf23),(0,0x8e483006),(5,0x2821774f),(4,0x3b005030),
-            (1,0x6bb6f09a),(3,0xb918ea6c),(5,0x259aca8a),(1,0x4bdaa577),
-            (3,0x585e295b),(2,0xd7c04cca),(6,0x00a0f04d),(3,0x0cb7eda9),
-            (5,0xb1d83641),(4,0xd1105e7d),(2,0xe8ad8382),(3,0x92df8405),
-            (4,0xffb344bf),(0,0x94471661),(-3,0x0b9714a4),(6,0x87e08f18),
-            (6,0xae594216),(5,0x51acdc5e),(4,0x83664747),(0,0x7b10c195),
-            (2,0x1ef4426a),(5,0x1dbf29d0),(2,0xe9b85e89),(3,0x18611e1a),
-            (0,0xa10966dd),(0,0xe54fad12),(5,0x03e6220d),(3,0x64fa4ada),
-            (4,0x8facb4b4),(2,0xfc0dae5b),(4,0x61a98300),(0,0xd919ee25),
-            (3,0x47d8f268),(1,0xd3d5250f),(1,0xa1b7d150),(1,0x39584b6a),
-            (1,0xb730f059),(0,0x421a930a),(0,0xf4520724),(2,0xf51ac97e),
-            (1,0x3a2e424f),(5,0x4488e824),(5,0x51f37f50),(0,0x2060682b),
-            (4,0x668bcc70),(0,0x87bfad0d),(3,0x87a5e2be),(3,0xdb87b268),
-            (0,0xbdc1bd9f),(0,0x9e97bae4),(0,0x5f8854cc),(1,0x6a54a576),
-            (0,0x6abb7c6e),(4,0x3529e627),(0,0x2b17bf18),(6,0xe718bb6f),
-            (0,0x2f8ca470),(5,0xabf106a3),(4,0x6f80543f),(0,0x7459d412),
-        ):
-            block.hashPrevBlock = block.sha256
-            block.nTime += time_offset
-            block.nNonce = nonce
-            block.rehash()
-            headers_fork2.append(CBlockHeader(block))
-
-        with self.nodes[1].assert_debug_log(['checkpoint-mismatch']):
-            peer_before_checkpoint.send_message(msg_headers(headers_fork2))
-            peer_before_checkpoint.wait_for_disconnect()
-        assert {
-            "height": 545,
-            "hash": "000000008ce04625549eb92726e39fe6de52cd44df861bbd477f9ada8bc30efc",
-            "branchlen": 545,
-            "status": "headers-only",
-        } in self.nodes[1].getchaintips()
 
 if __name__ == '__main__':
     RejectLowDifficultyHeadersTest(__file__).main()
diff --git a/test/functional/p2p_eviction.py b/test/functional/p2p_eviction.py
index 5cc552285c..0d2bdcc429 100755
--- a/test/functional/p2p_eviction.py
+++ b/test/functional/p2p_eviction.py
@@ -122,43 +122,6 @@ class P2PEvict(BitcoinTestFramework):
         self.log.debug("{} protected peers: {}".format(len(protected_peers), protected_peers))
         assert evicted_peers[0] not in protected_peers
 
-        self.log.info("Test that whitebind inbounds get extra eviction power")
-        # Allow 10 inbound connections, set whitebind and forceinbound
-        self.restart_node(0, extra_args=['-maxconnections=21', '-whitebind=127.0.0.1:30201', '-whitebind=forceinbound@127.0.0.1:30202'])
-        self.log.debug("Fill connections with unprivileged peers")
-        for i in range(10):
-            node.add_p2p_connection(P2PInterface())
-
-        # Create a peer that expects to be rejected
-        # FIXME: "multiprocess, i686, DEBUG" CI task has a reliable timeout issue for v2transport
-        class RejectedPeer(P2PInterface):
-            def connection_lost(self, exc):
-                return
-
-        allowed_peers = []
-
-        self.log.debug("Generic inbound gets rejected when full")
-        with node.assert_debug_log(["failed to find an eviction candidate - connection dropped (full)"]):
-            node.add_p2p_connection(RejectedPeer(), wait_for_verack=False, supports_v2_p2p=False)
-
-        self.log.debug("Default whitebind inbound gets rejected, even when full")
-        with node.assert_debug_log(["failed to find an eviction candidate - connection dropped (full)"]):
-            node.add_p2p_connection(RejectedPeer(), wait_for_verack=False, supports_v2_p2p=False, dstport=30201)
-
-        self.log.debug("ForceInbound whitebind inbound gets connected, even when full")
-        allowed_peers.append(node.add_p2p_connection(P2PInterface(), dstport=30202))
-
-        peerinfo = node.getpeerinfo()
-        assert_equal(len(peerinfo), 10)
-        for peer in peerinfo:
-            if "30202" in peer["addrbind"]:
-                assert peer["forced_inbound"]
-            else:
-                assert not peer["forced_inbound"]
-
-        self.log.debug("Generic inbound gets rejected when whitebind peer is filling inbound slot")
-        with node.assert_debug_log(["failed to find an eviction candidate - connection dropped (full)"]):
-            node.add_p2p_connection(RejectedPeer(), supports_v2_p2p=False, wait_for_verack=False)
 
 if __name__ == '__main__':
     P2PEvict(__file__).main()
diff --git a/test/functional/p2p_ibd_stalling.py b/test/functional/p2p_ibd_stalling.py
index 4348bf7ee9..fa07873929 100755
--- a/test/functional/p2p_ibd_stalling.py
+++ b/test/functional/p2p_ibd_stalling.py
@@ -74,7 +74,6 @@ class P2PIBDStallingTest(BitcoinTestFramework):
 
         self.log.info("Check that a staller does not get disconnected if the 1024 block lookahead buffer is filled")
         self.mocktime = int(time.time()) + 1
-        node.setmocktime(self.mocktime)
         for id in range(NUM_PEERS):
             peers.append(node.add_outbound_p2p_connection(P2PStaller(stall_block), p2p_idx=id, connection_type="outbound-full-relay"))
             peers[-1].block_store = block_dict
diff --git a/test/functional/p2p_invalid_messages.py b/test/functional/p2p_invalid_messages.py
index 13079cc4e2..507393fb70 100755
--- a/test/functional/p2p_invalid_messages.py
+++ b/test/functional/p2p_invalid_messages.py
@@ -307,13 +307,6 @@ class InvalidMessagesTest(BitcoinTestFramework):
             peer.send_message(msg_headers([blockheader]))
             peer.wait_for_disconnect()
 
-        self.log.info('Test same previous scenario but with a whitelisted (noban) outbound peer. '
-                      'It should log as misbehaving but not cause a disconnection')
-        self.restart_node(0, extra_args=["-whitelist=noban,out@127.0.0.1"])
-        ob_peer = self.nodes[0].add_outbound_p2p_connection(P2PInterface(), p2p_idx=5)
-        with self.nodes[0].assert_debug_log(['Misbehaving', 'header with invalid proof of work']):
-            ob_peer.send_and_ping(msg_headers([blockheader]))
-
     def test_noncontinuous_headers_msg(self):
         self.log.info("Test headers message with non-continuous headers sequence is logged as misbehaving")
         block_hashes = self.generate(self.nodes[0], 10)
diff --git a/test/functional/p2p_invalid_tx.py b/test/functional/p2p_invalid_tx.py
index 6099823579..241aefab24 100755
--- a/test/functional/p2p_invalid_tx.py
+++ b/test/functional/p2p_invalid_tx.py
@@ -33,8 +33,8 @@ class InvalidTxRequestTest(BitcoinTestFramework):
         """Add a P2P connection to the node.
 
         Helper to connect and wait for version handshake."""
-        for i in range(num_connections):
-            self.nodes[0].add_outbound_p2p_connection(P2PDataStore(), p2p_idx=i)
+        for _ in range(num_connections):
+            self.nodes[0].add_p2p_connection(P2PDataStore())
 
     def reconnect_p2p(self, **kwargs):
         """Tear down and bootstrap the P2P connection to the node.
@@ -165,7 +165,7 @@ class InvalidTxRequestTest(BitcoinTestFramework):
             node.p2ps[0].send_txs_and_test([rejected_parent], node, success=False)
 
         self.log.info('Test that a peer disconnection causes erase its transactions from the orphan pool')
-        with node.assert_debug_log(['Erased 100 orphan transaction(s) from peer=26']):
+        with node.assert_debug_log(['Erased 100 orphan transaction(s) from peer=25']):
             self.reconnect_p2p(num_connections=1)
 
         self.log.info('Test that a transaction in the orphan pool is included in a new tip block causes erase this transaction from the orphan pool')
diff --git a/test/functional/p2p_mutated_blocks.py b/test/functional/p2p_mutated_blocks.py
index cc88a0ee7b..4a790168da 100755
--- a/test/functional/p2p_mutated_blocks.py
+++ b/test/functional/p2p_mutated_blocks.py
@@ -99,7 +99,7 @@ class MutatedBlocksTest(BitcoinTestFramework):
 
         # Check that unexpected-witness mutation check doesn't trigger on a header that doesn't connect to anything
         assert_equal(len(self.nodes[0].getpeerinfo()), 1)
-        attacker = self.nodes[0].add_outbound_p2p_connection(P2PInterface(), p2p_idx=1)
+        attacker = self.nodes[0].add_p2p_connection(P2PInterface())
         block_missing_prev = copy.deepcopy(block)
         block_missing_prev.hashPrevBlock = 123
         block_missing_prev.solve()
diff --git a/test/functional/p2p_node_network_limited.py b/test/functional/p2p_node_network_limited.py
index c1b500869d..df6e6a2e28 100755
--- a/test/functional/p2p_node_network_limited.py
+++ b/test/functional/p2p_node_network_limited.py
@@ -11,11 +11,9 @@ and that it responds to getdata requests for blocks correctly:
 from test_framework.messages import (
     CInv,
     MSG_BLOCK,
-    NODE_BLOOM,
     NODE_NETWORK_LIMITED,
     NODE_P2P_V2,
     NODE_WITNESS,
-    NODE_REPLACE_BY_FEE,
     msg_getdata,
 )
 from test_framework.p2p import P2PInterface
@@ -120,7 +118,7 @@ class NodeNetworkLimitedTest(BitcoinTestFramework):
     def run_test(self):
         node = self.nodes[0].add_p2p_connection(P2PIgnoreInv())
 
-        expected_services = NODE_BLOOM | NODE_WITNESS | NODE_NETWORK_LIMITED | NODE_REPLACE_BY_FEE
+        expected_services = NODE_WITNESS | NODE_NETWORK_LIMITED
         if self.options.v2transport:
             expected_services |= NODE_P2P_V2
 
diff --git a/test/functional/p2p_opportunistic_1p1c.py b/test/functional/p2p_opportunistic_1p1c.py
index 227670303e..4477046c8d 100755
--- a/test/functional/p2p_opportunistic_1p1c.py
+++ b/test/functional/p2p_opportunistic_1p1c.py
@@ -226,7 +226,7 @@ class PackageRelayTest(BitcoinTestFramework):
         tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())
         tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']
 
-        bad_orphan_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0)
+        bad_orphan_sender = node.add_p2p_connection(P2PInterface())
         parent_sender = node.add_p2p_connection(P2PInterface())
 
         # 1. Child is received first. It is missing an input.
@@ -266,7 +266,7 @@ class PackageRelayTest(BitcoinTestFramework):
         tx_parent_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']
 
         package_sender = node.add_p2p_connection(P2PInterface())
-        fake_parent_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0)
+        fake_parent_sender = node.add_p2p_connection(P2PInterface())
 
         # 1. Child is received first. It is missing an input.
         child_wtxid_int = int(high_fee_child["tx"].getwtxid(), 16)
diff --git a/test/functional/p2p_orphan_handling.py b/test/functional/p2p_orphan_handling.py
index 9ec23e9d6e..22600bf8a4 100755
--- a/test/functional/p2p_orphan_handling.py
+++ b/test/functional/p2p_orphan_handling.py
@@ -5,7 +5,6 @@
 
 import time
 
-from test_framework.mempool_util import tx_in_orphanage
 from test_framework.messages import (
     CInv,
     CTxInWitness,
@@ -42,8 +41,6 @@ from test_framework.wallet import (
 # for one peer and y seconds for another, use specific values instead.
 TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1
 
-DEFAULT_MAX_ORPHAN_TRANSACTIONS = 100
-
 def cleanup(func):
     # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with
     # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist
@@ -569,47 +566,6 @@ class OrphanHandlingTest(BitcoinTestFramework):
         assert tx_child["txid"] in node_mempool
         assert_equal(node.getmempoolentry(tx_child["txid"])["wtxid"], tx_child["wtxid"])
 
-    @cleanup
-    def test_max_orphan_amount(self):
-        self.log.info("Check that we never exceed our storage limits for orphans")
-
-        node = self.nodes[0]
-        self.generate(self.wallet, 1)
-        peer_1 = node.add_p2p_connection(P2PInterface())
-
-        self.log.info("Check that orphanage is empty on start of test")
-        assert len(node.getorphantxs()) == 0
-
-        self.log.info("Filling up orphanage with " + str(DEFAULT_MAX_ORPHAN_TRANSACTIONS) + "(DEFAULT_MAX_ORPHAN_TRANSACTIONS) orphans")
-        orphans = []
-        parent_orphans = []
-        for _ in range(DEFAULT_MAX_ORPHAN_TRANSACTIONS):
-            tx_parent_1 = self.wallet.create_self_transfer()
-            tx_child_1 = self.wallet.create_self_transfer(utxo_to_spend=tx_parent_1["new_utxo"])
-            parent_orphans.append(tx_parent_1["tx"])
-            orphans.append(tx_child_1["tx"])
-            peer_1.send_message(msg_tx(tx_child_1["tx"]))
-
-        peer_1.sync_with_ping()
-        orphanage = node.getorphantxs()
-        assert_equal(len(orphanage), DEFAULT_MAX_ORPHAN_TRANSACTIONS)
-
-        for orphan in orphans:
-            assert tx_in_orphanage(node, orphan)
-
-        self.log.info("Check that we do not add more than the max orphan amount")
-        tx_parent_1 = self.wallet.create_self_transfer()
-        tx_child_1 = self.wallet.create_self_transfer(utxo_to_spend=tx_parent_1["new_utxo"])
-        peer_1.send_and_ping(msg_tx(tx_child_1["tx"]))
-        parent_orphans.append(tx_parent_1["tx"])
-        orphanage = node.getorphantxs()
-        assert_equal(len(orphanage), DEFAULT_MAX_ORPHAN_TRANSACTIONS)
-
-        self.log.info("Clearing the orphanage")
-        for index, parent_orphan in enumerate(parent_orphans):
-            peer_1.send_and_ping(msg_tx(parent_orphan))
-        assert_equal(len(node.getorphantxs()),0)
-
 
     def run_test(self):
         self.nodes[0].setmocktime(int(time.time()))
@@ -626,7 +582,6 @@ class OrphanHandlingTest(BitcoinTestFramework):
         self.test_same_txid_orphan()
         self.test_same_txid_orphan_of_orphan()
         self.test_orphan_txid_inv()
-        self.test_max_orphan_amount()
 
 
 if __name__ == '__main__':
diff --git a/test/functional/p2p_permissions.py b/test/functional/p2p_permissions.py
index 7195b155cd..c881dd6ff4 100755
--- a/test/functional/p2p_permissions.py
+++ b/test/functional/p2p_permissions.py
@@ -33,7 +33,7 @@ class P2PPermissionsTests(BitcoinTestFramework):
             # default permissions (no specific permissions)
             ["-whitelist=127.0.0.1"],
             # Make sure the default values in the command line documentation match the ones here
-            ["addr", "relay", "noban", "mempool", "download"])
+            ["relay", "noban", "mempool", "download"])
 
         self.checkpermission(
             # no permission (even with forcerelay)
@@ -43,14 +43,14 @@ class P2PPermissionsTests(BitcoinTestFramework):
         self.checkpermission(
             # relay permission removed (no specific permissions)
             ["-whitelist=127.0.0.1", "-whitelistrelay=0"],
-            ["addr", "noban", "mempool", "download"])
+            ["noban", "mempool", "download"])
 
         self.checkpermission(
             # forcerelay and relay permission added
             # Legacy parameter interaction which set whitelistrelay to true
             # if whitelistforcerelay is true
             ["-whitelist=127.0.0.1", "-whitelistforcerelay"],
-            ["addr", "forcerelay", "relay", "noban", "mempool", "download"])
+            ["forcerelay", "relay", "noban", "mempool", "download"])
 
         # Let's make sure permissions are merged correctly
         # For this, we need to use whitebind instead of bind
@@ -81,16 +81,7 @@ class P2PPermissionsTests(BitcoinTestFramework):
         self.checkpermission(
             # all permission added
             ["-whitelist=all@127.0.0.1"],
-            [
-                "blockfilters",
-                "forcerelay",
-                "noban",
-                "mempool",
-                "bloomfilter",
-                "relay",
-                "download",
-                "addr",
-            ])
+            ["forcerelay", "noban", "mempool", "bloomfilter", "relay", "download", "addr"])
 
         for flag, permissions in [(["-whitelist=noban,out@127.0.0.1"], ["noban", "download"]), (["-whitelist=noban@127.0.0.1"], [])]:
             self.restart_node(0, flag)
diff --git a/test/functional/p2p_segwit.py b/test/functional/p2p_segwit.py
index e6cb6f4ed0..9be53d2ab8 100755
--- a/test/functional/p2p_segwit.py
+++ b/test/functional/p2p_segwit.py
@@ -1387,7 +1387,7 @@ class SegWitTest(BitcoinTestFramework):
         # First we test this transaction against std_node
         # making sure the txid is added to the reject filter
         self.std_node.announce_tx_and_wait_for_getdata(tx3)
-        test_transaction_acceptance(self.nodes[1], self.std_node, tx3, with_witness=True, accepted=False, reason="bad-txns-input-witness-unknown")
+        test_transaction_acceptance(self.nodes[1], self.std_node, tx3, with_witness=True, accepted=False, reason="bad-txns-nonstandard-inputs")
         # Now the node will no longer ask for getdata of this transaction when advertised by same txid
         self.std_node.announce_tx_and_wait_for_getdata(tx3, success=False)
 
@@ -1750,7 +1750,7 @@ class SegWitTest(BitcoinTestFramework):
         tx2.rehash()
         # This will be rejected due to a policy check:
         # No witness is allowed, since it is not a witness program but a p2sh program
-        test_transaction_acceptance(self.nodes[1], self.std_node, tx2, True, False, 'bad-witness-nonwitness-input')
+        test_transaction_acceptance(self.nodes[1], self.std_node, tx2, True, False, 'bad-witness-nonstandard')
 
         # If we send without witness, it should be accepted.
         test_transaction_acceptance(self.nodes[1], self.std_node, tx2, False, True)
@@ -1819,13 +1819,13 @@ class SegWitTest(BitcoinTestFramework):
         # Testing native P2WSH
         # Witness stack size, excluding witnessScript, over 100 is non-standard
         p2wsh_txs[0].wit.vtxinwit[0].scriptWitness.stack = [pad] * 101 + [scripts[0]]
-        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[0], True, False, 'bad-witness-stackitem-count')
+        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[0], True, False, 'bad-witness-nonstandard')
         # Non-standard nodes should accept
         test_transaction_acceptance(self.nodes[0], self.test_node, p2wsh_txs[0], True, True)
 
         # Stack element size over 80 bytes is non-standard
         p2wsh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]
-        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[1], True, False, 'bad-witness-stackitem-size')
+        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[1], True, False, 'bad-witness-nonstandard')
         # Non-standard nodes should accept
         test_transaction_acceptance(self.nodes[0], self.test_node, p2wsh_txs[1], True, True)
         # Standard nodes should accept if element size is not over 80 bytes
@@ -1839,16 +1839,16 @@ class SegWitTest(BitcoinTestFramework):
 
         # witnessScript size at 3601 bytes is non-standard
         p2wsh_txs[3].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, pad, scripts[3]]
-        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[3], True, False, 'bad-witness-script-size')
+        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[3], True, False, 'bad-witness-nonstandard')
         # Non-standard nodes should accept
         test_transaction_acceptance(self.nodes[0], self.test_node, p2wsh_txs[3], True, True)
 
         # Repeating the same tests with P2SH-P2WSH
         p2sh_txs[0].wit.vtxinwit[0].scriptWitness.stack = [pad] * 101 + [scripts[0]]
-        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[0], True, False, 'bad-witness-stackitem-count')
+        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[0], True, False, 'bad-witness-nonstandard')
         test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[0], True, True)
         p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]
-        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[1], True, False, 'bad-witness-stackitem-size')
+        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[1], True, False, 'bad-witness-nonstandard')
         test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[1], True, True)
         p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 80] * 100 + [scripts[1]]
         test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[1], True, True)
@@ -1856,7 +1856,7 @@ class SegWitTest(BitcoinTestFramework):
         test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[2], True, True)
         test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[2], True, True)
         p2sh_txs[3].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, pad, scripts[3]]
-        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[3], True, False, 'bad-witness-script-size')
+        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[3], True, False, 'bad-witness-nonstandard')
         test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[3], True, True)
 
         self.generate(self.nodes[0], 1)  # Mine and clean up the mempool of non-standard node
diff --git a/test/functional/p2p_unrequested_blocks.py b/test/functional/p2p_unrequested_blocks.py
index d96be42d4f..835ecbf184 100755
--- a/test/functional/p2p_unrequested_blocks.py
+++ b/test/functional/p2p_unrequested_blocks.py
@@ -80,7 +80,7 @@ class AcceptBlockTest(BitcoinTestFramework):
         return False
 
     def run_test(self):
-        test_node = self.nodes[0].add_outbound_p2p_connection(P2PInterface(), p2p_idx=0)
+        test_node = self.nodes[0].add_p2p_connection(P2PInterface())
         min_work_node = self.nodes[1].add_p2p_connection(P2PInterface())
 
         # 1. Have nodes mine a block (leave IBD)
@@ -203,7 +203,7 @@ class AcceptBlockTest(BitcoinTestFramework):
         self.nodes[0].disconnect_p2ps()
         self.nodes[1].disconnect_p2ps()
 
-        test_node = self.nodes[0].add_outbound_p2p_connection(P2PInterface(), p2p_idx=2)
+        test_node = self.nodes[0].add_p2p_connection(P2PInterface())
 
         test_node.send_and_ping(msg_block(block_h1f))
         assert_equal(self.nodes[0].getblockcount(), 2)
@@ -275,7 +275,7 @@ class AcceptBlockTest(BitcoinTestFramework):
         test_node.wait_for_disconnect()
 
         self.nodes[0].disconnect_p2ps()
-        test_node = self.nodes[0].add_outbound_p2p_connection(P2PInterface(), p2p_idx=3)
+        test_node = self.nodes[0].add_p2p_connection(P2PInterface())
 
         # We should have failed reorg and switched back to 290 (but have block 291)
         assert_equal(self.nodes[0].getblockcount(), 290)
diff --git a/test/functional/p2p_v2_encrypted.py b/test/functional/p2p_v2_encrypted.py
index acb5bf0c22..3e8ce09d24 100755
--- a/test/functional/p2p_v2_encrypted.py
+++ b/test/functional/p2p_v2_encrypted.py
@@ -18,10 +18,8 @@ from test_framework.util import (
     assert_equal,
     assert_greater_than,
     check_node_connections,
-    p2p_port,
 )
 from test_framework.crypto.chacha20 import REKEY_INTERVAL
-from test_framework.socks5 import Socks5Configuration, Socks5Server
 
 
 class P2PEncrypted(BitcoinTestFramework):
@@ -131,27 +129,6 @@ class P2PEncrypted(BitcoinTestFramework):
         assert_equal(node0.getpeerinfo()[-1]["transport_protocol_type"], "v1")
         check_node_connections(node=node0, num_in=1, num_out=0)
 
-        conf = Socks5Configuration()
-        conf.auth = True
-        conf.unauth = True
-        conf.addr = ('127.0.0.1', p2p_port(self.num_nodes))
-        conf.keep_alive = True
-        proxy = Socks5Server(conf)
-        proxy.start()
-        args = ['-listen', f'-proxy={conf.addr[0]}:{conf.addr[1]}', '-proxyrandomize=0', '-v2onlyclearnet=1', '-v2transport=1']
-        self.restart_node(0, extra_args=args)
-        self.log.info("Test -v2onlyclearnet=1 behaviour")
-        self.log.info("Check that outbound v2 connection to an ipv4 peer is successful")
-        node0.addnode("15.61.23.23:1234", "onetry", True)
-        assert_equal(node0.getpeerinfo()[-1]["addr"], "15.61.23.23:1234")
-        self.log.info("Check that outbound v1 connection to an ipv4 peer is unsuccessful")
-        node0.addnode("8.8.8.8:1234", "onetry", False)
-        assert all(peer["addr"] != "8.8.8.8:1234" for peer in node0.getpeerinfo())
-        self.log.info("Check that outbound v1 connection to an onion peer is successful")
-        addr = "pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion:8333"
-        node0.addnode(addr, "onetry", False)
-        assert_equal(node0.getpeerinfo()[-1]["addr"], addr)
-
 
 if __name__ == '__main__':
     P2PEncrypted(__file__).main()
diff --git a/test/functional/rpc_blockchain.py b/test/functional/rpc_blockchain.py
index 1c29d2f2e0..98147237b1 100755
--- a/test/functional/rpc_blockchain.py
+++ b/test/functional/rpc_blockchain.py
@@ -215,7 +215,6 @@ class BlockchainTest(BitcoinTestFramework):
                     'since': 144,
                     'statistics': {
                         'period': 144,
-                        'period_start': 144,
                         'threshold': 108,
                         'elapsed': height - 143,
                         'count': height - 143,
diff --git a/test/functional/rpc_dumptxoutset.py b/test/functional/rpc_dumptxoutset.py
index 1b93e22216..aa12da6ceb 100755
--- a/test/functional/rpc_dumptxoutset.py
+++ b/test/functional/rpc_dumptxoutset.py
@@ -12,8 +12,6 @@ from test_framework.util import (
     assert_raises_rpc_error,
     sha256sum_file,
 )
-import hashlib
-import os
 
 
 class DumptxoutsetTest(BitcoinTestFramework):
@@ -21,30 +19,16 @@ class DumptxoutsetTest(BitcoinTestFramework):
         self.setup_clean_chain = True
         self.num_nodes = 1
 
-    @staticmethod
-    def check_output_file(path, is_human_readable, expected_digest):
-        with open(str(path), 'rb') as f:
-            content = f.read()
-
-            if is_human_readable:
-                # Normalise platform EOL to \n, while making sure any stray \n becomes a literal backslash+n to avoid a false positive
-                # This ensures the platform EOL and only the platform EOL produces the expected hash
-                linesep = os.linesep.encode('utf8')
-                content = b'\n'.join(line.replace(b'\n', b'\\n') for line in content.split(linesep))
-
-            digest = hashlib.sha256(content).hexdigest()
-            # UTXO snapshot hash should be deterministic based on mocked time.
-            assert_equal(digest, expected_digest)
-
-    def test_dump_file(self, testname, params, expected_digest):
+    def run_test(self):
+        """Test a trivial usage of the dumptxoutset RPC command."""
         node = self.nodes[0]
+        mocktime = node.getblockheader(node.getblockhash(0))['time'] + 1
+        node.setmocktime(mocktime)
+        self.generate(node, COINBASE_MATURITY)
 
-        self.log.info(testname)
-        filename = testname + '_txoutset.dat'
-        is_human_readable = not params.get('format') is None
-
-        out = node.dumptxoutset(path=filename, **params)
-        expected_path = node.datadir_path / self.chain / filename
+        FILENAME = 'txoutset.dat'
+        out = node.dumptxoutset(FILENAME)
+        expected_path = node.datadir_path / self.chain / FILENAME
 
         assert expected_path.is_file()
 
@@ -56,56 +40,22 @@ class DumptxoutsetTest(BitcoinTestFramework):
             out['base_hash'],
             '09abf0e7b510f61ca6cf33bab104e9ee99b3528b371d27a2d4b39abb800fba7e')
 
-        self.check_output_file(expected_path, is_human_readable, expected_digest)
+        # UTXO snapshot hash should be deterministic based on mocked time.
+        assert_equal(
+            sha256sum_file(str(expected_path)).hex(),
+            '31fcdd0cf542a4b1dfc13c3c05106620ce48951ef62907dd8e5e8c15a0aa993b')
 
         assert_equal(
             out['txoutset_hash'], 'a0b7baa3bf5ccbd3279728f230d7ca0c44a76e9923fca8f32dbfd08d65ea496a')
         assert_equal(out['nchaintx'], 101)
 
-        self.log.info("Test that a path to an existing or invalid file will fail")
+        # Specifying a path to an existing or invalid file will fail.
         assert_raises_rpc_error(
-            -8, '{} already exists'.format(filename),  node.dumptxoutset, filename)
+            -8, '{} already exists'.format(FILENAME),  node.dumptxoutset, FILENAME)
         invalid_path = node.datadir_path / "invalid" / "path"
         assert_raises_rpc_error(
             -8, "Couldn't open file {}.incomplete for writing".format(invalid_path), node.dumptxoutset, invalid_path)
 
-        if params.get('format') == ():
-            with open(expected_path, 'r', encoding='utf-8') as f:
-                content = f.readlines()
-                sep = params.get('separator', ',')
-                if params.get('show_header', True):
-                    assert_equal(content.pop(0).rstrip(),
-                        "#(blockhash 09abf0e7b510f61ca6cf33bab104e9ee99b3528b371d27a2d4b39abb800fba7e ) txid{s}vout{s}value{s}coinbase{s}height{s}scriptPubKey".format(s=sep))
-                assert_equal(content[0].rstrip(),
-                    "b9edce02689692b1cdc3440d03011486a27c46b966248b922cc6e4315e900708{s}0{s}5000000000{s}1{s}78{s}76a9142b4569203694fc997e13f2c0a1383b9e16c77a0d88ac".format(s=sep))
-
-    def run_test(self):
-        """Test a trivial usage of the dumptxoutset RPC command."""
-        node = self.nodes[0]
-        mocktime = node.getblockheader(node.getblockhash(0))['time'] + 1
-        node.setmocktime(mocktime)
-        self.generate(node, COINBASE_MATURITY)
-
-        self.test_dump_file('no_option',           {},
-                            '31fcdd0cf542a4b1dfc13c3c05106620ce48951ef62907dd8e5e8c15a0aa993b')
-        self.test_dump_file('all_data',            {'format': ()},
-                            '50d7bf3ecca8c5daf648aca884b91496386d8269ef001ff95a1db4381d399bfb')
-        self.test_dump_file('partial_data_1',      {'format': ('txid',)},
-                            'f9966db510b46d865a9412da88d17ac2c05c6bfe612ffc7c1b004aec1b508c5c')
-        self.test_dump_file('partial_data_order',  {'format': ('height', 'vout')},
-                            '0ef7e361fde77f5c9f3667b1d8ce4351ec8dc81826937da0dab5631e2aedc5fe')
-        self.test_dump_file('partial_data_double', {'format': ('scriptPubKey', 'scriptPubKey')},
-                            '8bd128d326b971ea37bd28c016aae506e29d23dac578edd849636a8ab2ee31a8')
-        self.test_dump_file('no_header',           {'format': (), 'show_header': False},
-                            'af1f38ee1d1b8bbdc117ab7e8353910dab5ab45f18be27aa4fa7d96ccc96a050')
-        self.test_dump_file('separator',           {'format': (), 'separator': ':'},
-                            '5bee81096e400d1b3bf02de432e0fd4af8f4d9244907dc1c857ec329c5ce4490')
-        self.test_dump_file('all_options',         {'format': (), 'show_header': False, 'separator': ':'},
-                            '5c52c2a9bdb23946eb0f6d088f25ed8f5d9ebc3a3512182287975f1041cdedb4')
-
-        # Other failing tests
-        assert_raises_rpc_error(
-            -8, 'unable to find item \'sample\'',  node.dumptxoutset, path='xxx', format=['sample'])
 
 if __name__ == '__main__':
     DumptxoutsetTest(__file__).main()
diff --git a/test/functional/rpc_getblockfrompeer.py b/test/functional/rpc_getblockfrompeer.py
index 43fe094185..e309018516 100755
--- a/test/functional/rpc_getblockfrompeer.py
+++ b/test/functional/rpc_getblockfrompeer.py
@@ -8,7 +8,6 @@ from test_framework.authproxy import JSONRPCException
 from test_framework.messages import (
     CBlock,
     from_hex,
-    msg_block,
     msg_headers,
     NODE_WITNESS,
 )
@@ -71,8 +70,8 @@ class GetBlockFromPeerTest(BitcoinTestFramework):
         assert_raises_rpc_error(-3, "JSON value of type number is not of expected type string", self.nodes[0].getblockfrompeer, 1234, peer_0_peer_1_id)
         assert_raises_rpc_error(-3, "JSON value of type string is not of expected type number", self.nodes[0].getblockfrompeer, short_tip, "0")
 
-        self.log.info("We can request blocks for which we do not have the header")
-        self.nodes[0].getblockfrompeer("11" * 32, 0)
+        self.log.info("We must already have the header")
+        assert_raises_rpc_error(-1, "Block header missing", self.nodes[0].getblockfrompeer, "00" * 32, 0)
 
         self.log.info("Non-existent peer generates error")
         for peer_id in [-1, peer_0_peer_1_id + 1]:
@@ -85,14 +84,6 @@ class GetBlockFromPeerTest(BitcoinTestFramework):
         presegwit_peer_id = peers[1]["id"]
         assert_raises_rpc_error(-1, "Pre-SegWit peer", self.nodes[0].getblockfrompeer, short_tip, presegwit_peer_id)
 
-        self.log.info("Fetching from same peer twice generates error")
-        self.nodes[0].add_p2p_connection(P2PInterface())
-        peers = self.nodes[0].getpeerinfo()
-        assert_equal(len(peers), 3)
-        slow_peer_id = peers[2]["id"]
-        assert_equal(self.nodes[0].getblockfrompeer(short_tip, slow_peer_id), {})
-        assert_raises_rpc_error(-1, "Already requested from this peer", self.nodes[0].getblockfrompeer, short_tip, slow_peer_id)
-
         self.log.info("Successful fetch")
         result = self.nodes[0].getblockfrompeer(short_tip, peer_0_peer_1_id)
         self.wait_until(lambda: self.check_for_block(node=0, hash=short_tip), timeout=1)
@@ -101,10 +92,7 @@ class GetBlockFromPeerTest(BitcoinTestFramework):
         self.log.info("Don't fetch blocks we already have")
         assert_raises_rpc_error(-1, "Block already downloaded", self.nodes[0].getblockfrompeer, short_tip, peer_0_peer_1_id)
 
-        self.log.info("Non-existent peer generates error, even if we already have the block")
-        assert_raises_rpc_error(-1, "Block already downloaded", self.nodes[0].getblockfrompeer, short_tip, peer_0_peer_1_id + 1)
-
-        self.log.info("Do fetch blocks even if the node has not seen the header yet")
+        self.log.info("Don't fetch blocks while the node has not synced past it yet")
         # For this test we need node 1 in prune mode and as a side effect this also disconnects
         # the nodes which is also necessary for the rest of the test.
         self.restart_node(1, ["-prune=550"])
@@ -114,40 +102,19 @@ class GetBlockFromPeerTest(BitcoinTestFramework):
         block_hex = self.nodes[0].getblock(blockhash=blockhash, verbosity=0)
         block = from_hex(CBlock(), block_hex)
 
-        # Connect a P2PInterface to the pruning node
-        p2p_i = P2PInterface()
-        node1_interface = self.nodes[1].add_p2p_connection(p2p_i)
-
-        node1_peers = self.nodes[1].getpeerinfo()
-        assert_equal(len(node1_peers), 1)
-        node1_interface_id = node1_peers[0]["id"]
-        assert_equal(self.nodes[1].getblockfrompeer(blockhash, node1_interface_id), {})
-        block.calc_sha256()
-        p2p_i.wait_for_getdata([block.sha256])
-        p2p_i.send_and_ping(msg_block(block))
-        assert_equal(block_hex, self.nodes[1].getblock(blockhash, 0))
-        self.nodes[1].disconnectnode(nodeid=node1_interface_id)
-
-        self.log.info("Do fetch blocks even if the node has not synced past it yet")
-
-        # Generate a block on the disconnected node that the pruning node is not connected to
-        blockhash = self.generate(self.nodes[0], 1, sync_fun=self.no_op)[0]
-        block_hex = self.nodes[0].getblock(blockhash=blockhash, verbosity=0)
-        block = from_hex(CBlock(), block_hex)
-
         # Connect a P2PInterface to the pruning node and have it submit only the header of the
         # block that the pruning node has not seen
         node1_interface = self.nodes[1].add_p2p_connection(P2PInterface())
         node1_interface.send_and_ping(msg_headers([block]))
 
         # Get the peer id of the P2PInterface from the pruning node
-        node1_interface = self.nodes[1].add_p2p_connection(P2PInterface())
         node1_peers = self.nodes[1].getpeerinfo()
-        assert_equal(len(node1_peers), 2)
-        node1_interface_id = node1_peers[1]["id"]
+        assert_equal(len(node1_peers), 1)
+        node1_interface_id = node1_peers[0]["id"]
 
-        # Trying to fetch this block from the P2PInterface should be possible
-        assert_equal(self.nodes[1].getblockfrompeer(blockhash, node1_interface_id), {})
+        # Trying to fetch this block from the P2PInterface should not be possible
+        error_msg = "In prune mode, only blocks that the node has already synced previously can be fetched from a peer"
+        assert_raises_rpc_error(-1, error_msg, self.nodes[1].getblockfrompeer, blockhash, node1_interface_id)
 
         self.log.info("Connect pruned node")
         self.connect_nodes(0, 2)
@@ -157,21 +124,10 @@ class GetBlockFromPeerTest(BitcoinTestFramework):
         # We need to generate more blocks to be able to prune
         self.generate(self.nodes[0], 400, sync_fun=self.no_op)
         self.sync_blocks([self.nodes[0], pruned_node])
-
-        # The goal now will be to mimic the automatic pruning process and verify what happens when we fetch an historic
-        # block at any point of time.
-        #
-        # Starting with three blocks files. The pruning process will prune them one by one. And, at the second pruning
-        # event, the test will fetch the past block. Which will be stored at the latest block file. Which can only be
-        # pruned when the latest block file is full (in this case, the third one), and a new one is created.
-
-        # First prune event, prune first block file
-        highest_pruned_block_num = pruned_node.getblockfileinfo(0)["highest_block"]
-        pruneheight = pruned_node.pruneblockchain(highest_pruned_block_num + 1)
-        assert_equal(pruneheight, highest_pruned_block_num)
+        pruneheight = pruned_node.pruneblockchain(300)
+        assert_equal(pruneheight, 248)
         # Ensure the block is actually pruned
-        fetch_block_num = 2
-        pruned_block = self.nodes[0].getblockhash(fetch_block_num)
+        pruned_block = self.nodes[0].getblockhash(2)
         assert_raises_rpc_error(-1, "Block not available (pruned data)", pruned_node.getblock, pruned_block)
 
         self.log.info("Fetch pruned block")
@@ -182,29 +138,18 @@ class GetBlockFromPeerTest(BitcoinTestFramework):
         self.wait_until(lambda: self.check_for_block(node=2, hash=pruned_block), timeout=1)
         assert_equal(result, {})
 
-        # Validate that the re-fetched block was stored at the last, current, block file
-        assert_equal(fetch_block_num, pruned_node.getblockfileinfo(2)["lowest_block"])
-
         self.log.info("Fetched block persists after next pruning event")
         self.generate(self.nodes[0], 250, sync_fun=self.no_op)
         self.sync_blocks([self.nodes[0], pruned_node])
-
-        # Second prune event, prune second block file
-        highest_pruned_block_num = pruned_node.getblockfileinfo(1)["highest_block"]
-        pruneheight = pruned_node.pruneblockchain(highest_pruned_block_num + 1)
-        assert_equal(pruneheight, highest_pruned_block_num)
-        # As the re-fetched block is in the third file, and we just pruned the second one, 'getblock' must work.
+        pruneheight += 251
+        assert_equal(pruned_node.pruneblockchain(700), pruneheight)
         assert_equal(pruned_node.getblock(pruned_block)["hash"], "36c56c5b5ebbaf90d76b0d1a074dcb32d42abab75b7ec6fa0ffd9b4fbce8f0f7")
 
-        self.log.info("Re-fetched block can be pruned again when a new block file is created")
+        self.log.info("Fetched block can be pruned again when prune height exceeds the height of the tip at the time when the block was fetched")
         self.generate(self.nodes[0], 250, sync_fun=self.no_op)
         self.sync_blocks([self.nodes[0], pruned_node])
-
-        # Third prune event, prune third block file
-        highest_pruned_block_num = pruned_node.getblockfileinfo(2)["highest_block"]
-        pruneheight = pruned_node.pruneblockchain(highest_pruned_block_num + 1)
-        assert_equal(pruneheight, highest_pruned_block_num)
-        # and check that the re-fetched block file is now pruned
+        pruneheight += 250
+        assert_equal(pruned_node.pruneblockchain(1000), pruneheight)
         assert_raises_rpc_error(-1, "Block not available (pruned data)", pruned_node.getblock, pruned_block)
 
 
diff --git a/test/functional/rpc_getblocklocations.py b/test/functional/rpc_getblocklocations.py
deleted file mode 100755
index bafa53a794..0000000000
--- a/test/functional/rpc_getblocklocations.py
+++ /dev/null
@@ -1,86 +0,0 @@
-#!/usr/bin/env python3
-# Copyright (c) 2019-2020 The Bitcoin Core developers
-# Distributed under the MIT software license, see the accompanying
-# file COPYING or http://www.opensource.org/licenses/mit-license.php.
-"""Test the getblocklocations rpc call."""
-from test_framework.test_framework import BitcoinTestFramework
-from test_framework.util import (
-    assert_equal,
-    assert_raises_rpc_error,
-    util_xor,
-)
-from test_framework.messages import ser_vector
-
-
-class GetblocklocationsTest(BitcoinTestFramework):
-    def set_test_params(self):
-        self.setup_clean_chain = True
-        self.num_nodes = 1
-
-    def run_test(self):
-        """Test a trivial usage of the getblocklocations RPC command."""
-        node = self.nodes[0]
-        test_block_count = 7
-        self.generate(node, test_block_count)
-
-        NULL_HASH = '0000000000000000000000000000000000000000000000000000000000000000'
-
-        block_hashes = [node.getblockhash(height) for height in range(test_block_count)]
-        block_hashes.reverse()
-
-        block_locations = {}
-        def check_consistency(tip, a):
-            for o in a:
-                if tip in block_locations:
-                    assert_equal(block_locations[tip], o)
-                else:
-                    block_locations[tip] = o
-                tip = o['prev']
-
-        # Get blocks' locations using several batch sizes
-        last_locations = None
-        for batch_size in range(1, 10):
-            locations = []
-            tip = block_hashes[0]
-            while tip != NULL_HASH:
-                locations.extend(node.getblocklocations(tip, batch_size))
-                check_consistency(block_hashes[0], locations)
-                tip = locations[-1]['prev']
-            if last_locations: assert_equal(last_locations, locations)
-            last_locations = locations
-
-        xor_key = node.read_xor_key()
-
-        # Read blocks' data from the file system
-        blocks_dir = node.chain_path / 'blocks'
-        with (blocks_dir / 'blk00000.dat').open('rb') as blkfile:
-            for block_hash in block_hashes:
-                location = block_locations[block_hash]
-                block_bytes = bytes.fromhex(node.getblock(block_hash, 0))
-                assert_file_contains(blkfile, location['data'], block_bytes, xor_key)
-
-
-        empty_undo = ser_vector([])  # empty blocks = no transactions to undo
-        with (blocks_dir / 'rev00000.dat').open('rb') as revfile:
-            for block_hash in block_hashes[:-1]:  # skip genesis block (has no undo)
-                location = block_locations[block_hash]
-                assert_file_contains(revfile, location['undo'], empty_undo, xor_key)
-
-        # Fail getting unknown block
-        unknown_block_hash = '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef'
-        assert_raises_rpc_error(-5, 'Block not found', node.getblocklocations, unknown_block_hash, 3)
-
-        # Fail in pruned mode
-        self.restart_node(0, ['-prune=1'])
-        tip = block_hashes[0]
-        assert_raises_rpc_error(-1, 'Block locations are not available in prune mode', node.getblocklocations, tip, 3)
-
-
-def assert_file_contains(fileobj, offset, data, xor_key):
-    fileobj.seek(offset)
-    read_data = fileobj.read(len(data))
-    read_data = util_xor(read_data, xor_key, offset=offset)
-    assert_equal(read_data, data)
-
-if __name__ == '__main__':
-    GetblocklocationsTest(__file__).main()
diff --git a/test/functional/rpc_getdescriptoractivity.py b/test/functional/rpc_getdescriptoractivity.py
deleted file mode 100755
index 3efa1948b7..0000000000
--- a/test/functional/rpc_getdescriptoractivity.py
+++ /dev/null
@@ -1,226 +0,0 @@
-#!/usr/bin/env python3
-# Copyright (c) 2024-present The Bitcoin Core developers
-# Distributed under the MIT software license, see the accompanying
-# file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-from decimal import Decimal
-
-from test_framework.test_framework import BitcoinTestFramework
-from test_framework.util import assert_equal, assert_raises_rpc_error
-from test_framework.messages import COIN
-from test_framework.wallet import MiniWallet, MiniWalletMode, getnewdestination
-
-
-class GetBlocksActivityTest(BitcoinTestFramework):
-    def set_test_params(self):
-        self.num_nodes = 1
-        self.setup_clean_chain = True
-
-    def run_test(self):
-        node = self.nodes[0]
-        wallet = MiniWallet(node)
-        node.setmocktime(node.getblockheader(node.getbestblockhash())['time'])
-        wallet.generate(200, invalid_call=False)
-
-        self.test_no_activity(node)
-        self.test_activity_in_block(node, wallet)
-        self.test_no_mempool_inclusion(node, wallet)
-        self.test_multiple_addresses(node, wallet)
-        self.test_invalid_blockhash(node, wallet)
-        self.test_invalid_descriptor(node, wallet)
-        self.test_confirmed_and_unconfirmed(node, wallet)
-        self.test_receive_then_spend(node, wallet)
-        self.test_no_address(node, wallet)
-
-    def test_no_activity(self, node):
-        _, _, addr_1 = getnewdestination()
-        result = node.getdescriptoractivity([], [f"addr({addr_1})"], True)
-        assert_equal(len(result['activity']), 0)
-
-    def test_activity_in_block(self, node, wallet):
-        _, spk_1, addr_1 = getnewdestination(address_type='bech32m')
-        txid = wallet.send_to(from_node=node, scriptPubKey=spk_1, amount=1 * COIN)['txid']
-        blockhash = self.generate(node, 1)[0]
-
-        # Test getdescriptoractivity with the specific blockhash
-        result = node.getdescriptoractivity([blockhash], [f"addr({addr_1})"], True)
-        assert_equal(list(result.keys()), ['activity'])
-        [activity] = result['activity']
-
-        for k, v in {
-                'amount': Decimal('1.00000000'),
-                'blockhash': blockhash,
-                'height': 201,
-                'txid': txid,
-                'type': 'receive',
-                'vout': 1,
-        }.items():
-            assert_equal(activity[k], v)
-
-        outspk = activity['output_spk']
-
-        assert_equal(outspk['asm'][:2], '1 ')
-        assert_equal(outspk['desc'].split('(')[0], 'rawtr')
-        assert_equal(outspk['hex'], spk_1.hex())
-        assert_equal(outspk['address'], addr_1)
-        assert_equal(outspk['type'], 'witness_v1_taproot')
-
-
-    def test_no_mempool_inclusion(self, node, wallet):
-        _, spk_1, addr_1 = getnewdestination()
-        wallet.send_to(from_node=node, scriptPubKey=spk_1, amount=1 * COIN)
-
-        _, spk_2, addr_2 = getnewdestination()
-        wallet.send_to(
-            from_node=node, scriptPubKey=spk_2, amount=1 * COIN)
-
-        # Do not generate a block to keep the transaction in the mempool
-
-        result = node.getdescriptoractivity([], [f"addr({addr_1})", f"addr({addr_2})"], False)
-
-        assert_equal(len(result['activity']), 0)
-
-    def test_multiple_addresses(self, node, wallet):
-        _, spk_1, addr_1 = getnewdestination()
-        _, spk_2, addr_2 = getnewdestination()
-        wallet.send_to(from_node=node, scriptPubKey=spk_1, amount=1 * COIN)
-        wallet.send_to(from_node=node, scriptPubKey=spk_2, amount=2 * COIN)
-
-        blockhash = self.generate(node, 1)[0]
-
-        result = node.getdescriptoractivity([blockhash], [f"addr({addr_1})", f"addr({addr_2})"], True)
-
-        assert_equal(len(result['activity']), 2)
-
-        # Duplicate address specification is fine.
-        assert_equal(
-            result,
-            node.getdescriptoractivity([blockhash], [
-                f"addr({addr_1})", f"addr({addr_1})", f"addr({addr_2})"], True))
-
-        # Flipping descriptor order doesn't affect results.
-        result_flipped = node.getdescriptoractivity(
-            [blockhash], [f"addr({addr_2})", f"addr({addr_1})"], True)
-        assert_equal(result, result_flipped)
-
-        [a1] = [a for a in result['activity'] if a['output_spk']['address'] == addr_1]
-        [a2] = [a for a in result['activity'] if a['output_spk']['address'] == addr_2]
-
-        assert a1['blockhash'] == blockhash
-        assert a1['amount'] == 1.0
-
-        assert a2['blockhash'] == blockhash
-        assert a2['amount'] == 2.0
-
-    def test_invalid_blockhash(self, node, wallet):
-        self.generate(node, 20) # Generate to get more fees
-
-        _, spk_1, addr_1 = getnewdestination()
-        wallet.send_to(from_node=node, scriptPubKey=spk_1, amount=1 * COIN)
-
-        invalid_blockhash = "0000000000000000000000000000000000000000000000000000000000000000"
-
-        assert_raises_rpc_error(
-            -5, "Block not found",
-            node.getdescriptoractivity, [invalid_blockhash], [f"addr({addr_1})"], True)
-
-    def test_invalid_descriptor(self, node, wallet):
-        blockhash = self.generate(node, 1)[0]
-        _, _, addr_1 = getnewdestination()
-
-        assert_raises_rpc_error(
-            -5, "is not a valid descriptor",
-            node.getdescriptoractivity, [blockhash], [f"addrx({addr_1})"], True)
-
-    def test_confirmed_and_unconfirmed(self, node, wallet):
-        self.generate(node, 20) # Generate to get more fees
-
-        _, spk_1, addr_1 = getnewdestination()
-        txid_1 = wallet.send_to(
-            from_node=node, scriptPubKey=spk_1, amount=1 * COIN)['txid']
-        blockhash = self.generate(node, 1)[0]
-
-        _, spk_2, to_addr = getnewdestination()
-        txid_2 = wallet.send_to(
-            from_node=node, scriptPubKey=spk_2, amount=1 * COIN)['txid']
-
-        result = node.getdescriptoractivity(
-            [blockhash], [f"addr({addr_1})", f"addr({to_addr})"], True)
-
-        activity = result['activity']
-        assert_equal(len(activity), 2)
-
-        [confirmed] = [a for a in activity if a.get('blockhash') == blockhash]
-        assert confirmed['txid'] == txid_1
-        assert confirmed['height'] == node.getblockchaininfo()['blocks']
-
-        [unconfirmed] = [a for a in activity if not a.get('blockhash')]
-        assert 'blockhash' not in unconfirmed
-        assert 'height' not in unconfirmed
-
-        assert any(a['txid'] == txid_2 for a in activity if not a.get('blockhash'))
-
-    def test_receive_then_spend(self, node, wallet):
-        """Also important because this tests multiple blockhashes."""
-        self.generate(node, 20) # Generate to get more fees
-
-        sent1 = wallet.send_self_transfer(from_node=node)
-        utxo = sent1['new_utxo']
-        blockhash_1 = self.generate(node, 1)[0]
-
-        sent2 = wallet.send_self_transfer(from_node=node, utxo_to_spend=utxo)
-        blockhash_2 = self.generate(node, 1)[0]
-
-        result = node.getdescriptoractivity(
-            [blockhash_1, blockhash_2], [wallet.get_descriptor()], True)
-
-        assert_equal(len(result['activity']), 4)
-
-        assert result['activity'][1]['type'] == 'receive'
-        assert result['activity'][1]['txid'] == sent1['txid']
-        assert result['activity'][1]['blockhash'] == blockhash_1
-
-        assert result['activity'][2]['type'] == 'spend'
-        assert result['activity'][2]['spend_txid'] == sent2['txid']
-        assert result['activity'][2]['prevout_txid'] == sent1['txid']
-        assert result['activity'][2]['blockhash'] == blockhash_2
-
-        # Test that reversing the blockorder yields the same result.
-        assert_equal(result, node.getdescriptoractivity(
-            [blockhash_1, blockhash_2], [wallet.get_descriptor()], True))
-
-        # Test that duplicating a blockhash yields the same result.
-        assert_equal(result, node.getdescriptoractivity(
-            [blockhash_1, blockhash_2, blockhash_2], [wallet.get_descriptor()], True))
-
-    def test_no_address(self, node, wallet):
-        raw_wallet = MiniWallet(self.nodes[0], mode=MiniWalletMode.RAW_P2PK)
-        raw_wallet.generate(100, invalid_call=False)
-
-        no_addr_tx = raw_wallet.send_self_transfer(from_node=node)
-        raw_desc = raw_wallet.get_descriptor()
-
-        blockhash = self.generate(node, 1)[0]
-
-        result = node.getdescriptoractivity([blockhash], [raw_desc], False)
-
-        assert_equal(len(result['activity']), 2)
-
-        a1 = result['activity'][0]
-        a2 = result['activity'][1]
-
-        assert a1['type'] == "spend"
-        assert a1['blockhash'] == blockhash
-        # sPK lacks address.
-        assert_equal(list(a1['prevout_spk'].keys()), ['asm', 'desc', 'hex', 'type'])
-        assert a1['amount'] == no_addr_tx["fee"] + Decimal(no_addr_tx["tx"].vout[0].nValue) / COIN
-
-        assert a2['type'] == "receive"
-        assert a2['blockhash'] == blockhash
-        # sPK lacks address.
-        assert_equal(list(a2['output_spk'].keys()), ['asm', 'desc', 'hex', 'type'])
-        assert a2['amount'] == Decimal(no_addr_tx["tx"].vout[0].nValue) / COIN
-
-
-if __name__ == '__main__':
-    GetBlocksActivityTest(__file__).main()
diff --git a/test/functional/rpc_getgeneralinfo.py b/test/functional/rpc_getgeneralinfo.py
deleted file mode 100755
index fba0aa052f..0000000000
--- a/test/functional/rpc_getgeneralinfo.py
+++ /dev/null
@@ -1,46 +0,0 @@
-#!/usr/bin/env python3
-# Copyright (c) 2020-2022 The Bitcoin Core developers
-# Distributed under the MIT software license, see the accompanying
-# file COPYING or http://www.opensource.org/licenses/mit-license.php.
-"""Test the getgeneralinfo RPC."""
-
-import os.path
-import time
-
-from test_framework.test_framework import BitcoinTestFramework
-from test_framework.util import assert_equal
-
-class GetGeneralInfoTest(BitcoinTestFramework):
-    def set_test_params(self):
-        self.setup_clean_chain = False
-        self.num_nodes = 1
-        self.min_starttime = int(time.time())
-
-    def run_test(self):
-        """Test getgeneralinfo."""
-        max_starttime = int(time.time()) + 1
-
-        """Check if 'getgeneralinfo' is idempotent (multiple requests return same data)."""
-        json1 = self.nodes[0].getgeneralinfo()
-        json2 = self.nodes[0].getgeneralinfo()
-        assert_equal(json1, json2)
-
-        """Check 'getgeneralinfo' result is correct."""
-        ver_search = f'version {json1["clientversion"]} ('
-        with open(self.nodes[0].debug_log_path, encoding='utf-8') as dl:
-            for line in dl:
-                if line.find(ver_search) >= 0:
-                    break
-            else:
-                raise AssertionError(f"Failed to find clientversion '{json1['clientversion']}' in debug log")
-
-        assert_equal(json1['useragent'], self.nodes[0].getnetworkinfo()['subversion'])
-
-        net_datadir = str(self.nodes[0].chain_path)
-        assert_equal(json1['datadir'], net_datadir)
-        assert_equal(json1['blocksdir'], os.path.join(net_datadir, "blocks"))
-        # startuptime is set before mocktime param is loaded
-        assert json1['startuptime'] >= self.min_starttime and json1['startuptime'] <= max_starttime
-
-if __name__ == '__main__':
-    GetGeneralInfoTest(__file__).main()
diff --git a/test/functional/rpc_getrpcwhitelist.py b/test/functional/rpc_getrpcwhitelist.py
deleted file mode 100755
index 8cc08fbae7..0000000000
--- a/test/functional/rpc_getrpcwhitelist.py
+++ /dev/null
@@ -1,111 +0,0 @@
-#!/usr/bin/env python3
-# Copyright (c) 2017-2020 The Bitcoin Core developers
-# Distributed under the MIT software license, see the accompanying
-# file COPYING or http://www.opensource.org/licenses/mit-license.php.
-"""
-Test getrpcwhitelist RPC call.
-"""
-from test_framework.test_framework import BitcoinTestFramework
-from test_framework.util import (
-    assert_equal,
-    get_datadir_path,
-    str_to_b64str
-)
-import http.client
-import json
-import os
-import urllib.parse
-
-def call_rpc(node, settings, rpc):
-    url = urllib.parse.urlparse(node.url)
-    headers = {"Authorization": "Basic " + str_to_b64str('{}:{}'.format(settings[0], settings[2]))}
-    conn = http.client.HTTPConnection(url.hostname, url.port)
-    conn.connect()
-    conn.request('POST', '/', '{"method": "' + rpc + '"}', headers)
-    resp = conn.getresponse()
-    code = resp.status
-    if code == 200:
-        json_ret = json.loads(resp.read().decode())
-    else:
-        json_ret = {"result": None}
-    conn.close()
-    return {"status": code, "json": json_ret['result']}
-
-class RPCWhitelistTest(BitcoinTestFramework):
-    def add_options(self, parser):
-        self.add_wallet_options(parser)
-
-    def set_test_params(self):
-        self.num_nodes = 1
-        if self.is_wallet_compiled():
-            self.skip_if_no_wallet()
-
-    def setup_chain(self):
-        super().setup_chain()
-        self.settings = ["dummy",
-                         "4e799db4b65924f4468b1c9ff3a68109$5fcd282dcaf4ae74599934a543626c0a11e7e83ead30f07b182058ead8e85da9",
-                         "dummypwd",
-                         "getbalance,getrpcwhitelist,getwalletinfo"]
-        self.settings_forbidden = ["dummy2",
-                        "f3d319f64b076012f75626c9d895fced$7f55381a24fda02c5de7c18fc377f56fc573149b4d6f83daa9fd584210b51f99",
-                        "dummy2pwd",
-                        "getbalance,getwalletinfo"]
-        self.settings3 = ["dummy3",
-                         "7afab69a70b08a1499a5a9031eaa5479$a3bcfa66a0050564afe4f86300f95be2432cf9581dc6f51eb831f8671650587a",
-                         "dummy3pwd",
-                         "getrpcwhitelist"]
-        self.settings4 = ["dummy4",
-                         "487024a6853066e1faecfd8a7bb46c63$3ac8b40945d1eeb735da6429db1fe6a179994ed8a0bc01590da1552935f41623",
-                         "dummy4pwd",
-                         "getrpcwhitelist"]
-
-        # declare rpc-whitelisting entries
-        with open(os.path.join(get_datadir_path(self.options.tmpdir, 0), "bitcoin.conf"), 'a', encoding='utf8') as f:
-            f.write("\nrpcwhitelistdefault=0\n")
-            f.write("rpcauth={}:{}\n".format(self.settings[0], self.settings[1]))
-            f.write("rpcwhitelist={}:{}\n".format(self.settings[0], self.settings[3]))
-            f.write("rpcauth={}:{}\n".format(self.settings_forbidden[0], self.settings_forbidden[1]))
-            f.write("rpcwhitelist={}:{}\n".format(self.settings_forbidden[0], self.settings_forbidden[3]))
-            f.write("rpcauth={}:{}:-\n".format(self.settings3[0], self.settings3[1]))
-            f.write("rpcwhitelist={}:{}\n".format(self.settings3[0], self.settings3[3]))
-            f.write("rpcauth={}:{}:second\n".format(self.settings4[0], self.settings4[1]))
-            f.write("rpcwhitelist={}:{}\n".format(self.settings4[0], self.settings4[3]))
-
-    def run_test(self):
-        if self.is_wallet_compiled():
-            self.nodes[0].createwallet('second')
-
-        self.log.info("Test getrpcwhitelist")
-        whitelisted = {method: None for method in self.settings[3].split(',')}
-
-        # should return allowed rpcs
-        result = call_rpc(self.nodes[0], self.settings, 'getrpcwhitelist')
-        assert_equal(200, result['status'])
-        assert_equal(result['json']['methods'], whitelisted)
-        if self.is_wallet_compiled():
-            assert_equal(result['json']['wallets'], {self.default_wallet_name: None, 'second': None})
-        else:
-            assert_equal(result['json']['wallets'], {})
-
-        whitelisted = {method: None for method in self.settings3[3].split(',')}
-        result = call_rpc(self.nodes[0], self.settings3, 'getrpcwhitelist')
-        assert_equal(200, result['status'])
-        assert_equal(result['json']['methods'], whitelisted)
-        assert_equal(result['json']['wallets'], {})
-
-        if self.is_wallet_compiled():
-            result = call_rpc(self.nodes[0], self.settings4, 'getrpcwhitelist')
-            assert_equal(200, result['status'])
-            assert_equal(result['json']['methods'], whitelisted)
-            assert_equal(result['json']['wallets'], {'second':None})
-
-        # should fail because user has no rpcwhitelist-rpc entry in bitcoin.conf
-        result = call_rpc(self.nodes[0], self.settings_forbidden, 'getrpcwhitelist')
-        assert_equal(result['status'], 403)
-
-        # should return a long list of allowed RPC methods (ie, all of them)
-        result = self.nodes[0].getrpcwhitelist()
-        assert len(result['methods']) > 10
-
-if __name__ == "__main__":
-    RPCWhitelistTest(__file__).main()
diff --git a/test/functional/rpc_help.py b/test/functional/rpc_help.py
index 4cc0ed8c1b..4ce24ecb67 100755
--- a/test/functional/rpc_help.py
+++ b/test/functional/rpc_help.py
@@ -65,7 +65,7 @@ class HelpRpcTest(BitcoinTestFramework):
 
         mapping_server = self.nodes[0].help("dump_all_command_conversions")
         # Filter all RPCs whether they need conversion
-        mapping_server_conversion = set(tuple(m[:3]) for m in mapping_server if not m[3])
+        mapping_server_conversion = [tuple(m[:3]) for m in mapping_server if not m[3]]
 
         # Only check if all RPC methods have been compiled (i.e. wallet is enabled)
         if self.is_wallet_compiled() and sorted(mapping_client) != sorted(mapping_server_conversion):
@@ -103,7 +103,7 @@ class HelpRpcTest(BitcoinTestFramework):
         # command titles
         titles = [line[3:-3] for line in node.help().splitlines() if line.startswith('==')]
 
-        components = ['Blockchain', 'Control', 'Mining', 'Network', 'Rawtransactions', 'Stats', 'Util']
+        components = ['Blockchain', 'Control', 'Mining', 'Network', 'Rawtransactions', 'Util']
 
         if self.is_wallet_compiled():
             components.append('Wallet')
diff --git a/test/functional/rpc_invalid_address_message.py b/test/functional/rpc_invalid_address_message.py
index a210d6a995..07795534a0 100755
--- a/test/functional/rpc_invalid_address_message.py
+++ b/test/functional/rpc_invalid_address_message.py
@@ -51,28 +51,18 @@ class InvalidAddressErrorMessageTest(BitcoinTestFramework):
         info = self.nodes[0].validateaddress(addr)
         assert info['isvalid']
         assert 'error' not in info
-        assert 'error_index' not in info
         assert 'error_locations' not in info
 
     def check_invalid(self, addr, error_str, error_locations=None):
         res = self.nodes[0].validateaddress(addr)
-        if addr[:2] == 'bc':
-            assert_equal(res, self.nodes[0].validateaddress(address=addr, address_type='bech32'))
         assert not res['isvalid']
         assert_equal(res['error'], error_str)
         if error_locations:
-            assert_equal(res['error_index'], error_locations[0])
             assert_equal(res['error_locations'], error_locations)
         else:
-            assert 'error_index' not in res
             assert_equal(res['error_locations'], [])
 
     def test_validateaddress(self):
-        # Invalid deprecated address_type field
-        assert_raises_rpc_error(-8, "Unknown address type 'nonsense'", self.nodes[0].validateaddress, address=BECH32_INVALID_SIZE, address_type='nonsense')
-        for inv_addrtype in (7, True, {}, [], ['bech32']):
-            assert_raises_rpc_error(-3, "is not of expected type string", self.nodes[0].validateaddress, address=BECH32_INVALID_SIZE, address_type=inv_addrtype)
-
         # Invalid Bech32
         self.check_invalid(BECH32_INVALID_SIZE, "Invalid Bech32 address program size (41 bytes)")
         self.check_invalid(BECH32_INVALID_PREFIX, 'Invalid or unsupported Segwit (Bech32) or Base58 encoding.')
diff --git a/test/functional/rpc_net.py b/test/functional/rpc_net.py
index 63e8d70eef..b63059b1ee 100755
--- a/test/functional/rpc_net.py
+++ b/test/functional/rpc_net.py
@@ -37,7 +37,7 @@ def assert_net_servicesnames(servicesflag, servicenames):
     """
     servicesflag_generated = 0
     for servicename in servicenames:
-        servicesflag_generated |= getattr(test_framework.messages, 'NODE_' + servicename.rstrip('?'))
+        servicesflag_generated |= getattr(test_framework.messages, 'NODE_' + servicename)
     assert servicesflag_generated == servicesflag
 
 
@@ -63,9 +63,6 @@ class NetTest(BitcoinTestFramework):
     def set_test_params(self):
         self.num_nodes = 2
         self.extra_args = [["-minrelaytxfee=0.00001000"], ["-minrelaytxfee=0.00000500"]]
-        # Specify a non-working proxy to make sure no actual connections to public IPs are attempted
-        for args in self.extra_args:
-            args.append("-proxy=127.0.0.1:1")
         self.supports_cli = False
 
     def run_test(self):
@@ -142,7 +139,6 @@ class NetTest(BitcoinTestFramework):
         # The next two fields will vary for v2 connections because we send a rng-based number of decoy messages
         peer_info.pop("bytesrecv")
         peer_info.pop("bytessent")
-        peer_info.pop("cpu_load", None)
         assert_equal(
             peer_info,
             {
@@ -165,7 +161,6 @@ class NetTest(BitcoinTestFramework):
                 "minfeefilter": Decimal("0E-8"),
                 "network": "not_publicly_routable",
                 "permissions": [],
-                "forced_inbound": False,
                 "presynced_headers": -1,
                 "relaytxes": False,
                 "services": "0000000000000000",
@@ -178,7 +173,6 @@ class NetTest(BitcoinTestFramework):
                 "timeoffset": 0,
                 "transport_protocol_type": "v1" if not self.options.v2transport else "v2",
                 "version": 0,
-                "misbehavior_score": 0,
             },
         )
         no_version_peer.peer_disconnect()
diff --git a/test/functional/rpc_orphans.py b/test/functional/rpc_orphans.py
deleted file mode 100755
index 4871166a39..0000000000
--- a/test/functional/rpc_orphans.py
+++ /dev/null
@@ -1,153 +0,0 @@
-#!/usr/bin/env python3
-# Copyright (c) 2014-2024 The Bitcoin Core developers
-# Distributed under the MIT software license, see the accompanying
-# file COPYING or http://www.opensource.org/licenses/mit-license.php.
-"""Tests for orphan related RPCs."""
-
-import time
-
-from test_framework.mempool_util import (
-    ORPHAN_TX_EXPIRE_TIME,
-    tx_in_orphanage,
-)
-from test_framework.messages import msg_tx
-from test_framework.p2p import P2PInterface
-from test_framework.util import (
-    assert_equal,
-    assert_raises_rpc_error,
-)
-from test_framework.test_framework import BitcoinTestFramework
-from test_framework.wallet import MiniWallet
-
-
-class OrphanRPCsTest(BitcoinTestFramework):
-    def set_test_params(self):
-        self.num_nodes = 1
-
-    def run_test(self):
-        self.wallet = MiniWallet(self.nodes[0])
-        self.test_orphan_activity()
-        self.test_orphan_details()
-        self.test_misc()
-
-    def test_orphan_activity(self):
-        self.log.info("Check that orphaned transactions are returned with getorphantxs")
-        node = self.nodes[0]
-
-        self.log.info("Create two 1P1C packages, but only broadcast the children")
-        tx_parent_1 = self.wallet.create_self_transfer()
-        tx_child_1 = self.wallet.create_self_transfer(utxo_to_spend=tx_parent_1["new_utxo"])
-        tx_parent_2 = self.wallet.create_self_transfer()
-        tx_child_2 = self.wallet.create_self_transfer(utxo_to_spend=tx_parent_2["new_utxo"])
-        peer = node.add_p2p_connection(P2PInterface())
-        peer.send_and_ping(msg_tx(tx_child_1["tx"]))
-        peer.send_and_ping(msg_tx(tx_child_2["tx"]))
-
-        self.log.info("Check that neither parent is in the mempool")
-        assert_equal(node.getmempoolinfo()["size"], 0)
-
-        orphanage = node.getorphantxs(verbosity=0)
-        self.log.info("Check the size of the orphanage")
-        assert_equal(len(orphanage), 2)
-        self.log.info("Check that undefined verbosity is disallowed")
-        assert_raises_rpc_error(-8, "Invalid verbosity value -1", node.getorphantxs, verbosity=-1)
-        assert_raises_rpc_error(-8, "Invalid verbosity value 3", node.getorphantxs, verbosity=3)
-        self.log.info("Check that both children are in the orphanage")
-        assert tx_in_orphanage(node, tx_child_1["tx"])
-        assert tx_in_orphanage(node, tx_child_2["tx"])
-
-        self.log.info("Broadcast parent 1")
-        peer.send_and_ping(msg_tx(tx_parent_1["tx"]))
-        self.log.info("Check that parent 1 and child 1 are in the mempool")
-        raw_mempool = node.getrawmempool()
-        assert_equal(len(raw_mempool), 2)
-        assert tx_parent_1["txid"] in raw_mempool
-        assert tx_child_1["txid"] in raw_mempool
-
-        self.log.info("Check that orphanage only contains child 2")
-        orphanage = node.getorphantxs()
-        assert_equal(len(orphanage), 1)
-        assert tx_in_orphanage(node, tx_child_2["tx"])
-
-        peer.send_and_ping(msg_tx(tx_parent_2["tx"]))
-        self.log.info("Check that all parents and children are now in the mempool")
-        raw_mempool = node.getrawmempool()
-        assert_equal(len(raw_mempool), 4)
-        assert tx_parent_1["txid"] in raw_mempool
-        assert tx_child_1["txid"] in raw_mempool
-        assert tx_parent_2["txid"] in raw_mempool
-        assert tx_child_2["txid"] in raw_mempool
-        self.log.info("Check that the orphanage is empty")
-        assert_equal(len(node.getorphantxs()), 0)
-
-        self.log.info("Confirm the transactions (clears mempool)")
-        self.generate(node, 1)
-        assert_equal(node.getmempoolinfo()["size"], 0)
-
-    def test_orphan_details(self):
-        self.log.info("Check the transaction details returned from getorphantxs")
-        node = self.nodes[0]
-
-        self.log.info("Create two orphans, from different peers")
-        tx_parent_1 = self.wallet.create_self_transfer()
-        tx_child_1 = self.wallet.create_self_transfer(utxo_to_spend=tx_parent_1["new_utxo"])
-        tx_parent_2 = self.wallet.create_self_transfer()
-        tx_child_2 = self.wallet.create_self_transfer(utxo_to_spend=tx_parent_2["new_utxo"])
-        peer_1 = node.add_p2p_connection(P2PInterface())
-        peer_2 = node.add_p2p_connection(P2PInterface())
-        entry_time = int(time.time())
-        node.setmocktime(entry_time)
-        peer_1.send_and_ping(msg_tx(tx_child_1["tx"]))
-        peer_2.send_and_ping(msg_tx(tx_child_2["tx"]))
-
-        orphanage = node.getorphantxs(verbosity=2)
-        assert tx_in_orphanage(node, tx_child_1["tx"])
-        assert tx_in_orphanage(node, tx_child_2["tx"])
-
-        self.log.info("Check that orphan 1 and 2 were from different peers")
-        assert orphanage[0]["from"][0] != orphanage[1]["from"][0]
-
-        self.log.info("Unorphan child 2")
-        peer_2.send_and_ping(msg_tx(tx_parent_2["tx"]))
-        assert not tx_in_orphanage(node, tx_child_2["tx"])
-
-        self.log.info("Checking orphan details")
-        orphanage = node.getorphantxs(verbosity=1)
-        assert_equal(len(node.getorphantxs()), 1)
-        orphan_1 = orphanage[0]
-        self.orphan_details_match(orphan_1, tx_child_1, verbosity=1)
-        self.log.info("Checking orphan entry/expiration times")
-        assert_equal(orphan_1["entry"], entry_time)
-        assert_equal(orphan_1["expiration"], entry_time + ORPHAN_TX_EXPIRE_TIME)
-
-        self.log.info("Checking orphan details (verbosity 2)")
-        orphanage = node.getorphantxs(verbosity=2)
-        orphan_1 = orphanage[0]
-        self.orphan_details_match(orphan_1, tx_child_1, verbosity=2)
-
-    def orphan_details_match(self, orphan, tx, verbosity):
-        self.log.info("Check txid/wtxid of orphan")
-        assert_equal(orphan["txid"], tx["txid"])
-        assert_equal(orphan["wtxid"], tx["wtxid"])
-
-        self.log.info("Check the sizes of orphan")
-        assert_equal(orphan["bytes"], len(tx["tx"].serialize()))
-        assert_equal(orphan["vsize"], tx["tx"].get_vsize())
-        assert_equal(orphan["weight"], tx["tx"].get_weight())
-
-        if verbosity == 2:
-            self.log.info("Check the transaction hex of orphan")
-            assert_equal(orphan["hex"], tx["hex"])
-
-    def test_misc(self):
-        node = self.nodes[0]
-        assert_raises_rpc_error(-3, "Verbosity was boolean but only integer allowed", node.getorphantxs, verbosity=True)
-        assert_raises_rpc_error(-3, "Verbosity was boolean but only integer allowed", node.getorphantxs, verbosity=False)
-        help_output = node.help()
-        self.log.info("Check that getorphantxs is a hidden RPC")
-        assert "getorphantxs" not in help_output
-        assert "unknown command: getorphantxs" not in node.help("getorphantxs")
-
-
-if __name__ == '__main__':
-    OrphanRPCsTest(__file__).main()
diff --git a/test/functional/rpc_psbt.py b/test/functional/rpc_psbt.py
index ea54977691..8042bdf071 100755
--- a/test/functional/rpc_psbt.py
+++ b/test/functional/rpc_psbt.py
@@ -210,58 +210,8 @@ class PSBTTest(BitcoinTestFramework):
         assert_equal(decoded_psbt["tx"]["vout"][changepos]["scriptPubKey"]["type"], expected_type)
 
     def run_test(self):
-
-        self.log.info("Test that PSBT can have user-provided UTXOs filled and signed")
-
-        # Create 1 parent 1 child chain from same wallet
-        psbtx_parent = self.nodes[0].walletcreatefundedpsbt([], {self.nodes[0].getnewaddress():10})['psbt']
-        processed_parent = self.nodes[0].walletprocesspsbt(psbtx_parent)
-        parent_txinfo = self.nodes[0].decoderawtransaction(processed_parent["hex"])
-        parent_txid = parent_txinfo["txid"]
-        parent_vout = 0 # just take the first output to spend
-
-        psbtx_child = self.nodes[0].createpsbt([{"txid": parent_txid, "vout": parent_vout}], {self.nodes[0].getnewaddress(): parent_txinfo["vout"][0]["value"] - Decimal("0.01")})
-
-        # Can not sign due to lack of utxo
-        res = self.nodes[0].walletprocesspsbt(psbtx_child)
-        assert not res["complete"]
-
-        prev_txs = [processed_parent["hex"]]
-        utxo_updated = self.nodes[0].utxoupdatepsbt(psbt=psbtx_child, prevtxs=prev_txs)
-        res = self.nodes[0].walletprocesspsbt(utxo_updated)
-        assert res["complete"]
-
-        # And descriptorprocesspsbt does the same
-        utxo_updated = self.nodes[0].descriptorprocesspsbt(psbt=psbtx_child, descriptors=[], prevtxs=prev_txs)
-        res = self.nodes[0].walletprocesspsbt(utxo_updated["psbt"])
-        assert res["complete"]
-
-        # Multiple inputs are ok, even if unrelated transactions included
-        prev_txs = [processed_parent["hex"], self.nodes[0].createrawtransaction([], [])]
-        utxo_updated = self.nodes[0].utxoupdatepsbt(psbt=psbtx_child, prevtxs=prev_txs)
-        res = self.nodes[0].walletprocesspsbt(utxo_updated)
-        assert res["complete"]
-
-        # If only irrelevant previous transactions are included, it's a no-op
-        prev_txs = [self.nodes[0].createrawtransaction([], [])]
-        utxo_updated = self.nodes[0].utxoupdatepsbt(psbt=psbtx_child, prevtxs=prev_txs)
-        assert_equal(utxo_updated, psbtx_child)
-        res = self.nodes[0].walletprocesspsbt(utxo_updated)
-        assert not res["complete"]
-
-        # If there's a txid collision, it's rejected
-        prev_txs = [processed_parent["hex"], processed_parent["hex"]]
-        assert_raises_rpc_error(-22, f"Duplicate txids in prev_txs {parent_txid}", self.nodes[0].utxoupdatepsbt, psbt=psbtx_child, prevtxs=prev_txs)
-
-        # Should abort safely if supplied transaction matches txid of prevout, but has insufficient outputs to match with prevout.n
-        psbtx_bad_child = self.nodes[0].createpsbt([{"txid": parent_txid, "vout": len(parent_txinfo["vout"])}], {self.nodes[0].getnewaddress(): parent_txinfo["vout"][0]["value"] - Decimal("0.01")})
-
-        prev_txs = [processed_parent["hex"]]
-        assert_raises_rpc_error(-22, f"Previous tx has too few outputs for PSBT input {parent_txid}", self.nodes[0].utxoupdatepsbt, psbt=psbtx_bad_child, prevtxs=prev_txs)
-
         # Create and fund a raw tx for sending 10 BTC
-        assert_raises_rpc_error(-4, "Insufficient funds", self.nodes[0].walletcreatefundedpsbt, inputs=[], outputs={self.nodes[2].getnewaddress():1}, options={'min_conf': 201})
-        psbtx1 = self.nodes[0].walletcreatefundedpsbt(inputs=[], outputs={self.nodes[2].getnewaddress():11}, options={'min_conf': 200})['psbt']
+        psbtx1 = self.nodes[0].walletcreatefundedpsbt([], {self.nodes[2].getnewaddress():10})['psbt']
 
         self.log.info("Test for invalid maximum transaction weights")
         dest_arg = [{self.nodes[0].getnewaddress(): 1}]
@@ -331,7 +281,6 @@ class PSBTTest(BitcoinTestFramework):
 
         # Sign the transaction but don't finalize
         processed_psbt = self.nodes[0].walletprocesspsbt(psbt=psbtx, finalize=False)
-        assert_equal(processed_psbt, self.nodes[0].walletprocesspsbt(psbtx, {"finalize": False}))
         assert "hex" not in processed_psbt
         signed_psbt = processed_psbt['psbt']
 
@@ -341,7 +290,6 @@ class PSBTTest(BitcoinTestFramework):
 
         # Alternative method: sign AND finalize in one command
         processed_finalized_psbt = self.nodes[0].walletprocesspsbt(psbt=psbtx, finalize=True)
-        assert_equal(processed_finalized_psbt, self.nodes[0].walletprocesspsbt(psbtx, {"finalize": True}))
         finalized_psbt = processed_finalized_psbt['psbt']
         finalized_psbt_hex = processed_finalized_psbt['hex']
         assert signed_psbt != finalized_psbt
@@ -548,13 +496,11 @@ class PSBTTest(BitcoinTestFramework):
 
         # Update psbts, should only have data for one input and not the other
         psbt1 = self.nodes[1].walletprocesspsbt(psbt_orig, False, "ALL")['psbt']
-        assert_equal(psbt1, self.nodes[1].walletprocesspsbt(psbt_orig, {"sign": False, "sighashtype": "ALL"})["psbt"])
         psbt1_decoded = self.nodes[0].decodepsbt(psbt1)
         assert psbt1_decoded['inputs'][0] and not psbt1_decoded['inputs'][1]
         # Check that BIP32 path was added
         assert "bip32_derivs" in psbt1_decoded['inputs'][0]
         psbt2 = self.nodes[2].walletprocesspsbt(psbt_orig, False, "ALL", False)['psbt']
-        assert_equal(psbt2, self.nodes[2].walletprocesspsbt(psbt_orig, {"sign": False, "sighashtype": "ALL", "bip32derivs": False})["psbt"])
         psbt2_decoded = self.nodes[0].decodepsbt(psbt2)
         assert not psbt2_decoded['inputs'][0] and psbt2_decoded['inputs'][1]
         # Check that BIP32 paths were not added
@@ -793,7 +739,6 @@ class PSBTTest(BitcoinTestFramework):
 
         # After update with wallet, only needs signing
         updated = self.nodes[1].walletprocesspsbt(psbt, False, 'ALL', True)['psbt']
-        assert_equal(updated, self.nodes[1].walletprocesspsbt(psbt, {"sign": False, "sighashtype": 'ALL', "bip32derivs": True})["psbt"])
         analyzed = self.nodes[0].analyzepsbt(updated)
         assert analyzed['inputs'][0]['has_utxo'] and not analyzed['inputs'][0]['is_final'] and analyzed['inputs'][0]['next'] == 'signer' and analyzed['next'] == 'signer' and analyzed['inputs'][0]['missing']['signatures'][0] == addrinfo['embedded']['witness_program']
 
@@ -1082,14 +1027,11 @@ class PSBTTest(BitcoinTestFramework):
         # are still added to the psbt
         alt_descriptor = descsum_create(f"wpkh({get_generate_key().privkey})")
         alt_psbt = self.nodes[2].descriptorprocesspsbt(psbt=psbt, descriptors=[alt_descriptor], sighashtype="ALL")["psbt"]
-        assert_equal(alt_psbt, self.nodes[2].descriptorprocesspsbt(psbt=psbt, descriptors=[alt_descriptor], options={'sighashtype': "ALL"})["psbt"])
         decoded = self.nodes[2].decodepsbt(alt_psbt)
         test_psbt_input_keys(decoded['inputs'][0], ['witness_utxo', 'non_witness_utxo'])
 
         # Test that the psbt is not finalized and does not have bip32_derivs unless specified
         processed_psbt = self.nodes[2].descriptorprocesspsbt(psbt=psbt, descriptors=[descriptor], sighashtype="ALL", bip32derivs=True, finalize=False)
-        assert_equal(processed_psbt, self.nodes[2].descriptorprocesspsbt(psbt=psbt, descriptors=[descriptor], options={'sighashtype': "ALL", 'bip32derivs': True, 'finalize': False}))
-        assert_equal(processed_psbt, self.nodes[2].descriptorprocesspsbt(psbt, [descriptor], "ALL", True, False))
         decoded = self.nodes[2].decodepsbt(processed_psbt['psbt'])
         test_psbt_input_keys(decoded['inputs'][0], ['witness_utxo', 'non_witness_utxo', 'partial_signatures', 'bip32_derivs'])
 
@@ -1097,7 +1039,6 @@ class PSBTTest(BitcoinTestFramework):
         assert "hex" not in processed_psbt
 
         processed_psbt = self.nodes[2].descriptorprocesspsbt(psbt=psbt, descriptors=[descriptor], sighashtype="ALL", bip32derivs=False, finalize=True)
-        assert_equal(processed_psbt, self.nodes[2].descriptorprocesspsbt(psbt, [descriptor], {'sighashtype': "ALL", 'bip32derivs': False, 'finalize': True}))
         decoded = self.nodes[2].decodepsbt(processed_psbt['psbt'])
         test_psbt_input_keys(decoded['inputs'][0], ['witness_utxo', 'non_witness_utxo', 'final_scriptwitness'])
 
@@ -1109,8 +1050,6 @@ class PSBTTest(BitcoinTestFramework):
 
         self.log.info("Test descriptorprocesspsbt raises if an invalid sighashtype is passed")
         assert_raises_rpc_error(-8, "'all' is not a valid sighash parameter.", self.nodes[2].descriptorprocesspsbt, psbt, [descriptor], sighashtype="all")
-        assert_raises_rpc_error(-8, "'all' is not a valid sighash parameter.", self.nodes[2].descriptorprocesspsbt, psbt, [descriptor], "all")
-        assert_raises_rpc_error(-8, "'all' is not a valid sighash parameter.", self.nodes[2].descriptorprocesspsbt, psbt, [descriptor], {'sighashtype': "all"})
 
 
 if __name__ == '__main__':
diff --git a/test/functional/rpc_rawtransaction.py b/test/functional/rpc_rawtransaction.py
index becd7fb7d8..18b1fc1896 100755
--- a/test/functional/rpc_rawtransaction.py
+++ b/test/functional/rpc_rawtransaction.py
@@ -409,22 +409,12 @@ class RawTransactionsTest(BitcoinTestFramework):
         testres = self.nodes[2].testmempoolaccept([tx['hex']], 0.00001000)[0]
         assert_equal(testres['allowed'], False)
         assert_equal(testres['reject-reason'], 'max-fee-exceeded')
-        testres = self.nodes[2].testmempoolaccept([tx['hex']], 0.00001000, ['foobar'])[0]
-        assert_equal(testres['allowed'], False)
-        assert_equal(testres['reject-reason'], 'max-fee-exceeded')
-        # unless ignored explicitly
-        testres = self.nodes[2].testmempoolaccept([tx['hex']], 0.00001000, ['max-fee-exceeded'])[0]
-        assert_equal(testres['allowed'], True)
-        assert('reject-reason' not in testres)
-        testres = self.nodes[2].testmempoolaccept([tx['hex']], 0.00001000, ['absurdly-high-fee'])[0]
-        assert_equal(testres['allowed'], True)
-        assert('reject-reason' not in testres)
         # and sendrawtransaction should throw
         assert_raises_rpc_error(-25, fee_exceeds_max, self.nodes[2].sendrawtransaction, tx['hex'], 0.00001000)
         # and the following calls should both succeed
         testres = self.nodes[2].testmempoolaccept(rawtxs=[tx['hex']])[0]
         assert_equal(testres['allowed'], True)
-        self.nodes[2].sendrawtransaction(hexstring=tx['hex'], maxfeerate=0.00001000, ignore_rejects=['max-fee-exceeded'])
+        self.nodes[2].sendrawtransaction(hexstring=tx['hex'])
 
         # Test a transaction with a large fee.
         # Fee rate is 0.20000000 BTC/kvB
diff --git a/test/functional/rpc_signmessagewithprivkey.py b/test/functional/rpc_signmessagewithprivkey.py
index c1ab367faf..8e86698781 100755
--- a/test/functional/rpc_signmessagewithprivkey.py
+++ b/test/functional/rpc_signmessagewithprivkey.py
@@ -4,8 +4,6 @@
 # file COPYING or http://www.opensource.org/licenses/mit-license.php.
 """Test RPC commands for signing messages with private key."""
 
-import base64
-
 from test_framework.descriptors import (
     descsum_create,
 )
@@ -24,7 +22,7 @@ class SignMessagesWithPrivTest(BitcoinTestFramework):
     def addresses_from_privkey(self, priv_key):
         '''Return addresses for a given WIF private key in legacy (P2PKH),
            nested segwit (P2SH-P2WPKH) and native segwit (P2WPKH) formats.'''
-        descriptors = f'pkh({priv_key})', f'sh(wpkh({priv_key}))', f'wpkh({priv_key})', f'wsh(pk({priv_key}))', f'tr({priv_key})'
+        descriptors = f'pkh({priv_key})', f'sh(wpkh({priv_key}))', f'wpkh({priv_key})'
         return [self.nodes[0].deriveaddresses(descsum_create(desc))[0] for desc in descriptors]
 
     def run_test(self):
@@ -41,43 +39,9 @@ class SignMessagesWithPrivTest(BitcoinTestFramework):
         assert_equal(addresses[0], 'mpLQjfK79b7CCV4VMJWEWAj5Mpx8Up5zxB')
         assert self.nodes[0].verifymessage(addresses[0], signature, message)
 
-        self.log.info('test that verifying with non-P2PKH addresses succeeds')
-        bin_sig = bytearray(base64.b64decode(signature))
-        for non_p2pkh_address in addresses[1:3]:
-            assert self.nodes[0].verifymessage(non_p2pkh_address, signature, message)
-            bin_sig[0] += 4
-            bip137_signature = base64.b64encode(bin_sig).decode('ascii')
-            assert self.nodes[0].verifymessage(non_p2pkh_address, bip137_signature, message)
-
-        self.log.info('test that verifying with p2wsh address throws error')
-        assert_raises_rpc_error(-3, "Address does not refer to key", self.nodes[0].verifymessage, addresses[3], signature, message)
-
-        self.log.info('test that verifying with p2tr address throws error')
-        assert_raises_rpc_error(-3, "Address does not refer to key", self.nodes[0].verifymessage, addresses[4], signature, message)
-
-        self.log.info('test that verifying Electrum p2sh-segwit succeeds')
-        signature = 'IFBRc4WU3K2c75KG7kcn/x9Ov6y75xrk05t9Zi7kwEIJNU0dMFMgRdeeKYo8JC4L83ckPavuaI+GUuvYZdwkGsM='
-        assert self.nodes[0].verifymessage('2MzoTgQ7YuReUaXaW2iciHoewDGdmagMVuy', signature, message)
-
-        self.log.info('test that verifying Electrum p2wpkh succeeds')
-        signature = 'IBR+8bubsBxBFFE3CO6pggzNSRyg/23HRMNXyWUIIEXmTe3P0apzd5izyR/d80nVRE883I58gijFKIevBLtcPRI='
-        assert self.nodes[0].verifymessage('bcrt1qa0mscp9epevt07rscyjsre5fdlxjp3tlcchs4x', signature, message)
-
-        self.log.info('test that verifying Sparrow p2wpkh ("Electrum") succeeds')
-        signature = 'H036ky29d5FwS0K46di8ssfP+UbVEghDoexR2GGv+WX+WQHVnTWiUTOSjazS3+aIx92qsnE0m/WK2uflxI47BhQ='
-        assert self.nodes[0].verifymessage('bcrt1q00cc7f4m04f5mjdcm9g6c5y2a3wnvfvflljety', signature, message)
-
-        self.log.info('test that verifying Sparrow p2wpkh ("BIP137/Trezor") succeeds')
-        signature = 'J036ky29d5FwS0K46di8ssfP+UbVEghDoexR2GGv+WX+WQHVnTWiUTOSjazS3+aIx92qsnE0m/WK2uflxI47BhQ='
-        assert self.nodes[0].verifymessage('bcrt1q00cc7f4m04f5mjdcm9g6c5y2a3wnvfvflljety', signature, message)
-
-        self.log.info('test that verifying Sparrow p2wpkh ("BIP322 Simple") succeeds')
-        signature = 'AkcwRAIgCu7IrN3jCvBdp5myPZHCKiOW5o3EToYG2xgPbjiw6JsCIFwaZMcYQj9FmWcNtZk3qTp2UDBm77cbFmxQ3WVnVxrCASEDonFDI6fuQ05yUfeQIsOs599XHZnpaTxaqD13g4sXYRY='
-        assert self.nodes[0].verifymessage('bcrt1q00cc7f4m04f5mjdcm9g6c5y2a3wnvfvflljety', signature, message)
-
-        self.log.info('test that verifying Sparrow p2tr ("BIP322 Simple") succeeds')
-        signature = 'AUFdYU3dZCSmTxWnl5ja/Jo096VAaKtdaYs8b4ikF2iuQ2fiy7YSFHBWcD40a1oBKTVWUrXqOC0pXoDjTFKqM/ObAQ=='
-        assert self.nodes[0].verifymessage('bcrt1p5t6gmtfkd4q8jfgz40auxqgtll895n85amlgvgsz0jwxvfw9qltss6wfve', signature, message)
+        self.log.info('test that verifying with non-P2PKH addresses throws error')
+        for non_p2pkh_address in addresses[1:]:
+            assert_raises_rpc_error(-3, "Address does not refer to key", self.nodes[0].verifymessage, non_p2pkh_address, signature, message)
 
         self.log.info('test parameter validity and error codes')
         # signmessagewithprivkey has two required parameters
diff --git a/test/functional/rpc_sort_multisig.py b/test/functional/rpc_sort_multisig.py
deleted file mode 100755
index 81528f4472..0000000000
--- a/test/functional/rpc_sort_multisig.py
+++ /dev/null
@@ -1,90 +0,0 @@
-#!/usr/bin/env python3
-# Copyright (c) 2014-2016 The Bitcoin Core developers
-# Distributed under the MIT software license, see the accompanying
-# file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-# Exercise the createmultisig API
-
-from test_framework.test_framework import BitcoinTestFramework
-from test_framework.util import (
-    assert_equal,
-    assert_raises_rpc_error,
-)
-
-class SortMultisigTest(BitcoinTestFramework):
-    def set_test_params(self):
-        self.num_nodes = 1
-        self.extra_args = [[]]
-        self.setup_clean_chain = True
-
-    def run_simple_test(self):
-        pub1 = "022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da"
-        pub2 = "03e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e9"
-        pub3 = "021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc18"
-
-        pubs = [pub1,pub2,pub3]
-
-        default = self.nodes[0].createmultisig(2, pubs)
-        unsorted_ms = self.nodes[0].createmultisig(2, pubs, {"sort": False})
-        assert_equal(unsorted_ms, self.nodes[0].createmultisig(2, pubs, options={"sort": False}))
-        assert_equal(unsorted_ms, self.nodes[0].createmultisig(2, pubs, sort=False))
-
-        assert_equal("2N2BchzwfyuqJep7sKmFfBucfopHZQuPnpt", unsorted_ms["address"])
-        assert_equal("5221022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da2103e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e921021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc1853ae", unsorted_ms["redeemScript"])
-        assert_equal(default["address"], unsorted_ms["address"])
-        assert_equal(default["redeemScript"], unsorted_ms["redeemScript"])
-
-        sorted_ms = self.nodes[0].createmultisig(2, pubs, {"sort": True})
-        assert_equal(sorted_ms, self.nodes[0].createmultisig(2, pubs, options={"sort": True}))
-        assert_equal(sorted_ms, self.nodes[0].createmultisig(2, pubs, sort=True))
-        assert_equal("2NFd5JqpwmQNz3gevZJ3rz9ofuHvqaP9Cye", sorted_ms["address"])
-        assert_equal("5221021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc1821022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da2103e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e953ae", sorted_ms["redeemScript"])
-
-    def run_demonstrate_sorting(self):
-        pub1 = "022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da"
-        pub2 = "03e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e9"
-        pub3 = "021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc18"
-
-        sorted_ms = self.nodes[0].createmultisig(2, [pub3,pub1,pub2,])
-
-        self.test_if_result_matches(2, [pub1,pub2,pub3], True, sorted_ms["address"])
-        self.test_if_result_matches(2, [pub1,pub3,pub2], True, sorted_ms["address"])
-        self.test_if_result_matches(2, [pub2,pub3,pub1], True, sorted_ms["address"])
-        self.test_if_result_matches(2, [pub2,pub1,pub3], True, sorted_ms["address"])
-        self.test_if_result_matches(2, [pub3,pub1,pub2], True, sorted_ms["address"])
-        self.test_if_result_matches(2, [pub3,pub2,pub1], True, sorted_ms["address"])
-
-        self.test_if_result_matches(2, [pub1,pub2,pub3], False, sorted_ms["address"])
-        self.test_if_result_matches(2, [pub1,pub3,pub2], False, sorted_ms["address"])
-        self.test_if_result_matches(2, [pub2,pub3,pub1], False, sorted_ms["address"])
-        self.test_if_result_matches(2, [pub2,pub1,pub3], False, sorted_ms["address"])
-        self.test_if_result_matches(2, [pub3,pub2,pub1], False, sorted_ms["address"])
-
-    def test_if_result_matches(self, m, keys, sort, against):
-        result = self.nodes[0].createmultisig(m, keys, {"sort": sort})
-        assert_equal(sort, result["address"] == against)
-
-    def test_compressed_keys_forbidden(self):
-        pub1 = "02fdf7e1b65a477a7815effde996a03a7d94cbc46f7d14c05ef38425156fc92e22"
-        pub2 = "04823336da95f0b4cf745839dff26992cef239ad2f08f494e5b57c209e4f3602d5526bc251d480e3284d129f736441560e17f3a7eb7ed665fdf0158f44550b926c"
-        rs = "522102fdf7e1b65a477a7815effde996a03a7d94cbc46f7d14c05ef38425156fc92e224104823336da95f0b4cf745839dff26992cef239ad2f08f494e5b57c209e4f3602d5526bc251d480e3284d129f736441560e17f3a7eb7ed665fdf0158f44550b926c52ae"
-        pubs = [pub1,pub2]
-
-        default = self.nodes[0].createmultisig(2, pubs)
-        assert_equal(rs, default["redeemScript"])
-
-        unsorted_ms = self.nodes[0].createmultisig(2, pubs, {"sort": False})
-        assert_equal(rs, unsorted_ms["redeemScript"])
-        assert_equal(default["address"], unsorted_ms["address"])
-        assert_equal(default["redeemScript"], unsorted_ms["redeemScript"])
-
-        assert_raises_rpc_error(-1, "Compressed key required for BIP67: 04823336da95f0b4cf745839dff26992cef239ad2f08f494e5b57c209e4f3602d5526bc251d480e3284d129f736441560e17f3a7eb7ed665fdf0158f44550b926c", self.nodes[0].createmultisig, 2, pubs, {"sort": True})
-
-    def run_test(self):
-        self.run_simple_test()
-        self.run_demonstrate_sorting()
-        self.test_compressed_keys_forbidden()
-
-if __name__ == '__main__':
-    SortMultisigTest(__file__).main()
-
diff --git a/test/functional/rpc_users.py b/test/functional/rpc_users.py
index 2ce218c9bf..44187ce790 100755
--- a/test/functional/rpc_users.py
+++ b/test/functional/rpc_users.py
@@ -12,7 +12,6 @@ from test_framework.util import (
 
 import http.client
 import os
-from pathlib import Path
 import platform
 import urllib.parse
 import subprocess
@@ -23,30 +22,24 @@ import sys
 from typing import Optional
 
 
-def call_with_auth(node, user, password, *, uripath='/', method='getbestblockhash'):
+def call_with_auth(node, user, password):
     url = urllib.parse.urlparse(node.url)
     headers = {"Authorization": "Basic " + str_to_b64str('{}:{}'.format(user, password))}
 
     conn = http.client.HTTPConnection(url.hostname, url.port)
     conn.connect()
-    conn.request('POST', uripath, f'{{"method": "{method}"}}', headers)
+    conn.request('POST', '/', '{"method": "getbestblockhash"}', headers)
     resp = conn.getresponse()
-    resp.data = resp.read()
     conn.close()
     return resp
 
 
 class HTTPBasicsTest(BitcoinTestFramework):
-    def add_options(self, parser):
-        self.add_wallet_options(parser)
-
     def set_test_params(self):
         self.num_nodes = 2
         self.supports_cli = False
 
     def conf_setup(self):
-        self.authinfo = []
-
         #Append rpcauth to bitcoin.conf before initialization
         self.rtpassword = "cA773lm788buwYe4g4WT+05pKyNruVKjQ25x3n0DQcM="
         rpcauth = "rpcauth=rt:93648e835a54c573682c2eb19f882535$7681e9c5b74bdd85e78166031d2058e1069b3ed7ed967c93fc63abba06f31144"
@@ -71,80 +64,18 @@ class HTTPBasicsTest(BitcoinTestFramework):
         rpcauth3 = lines[1]
         self.password = lines[3]
 
-        # Generate rpcauthfile with one entry
-        username = 'rpcauth_single_' + ''.join(SystemRandom().choice(string.ascii_letters + string.digits) for _ in range(10))
-        p = subprocess.Popen([sys.executable, gen_rpcauth, "--output", Path(self.options.tmpdir) / 'rpcauth_single', username], stdout=subprocess.PIPE, universal_newlines=True)
-        lines = p.stdout.read().splitlines()
-        self.authinfo.append( (username, lines[1]) )
-
-        # Generate rpcauthfile with two entries
-        username = 'rpcauth_multi1_' + ''.join(SystemRandom().choice(string.ascii_letters + string.digits) for _ in range(10))
-        p = subprocess.Popen([sys.executable, gen_rpcauth, "--output", Path(self.options.tmpdir) / 'rpcauth_multi', username], stdout=subprocess.PIPE, universal_newlines=True)
-        lines = p.stdout.read().splitlines()
-        self.authinfo.append( (username, lines[1]) )
-        # Blank lines in between should get ignored
-        with open(Path(self.options.tmpdir) / 'rpcauth_multi', "a", encoding='utf8') as f:
-            f.write("\n\n")
-        username = 'rpcauth_multi2_' + ''.join(SystemRandom().choice(string.ascii_letters + string.digits) for _ in range(10))
-        p = subprocess.Popen([sys.executable, gen_rpcauth, "--output", Path(self.options.tmpdir) / 'rpcauth_multi', username], stdout=subprocess.PIPE, universal_newlines=True)
-        lines = p.stdout.read().splitlines()
-        self.authinfo.append( (username, lines[1]) )
-
-        def gen_userpass(username_prefix, wallet_restrictions=None):
-            username = username_prefix + '_' + ''.join(SystemRandom().choice(string.ascii_letters + string.digits) for _ in range(10))
-            p = subprocess.Popen([sys.executable, gen_rpcauth, username], stdout=subprocess.PIPE, universal_newlines=True)
-            lines = p.stdout.read().splitlines()
-            assert "\n" not in lines[1]
-            assert lines[1][:8] == 'rpcauth='
-            config_line = lines[1]
-            self.authinfo.append( (username, lines[3], wallet_restrictions) )
-            if not (wallet_restrictions is None):
-                config_line += ":" + wallet_restrictions
-            return config_line + "\n"
-
-        # Hand-generated rpcauthfile with one entry and no newline
-        with open(Path(self.options.tmpdir) / 'rpcauth_nonewline', "a", encoding='utf8') as f:
-            f.write(gen_userpass('rpcauth_nonewline')[8:-1])
-
-        if self.is_wallet_compiled():
-            # Hand-generated rpcauthfile with wallet restrictions
-            with open(Path(self.options.tmpdir) / 'rpcauth_walletrestricted', "a", encoding='utf8') as f:
-                f.write(gen_userpass('rpcauth_walletrestricted_allow_all', '')[8:])
-                f.write(gen_userpass('rpcauth_walletrestricted_allow_none', '-')[8:])
-                f.write(gen_userpass('rpcauth_walletrestricted_allow_one', 'limitedwallet1')[8:])
-                # Uses the same username as a privileged one, but with different passwords:
-                f.write(gen_userpass('rpcauth_walletrestricted_allow_all', 'limitedwallet1')[8:])
-                f.write(gen_userpass('rpcauth_walletrestricted_allow_all', 'limitedwallet2')[8:])
-                f.write(gen_userpass('rpcauth_walletrestricted_allow_all', '-')[8:])
-                f.write(gen_userpass('rpcauth_walletrestricted_allow_one', 'limitedwallet2')[8:])
-                f.write(gen_userpass('rpcauth_walletrestricted_allow_one', '-')[8:])
-
         with open(self.nodes[0].datadir_path / "bitcoin.conf", "a", encoding="utf8") as f:
             f.write(rpcauth + "\n")
             f.write(rpcauth2 + "\n")
             f.write(rpcauth3 + "\n")
-            f.write("rpcauthfile=rpcauth_single\n")
-            f.write("rpcauthfile=rpcauth_multi\n")
-            f.write("rpcauthfile=rpcauth_nonewline\n")
-            if self.is_wallet_compiled():
-                f.write("rpcauthfile=rpcauth_walletrestricted\n")
-                f.write(gen_userpass('rpcauth_walletrestricted2_allow_all', '') + "\n")
-                f.write(gen_userpass('rpcauth_walletrestricted2_allow_none', '-') + "\n")
-                f.write(gen_userpass('rpcauth_walletrestricted2_allow_one', 'limitedwallet1') + "\n")
-                # Uses the same username as a privileged one, but with different passwords:
-                f.write(gen_userpass('rpcauth_walletrestricted2_allow_all', 'limitedwallet1') + "\n")
-                f.write(gen_userpass('rpcauth_walletrestricted2_allow_all', 'limitedwallet2') + "\n")
-                f.write(gen_userpass('rpcauth_walletrestricted2_allow_all', '-') + "\n")
-                f.write(gen_userpass('rpcauth_walletrestricted2_allow_one', 'limitedwallet2') + "\n")
-                f.write(gen_userpass('rpcauth_walletrestricted2_allow_one', '-') + "\n")
         with open(self.nodes[1].datadir_path / "bitcoin.conf", "a", encoding="utf8") as f:
             f.write("rpcuser={}\n".format(self.rpcuser))
             f.write("rpcpassword={}\n".format(self.rpcpassword))
         self.restart_node(0)
         self.restart_node(1)
 
-    def test_auth(self, node, user, password, wallet_restrictions=None):
-        self.log.info('Correct... %s (wallet_restrictions=%s)' % (user, wallet_restrictions))
+    def test_auth(self, node, user, password):
+        self.log.info('Correct...')
         assert_equal(200, call_with_auth(node, user, password).status)
 
         self.log.info('Wrong...')
@@ -156,27 +87,8 @@ class HTTPBasicsTest(BitcoinTestFramework):
         self.log.info('Wrong...')
         assert_equal(401, call_with_auth(node, user + 'wrong', password + 'wrong').status)
 
-        if not (wallet_restrictions is None):
-            for n in range(1, 3):
-                wallet_name = f'limitedwallet{n}'
-                self.log.info(f'{wallet_name}...')
-                resp = call_with_auth(node, user, password, uripath=f'/wallet/{wallet_name}', method='getwalletinfo')
-                if wallet_restrictions in ('', f'{wallet_name}'):
-                    assert_equal(200, resp.status)
-                else:
-                    assert_equal(500, resp.status)
-                    assert b'"Requested wallet does not exist or is not loaded"' in resp.data
-
     def test_rpccookieperms(self):
-        p = {
-            "owner": 0o600,
-            "group": 0o640,
-            "all": 0o644,
-            "440": 0o440,
-            "0640": 0o640,
-            "444": 0o444,
-            "1660": 0o1660,
-        }
+        p = {"owner": 0o600, "group": 0o640, "all": 0o644}
 
         if platform.system() == 'Windows':
             self.log.info(f"Skip cookie file permissions checks as OS detected as: {platform.system()=}")
@@ -185,7 +97,7 @@ class HTTPBasicsTest(BitcoinTestFramework):
         self.log.info('Check cookie file permissions can be set using -rpccookieperms')
 
         cookie_file_path = self.nodes[1].chain_path / '.cookie'
-        PERM_BITS_UMASK = 0o7777
+        PERM_BITS_UMASK = 0o777
 
         def test_perm(perm: Optional[str]):
             if not perm:
@@ -198,72 +110,26 @@ class HTTPBasicsTest(BitcoinTestFramework):
             actual_perms = file_stat.st_mode & PERM_BITS_UMASK
             expected_perms = p[perm]
             assert_equal(expected_perms, actual_perms)
-            return actual_perms
 
         # Remove any leftover rpc{user|password} config options from previous tests
         self.nodes[1].replace_in_config([("rpcuser", "#rpcuser"), ("rpcpassword", "#rpcpassword")])
 
         self.log.info('Check default cookie permission')
-        default_perms = test_perm(None)
+        test_perm(None)
 
         self.log.info('Check custom cookie permissions')
-        for perm in p.keys():
+        for perm in ["owner", "group", "all"]:
             test_perm(perm)
 
-        self.log.info('Check leaving cookie permissions alone')
-        unassigned_perms = os.stat(self.nodes[1].chain_path / 'debug.log').st_mode & PERM_BITS_UMASK
-        self.restart_node(1, extra_args=["-rpccookieperms=0"])
-        actual_perms = os.stat(cookie_file_path).st_mode & PERM_BITS_UMASK
-        assert_equal(unassigned_perms, actual_perms)
-        self.restart_node(1, extra_args=["-norpccookieperms"])
-        actual_perms = os.stat(cookie_file_path).st_mode & PERM_BITS_UMASK
-        assert_equal(unassigned_perms, actual_perms)
-
-        self.log.info('Check -norpccookieperms -rpccookieperms')
-        self.restart_node(1, extra_args=["-rpccookieperms=0", "-rpccookieperms=1"])
-        actual_perms = os.stat(cookie_file_path).st_mode & PERM_BITS_UMASK
-        assert_equal(default_perms, actual_perms)
-        self.restart_node(1, extra_args=["-norpccookieperms", "-rpccookieperms"])
-        actual_perms = os.stat(cookie_file_path).st_mode & PERM_BITS_UMASK
-        assert_equal(default_perms, actual_perms)
-        self.restart_node(1, extra_args=["-rpccookieperms=1660", "-norpccookieperms", "-rpccookieperms"])
-        actual_perms = os.stat(cookie_file_path).st_mode & PERM_BITS_UMASK
-        assert_equal(default_perms, actual_perms)
-
-    def test_norpccookiefile(self, node0_cookie_path):
-        assert self.nodes[0].is_node_stopped(), "We expect previous test to stopped the node"
-        assert not node0_cookie_path.exists()
-
-        self.log.info('Starting with -norpccookiefile')
-        # Start, but don't wait for RPC connection as TestNode.wait_for_rpc_connection() requires the cookie.
-        with self.nodes[0].busy_wait_for_debug_log([b'init message: Done loading']):
-            self.nodes[0].start(extra_args=["-norpccookiefile"])
-        assert not node0_cookie_path.exists()
-
-        self.log.info('Testing user/password authentication still works without cookie file')
-        assert_equal(200, call_with_auth(self.nodes[0], "rt", self.rtpassword).status)
-        # After confirming that we could log in, check that cookie file does not exist.
-        assert not node0_cookie_path.exists()
-
-        # Need to shut down in slightly unorthodox way since cookie auth can't be used
-        assert_equal(200, call_with_auth(self.nodes[0], "rt", self.rtpassword, method="stop").status)
-        self.nodes[0].wait_until_stopped()
-
     def run_test(self):
         self.conf_setup()
         self.log.info('Check correctness of the rpcauth config option')
         url = urllib.parse.urlparse(self.nodes[0].url)
 
-        if self.is_wallet_compiled():
-            self.nodes[0].createwallet('limitedwallet1')
-            self.nodes[0].createwallet('limitedwallet2')
-
         self.test_auth(self.nodes[0], url.username, url.password)
         self.test_auth(self.nodes[0], 'rt', self.rtpassword)
         self.test_auth(self.nodes[0], 'rt2', self.rt2password)
         self.test_auth(self.nodes[0], self.user, self.password)
-        for info in self.authinfo:
-            self.test_auth(self.nodes[0], *info)
 
         self.log.info('Check correctness of the rpcuser/rpcpassword config options')
         url = urllib.parse.urlparse(self.nodes[1].url)
@@ -272,45 +138,9 @@ class HTTPBasicsTest(BitcoinTestFramework):
 
         init_error = 'Error: Unable to start HTTP server. See debug log for details.'
 
-        self.log.info('Check blank -rpcauth is ignored')
-        rpcauth_abc = '-rpcauth=abc:$2e32c2f20c67e29c328dd64a4214180f18da9e667d67c458070fd856f1e9e5e7'
-        rpcauth_def = '-rpcauth=def:$fd7adb152c05ef80dccf50a1fa4c05d5a3ec6da95575fc312ae7c5d091836351'
-        self.restart_node(0, extra_args=['-rpcauth'])
-        self.restart_node(0, extra_args=['-rpcauth=', rpcauth_abc])
-        self.restart_node(0, extra_args=[rpcauth_def, '-rpcauth='])
-        # ...without disrupting usage of other -rpcauth tokens
-        assert_equal(200, call_with_auth(self.nodes[0], 'def', 'abc').status)
-        assert_equal(200, call_with_auth(self.nodes[0], 'rt', self.rtpassword).status)
-        for info in self.authinfo:
-            assert_equal(200, call_with_auth(self.nodes[0], *info[:2]).status)
-
-        self.log.info('Check -norpcauth disables all previous -rpcauth* params')
-        self.restart_node(0, extra_args=[rpcauth_def, '-norpcauth'])
-        assert_equal(401, call_with_auth(self.nodes[0], 'def', 'abc').status)
-        assert_equal(401, call_with_auth(self.nodes[0], 'rt', self.rtpassword).status)
-        for info in self.authinfo:
-            assert_equal(401, call_with_auth(self.nodes[0], *info[:2]).status)
-
-        self.log.info('Check -norpcauth can be reversed with -rpcauth')
-        self.restart_node(0, extra_args=[rpcauth_def, '-norpcauth', '-rpcauth'])
-        # FIXME: assert_equal(200, call_with_auth(self.nodes[0], 'def', 'abc').status)
-        assert_equal(200, call_with_auth(self.nodes[0], 'rt', self.rtpassword).status)
-        for info in self.authinfo:
-            assert_equal(200, call_with_auth(self.nodes[0], *info[:2]).status)
-
-        self.log.info('Check -norpcauth followed by a specific -rpcauth=* restores config file -rpcauth=* values too')
-        self.restart_node(0, extra_args=[rpcauth_def, '-norpcauth', rpcauth_abc])
-        assert_equal(401, call_with_auth(self.nodes[0], 'def', 'abc').status)
-        assert_equal(200, call_with_auth(self.nodes[0], 'rt', self.rtpassword).status)
-        for info in self.authinfo:
-            assert_equal(200, call_with_auth(self.nodes[0], *info[:2]).status)
-        self.restart_node(0, extra_args=[rpcauth_def, '-norpcauth', '-rpcauth='])
-        assert_equal(401, call_with_auth(self.nodes[0], 'def', 'abc').status)
-        assert_equal(200, call_with_auth(self.nodes[0], 'rt', self.rtpassword).status)
-        for info in self.authinfo:
-            assert_equal(200, call_with_auth(self.nodes[0], *info[:2]).status)
-
         self.log.info('Check -rpcauth are validated')
+        # Empty -rpcauth= are ignored
+        self.restart_node(0, extra_args=['-rpcauth='])
         self.stop_node(0)
         self.nodes[0].assert_start_raises_init_error(expected_msg=init_error, extra_args=['-rpcauth=foo'])
         self.nodes[0].assert_start_raises_init_error(expected_msg=init_error, extra_args=['-rpcauth=foo:bar'])
@@ -319,34 +149,11 @@ class HTTPBasicsTest(BitcoinTestFramework):
         self.nodes[0].assert_start_raises_init_error(expected_msg=init_error, extra_args=['-rpcauth=foo$bar$baz'])
 
         self.log.info('Check that failure to write cookie file will abort the node gracefully')
-        cookie_path =     self.nodes[0].chain_path / ".cookie"
-        cookie_path_tmp = self.nodes[0].chain_path / ".cookie.tmp"
-        cookie_path_tmp.mkdir()
-        cookie_path_tmp_subdir = cookie_path_tmp / "subdir"
-        cookie_path_tmp_subdir.mkdir()
+        (self.nodes[0].chain_path / ".cookie.tmp").mkdir()
         self.nodes[0].assert_start_raises_init_error(expected_msg=init_error)
-        cookie_path_tmp_subdir.rmdir()
-        cookie_path_tmp.rmdir()
-        assert not cookie_path.exists()
-        self.restart_node(0)
-        assert cookie_path.exists()
-        self.stop_node(0)
-
-        cookie_path.mkdir()
-        cookie_path_subdir = cookie_path / "subdir"
-        cookie_path_subdir.mkdir()
-        self.nodes[0].assert_start_raises_init_error(expected_msg=init_error)
-        cookie_path_subdir.rmdir()
-        cookie_path.rmdir()
-
-        self.log.info('Check that a non-writable cookie file will get replaced gracefully')
-        cookie_path.mkdir(mode=1)
-        self.restart_node(0)
-        self.stop_node(0)
 
         self.test_rpccookieperms()
 
-        self.test_norpccookiefile(cookie_path)
 
 if __name__ == '__main__':
     HTTPBasicsTest(__file__).main()
diff --git a/test/functional/test_framework/authproxy.py b/test/functional/test_framework/authproxy.py
index 3adb744b4d..a357ae4d34 100644
--- a/test/functional/test_framework/authproxy.py
+++ b/test/functional/test_framework/authproxy.py
@@ -192,7 +192,7 @@ class AuthServiceProxy():
         response = json.loads(responsedata, parse_float=decimal.Decimal)
         elapsed = time.time() - req_start_time
         if "error" in response and response["error"] is None:
-            log.debug("<-%s- [%.6f] %s" % (response.get("id"), elapsed, json.dumps(response["result"], default=serialization_fallback, ensure_ascii=self.ensure_ascii)))
+            log.debug("<-%s- [%.6f] %s" % (response["id"], elapsed, json.dumps(response["result"], default=serialization_fallback, ensure_ascii=self.ensure_ascii)))
         else:
             log.debug("<-- [%.6f] %s" % (elapsed, responsedata))
         return response, http_response.status
diff --git a/test/functional/test_framework/mempool_util.py b/test/functional/test_framework/mempool_util.py
index 67343ae485..148cc935ed 100644
--- a/test/functional/test_framework/mempool_util.py
+++ b/test/functional/test_framework/mempool_util.py
@@ -8,7 +8,6 @@ from decimal import Decimal
 from .blocktools import (
     COINBASE_MATURITY,
 )
-from .messages import CTransaction
 from .util import (
     assert_equal,
     assert_greater_than,
@@ -19,8 +18,6 @@ from .wallet import (
     MiniWallet,
 )
 
-ORPHAN_TX_EXPIRE_TIME = 1200
-
 
 def fill_mempool(test_framework, node):
     """Fill mempool until eviction.
@@ -82,8 +79,3 @@ def fill_mempool(test_framework, node):
     test_framework.log.debug("Check that mempoolminfee is larger than minrelaytxfee")
     assert_equal(node.getmempoolinfo()['minrelaytxfee'], Decimal('0.00001000'))
     assert_greater_than(node.getmempoolinfo()['mempoolminfee'], Decimal('0.00001000'))
-
-def tx_in_orphanage(node, tx: CTransaction) -> bool:
-    """Returns true if the transaction is in the orphanage."""
-    found = [o for o in node.getorphantxs(verbosity=1) if o["txid"] == tx.rehash() and o["wtxid"] == tx.getwtxid()]
-    return len(found) == 1
diff --git a/test/functional/test_framework/messages.py b/test/functional/test_framework/messages.py
index a4c1b30721..1f566a1348 100755
--- a/test/functional/test_framework/messages.py
+++ b/test/functional/test_framework/messages.py
@@ -53,7 +53,6 @@ NODE_WITNESS = (1 << 3)
 NODE_COMPACT_FILTERS = (1 << 6)
 NODE_NETWORK_LIMITED = (1 << 10)
 NODE_P2P_V2 = (1 << 11)
-NODE_REPLACE_BY_FEE = (1 << 26)
 
 MSG_TX = 1
 MSG_BLOCK = 2
diff --git a/test/functional/test_framework/netutil.py b/test/functional/test_framework/netutil.py
index 75fff2079d..08d41fe97f 100644
--- a/test/functional/test_framework/netutil.py
+++ b/test/functional/test_framework/netutil.py
@@ -13,10 +13,6 @@ import struct
 import array
 import os
 
-# Easily unreachable address. Attempts to connect to it will stay within the machine.
-# Used to avoid non-loopback traffic or DNS queries.
-UNREACHABLE_PROXY_ARG = '-proxy=127.0.0.1:1'
-
 # STATE_ESTABLISHED = '01'
 # STATE_SYN_SENT  = '02'
 # STATE_SYN_RECV = '03'
diff --git a/test/functional/test_framework/p2p.py b/test/functional/test_framework/p2p.py
index c31fb52e7f..4f1265eb54 100755
--- a/test/functional/test_framework/p2p.py
+++ b/test/functional/test_framework/p2p.py
@@ -363,7 +363,7 @@ class P2PConnection(asyncio.Protocol):
                 self.on_message(t)
         except Exception as e:
             if not self.reconnect:
-                logger.exception(f"Error reading message: {repr(e)}")
+                logger.exception('Error reading message:', repr(e))
             raise
 
     def on_message(self, message):
diff --git a/test/functional/test_framework/test_framework.py b/test/functional/test_framework/test_framework.py
index d67535b400..49212eb019 100755
--- a/test/functional/test_framework/test_framework.py
+++ b/test/functional/test_framework/test_framework.py
@@ -980,8 +980,8 @@ class BitcoinTestFramework(metaclass=BitcoinTestMetaClass):
             raise SkipTest("bitcoin-util has not been compiled")
 
     def skip_if_no_cli(self):
-        """Skip the running test if bitcoin-cli is not available."""
-        if not self.is_cli_available():
+        """Skip the running test if bitcoin-cli has not been compiled."""
+        if not self.is_cli_compiled():
             raise SkipTest("bitcoin-cli has not been compiled.")
 
     def skip_if_no_previous_releases(self):
@@ -1002,11 +1002,8 @@ class BitcoinTestFramework(metaclass=BitcoinTestMetaClass):
         if not self.is_external_signer_compiled():
             raise SkipTest("external signer support has not been compiled.")
 
-    def is_cli_available(self):
-        """Checks whether bitcoin-cli is available."""
-        if "BITCOINCLI" in os.environ:
-            return os.environ["BITCOINCLI"]
-
+    def is_cli_compiled(self):
+        """Checks whether bitcoin-cli was compiled."""
         return self.config["components"].getboolean("ENABLE_CLI")
 
     def is_external_signer_compiled(self):
diff --git a/test/functional/test_framework/test_node.py b/test/functional/test_framework/test_node.py
index 2fa829b038..32a266586a 100755
--- a/test/functional/test_framework/test_node.py
+++ b/test/functional/test_framework/test_node.py
@@ -129,13 +129,6 @@ class TestNode():
                          "--gen-suppressions=all", "--exit-on-first-error=yes",
                          "--error-exitcode=1", "--quiet"] + self.args
 
-        if self.version is None:
-            self.args += [
-                "-corepolicy",
-                "-softwareexpiry=0",
-                "-walletimplicitsegwit",
-            ]
-
         if self.version_is_at_least(190000):
             self.args.append("-logthreadnames")
         if self.version_is_at_least(219900):
@@ -370,14 +363,6 @@ class TestNode():
         assert not invalid_call
         return self.__getattr__('generatetodescriptor')(*args, **kwargs)
 
-    def getprioritisedtransactions(self, *args, **kwargs):
-        res = self.__getattr__('getprioritisedtransactions')(*args, **kwargs)
-        assert not (args or kwargs)
-        for res_val in res.values():
-            if res_val['priority_delta'] == 0:
-                del res_val['priority_delta']
-        return res
-
     def setmocktime(self, timestamp):
         """Wrapper for setmocktime RPC, sets self.mocktime"""
         if timestamp == 0:
@@ -508,12 +493,6 @@ class TestNode():
         assert_equal(type(expected_msgs), list)
         assert_equal(type(unexpected_msgs), list)
 
-        if not self.debug_log_path.exists():
-            # File must exist for this to work
-            os.makedirs(self.debug_log_path.parent, exist_ok=True)
-            with open(self.debug_log_path, mode='a', encoding='utf-8'):
-                pass
-
         time_end = time.time() + timeout * self.timeout_factor
         prev_size = self.debug_log_size(encoding="utf-8")  # Must use same encoding that is used to read() below
 
@@ -539,7 +518,7 @@ class TestNode():
         self._raise_assertion_error('Expected messages "{}" does not partially match log:\n\n{}\n\n'.format(str(expected_msgs), print_log))
 
     @contextlib.contextmanager
-    def busy_wait_for_debug_log(self, expected_msgs, timeout=60, *, forbid_msgs=()):
+    def busy_wait_for_debug_log(self, expected_msgs, timeout=60):
         """
         Block until we see a particular debug log message fragment or until we exceed the timeout.
         Return:
@@ -556,13 +535,6 @@ class TestNode():
                 dl.seek(prev_size)
                 log = dl.read()
 
-            for msg in forbid_msgs:
-                if msg in log:
-                    print_log = " - " + "\n - ".join(log.decode("utf8", errors="replace").splitlines())
-                    self._raise_assertion_error(
-                        'Forbidden message "{}" partially matched log:\n\n{}\n\n'.format(
-                            str(msg), print_log))
-
             for expected_msg in expected_msgs:
                 if expected_msg not in log:
                     found = False
@@ -981,12 +953,6 @@ class RPCOverloadWrapper():
         wallet_info = self.getwalletinfo()
         if 'descriptors' not in wallet_info or ('descriptors' in wallet_info and not wallet_info['descriptors']):
             return self.__getattr__('addmultisigaddress')(nrequired, keys, label, address_type)
-        if isinstance(label, dict):
-            options = dict(label)  # copy, so we can pop and check for emptiness
-            assert address_type is None
-            address_type = options.pop('address_type', None)
-            label = options.pop('label', None)
-            assert not options
         cms = self.createmultisig(nrequired, keys, address_type)
         req = [{
             'desc': cms['descriptor'],
@@ -1012,7 +978,7 @@ class RPCOverloadWrapper():
         if not import_res[0]['success']:
             raise JSONRPCException(import_res[0]['error'])
 
-    def _deleted_importaddress(self, address, label=None, rescan=None, p2sh=None):
+    def importaddress(self, address, label=None, rescan=None, p2sh=None):
         wallet_info = self.getwalletinfo()
         if 'descriptors' not in wallet_info or ('descriptors' in wallet_info and not wallet_info['descriptors']):
             return self.__getattr__('importaddress')(address, label, rescan, p2sh)
diff --git a/test/functional/test_framework/util.py b/test/functional/test_framework/util.py
index 47de371e4e..00fe5b08e4 100644
--- a/test/functional/test_framework/util.py
+++ b/test/functional/test_framework/util.py
@@ -216,18 +216,6 @@ def assert_array_result(object_array, to_match, expected, should_not_find=False)
     if num_matched > 0 and should_not_find:
         raise AssertionError("Objects were found %s" % (str(to_match)))
 
-def assert_scale(number, expected_scale=8):
-    """Assert number has expected scale, e.g. fractional digits; number of
-    digits after the decimal. The default of 8 corresponds to a Bitcoin amount."""
-    number = str(number)
-    mantissa = number.split('.')[-1].upper()
-    if mantissa[:3] == '0E-':
-        assert_equal(mantissa, '0E-{}'.format(expected_scale))  # zeros in exponent notation
-    elif mantissa == number:
-        assert_equal(0, expected_scale)  # no mantissa, ergo, expected scale must be 0
-    else:
-        assert_equal(len(mantissa), expected_scale)
-
 
 # Utility functions
 ###################
diff --git a/test/functional/test_runner.py b/test/functional/test_runner.py
index 71c8fd7253..842328e2cf 100755
--- a/test/functional/test_runner.py
+++ b/test/functional/test_runner.py
@@ -157,7 +157,6 @@ BASE_SCRIPTS = [
     'wallet_importmulti.py --legacy-wallet',
     'mempool_limit.py',
     'rpc_txoutproof.py',
-    'rpc_orphans.py',
     'wallet_listreceivedby.py --legacy-wallet',
     'wallet_listreceivedby.py --descriptors',
     'wallet_abandonconflict.py --legacy-wallet',
@@ -177,7 +176,6 @@ BASE_SCRIPTS = [
     'wallet_fast_rescan.py --descriptors',
     'wallet_gethdkeys.py --descriptors',
     'wallet_createwalletdescriptor.py --descriptors',
-    'feature_fee_estimates_persist.py',
     'interface_zmq.py',
     'rpc_invalid_address_message.py',
     'rpc_validateaddress.py',
@@ -185,9 +183,7 @@ BASE_SCRIPTS = [
     'interface_bitcoin_cli.py --descriptors',
     'feature_bind_extra.py',
     'mempool_resurrect.py',
-    'wallet_sweepprivkeys.py',
     'wallet_txn_doublespend.py --mineblock',
-    'tool_cli_bash_completion.py',
     'tool_wallet.py --legacy-wallet',
     'tool_wallet.py --legacy-wallet --bdbro',
     'tool_wallet.py --legacy-wallet --bdbro --swap-bdb-endian',
@@ -196,7 +192,6 @@ BASE_SCRIPTS = [
     'tool_signet_miner.py --descriptors',
     'wallet_txn_clone.py',
     'wallet_txn_clone.py --segwit',
-    'mining_coin_age_priority.py',
     'rpc_getchaintips.py',
     'rpc_misc.py',
     'p2p_1p1c_network.py',
@@ -226,7 +221,6 @@ BASE_SCRIPTS = [
     'interface_usdt_validation.py',
     'rpc_users.py',
     'rpc_whitelist.py',
-    'rpc_getrpcwhitelist.py',
     'feature_proxy.py',
     'wallet_signrawtransactionwithwallet.py --legacy-wallet',
     'wallet_signrawtransactionwithwallet.py --descriptors',
@@ -310,12 +304,9 @@ BASE_SCRIPTS = [
     'p2p_initial_headers_sync.py',
     'feature_nulldummy.py',
     'mempool_accept.py',
-    'mempool_fee_histogram.py',
     'mempool_expiry.py',
-    'rpc_sort_multisig.py',
     'wallet_import_with_label.py --legacy-wallet',
     'wallet_importdescriptors.py --descriptors',
-    'wallet_importseed.py --descriptors',
     'wallet_upgradewallet.py --legacy-wallet',
     'wallet_crosschain.py',
     'mining_basic.py',
@@ -341,7 +332,6 @@ BASE_SCRIPTS = [
     'wallet_fallbackfee.py --legacy-wallet',
     'wallet_fallbackfee.py --descriptors',
     'rpc_dumptxoutset.py',
-    'rpc_getblocklocations.py',
     'feature_minchainwork.py',
     'rpc_estimatefee.py',
     'rpc_getblockstats.py',
@@ -377,7 +367,6 @@ BASE_SCRIPTS = [
     'feature_asmap.py',
     'feature_fastprune.py',
     'feature_framework_miniwallet.py',
-    'feature_sync_coins_tip_after_chain_sync.py',
     'mempool_unbroadcast.py',
     'mempool_compatibility.py',
     'mempool_accept_wtxid.py',
@@ -387,7 +376,6 @@ BASE_SCRIPTS = [
     'rpc_deriveaddresses.py --usecli',
     'p2p_ping.py',
     'p2p_tx_privacy.py',
-    'rpc_getdescriptoractivity.py',
     'rpc_scanblocks.py',
     'p2p_sendtxrcncl.py',
     'rpc_scantxoutset.py',
@@ -411,7 +399,6 @@ BASE_SCRIPTS = [
     'feature_settings.py',
     'rpc_getdescriptorinfo.py',
     'rpc_mempool_info.py',
-    'rpc_getgeneralinfo.py',
     'rpc_help.py',
     'p2p_handshake.py',
     'p2p_handshake.py --v2transport',
@@ -699,6 +686,7 @@ def run_tests(*, test_list, src_dir, build_dir, tmpdir, jobs=1, enable_coverage=
     if not os.listdir(tmpdir):
         os.rmdir(tmpdir)
 
+    all_passed = all_passed and coverage_passed
 
     # Clean up dangling processes if any. This may only happen with --failfast option.
     # Killing the process group will also terminate the current process but that is
diff --git a/test/functional/tool_cli_bash_completion.py b/test/functional/tool_cli_bash_completion.py
deleted file mode 100755
index b8e0246b62..0000000000
--- a/test/functional/tool_cli_bash_completion.py
+++ /dev/null
@@ -1,282 +0,0 @@
-#!/usr/bin/env python3
-
-from os import path
-from collections import defaultdict
-
-from test_framework.test_framework import BitcoinTestFramework
-from test_framework.util import assert_equal
-
-
-# bash cli completion file header
-COMPLETION_HEADER = """# Dynamic bash programmable completion for bitcoin-cli(1)
-#     DO NOT EDIT THIS FILE BY HAND -- THIS WILL FAIL THE FUNCTIONAL TEST tool_cli_completion
-# This file is auto-generated by the functional test tool_cli_completion.
-# If you want to modify this file, modify test/functional/tool_cli_completion.py and re-autogenerate
-# this file via the --overwrite test flag.
-
-"""
-
-# option types which are limited to certain values
-TYPED_OPTIONS = [
-        ["estimate_mode", {"UNSET", "ECONOMICAL", "CONSERVATIVE"}],
-        ["sighashtype", {"ALL", "NONE", "SINGLE", "ALL|ANYONECANPAY",
-                         "NONE|ANYONECANPAY", "SINGLE|ANYONECANPAY"}]
-]
-
-
-class PossibleArgs():
-    """ Helper class to store options associated to a command. """
-    def __init__(self, command):
-        self.command = command
-        self.arguments = {}
-
-    def set_args(self, position, values):
-        """ Set the position-th positional argument as having values as possible values. """
-        if position in self.arguments:
-            raise AssertionError(f"The positional parameter at position {position} is already defined for command '{self.command}'")
-
-        self.arguments[position] = values
-        return self
-
-    def set_bool_args(self, position):
-        return self.set_args(position, {"true", "false"})
-
-    def set_file_args(self, position):
-        # We consider an empty string as a file value for the sake of simplicity (don't
-        # have to create an extra level of indirection).
-        return self.set_args(position, {""})
-
-    def set_unknown_args(self, position):
-        return self.set_args(position, {})
-
-    def set_typed_option(self, position, arg_name):
-        """ Checks if arg_name is a typed option; if it is, sets it and return True. """
-        for option_type in TYPED_OPTIONS:
-            if arg_name == option_type[0]:
-                self.set_args(position, option_type[1])
-                return True
-        return False
-
-    def has_option(self, position):
-        return position in self.arguments and len(self.arguments[position]) > 0
-
-    def get_num_args(self):
-        """ Return the max number of positional argument the option accepts. """
-        pos = list(self.arguments.keys())
-        if len(pos) == 0:
-            return 0
-
-        return max(pos)
-
-    def generate_autocomplete(self, pos):
-        """ Generate the autocomplete file line relevent to the given position pos. """
-        if len(self.arguments[pos]) == 0:
-            raise AssertionError(f"generating undefined arg id {pos} ({self.arguments})")
-
-        # handle special file case
-        if len(self.arguments[pos]) == 1 and len(next(iter(self.arguments[pos]))) == 0:
-            return "_filedir"
-
-        # a set order is undefined, so we order args alphabetically
-        args = list(self.arguments[pos])
-        args.sort()
-
-        return "COMPREPLY=( $( compgen -W \"" + ' '.join(args) + "\" -- \"$cur\" ) )"
-
-# commands where the option type can only be difficultly derived from the help message
-SPECIAL_OPTIONS = [
-        PossibleArgs("addnode").set_args(2, {"add", "remove", "onetry"}),
-        PossibleArgs("setban").set_args(2, {"add", "remove"}),
-]
-
-
-def generate_start_complete(cword):
-    """ Generate the start of an autocomplete block (beware of indentation). """
-    if cword > 1:
-        return f"""    if ((cword > {cword})); then
-        case ${{words[cword-{cword}]}} in"""
-
-    return "    case \"$prev\" in"
-
-
-def generate_end_complete(cword):
-    """ Generate the end of an autocomplete block. """
-    if cword > 1:
-        return f"\n{' ' * 8}esac\n{' ' * 4}fi\n\n"
-
-    return f"\n{' ' * 4}esac\n"
-
-
-class CliCompletionTest(BitcoinTestFramework):
-    def set_test_params(self):
-        self.num_nodes = 1
-
-    def skip_test_if_missing_module(self):
-        self.skip_if_no_cli()
-        # self.skip_if_no_wallet()
-        self.skip_if_no_bitcoind_zmq()
-
-    def add_options(self, parser):
-        parser.add_argument(
-                '--header',
-                help='Static header part of the bash completion file',
-        )
-
-        parser.add_argument(
-                '--footer',
-                help='Static footer part of the bash completion file',
-        )
-
-        parser.add_argument(
-                '--completion',
-                help='Location of the current bash completion file',
-        )
-
-        parser.add_argument(
-                '--overwrite',
-                default=False,
-                action='store_true',
-                help='Force the test to overwrite the file pointer to by the --completion'
-                     'to the newly generated completion file',
-        )
-    def parse_single_helper(self, option):
-        """ Complete the arguments of option via the RPC format command. """
-
-        res = self.nodes[0].format(command=option.command, output='args_cli')
-        if len(res) == 0:
-            return option
-
-        if res.count('\n') > 1:
-            raise AssertionError(
-                f"command {option.command} doesn't support format RPC. Should it be a hidden command? "
-                f"Please call RPCHelpMan::Check when adding a new non-hidden command. Returned: {res}"
-            )
-
-        for idx, argument in enumerate(res.split(",")):
-            elems = argument.split(":")
-
-            if option.set_typed_option(idx+1, elems[0]):
-                continue
-
-            if elems[1] == "boolean":
-                option.set_bool_args(idx+1)
-                continue
-
-            if elems[1] == "file":
-                option.set_file_args(idx+1)
-                continue
-
-            if not option.has_option(idx+1):
-                option.set_unknown_args(idx+1)
-
-        return option
-
-    def get_command_options(self, command):
-        """ Returns the corresponding PossibleArgs for the command. """
-
-        # verify it's not a special option first
-        for soption in SPECIAL_OPTIONS:
-            if command == soption.command:
-                return self.parse_single_helper(soption)
-
-        return self.parse_single_helper(PossibleArgs(command))
-
-    def generate_completion_block(self, options):
-        commands = [o.command for o in options]
-        self.log.info(f"Generating part of the completion file for options {commands}")
-
-        if len(options) == 0:
-            return ""
-
-        generated = ""
-        max_pos_options = max(options, key=lambda o: o.get_num_args()).get_num_args()
-        for cword in range(max_pos_options, 0, -1):
-            this_options = [option for option in options if option.has_option(cword)]
-            if len(this_options) == 0:
-                continue
-
-            # group options by their arguments value
-            grouped_options = defaultdict(list)
-            for option in this_options:
-                arg = option.generate_autocomplete(cword)
-                grouped_options[arg].append(option)
-
-            # generate the cword block
-            indent = 12 if cword > 1 else 8
-            generated += generate_start_complete(cword)
-            for line, opt_gr in grouped_options.items():
-                opt_gr.sort(key=lambda o: o.command)  # show options alphabetically for clarity
-                args = '|'.join([o.command for o in opt_gr])
-                generated += f"\n{' '*indent}{args})\n"
-                generated += f"{' ' * (indent + 4)}{line}\n{' ' * (indent + 4)}return 0\n{' ' * (indent + 4)};;"
-            generated += generate_end_complete(cword)
-
-        return generated
-
-    def generate_completion_file(self, commands):
-        try:
-            with open(self.options.header, 'r', encoding='utf-8') as header_file:
-                header = header_file.read()
-
-            with open(self.options.footer, 'r', encoding='utf-8') as footer_file:
-                footer = footer_file.read()
-        except Exception as e:
-            raise AssertionError(
-                        f"Could not read header/footer ({self.options.header} and {self.options.footer}) files. "
-                        f"Tell the test where to find them using the --header/--footer parameters ({e})."
-            )
-        return COMPLETION_HEADER + header + commands + footer
-
-    def write_completion_file(self, new_file):
-        try:
-            with open(self.options.completion, 'w', encoding='utf-8') as completion_file:
-                completion_file.write(new_file)
-        except Exception as e:
-            raise AssertionError(
-                        f"Could not write the autocomplete file to {self.options.completion}. "
-                        f"Tell the test where to find it using the --completion parameters ({e})."
-            )
-
-    def read_completion_file(self):
-        try:
-            with open(self.options.completion, 'r', encoding='utf-8') as completion_file:
-                return completion_file.read()
-        except Exception as e:
-            raise AssertionError(
-                        f"Could not read the autocomplete file ({self.options.completion}) file. "
-                        f"Tell the test where to find it using the --completion parameters ({e})."
-            )
-
-
-    def run_test(self):
-        # self.config is not available in self.add_options, so complete filepaths here
-        src_dir = self.config["environment"]["SRCDIR"]
-        test_data_dir = path.join(src_dir, 'test', 'functional', 'data', 'completion')
-        if self.options.header is None or len(self.options.header) == 0:
-            self.options.header = path.join(test_data_dir, 'bitcoin-cli.header.bash-completion')
-
-        if self.options.footer is None or len(self.options.footer) == 0:
-            self.options.footer = path.join(test_data_dir, 'bitcoin-cli.footer.bash-completion')
-
-        if self.options.completion is None or len(self.options.completion) == 0:
-            self.options.completion = path.join(src_dir, 'contrib', 'completions', 'bash', 'bitcoin-cli.bash')
-
-        self.log.info('Parsing help commands to get all the command arguments...')
-        commands = self.nodes[0].help().split("\n")
-        commands = [c.split(' ')[0] for c in commands if not c.startswith("== ") and len(c) > 0]
-        commands = [self.get_command_options(c) for c in commands]
-
-        self.log.info('Generating new autocompletion file...')
-        commands = self.generate_completion_block(commands)
-        new_completion = self.generate_completion_file(commands)
-
-        if self.options.overwrite:
-            self.log.info("Overwriting the completion file...")
-            self.write_completion_file(new_completion)
-
-        self.log.info('Checking if the generated and the original completion files matches...')
-        completion = self.read_completion_file()
-        assert_equal(new_completion, completion)
-
-if __name__ == '__main__':
-    CliCompletionTest(__file__).main()
diff --git a/test/functional/tool_wallet.py b/test/functional/tool_wallet.py
index c42213bbc4..784a769882 100755
--- a/test/functional/tool_wallet.py
+++ b/test/functional/tool_wallet.py
@@ -57,10 +57,10 @@ class ToolWalletTest(BitcoinTestFramework):
             assert_equal(p.poll(), 1)
             assert error in stderr.strip()
 
-    def assert_tool_output(self, output, *args, stderr=''):
+    def assert_tool_output(self, output, *args):
         p = self.bitcoin_wallet_process(*args)
         stdout, stderr = p.communicate()
-        assert_equal(stderr, stderr)
+        assert_equal(stderr, '')
         assert_equal(stdout, output)
         assert_equal(p.poll(), 0)
 
@@ -179,10 +179,10 @@ class ToolWalletTest(BitcoinTestFramework):
         load_output = ""
         if file_format is not None and file_format != dump_data["format"]:
             load_output += "Warning: Dumpfile wallet format \"{}\" does not match command line specified format \"{}\".\n".format(dump_data["format"], file_format)
-        self.assert_tool_output('', *args, stderr=load_output)
+        self.assert_tool_output(load_output, *args)
         assert (self.nodes[0].wallets_path / wallet_name).is_dir()
 
-        self.assert_tool_output('', '-wallet={}'.format(wallet_name), '-dumpfile={}'.format(rt_dumppath), 'dump', stderr="The dumpfile may contain private keys. To ensure the safety of your Bitcoin, do not share the dumpfile.\n")
+        self.assert_tool_output("The dumpfile may contain private keys. To ensure the safety of your Bitcoin, do not share the dumpfile.\n", '-wallet={}'.format(wallet_name), '-dumpfile={}'.format(rt_dumppath), 'dump')
 
         rt_dump_data = self.read_dump(rt_dumppath)
         wallet_dat = self.nodes[0].wallets_path / wallet_name / "wallet.dat"
@@ -337,7 +337,7 @@ class ToolWalletTest(BitcoinTestFramework):
 
         self.log.info('Checking basic dump')
         wallet_dump = self.nodes[0].datadir_path / "wallet.dump"
-        self.assert_tool_output('', '-wallet=todump', '-dumpfile={}'.format(wallet_dump), 'dump', stderr='The dumpfile may contain private keys. To ensure the safety of your Bitcoin, do not share the dumpfile.\n')
+        self.assert_tool_output('The dumpfile may contain private keys. To ensure the safety of your Bitcoin, do not share the dumpfile.\n', '-wallet=todump', '-dumpfile={}'.format(wallet_dump), 'dump')
 
         dump_data = self.read_dump(wallet_dump)
         orig_dump = dump_data.copy()
@@ -347,20 +347,15 @@ class ToolWalletTest(BitcoinTestFramework):
         assert_equal(dump_data["format"], file_format)
 
         self.log.info('Checking that a dumpfile cannot be overwritten')
-        if self.options.descriptors:
-            expected_warnings_dump = expected_warnings_restore = ""
-        else:
-            expected_warnings_dump = "dump: WARNING: BDB-backed wallets have a wallet id that is not currently dumped.\n"
-            expected_warnings_restore = "Warning: BDB-backed wallets have a wallet id that is not currently restored.\n"
-        self.assert_raises_tool_error(f'{expected_warnings_dump}File {wallet_dump} already exists. If you are sure this is what you want, move it out of the way first.',  '-wallet=todump2', '-dumpfile={}'.format(wallet_dump), 'dump')
+        self.assert_raises_tool_error('File {} already exists. If you are sure this is what you want, move it out of the way first.'.format(wallet_dump),  '-wallet=todump2', '-dumpfile={}'.format(wallet_dump), 'dump')
 
         self.log.info('Checking createfromdump arguments')
         self.assert_raises_tool_error('No dump file provided. To use createfromdump, -dumpfile=<filename> must be provided.', '-wallet=todump', 'createfromdump')
         non_exist_dump = self.nodes[0].datadir_path / "wallet.nodump"
-        self.assert_raises_tool_error(f'{expected_warnings_restore}Unknown wallet file format "notaformat" provided. Please provide one of "bdb" or "sqlite".', '-wallet=todump', '-format=notaformat', '-dumpfile={}'.format(wallet_dump), 'createfromdump')
+        self.assert_raises_tool_error('Unknown wallet file format "notaformat" provided. Please provide one of "bdb" or "sqlite".', '-wallet=todump', '-format=notaformat', '-dumpfile={}'.format(wallet_dump), 'createfromdump')
         self.assert_raises_tool_error('Dump file {} does not exist.'.format(non_exist_dump), '-wallet=todump', '-dumpfile={}'.format(non_exist_dump), 'createfromdump')
         wallet_path = self.nodes[0].wallets_path / "todump2"
-        self.assert_raises_tool_error(f'{expected_warnings_restore}Failed to create database path \'{wallet_path}\'. Database already exists.', '-wallet=todump2', '-dumpfile={}'.format(wallet_dump), 'createfromdump')
+        self.assert_raises_tool_error('Failed to create database path \'{}\'. Database already exists.'.format(wallet_path), '-wallet=todump2', '-dumpfile={}'.format(wallet_dump), 'createfromdump')
         self.assert_raises_tool_error("The -descriptors option can only be used with the 'create' command.", '-descriptors', '-wallet=todump2', '-dumpfile={}'.format(wallet_dump), 'createfromdump')
 
         self.log.info('Checking createfromdump')
@@ -394,21 +389,21 @@ class ToolWalletTest(BitcoinTestFramework):
         checksum = dump_data["checksum"]
         dump_data["checksum"] = "1" * 64
         self.write_dump(dump_data, bad_sum_wallet_dump)
-        self.assert_raises_tool_error(f'{expected_warnings_restore}Error: Dumpfile checksum does not match. Computed {checksum}, expected {"1" * 64}', '-wallet=bad', '-dumpfile={}'.format(bad_sum_wallet_dump), 'createfromdump')
+        self.assert_raises_tool_error('Error: Dumpfile checksum does not match. Computed {}, expected {}'.format(checksum, "1" * 64), '-wallet=bad', '-dumpfile={}'.format(bad_sum_wallet_dump), 'createfromdump')
         assert not (self.nodes[0].wallets_path / "badload").is_dir()
         bad_sum_wallet_dump = self.nodes[0].datadir_path / "wallet-bad_sum2.dump"
         del dump_data["checksum"]
         self.write_dump(dump_data, bad_sum_wallet_dump, skip_checksum=True)
-        self.assert_raises_tool_error(f'{expected_warnings_restore}Error: Missing checksum', '-wallet=badload', '-dumpfile={}'.format(bad_sum_wallet_dump), 'createfromdump')
+        self.assert_raises_tool_error('Error: Missing checksum', '-wallet=badload', '-dumpfile={}'.format(bad_sum_wallet_dump), 'createfromdump')
         assert not (self.nodes[0].wallets_path / "badload").is_dir()
         bad_sum_wallet_dump = self.nodes[0].datadir_path / "wallet-bad_sum3.dump"
         dump_data["checksum"] = "2" * 10
         self.write_dump(dump_data, bad_sum_wallet_dump)
-        self.assert_raises_tool_error(f'{expected_warnings_restore}Error: Checksum is not the correct size', '-wallet=badload', '-dumpfile={}'.format(bad_sum_wallet_dump), 'createfromdump')
+        self.assert_raises_tool_error('Error: Checksum is not the correct size', '-wallet=badload', '-dumpfile={}'.format(bad_sum_wallet_dump), 'createfromdump')
         assert not (self.nodes[0].wallets_path / "badload").is_dir()
         dump_data["checksum"] = "3" * 66
         self.write_dump(dump_data, bad_sum_wallet_dump)
-        self.assert_raises_tool_error(f'{expected_warnings_restore}Error: Checksum is not the correct size', '-wallet=badload', '-dumpfile={}'.format(bad_sum_wallet_dump), 'createfromdump')
+        self.assert_raises_tool_error('Error: Checksum is not the correct size', '-wallet=badload', '-dumpfile={}'.format(bad_sum_wallet_dump), 'createfromdump')
         assert not (self.nodes[0].wallets_path / "badload").is_dir()
 
     def test_chainless_conflicts(self):
@@ -476,7 +471,7 @@ class ToolWalletTest(BitcoinTestFramework):
         self.stop_node(0)
 
         wallet_dump = self.nodes[0].datadir_path / "endian.dump"
-        self.assert_tool_output('', "-wallet=endian", f"-dumpfile={wallet_dump}", "dump", stderr="The dumpfile may contain private keys. To ensure the safety of your Bitcoin, do not share the dumpfile.\n")
+        self.assert_tool_output("The dumpfile may contain private keys. To ensure the safety of your Bitcoin, do not share the dumpfile.\n", "-wallet=endian", f"-dumpfile={wallet_dump}", "dump")
         expected_dump = self.read_dump(wallet_dump)
 
         self.do_tool_createfromdump("native_endian", "endian.dump", "bdb")
@@ -515,7 +510,7 @@ class ToolWalletTest(BitcoinTestFramework):
         self.stop_node(0)
 
         wallet_dump = self.nodes[0].datadir_path / "bigrecords.dump"
-        self.assert_tool_output('', "-wallet=bigrecords", f"-dumpfile={wallet_dump}", "dump", stderr="The dumpfile may contain private keys. To ensure the safety of your Bitcoin, do not share the dumpfile.\n")
+        self.assert_tool_output("The dumpfile may contain private keys. To ensure the safety of your Bitcoin, do not share the dumpfile.\n", "-wallet=bigrecords", f"-dumpfile={wallet_dump}", "dump")
         dump = self.read_dump(wallet_dump)
         for k,v in dump.items():
             if tx["hex"] in v:
@@ -548,7 +543,7 @@ class ToolWalletTest(BitcoinTestFramework):
         self.start_node(0)
         self.nodes[0].loadwallet("unclean_lsn")
         self.stop_node(0)
-        self.assert_tool_output('', "-wallet=unclean_lsn", f"-dumpfile={wallet_dump}", "dump", stderr="The dumpfile may contain private keys. To ensure the safety of your Bitcoin, do not share the dumpfile.\n")
+        self.assert_tool_output("The dumpfile may contain private keys. To ensure the safety of your Bitcoin, do not share the dumpfile.\n", "-wallet=unclean_lsn", f"-dumpfile={wallet_dump}", "dump")
 
     def run_test(self):
         self.wallet_path = self.nodes[0].wallets_path / self.default_wallet_name / self.wallet_data_filename
diff --git a/test/functional/wallet_backwards_compatibility.py b/test/functional/wallet_backwards_compatibility.py
index 8da891b82b..e71283b928 100755
--- a/test/functional/wallet_backwards_compatibility.py
+++ b/test/functional/wallet_backwards_compatibility.py
@@ -339,9 +339,10 @@ class BackwardsCompatibilityTest(BitcoinTestFramework):
             # Restore the wallet to master
             load_res = node_master.restorewallet(wallet_name, backup_path)
 
-            # Make sure this wallet opens without warnings
+            # Make sure this wallet opens with only the migration warning. See https://github.com/bitcoin/bitcoin/pull/19054
             if not self.options.descriptors:
-                assert "warnings" not in load_res
+                # Legacy wallets will have only a deprecation warning
+                assert_equal(load_res["warnings"], ["Wallet loaded successfully. The legacy wallet type is being deprecated and support for creating and opening legacy wallets will be removed in the future. Legacy wallets can be migrated to a descriptor wallet with migratewallet."])
             else:
                 assert "warnings" not in load_res
 
diff --git a/test/functional/wallet_balance.py b/test/functional/wallet_balance.py
index fde705ea6d..9da53402a4 100755
--- a/test/functional/wallet_balance.py
+++ b/test/functional/wallet_balance.py
@@ -106,13 +106,14 @@ class WalletTest(BitcoinTestFramework):
         self.log.info("Test getbalance with different arguments")
         assert_equal(self.nodes[0].getbalance("*"), 50)
         assert_equal(self.nodes[0].getbalance("*", 1), 50)
-        assert_raises_rpc_error(-8, "getbalance minconf option is only currently supported if dummy is set to \"*\"", self.nodes[0].getbalance, minconf=1)
-        assert_raises_rpc_error(-8, "getbalance minconf option is only currently supported if dummy is set to \"*\"", self.nodes[0].getbalance, minconf=0, include_watchonly=True)
+        assert_equal(self.nodes[0].getbalance(minconf=1), 50)
         if not self.options.descriptors:
+            assert_equal(self.nodes[0].getbalance(minconf=0, include_watchonly=True), 100)
             assert_equal(self.nodes[0].getbalance("*", 1, True), 100)
         else:
+            assert_equal(self.nodes[0].getbalance(minconf=0, include_watchonly=True), 50)
             assert_equal(self.nodes[0].getbalance("*", 1, True), 50)
-        assert_raises_rpc_error(-8, "getbalance minconf option is only currently supported if dummy is set to \"*\"", self.nodes[1].getbalance, minconf=0, include_watchonly=True)
+        assert_equal(self.nodes[1].getbalance(minconf=0, include_watchonly=True), 50)
 
         # Send 40 BTC from 0 to 1 and 60 BTC from 1 to 0.
         txs = create_transactions(self.nodes[0], self.nodes[1].getnewaddress(), 40, [Decimal('0.01')])
@@ -191,12 +192,13 @@ class WalletTest(BitcoinTestFramework):
             # getbalance without any arguments includes unconfirmed transactions, but not untrusted transactions
             assert_equal(self.nodes[0].getbalance(), Decimal('9.99'))  # change from node 0's send
             assert_equal(self.nodes[1].getbalance(), Decimal('0'))  # node 1's send had an unsafe input
-            # getbalance with '*' and minconf=0 includes unconfirmed transactions, AND untrusted transactions
-            assert_equal(self.nodes[0].getbalance('*', 0), Decimal('69.99'))
-            assert_equal(self.nodes[1].getbalance('*', 0), Decimal('30') - fee_node_1)
-            # getbalance with '*' and minconf=1 includes only confirmed and sent transactions
-            assert_equal(self.nodes[0].getbalance('*', 1), Decimal('9.99'))
-            assert_equal(self.nodes[1].getbalance('*', 1), Decimal('-10') - fee_node_1)
+            # Same with minconf=0
+            assert_equal(self.nodes[0].getbalance(minconf=0), Decimal('9.99'))
+            assert_equal(self.nodes[1].getbalance(minconf=0), Decimal('0'))
+            # getbalance with a minconf incorrectly excludes coins that have been spent more recently than the minconf blocks ago
+            # TODO: fix getbalance tracking of coin spentness depth
+            assert_equal(self.nodes[0].getbalance(minconf=1), Decimal('0'))
+            assert_equal(self.nodes[1].getbalance(minconf=1), Decimal('0'))
             # getunconfirmedbalance
             assert_equal(self.nodes[0].getunconfirmedbalance(), Decimal('60'))  # output of node 1's spend
             assert_equal(self.nodes[1].getunconfirmedbalance(), Decimal('30') - fee_node_1)  # Doesn't include output of node 0's send since it was spent
@@ -229,6 +231,14 @@ class WalletTest(BitcoinTestFramework):
         self.nodes[1].sendrawtransaction(txs[0]['hex'])
         self.generatetoaddress(self.nodes[1], 2, ADDRESS_WATCHONLY)
 
+        # getbalance with a minconf incorrectly excludes coins that have been spent more recently than the minconf blocks ago
+        # TODO: fix getbalance tracking of coin spentness depth
+        # getbalance with minconf=3 should still show the old balance
+        assert_equal(self.nodes[1].getbalance(minconf=3), Decimal('0'))
+
+        # getbalance with minconf=2 will show the new balance.
+        assert_equal(self.nodes[1].getbalance(minconf=2), Decimal('0'))
+
         # check mempool transactions count for wallet unconfirmed balance after
         # dynamically loading the wallet.
         before = self.nodes[1].getbalances()['mine']['untrusted_pending']
@@ -249,7 +259,7 @@ class WalletTest(BitcoinTestFramework):
         self.log.info('Check that wallet txs not in the mempool are untrusted')
         assert txid not in self.nodes[0].getrawmempool()
         assert_equal(self.nodes[0].gettransaction(txid)['trusted'], False)
-        assert_equal(self.nodes[0].getbalances()['mine']['trusted'], 0)
+        assert_equal(self.nodes[0].getbalance(minconf=0), 0)
 
         self.log.info("Test replacement and reorg of non-mempool tx")
         tx_orig = self.nodes[0].gettransaction(txid)['hex']
@@ -266,12 +276,12 @@ class WalletTest(BitcoinTestFramework):
 
         # Now confirm tx_replace
         block_reorg = self.generatetoaddress(self.nodes[1], 1, ADDRESS_WATCHONLY)[0]
-        assert_equal(self.nodes[0].getbalances()['mine']['trusted'], total_amount)
+        assert_equal(self.nodes[0].getbalance(minconf=0), total_amount)
 
         self.log.info('Put txs back into mempool of node 1 (not node 0)')
         self.nodes[0].invalidateblock(block_reorg)
         self.nodes[1].invalidateblock(block_reorg)
-        assert_equal(self.nodes[0].getbalances()['mine']['trusted'], 0)  # wallet txs not in the mempool are untrusted
+        assert_equal(self.nodes[0].getbalance(minconf=0), 0)  # wallet txs not in the mempool are untrusted
         self.generatetoaddress(self.nodes[0], 1, ADDRESS_WATCHONLY, sync_fun=self.no_op)
 
         # Now confirm tx_orig
@@ -280,7 +290,7 @@ class WalletTest(BitcoinTestFramework):
         self.sync_blocks()
         self.nodes[1].sendrawtransaction(tx_orig)
         self.generatetoaddress(self.nodes[1], 1, ADDRESS_WATCHONLY)
-        assert_equal(self.nodes[0].getbalances()['mine']['trusted'], total_amount + 1)  # The reorg recovered our fee of 1 coin
+        assert_equal(self.nodes[0].getbalance(minconf=0), total_amount + 1)  # The reorg recovered our fee of 1 coin
 
         if not self.options.descriptors:
             self.log.info('Check if mempool is taken into account after import*')
diff --git a/test/functional/wallet_basic.py b/test/functional/wallet_basic.py
index df9e88ea28..c968e4333a 100755
--- a/test/functional/wallet_basic.py
+++ b/test/functional/wallet_basic.py
@@ -61,24 +61,6 @@ class WalletTest(BitcoinTestFramework):
     def get_vsize(self, txn):
         return self.nodes[0].decoderawtransaction(txn)['vsize']
 
-    def test_legacy_importaddress(self):
-        if self.options.descriptors:
-            return
-
-        addr = self.nodes[1].getnewaddress()
-        self.nodes[1].sendtoaddress(addr, 10)
-        self.sync_mempools(self.nodes[0:2])
-
-        self.log.info("Test 'importaddress' on a blank, private keys disabled, wallet with no descriptors support")
-        self.nodes[0].createwallet(wallet_name="watch-only-legacy", disable_private_keys=False, descriptors=False, blank=True)
-        wallet_watch_only = self.nodes[0].get_wallet_rpc("watch-only-legacy")
-        wallet_watch_only.importaddress(addr)
-        assert_equal(wallet_watch_only.getaddressinfo(addr)['ismine'], False)
-        assert_equal(wallet_watch_only.getaddressinfo(addr)['iswatchonly'], True)
-        assert_equal(wallet_watch_only.getaddressinfo(addr)['solvable'], False)
-        assert_equal(wallet_watch_only.getbalances()["watchonly"]['untrusted_pending'], 10)
-        self.nodes[0].unloadwallet("watch-only-legacy")
-
     def run_test(self):
 
         # Check that there's no UTXO on none of the nodes
@@ -576,9 +558,6 @@ class WalletTest(BitcoinTestFramework):
                                 {"address": address_to_import},
                                 {"spendable": True})
 
-        # Test importaddress on a blank, private keys disabled, legacy wallet with no descriptors support
-        self.test_legacy_importaddress()
-
         # Mine a block from node0 to an address from node1
         coinbase_addr = self.nodes[1].getnewaddress()
         block_hash = self.generatetoaddress(self.nodes[0], 1, coinbase_addr, sync_fun=lambda: self.sync_all(self.nodes[0:3]))[0]
@@ -679,16 +658,6 @@ class WalletTest(BitcoinTestFramework):
         assert not address_info["iswatchonly"]
         assert not address_info["isscript"]
         assert not address_info["ischange"]
-        assert_equal(address_info['use_txids'], [])
-
-        # Test getaddressinfo 'use_txids' field
-        addr = "mneYUmWYsuk7kySiURxCi3AGxrAqZxLgPZ"
-        txid_1 = self.nodes[0].sendtoaddress(addr, 1)
-        address_info = self.nodes[0].getaddressinfo(addr)
-        assert_equal(address_info['use_txids'], [txid_1])
-        txid_2 = self.nodes[0].sendtoaddress(addr, 1)
-        address_info = self.nodes[0].getaddressinfo(addr)
-        assert_equal(sorted(address_info['use_txids']), sorted([txid_1, txid_2]))
 
         # Test getaddressinfo 'ischange' field on change address.
         self.generate(self.nodes[0], 1, sync_fun=self.no_op)
@@ -714,23 +683,8 @@ class WalletTest(BitcoinTestFramework):
                                  "amount":   baz["amount"],
                                  "category": baz["category"],
                                  "vout":     baz["vout"]}
-        expected_fields = frozenset({
-            'amount',
-            'bip125-replaceable',
-            'confirmations',
-            'details',
-            'fee',
-            'hex',
-            'in_mempool',
-            'lastprocessedblock',
-            'mempoolconflicts',
-            'time',
-            'timereceived',
-            'trusted',
-            'txid',
-            'wtxid',
-            'walletconflicts',
-        })
+        expected_fields = frozenset({'amount', 'bip125-replaceable', 'confirmations', 'details', 'fee',
+                                     'hex', 'lastprocessedblock', 'time', 'timereceived', 'trusted', 'txid', 'wtxid', 'walletconflicts', 'mempoolconflicts'})
         verbose_field = "decoded"
         expected_verbose_fields = expected_fields | {verbose_field}
 
diff --git a/test/functional/wallet_bumpfee.py b/test/functional/wallet_bumpfee.py
index 1781fca703..061e9f2caa 100755
--- a/test/functional/wallet_bumpfee.py
+++ b/test/functional/wallet_bumpfee.py
@@ -19,12 +19,10 @@ from test_framework.blocktools import (
     COINBASE_MATURITY,
 )
 from test_framework.messages import (
-    COIN,
     MAX_BIP125_RBF_SEQUENCE,
 )
 from test_framework.test_framework import BitcoinTestFramework
 from test_framework.util import (
-    assert_approx,
     assert_equal,
     assert_fee_amount,
     assert_greater_than,
@@ -64,7 +62,6 @@ class BumpFeeTest(BitcoinTestFramework):
             "-mintxfee=0.00002",
             "-addresstype=bech32",
         ] for i in range(self.num_nodes)]
-        self.wallet_names = [self.default_wallet_name, "RBF wallet"]
 
     def skip_test_if_missing_module(self):
         self.skip_if_no_wallet()
@@ -109,7 +106,6 @@ class BumpFeeTest(BitcoinTestFramework):
         test_bumpfee_metadata(self, rbf_node, dest_address)
         test_locked_wallet_fails(self, rbf_node, dest_address)
         test_change_script_match(self, rbf_node, dest_address)
-        test_setfeerate(self, rbf_node, dest_address)
         test_settxfee(self, rbf_node, dest_address)
         test_maxtxfee_fails(self, rbf_node, dest_address)
         # These tests wipe out a number of utxos that are expected in other tests
@@ -536,44 +532,6 @@ def test_dust_to_fee(self, rbf_node, dest_address):
     self.clear_mempool()
 
 
-def test_setfeerate(self, rbf_node, dest_address):
-    self.log.info("Test setfeerate")
-
-    def test_response(*, wallet="RBF wallet", requested=0, expected=0, error=None, msg):
-        assert_equal(rbf_node.setfeerate(requested), {"wallet_name": wallet, "fee_rate": expected, ("error" if error else "result"): msg})
-
-    # Test setfeerate with too high/low values returns expected errors
-    new = Decimal("10000.001")
-    test_response(requested=new, error=True, msg=f"The requested fee rate of {new} sat/vB cannot be greater than the wallet max fee rate of 10000.000 sat/vB. The current setting of 0 (unset) for this wallet remains unchanged.")
-    new = Decimal("0.999")
-    test_response(requested=new, error=True, msg=f"The requested fee rate of {new} sat/vB cannot be less than the minimum relay fee rate of 1.000 sat/vB. The current setting of 0 (unset) for this wallet remains unchanged.")
-    fee_rate = Decimal("2.001")
-    test_response(requested=fee_rate, expected=fee_rate, msg=f"Fee rate for transactions with this wallet successfully set to {fee_rate} sat/vB")
-    new = Decimal("1.999")
-    test_response(requested=new, expected=fee_rate, error=True, msg=f"The requested fee rate of {new} sat/vB cannot be less than the wallet min fee rate of 2.000 sat/vB. The current setting of {fee_rate} sat/vB for this wallet remains unchanged.")
-
-    # Test setfeerate with valid values returns expected results
-    rbfid = spend_one_input(rbf_node, dest_address)
-    fee_rate = 25
-    test_response(requested=fee_rate, expected=fee_rate, msg="Fee rate for transactions with this wallet successfully set to 25.000 sat/vB")
-    bumped_tx = rbf_node.bumpfee(rbfid)
-    bumped_txdetails = rbf_node.getrawtransaction(bumped_tx["txid"], True)
-    allow_for_bytes_offset = len(bumped_txdetails['vout']) * 2  # potentially up to 2 bytes per output
-    actual_fee = bumped_tx["fee"] * COIN
-    assert_approx(actual_fee, fee_rate * bumped_txdetails['vsize'], fee_rate * allow_for_bytes_offset)
-    test_response(msg="Fee rate for transactions with this wallet successfully unset. By default, automatic fee selection will be used.")
-
-    # Test setfeerate with a different -maxtxfee
-    self.restart_node(1, ["-maxtxfee=0.000025"] + self.extra_args[1])
-    new = "2.501"
-    test_response(requested=new, error=True, msg=f"The requested fee rate of {new} sat/vB cannot be greater than the wallet max fee rate of 2.500 sat/vB. The current setting of 0 (unset) for this wallet remains unchanged.")
-
-    self.restart_node(1, self.extra_args[1])
-    rbf_node.walletpassphrase(WALLET_PASSPHRASE, WALLET_PASSPHRASE_TIMEOUT)
-    self.connect_nodes(1, 0)
-    self.clear_mempool()
-
-
 def test_settxfee(self, rbf_node, dest_address):
     self.log.info('Test settxfee')
     assert_raises_rpc_error(-8, "txfee cannot be less than min relay tx fee", rbf_node.settxfee, Decimal('0.000005'))
diff --git a/test/functional/wallet_create_tx.py b/test/functional/wallet_create_tx.py
index fbd11d1ec8..6deb262c9a 100755
--- a/test/functional/wallet_create_tx.py
+++ b/test/functional/wallet_create_tx.py
@@ -3,8 +3,6 @@
 # Distributed under the MIT software license, see the accompanying
 # file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
-from decimal import Decimal
-
 from test_framework.messages import (
     tx_from_hex,
 )
@@ -39,7 +37,6 @@ class CreateTxWalletTest(BitcoinTestFramework):
         self.test_tx_size_too_large()
         self.test_create_too_long_mempool_chain()
         self.test_version3()
-        self.test_setfeerate()
 
     def test_anti_fee_sniping(self):
         self.log.info('Check that we have some (old) blocks and that anti-fee-sniping is disabled')
@@ -58,7 +55,6 @@ class CreateTxWalletTest(BitcoinTestFramework):
         # More than 10kB of outputs, so that we hit -maxtxfee with a high feerate
         outputs = {self.nodes[0].getnewaddress(address_type='bech32'): 0.000025 for _ in range(400)}
         raw_tx = self.nodes[0].createrawtransaction(inputs=[], outputs=outputs)
-        msg = "Fee exceeds maximum configured by user (e.g. -maxtxfee, maxfeerate)"
 
         for fee_setting in ['-minrelaytxfee=0.01', '-mintxfee=0.01', '-paytxfee=0.01']:
             self.log.info('Check maxtxfee in combination with {}'.format(fee_setting))
@@ -89,12 +85,6 @@ class CreateTxWalletTest(BitcoinTestFramework):
         )
         self.nodes[0].settxfee(0)
 
-        self.log.info('Check maxtxfee in combination with setfeerate (sat/vB)')
-        self.nodes[0].setfeerate(1000)
-        assert_raises_rpc_error(-6, msg, self.nodes[0].sendmany, dummy="", amounts=outputs)
-        assert_raises_rpc_error(-4, msg, self.nodes[0].fundrawtransaction, hexstring=raw_tx)
-        self.nodes[0].setfeerate(0)
-
     def test_create_too_long_mempool_chain(self):
         self.log.info('Check too-long mempool chain error')
         df_wallet = self.nodes[0].get_wallet_rpc(self.default_wallet_name)
@@ -137,51 +127,6 @@ class CreateTxWalletTest(BitcoinTestFramework):
         assert_equal(tx_current_version.version, 2)
         wallet_v3.unloadwallet()
 
-    def test_setfeerate(self):
-        self.log.info("Test setfeerate")
-        self.restart_node(0, extra_args=["-mintxfee=0.00003141"])  # 3.141 sat/vB
-        node = self.nodes[0]
-
-        def test_response(*, requested=0, expected=0, error=None, msg):
-            assert_equal(node.setfeerate(requested), {"wallet_name": self.default_wallet_name, "fee_rate": expected, ("error" if error else "result"): msg})
-
-        # Test setfeerate with 10.0001 (CFeeRate rounding), "10.001" and "4" sat/vB
-        test_response(requested=10.0001, expected=10, msg="Fee rate for transactions with this wallet successfully set to 10.000 sat/vB")
-        assert_equal(node.getwalletinfo()["paytxfee"], Decimal("0.00010000"))
-        test_response(requested="10.001", expected=Decimal("10.001"), msg="Fee rate for transactions with this wallet successfully set to 10.001 sat/vB")
-        assert_equal(node.getwalletinfo()["paytxfee"], Decimal("0.00010001"))
-        test_response(requested="4", expected=4, msg="Fee rate for transactions with this wallet successfully set to 4.000 sat/vB")
-        assert_equal(node.getwalletinfo()["paytxfee"], Decimal("0.00004000"))
-
-        # Test setfeerate with too-high/low values returns expected errors
-        test_response(requested=Decimal("10000.001"), expected=4, error=True, msg="The requested fee rate of 10000.001 sat/vB cannot be greater than the wallet max fee rate of 10000.000 sat/vB. The current setting of 4.000 sat/vB for this wallet remains unchanged.")
-        test_response(requested=Decimal("0.999"), expected=4, error=True, msg="The requested fee rate of 0.999 sat/vB cannot be less than the minimum relay fee rate of 1.000 sat/vB. The current setting of 4.000 sat/vB for this wallet remains unchanged.")
-        test_response(requested=Decimal("3.140"), expected=4, error=True, msg="The requested fee rate of 3.140 sat/vB cannot be less than the wallet min fee rate of 3.141 sat/vB. The current setting of 4.000 sat/vB for this wallet remains unchanged.")
-        assert_equal(node.getwalletinfo()["paytxfee"], Decimal("0.00004000"))
-
-        # Test setfeerate to 3.141 sat/vB
-        test_response(requested=3.141, expected=Decimal("3.141"), msg="Fee rate for transactions with this wallet successfully set to 3.141 sat/vB")
-        assert_equal(node.getwalletinfo()["paytxfee"], Decimal("0.00003141"))
-
-        # Test setfeerate with values non-representable by CFeeRate
-        for invalid_value in [0.00000001, 0.0009, 0.00099999]:
-            assert_raises_rpc_error(-3, "Invalid amount", node.setfeerate, amount=invalid_value)
-
-        # Test setfeerate with values rejected by ParseFixedPoint() called in AmountFromValue()
-        for invalid_value in ["", 0.000000001, "1.111111111", 11111111111]:
-            assert_raises_rpc_error(-3, "Invalid amount", node.setfeerate, amount=invalid_value)
-
-        # Test deactivating setfeerate
-        test_response(msg="Fee rate for transactions with this wallet successfully unset. By default, automatic fee selection will be used.")
-        assert_equal(node.getwalletinfo()["paytxfee"], 0)
-
-        # Test currently-unset setfeerate with too-high/low values returns expected errors
-        test_response(requested=Decimal("10000.001"), error=True, msg="The requested fee rate of 10000.001 sat/vB cannot be greater than the wallet max fee rate of 10000.000 sat/vB. The current setting of 0 (unset) for this wallet remains unchanged.")
-        assert_equal(node.getwalletinfo()["paytxfee"], 0)
-        test_response(requested=Decimal("0.999"), error=True, msg="The requested fee rate of 0.999 sat/vB cannot be less than the minimum relay fee rate of 1.000 sat/vB. The current setting of 0 (unset) for this wallet remains unchanged.")
-        test_response(requested=Decimal("3.140"), error=True, msg="The requested fee rate of 3.140 sat/vB cannot be less than the wallet min fee rate of 3.141 sat/vB. The current setting of 0 (unset) for this wallet remains unchanged.")
-        assert_equal(node.getwalletinfo()["paytxfee"], 0)
-
 
 if __name__ == '__main__':
     CreateTxWalletTest(__file__).main()
diff --git a/test/functional/wallet_createwallet.py b/test/functional/wallet_createwallet.py
index c10acfb86f..0232af1658 100755
--- a/test/functional/wallet_createwallet.py
+++ b/test/functional/wallet_createwallet.py
@@ -161,7 +161,7 @@ class CreateWalletTest(BitcoinTestFramework):
             assert_equal(walletinfo['keypoolsize_hd_internal'], keys)
         # Allow empty passphrase, but there should be a warning
         resp = self.nodes[0].createwallet(wallet_name='w7', disable_private_keys=False, blank=False, passphrase='')
-        assert_equal(resp["warnings"], [EMPTY_PASSPHRASE_MSG])
+        assert_equal(resp["warnings"], [EMPTY_PASSPHRASE_MSG] if self.options.descriptors else [EMPTY_PASSPHRASE_MSG, LEGACY_WALLET_MSG])
 
         w7 = node.get_wallet_rpc('w7')
         assert_raises_rpc_error(-15, 'Error: running with an unencrypted wallet, but walletpassphrase was called.', w7.walletpassphrase, '', 60)
@@ -175,7 +175,7 @@ class CreateWalletTest(BitcoinTestFramework):
         self.log.info('Using a passphrase with private keys disabled returns error')
         assert_raises_rpc_error(-4, 'Passphrase provided but private keys are disabled. A passphrase is only used to encrypt private keys, so cannot be used for wallets with private keys disabled.', self.nodes[0].createwallet, wallet_name='w9', disable_private_keys=True, passphrase='thisisapassphrase')
 
-        if False:
+        if self.is_bdb_compiled():
             self.log.info("Test legacy wallet deprecation")
             result = self.nodes[0].createwallet(wallet_name="legacy_w0", descriptors=False, passphrase=None)
             assert_equal(result, {
diff --git a/test/functional/wallet_descriptor.py b/test/functional/wallet_descriptor.py
index 54a95078ed..5e0ee97892 100755
--- a/test/functional/wallet_descriptor.py
+++ b/test/functional/wallet_descriptor.py
@@ -153,6 +153,7 @@ class WalletDescriptorTest(BitcoinTestFramework):
         self.log.info("Test disabled RPCs")
         assert_raises_rpc_error(-4, "Only legacy wallets are supported by this command", recv_wrpc.rpc.importprivkey, "cVpF924EspNh8KjYsfhgY96mmxvT6DgdWiTYMtMjuM74hJaU5psW")
         assert_raises_rpc_error(-4, "Only legacy wallets are supported by this command", recv_wrpc.rpc.importpubkey, send_wrpc.getaddressinfo(send_wrpc.getnewaddress())["pubkey"])
+        assert_raises_rpc_error(-4, "Only legacy wallets are supported by this command", recv_wrpc.rpc.importaddress, recv_wrpc.getnewaddress())
         assert_raises_rpc_error(-4, "Only legacy wallets are supported by this command", recv_wrpc.rpc.importmulti, [])
         assert_raises_rpc_error(-4, "Only legacy wallets are supported by this command", recv_wrpc.rpc.addmultisigaddress, 1, [recv_wrpc.getnewaddress()])
         assert_raises_rpc_error(-4, "Only legacy wallets are supported by this command", recv_wrpc.rpc.dumpprivkey, recv_wrpc.getnewaddress())
@@ -160,16 +161,6 @@ class WalletDescriptorTest(BitcoinTestFramework):
         assert_raises_rpc_error(-4, "Only legacy wallets are supported by this command", recv_wrpc.rpc.importwallet, 'wallet.dump')
         assert_raises_rpc_error(-4, "Only legacy wallets are supported by this command", recv_wrpc.rpc.sethdseed)
 
-        # Test importaddress
-        self.log.info("Test watch-only descriptor wallet")
-        self.nodes[0].createwallet(wallet_name="watch-only-desc", disable_private_keys=True, descriptors=True, blank=True)
-        wallet_watch_only = self.nodes[0].get_wallet_rpc("watch-only-desc")
-        wallet_watch_only.importaddress(addr)
-        assert_equal(wallet_watch_only.getaddressinfo(addr)['ismine'], True)
-        assert_equal(wallet_watch_only.getaddressinfo(addr)['solvable'], False)
-        assert_equal(wallet_watch_only.getbalances()["mine"]['untrusted_pending'], 10)
-        self.nodes[0].unloadwallet("watch-only-desc")
-
         self.log.info("Test encryption")
         # Get the master fingerprint before encrypt
         info1 = send_wrpc.getaddressinfo(send_wrpc.getnewaddress())
diff --git a/test/functional/wallet_dump.py b/test/functional/wallet_dump.py
index 165a0fe2fb..3a4f23a124 100755
--- a/test/functional/wallet_dump.py
+++ b/test/functional/wallet_dump.py
@@ -37,10 +37,10 @@ def read_dump(file_name, addrs, script_addrs, hd_master_addr_old):
             else:
                 # split out some data
                 key_date_label, comment = line.split("#")
-                key_date_label = key_date_label.rstrip().split(" ")
+                key_date_label = key_date_label.split(" ")
                 # key = key_date_label[0]
                 date = key_date_label[1]
-                key_params = dict(map(lambda x: x.split('=', 1), key_date_label[2:]))
+                keytype = key_date_label[2]
 
                 imported_key = date == '1970-01-01T00:00:01Z'
                 if imported_key:
@@ -48,25 +48,25 @@ def read_dump(file_name, addrs, script_addrs, hd_master_addr_old):
                     # Skip them
                     continue
 
-                comment_params = dict(map(lambda x: x.split('=', 1), comment.strip().split(" ")))
-                addr = comment_params['addr']
+                addr_keypath = comment.split(" addr=")[1]
+                addr = addr_keypath.split(" ")[0]
                 keypath = None
-                if key_params.get('inactivehdseed'):
+                if keytype == "inactivehdseed=1":
                     # ensure the old master is still available
                     assert hd_master_addr_old == addr
-                elif key_params.get('hdseed'):
+                elif keytype == "hdseed=1":
                     # ensure we have generated a new hd master key
                     assert hd_master_addr_old != addr
                     hd_master_addr_ret = addr
-                elif key_params.get('script'):
+                elif keytype == "script=1":
                     # scripts don't have keypaths
                     keypath = None
                 else:
-                    keypath = key_params['hdkeypath']
+                    keypath = addr_keypath.rstrip().split("hdkeypath=")[1]
 
                 # count key types
                 for addrObj in addrs:
-                    if addrObj['address'] == addr.split(",")[0] and addrObj['hdkeypath'] == keypath and key_params.get('label') == "":
+                    if addrObj['address'] == addr.split(",")[0] and addrObj['hdkeypath'] == keypath and keytype == "label=":
                         if addr.startswith('m') or addr.startswith('n'):
                             # P2PKH address
                             found_legacy_addr += 1
@@ -76,16 +76,16 @@ def read_dump(file_name, addrs, script_addrs, hd_master_addr_old):
                         elif addr.startswith('bcrt1'):
                             found_bech32_addr += 1
                         break
-                    elif key_params.get('change'):
+                    elif keytype == "change=1":
                         found_addr_chg += 1
                         break
-                    elif key_params.get('reserve'):
+                    elif keytype == "reserve=1":
                         found_addr_rsv += 1
                         break
 
                 # count scripts
                 for script_addr in script_addrs:
-                    if script_addr == addr.rstrip() and key_params.get('script'):
+                    if script_addr == addr.rstrip() and keytype == "script=1":
                         found_script_addr += 1
                         break
 
diff --git a/test/functional/wallet_fundrawtransaction.py b/test/functional/wallet_fundrawtransaction.py
index 9a818cff79..827f27b431 100755
--- a/test/functional/wallet_fundrawtransaction.py
+++ b/test/functional/wallet_fundrawtransaction.py
@@ -9,7 +9,6 @@ from decimal import Decimal
 from itertools import product
 from math import ceil
 from test_framework.address import address_to_scriptpubkey
-from test_framework.blocktools import COINBASE_MATURITY
 
 from test_framework.descriptors import descsum_create
 from test_framework.messages import (
@@ -138,7 +137,6 @@ class RawTransactionsTest(BitcoinTestFramework):
         self.test_locked_wallet()
         self.test_many_inputs_fee()
         self.test_many_inputs_send()
-        self.test_witness_only()
         self.test_op_return()
         self.test_watchonly()
         self.test_all_watched_funds()
@@ -218,52 +216,6 @@ class RawTransactionsTest(BitcoinTestFramework):
         dec_tx  = self.nodes[2].decoderawtransaction(rawtxfund['hex'])
         assert len(dec_tx['vin']) > 0  #test that we have enough inputs
 
-    def check_witness_inputs(self, vins):
-        for vin in vins:
-            # check vin is a segwit input
-            utxo = self.nodes[2].gettxout(vin['txid'], vin['vout'])
-            info = self.nodes[2].getaddressinfo(utxo['scriptPubKey']['address'])
-            if not (info['iswitness'] or info['embedded']['iswitness']):
-                return False
-
-        return True
-
-    def test_witness_only(self):
-        self.log.info("Testing fundrawtxn with witness inputs only")
-
-        self.generate(self.nodes[0], COINBASE_MATURITY + 10)
-        self.nodes[2].sendall(recipients=[self.nodes[0].getnewaddress()])
-
-        output_types = ['legacy', 'p2sh-segwit', 'bech32']
-        if self.options.descriptors:
-            output_types.append('bech32m')
-        # Create coins
-        for _ in range(10):
-            for output_type in output_types:
-                self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(address_type=output_type), 1)
-
-        self.generate(self.nodes[0], 1)
-
-        inputs = [ ]
-        target_addr = self.nodes[2].getnewaddress()
-        segwit_balance = (len(output_types) - 1) * 10
-
-        # make sure legacy inputs are not accepted in witness only mode if no witness inputs are found
-        # trying to spend more than segwit total should fail
-        outputs = { target_addr : segwit_balance + Decimal('0.00000001') }
-        rawtx = self.nodes[2].createrawtransaction(inputs, outputs)
-        assert_raises_rpc_error(-4, "Insufficient funds", self.nodes[2].fundrawtransaction, rawtx, {'segwit_inputs_only': True, 'subtractFeeFromOutputs': [0]})
-
-        # make sure all inputs are of type witness
-        outputs = { target_addr : segwit_balance }
-        rawtx = self.nodes[2].createrawtransaction(inputs, outputs)
-        rawtxfund = self.nodes[2].fundrawtransaction(rawtx, {'segwit_inputs_only': True, 'subtractFeeFromOutputs': [0]})
-        dec_tx = self.nodes[2].decoderawtransaction(rawtxfund['hex'])
-
-        assert len(dec_tx['vin']) > 0
-        assert(self.check_witness_inputs(dec_tx['vin']))
-
-
     def test_simple_two_coins(self):
         self.log.info("Test fundrawtxn with 2 coins")
         inputs  = [ ]
@@ -1042,16 +994,6 @@ class RawTransactionsTest(BitcoinTestFramework):
         # The total subtracted from the outputs is equal to the fee.
         assert_equal(share[0] + share[2] + share[3], result[0]['fee'])
 
-        # test funding with custom min_conf
-        inputs = []
-        outputs = {self.nodes[2].getnewaddress(): 1}
-        rawtx = self.nodes[3].createrawtransaction(inputs, outputs)
-        unspent = self.nodes[3].listunspent()
-        assert len(unspent) == 1
-        input_confs = unspent[0]['confirmations']
-        assert_raises_rpc_error(-4, "Insufficient funds", self.nodes[3].fundrawtransaction, rawtx,  {'min_conf': input_confs + 1})
-        result = self.nodes[3].fundrawtransaction(rawtx, {'min_conf': input_confs})
-
     def test_subtract_fee_with_presets(self):
         self.log.info("Test fundrawtxn subtract fee from outputs with preset inputs that are sufficient")
 
diff --git a/test/functional/wallet_hd.py b/test/functional/wallet_hd.py
index d860c62518..8f2a5fc78b 100755
--- a/test/functional/wallet_hd.py
+++ b/test/functional/wallet_hd.py
@@ -40,20 +40,9 @@ class WalletHDTest(BitcoinTestFramework):
         change_addrV = self.nodes[1].getaddressinfo(change_addr)
         if self.options.descriptors:
             assert_equal(change_addrV["hdkeypath"], "m/84h/1h/0h/1/0")
-
-            # Exporting the master private key should fail on a descriptor wallet
-            assert_raises_rpc_error(-4, "Only legacy wallets are supported by this command", self.nodes[1].dumpmasterprivkey)
         else:
             assert_equal(change_addrV["hdkeypath"], "m/0'/1'/0'")  #first internal child key
 
-            # Check that the exported master private key begins with tprv
-            xprv = self.nodes[1].dumpmasterprivkey()
-            assert_equal(xprv[0:4], "tprv")
-
-            # Exporting the master private key should fail on a non-HD wallet
-            # FIXME: No way to make non-HD wallets anymore
-            #assert_raises_rpc_error(-4, "Wallet is not a HD wallet.", self.nodes[0].dumpmasterprivkey)
-
         # Import a non-HD private key in the HD wallet
         non_hd_add = 'bcrt1qmevj8zfx0wdvp05cqwkmr6mxkfx60yezwjksmt'
         non_hd_key = 'cS9umN9w6cDMuRVYdbkfE4c7YUFLJRoXMfhQ569uY4odiQbVN8Rt'
diff --git a/test/functional/wallet_implicitsegwit.py b/test/functional/wallet_implicitsegwit.py
index c6441b80bf..e5787c0304 100755
--- a/test/functional/wallet_implicitsegwit.py
+++ b/test/functional/wallet_implicitsegwit.py
@@ -38,18 +38,6 @@ def check_implicit_transactions(implicit_keys, implicit_node):
             b_address = key_to_address(pubkey, b)
             assert ('receive', b_address) in tuple((tx['category'], tx['address']) for tx in txs)
 
-def check_explicit_transactions(explicit_keys, explicit_node):
-    # The explicit segwit node doesn't allow conversion from legacy to segwit
-    txs = explicit_node.listtransactions(None, 99999)
-    for a in address_types:
-        pubkey = explicit_keys[a]
-        for b in address_types:
-            b_address = key_to_address(pubkey, b)
-            if a == 'legacy' and a != b:
-                assert(('receive', b_address) not in tuple((tx['category'], tx['address']) for tx in txs))
-            else:
-                assert(('receive', b_address) in tuple((tx['category'], tx['address']) for tx in txs))
-
 class ImplicitSegwitTest(BitcoinTestFramework):
     def add_options(self, parser):
         self.add_wallet_options(parser, descriptors=False)
@@ -57,14 +45,6 @@ class ImplicitSegwitTest(BitcoinTestFramework):
     def set_test_params(self):
         self.num_nodes = 2
         self.supports_cli = False
-        self.extra_args = [
-            [
-                "-walletimplicitsegwit=1",
-            ],
-            [
-                "-walletimplicitsegwit=0",
-            ],
-        ]
 
     def skip_test_if_missing_module(self):
         self.skip_if_no_wallet()
@@ -72,20 +52,17 @@ class ImplicitSegwitTest(BitcoinTestFramework):
     def run_test(self):
         self.log.info("Manipulating addresses and sending transactions to all variations")
         implicit_keys = send_a_to_b(self.nodes[0], self.nodes[1])
-        explicit_keys = send_a_to_b(self.nodes[1], self.nodes[0])
 
         self.sync_all()
 
         self.log.info("Checking that transactions show up correctly without a restart")
         check_implicit_transactions(implicit_keys, self.nodes[0])
-        check_explicit_transactions(explicit_keys, self.nodes[1])
 
         self.log.info("Checking that transactions still show up correctly after a restart")
         self.restart_node(0)
         self.restart_node(1)
 
         check_implicit_transactions(implicit_keys, self.nodes[0])
-        check_explicit_transactions(explicit_keys, self.nodes[1])
 
 if __name__ == '__main__':
     ImplicitSegwitTest(__file__).main()
diff --git a/test/functional/wallet_import_rescan.py b/test/functional/wallet_import_rescan.py
index 5a3277b2b1..c5834c15d2 100755
--- a/test/functional/wallet_import_rescan.py
+++ b/test/functional/wallet_import_rescan.py
@@ -300,7 +300,6 @@ class ImportRescanTest(BitcoinTestFramework):
                 add_to_wallet=False,
                 inputs=[unspent_txid_map[variant.initial_txid]],
                 outputs=[{ADDRESS_BCRT1_UNSPENDABLE : variant.initial_amount}],
-                locktime=0,
                 subtract_fee_from_outputs=[0]
             )
             variant.child_txid = child["txid"]
diff --git a/test/functional/wallet_importseed.py b/test/functional/wallet_importseed.py
deleted file mode 100755
index a964e8dbf6..0000000000
--- a/test/functional/wallet_importseed.py
+++ /dev/null
@@ -1,269 +0,0 @@
-#!/usr/bin/env python3
-# Copyright (c) 2013 The Bitcoin Core developers
-# Distributed under the MIT software license, see the accompanying
-# file COPYING or http://www.opensource.org/licenses/mit-license.php.
-"""Test the 'seeds' argument to the importdescriptors RPC
-
-Test importingi seeds by using the BIP 93 test vectors to verify that imported
-seeds are compatible with descriptors containing the corresponding xpubs, that
-the wallet is able to recognize and send funds, and that the wallet can derive
-addresses, when given only seeds as private data."""
-
-import time
-
-from test_framework.test_framework import BitcoinTestFramework
-from test_framework.util import (
-    assert_raises_rpc_error,
-)
-
-
-class ImportDescriptorsTest(BitcoinTestFramework):
-    def add_options(self, parser):
-        self.add_wallet_options(parser, legacy=False)
-
-    def set_test_params(self):
-        self.num_nodes = 1
-        self.setup_clean_chain = True
-        self.wallet_names = []
-
-    def skip_test_if_missing_module(self):
-        self.skip_if_no_wallet()
-
-    def run_test(self):
-        test_start = int(time.time())
-
-        # Spend/receive tests
-        self.nodes[0].createwallet(wallet_name='w0', descriptors=True)
-        self.nodes[0].createwallet(wallet_name='w1', descriptors=True, blank=True)
-        w0 = self.nodes[0].get_wallet_rpc('w0')
-        w1 = self.nodes[0].get_wallet_rpc('w1')
-
-        self.generatetoaddress(self.nodes[0], 2, w0.getnewaddress())
-        self.generate(self.nodes[0], 100)
-
-        # Test 1: send coins to wallet, check they are not received, then import
-        #         the descriptor and make sure they are recognized. Send them
-        #         back and repeat. Uses single codex32 seed.
-        #
-        # xpub converted from BIP 93 test vector 1 xpriv using rust-bitcoin
-        xpub = "tpubD6NzVbkrYhZ4YAqhvsGTCD5axU32P9MH7ySPr38icriLyJc4KcCvwVzE3rsi" \
-               "XaAHBC8QtYWhiBGdc6aZRmroQShGcWygQfErbvLULfJSi8j"
-        descriptors = [
-            f"wsh(pk({xpub}/55/*))",
-            f"tr({xpub}/1/2/3/4/5/*)",
-            f"pkh({xpub}/*)",
-            f"wpkh({xpub}/*)",
-            f"rawtr({xpub}/1/2/3/*)",
-        ]
-        assert_raises_rpc_error(-4, "This wallet has no available keys", w1.getnewaddress)
-        for descriptor in descriptors:
-            descriptor_chk = w0.getdescriptorinfo(descriptor)["descriptor"]
-            addr = w0.deriveaddresses(descriptor_chk, range=[0, 20])[0]
-
-            assert w0.getbalance() > 99  # sloppy balance checks, to account for fees
-            w0.sendtoaddress(addr, 95)
-            self.generate(self.nodes[0], 1)
-            assert w0.getbalance() < 5
-
-            w1.importdescriptors(
-                [{"desc": descriptor_chk, "timestamp": test_start, "range": 0, "active": True}],
-                [["ms10testsxxxxxxxxxxxxxxxxxxxxxxxxxx4nzvca9cmczlw"]],
-            )
-
-            assert w1.getbalance() > 94
-            w1.sendtoaddress(w0.getnewaddress(), 95, "", "", True)
-            self.generate(self.nodes[0], 1)
-            assert w0.getbalance() > 99
-        w1.getnewaddress()  # no failure now
-
-        # Test 2: deriveaddresses on hardened keys fails before import, succeeds after.
-        #         Uses single codex32 seed in 2 shares.
-        #
-        # xpub converted from BIP 93 test vector 2 xpriv using rust-bitcoin
-        self.nodes[0].createwallet(wallet_name='w2', descriptors=True, blank=True)
-        w2 = self.nodes[0].get_wallet_rpc('w2')
-
-        xpub = "tpubD6NzVbkrYhZ4Wf289qp46iFM6zACTdXTqqrA3pKUV8bF8SNBcYS8xvVPZg43" \
-               "6YhSuCqTKLfnDkmwi9TE6fa5cvxm3NHRCBbgJoC6YgsQBFY"
-        descriptor = f"tr([fab6868a/1h/2]{xpub}/1h/2/*h)"
-        descriptor_chk = w2.getdescriptorinfo(descriptor)["descriptor"]
-        assert_raises_rpc_error(
-            -4,
-            "This wallet has no available keys",
-            w2.getnewaddress,
-            address_type="bech32m",
-        )
-
-        # Try importing descriptor with wrong seed
-        err = w2.importdescriptors(
-            [{"desc": descriptor_chk, "timestamp": test_start, "active": True, "range": [0, 20]}],
-            [["ms10testsxxxxxxxxxxxxxxxxxxxxxxxxxx4nzvca9cmczlw"]],
-        )
-        assert "Cannot expand descriptor." in err[0]["error"]["message"]
-        assert_raises_rpc_error(
-            -4,
-            "This wallet has no available keys",
-            w2.getnewaddress,
-            address_type="bech32m",
-        )
-
-        # Try various failure cases
-        assert_raises_rpc_error(
-            -5,
-            "single share must be the S share",
-            w2.importdescriptors,
-            [{"desc": descriptor_chk, "timestamp": test_start, "active": True, "range": [0, 20]}],
-            [["MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM"]],
-        )
-
-        assert_raises_rpc_error(
-            -5,
-            "two input shares had the same index",
-            w2.importdescriptors,
-            [{"desc": descriptor_chk, "timestamp": test_start, "active": True, "range": [0, 20]}],
-            [[
-                "MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM",
-                "MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM",
-            ]],
-        )
-
-        assert_raises_rpc_error(
-            -5,
-            "input shares had inconsistent seed IDs",
-            w2.importdescriptors,
-            [{"desc": descriptor_chk, "timestamp": test_start, "active": True, "range": [0, 20]}],
-            [[
-                "MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM",
-                "ms13cashcacdefghjklmnpqrstuvwxyz023949xq35my48dr",
-            ]],
-        )
-
-        # Do it correctly
-        w2.importdescriptors(
-            [{"desc": descriptor_chk, "timestamp": test_start, "active": True, "range": [0, 20]}],
-            [[
-                "MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM",
-                "MS12NAMECACDEFGHJKLMNPQRSTUVWXYZ023FTR2GDZMPY6PN",
-            ]],
-        )
-        # getnewaddress no longer fails. Annoyingl, deriveaddresses will
-        w2.getnewaddress(address_type="bech32m")
-        assert_raises_rpc_error(
-            -5,
-            "Cannot derive script without private keys",
-            w2.deriveaddresses,
-            descriptor_chk,
-            0,
-        )
-        # Do it again, to see if nothing breaks
-        w2.importdescriptors(
-            [{"desc": descriptor_chk, "timestamp": test_start, "active": True, "range": [0, 20]}],
-            [[
-                "MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM",
-                "MS12NAMECACDEFGHJKLMNPQRSTUVWXYZ023FTR2GDZMPY6PN",
-            ]],
-        )
-
-        # Test 3: multiple seeds, multiple descriptors
-        #
-        # xpubs converted from BIP 93 test vector 3, 4 and 5 xprivs using rust-bitcoin
-
-        self.nodes[0].createwallet(wallet_name='w3', descriptors=True, blank=True)
-        w3 = self.nodes[0].get_wallet_rpc('w3')
-        xpub1 = "tpubD6NzVbkrYhZ4WNNA2qNKYbaxKR3TYtP2n5bNSj6JKzYsVUPxahe2vWJKwiX2" \
-                "wfoTJyERQNJ8YnmJvprMHygyaXziTdyFVsSGNmfQtDCCSJ3"  # vector 3
-        xpub2 = "tpubD6NzVbkrYhZ4Y9KL2R346X9ZwcN16c37vjXuZEhDV2LaMt84zqVbKVbVAw1z" \
-                "nMksNtdKnSRZQXyBL9qJaNnq9BkjtRBdsQbxkTbSGZGrcG6"  # vector 4
-        xpub3 = "tpubD6NzVbkrYhZ4Ykomd4u92cmRCkhZtctLkKU3vCVi7DKBAopRDWVpq6wEGoq7" \
-                "xYbCQQjEGM8KkqxvQDoLa3sdfpzTBv1yodq4FKwrCdxweHE"  # vector 5
-
-        descriptor1 = f"rawtr({xpub1}/1/2h/*)"
-        descriptor1_chk = w3.getdescriptorinfo(descriptor1)["descriptor"]
-        descriptor2 = f"wpkh({xpub2}/1h/2/*)"
-        descriptor2_chk = w3.getdescriptorinfo(descriptor2)["descriptor"]
-        descriptor3 = f"pkh({xpub3}/1h/2/3/4/5/6/7/8/9/10/*)"
-        descriptor3_chk = w3.getdescriptorinfo(descriptor3)["descriptor"]
-
-        assert_raises_rpc_error(
-            -4,
-            "This wallet has no available keys",
-            w3.getnewaddress,
-            address_type="bech32m",
-        )
-        assert_raises_rpc_error(
-            -4,
-            "This wallet has no available keys",
-            w3.getnewaddress,
-            address_type="bech32",
-        )
-        assert_raises_rpc_error(
-            -4,
-            "This wallet has no available keys",
-            w3.getnewaddress,
-            address_type="legacy",
-        )
-
-        # First try without enough input shares.
-        assert_raises_rpc_error(
-            -5,
-            "did not have enough input shares",
-            w3.importdescriptors,
-            [
-                {"desc": descriptor1_chk, "timestamp": test_start, "active": True, "range": 10},
-                {"desc": descriptor2_chk, "timestamp": test_start, "active": True, "range": 15},
-            ],
-            [[
-                "ms13casheekgpemxzshcrmqhaydlp6yhms3ws7320xyxsar9",
-                "ms13cashf8jh6sdrkpyrsp5ut94pj8ktehhw2hfvyrj48704",
-            ], [
-                "ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqqtum9pgv99ycma",
-            ]],
-        )
-        # Wallet still doesn't work, even the descriptor whose seed was correctly specified
-        assert_raises_rpc_error(
-            -4,
-            "This wallet has no available keys",
-            w3.getnewaddress,
-            address_type="bech32",
-        )
-
-        # Do it properly
-        w3.importdescriptors(
-            [
-                {"desc": descriptor1_chk, "timestamp": test_start, "active": True, "range": 10},
-                {"desc": descriptor2_chk, "timestamp": test_start, "active": True, "range": 15},
-                {"desc": descriptor3_chk, "timestamp": test_start, "active": True, "range": 15},
-            ],
-            [[
-                "ms13cashd0wsedstcdcts64cd7wvy4m90lm28w4ffupqs7rm",
-                "ms13casheekgpemxzshcrmqhaydlp6yhms3ws7320xyxsar9",
-                "ms13cashf8jh6sdrkpyrsp5ut94pj8ktehhw2hfvyrj48704",
-            ], [
-                "ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqqtum9pgv99ycma",
-            ]],
-        )
-        # All good now for the two descriptors that had seeds
-        w3.getnewaddress(address_type="bech32")
-        w3.getnewaddress(address_type="bech32m")
-        # but the one without a seed still doesn't work
-        assert_raises_rpc_error(
-            -12,
-            "No legacy addresses available",
-            w3.getnewaddress,
-            address_type="legacy",
-        )
-
-        # Ok, try to import the legacy one separately.
-        w3.importdescriptors(
-            [{"desc": descriptor3_chk, "timestamp": test_start, "active": True, "range": 15}],
-            [["MS100C8VSM32ZXFGUHPCHTLUPZRY9X8GF2TVDW0S3JN54KHCE6MUA7LQPZYGSFJD"  # concat string
-              "6AN074RXVCEMLH8WU3TK925ACDEFGHJKLMNPQRSTUVWXY06FHPV80UNDVARHRAK"]],
-        )
-        # And all is well!
-        w3.getnewaddress(address_type="bech32")
-        w3.getnewaddress(address_type="bech32m")
-        w3.getnewaddress(address_type="legacy")
-
-
-if __name__ == '__main__':
-    ImportDescriptorsTest(__file__).main()
diff --git a/test/functional/wallet_keypool.py b/test/functional/wallet_keypool.py
index c539b4ad63..d3b6ca1ed1 100755
--- a/test/functional/wallet_keypool.py
+++ b/test/functional/wallet_keypool.py
@@ -4,113 +4,33 @@
 # file COPYING or http://www.opensource.org/licenses/mit-license.php.
 """Test the wallet keypool and interaction with wallet encryption/locking."""
 
-import re
 import time
 from decimal import Decimal
 
-from test_framework.descriptors import descsum_create
 from test_framework.test_framework import BitcoinTestFramework
 from test_framework.util import assert_equal, assert_raises_rpc_error
 from test_framework.wallet_util import WalletUnlock
 
-TEST_KEYPOOL_SIZE = 10
-TEST_NEW_KEYPOOL_SIZE = TEST_KEYPOOL_SIZE + 2
-
 class KeyPoolTest(BitcoinTestFramework):
     def add_options(self, parser):
         self.add_wallet_options(parser)
 
     def set_test_params(self):
         self.num_nodes = 1
-        self.extra_args = [[f"-keypool={TEST_KEYPOOL_SIZE}"]]
 
     def skip_test_if_missing_module(self):
         self.skip_if_no_wallet()
 
     def run_test(self):
         nodes = self.nodes
-
-        # Derive addresses from the wallet without removing them from keypool
-        addrs = []
-        if not self.options.descriptors:
-            path = str(self.nodes[0].datadir_path / 'wallet.dump')
-            nodes[0].dumpwallet(path)
-            file = open(path, "r", encoding="utf8")
-            m = re.search(r"masterkey: (\w+)", file.read())
-            file.close()
-            xpriv = m.group(1)
-            desc = descsum_create(f"wpkh({xpriv}/0h/0h/*h)")
-            addrs = nodes[0].deriveaddresses(descriptor=desc, range=[0, 9])
-        else:
-            list_descriptors = nodes[0].listdescriptors()
-            for desc in list_descriptors["descriptors"]:
-                if desc['active'] and not desc["internal"] and desc["desc"][:4] == "wpkh":
-                    addrs = nodes[0].deriveaddresses(descriptor=desc["desc"], range=[0, 9])
-
-        addr0 = addrs[0]
-        addr9 = addrs[9] # arbitrary future address index
-
-        # Address is mine and active before it is removed from keypool by getnewaddress
-        addr0_before_getting_data = nodes[0].getaddressinfo(addr0)
-        assert addr0_before_getting_data['ismine']
-        assert addr0_before_getting_data['isactive']
-
         addr_before_encrypting = nodes[0].getnewaddress()
         addr_before_encrypting_data = nodes[0].getaddressinfo(addr_before_encrypting)
-        assert addr0 == addr_before_encrypting
-        # Address is still mine and active even after being removed from keypool
-        assert addr_before_encrypting_data['ismine']
-        assert addr_before_encrypting_data['isactive']
-
         wallet_info_old = nodes[0].getwalletinfo()
         if not self.options.descriptors:
             assert addr_before_encrypting_data['hdseedid'] == wallet_info_old['hdseedid']
 
-        # Address is mine and active before wallet is encrypted (resetting keypool)
-        addr9_before_encrypting_data = nodes[0].getaddressinfo(addr9)
-        assert addr9_before_encrypting_data['ismine']
-        assert addr9_before_encrypting_data['isactive']
-
-        # Imported things are never considered active, no need to rescan
-        # Imported public keys / addresses can't be mine because they are not spendable
-        if self.options.descriptors:
-            nodes[0].importdescriptors([{
-                "desc": "addr(bcrt1q95gp4zeaah3qcerh35yhw02qeptlzasdtst55v)",
-                "timestamp": "now"
-            }])
-        else:
-            nodes[0].importaddress("bcrt1q95gp4zeaah3qcerh35yhw02qeptlzasdtst55v", "label", rescan=False)
-        import_addr_data = nodes[0].getaddressinfo("bcrt1q95gp4zeaah3qcerh35yhw02qeptlzasdtst55v")
-        assert import_addr_data["iswatchonly"] is not self.options.descriptors
-        assert not import_addr_data["ismine"]
-        assert not import_addr_data["isactive"]
-
-        if self.options.descriptors:
-            nodes[0].importdescriptors([{
-                "desc": "pk(02f893ca95b0d55b4ce4e72ae94982eb679158cb2ebc120ff62c17fedfd1f0700e)",
-                "timestamp": "now"
-            }])
-        else:
-            nodes[0].importpubkey("02f893ca95b0d55b4ce4e72ae94982eb679158cb2ebc120ff62c17fedfd1f0700e", "label", rescan=False)
-        import_pub_data = nodes[0].getaddressinfo("bcrt1q4v7a8wn5vqd6fk4026s5gzzxyu7cfzz23n576h")
-        assert import_pub_data["iswatchonly"] is not self.options.descriptors
-        assert not import_pub_data["ismine"]
-        assert not import_pub_data["isactive"]
-
-        nodes[0].importprivkey("cPMX7v5CNV1zCphFSq2hnR5rCjzAhA1GsBfD1qrJGdj4QEfu38Qx", "label", rescan=False)
-        import_priv_data = nodes[0].getaddressinfo("bcrt1qa985v5d53qqtrfujmzq2zrw3r40j6zz4ns02kj")
-        assert not import_priv_data["iswatchonly"]
-        assert import_priv_data["ismine"]
-        assert not import_priv_data["isactive"]
-
         # Encrypt wallet and wait to terminate
         nodes[0].encryptwallet('test')
-        addr9_after_encrypting_data = nodes[0].getaddressinfo(addr9)
-        # Key is from unencrypted seed, no longer considered active
-        assert not addr9_after_encrypting_data['isactive']
-        # ...however it *IS* still mine since we can spend with this key
-        assert addr9_after_encrypting_data['ismine']
-
         if self.options.descriptors:
             # Import hardened derivation only descriptors
             nodes[0].walletpassphrase('test', 10)
@@ -156,9 +76,7 @@ class KeyPoolTest(BitcoinTestFramework):
                 }
             ])
             nodes[0].walletlock()
-        # Keep creating keys until we run out
-        for _ in range(TEST_KEYPOOL_SIZE - 1):
-            nodes[0].getnewaddress()
+        # Keep creating keys
         addr = nodes[0].getnewaddress()
         addr_data = nodes[0].getaddressinfo(addr)
         wallet_info = nodes[0].getwalletinfo()
@@ -167,23 +85,24 @@ class KeyPoolTest(BitcoinTestFramework):
             assert addr_data['hdseedid'] == wallet_info['hdseedid']
         assert_raises_rpc_error(-12, "Error: Keypool ran out, please call keypoolrefill first", nodes[0].getnewaddress)
 
-        # put two new keys in the keypool
+        # put six (plus 2) new keys in the keypool (100% external-, +100% internal-keys, 1 in min)
         with WalletUnlock(nodes[0], 'test'):
-            nodes[0].keypoolrefill(TEST_NEW_KEYPOOL_SIZE)
+            nodes[0].keypoolrefill(6)
         wi = nodes[0].getwalletinfo()
         if self.options.descriptors:
-            # Descriptors wallet: keypool size applies to both internal and external
-            # chains and there are four of each (legacy, nested, segwit, and taproot)
-            assert_equal(wi['keypoolsize_hd_internal'], TEST_NEW_KEYPOOL_SIZE * 4)
-            assert_equal(wi['keypoolsize'], TEST_NEW_KEYPOOL_SIZE * 4)
+            assert_equal(wi['keypoolsize_hd_internal'], 24)
+            assert_equal(wi['keypoolsize'], 24)
         else:
-            # Legacy wallet: keypool size applies to both internal and external HD chains
-            assert_equal(wi['keypoolsize_hd_internal'], TEST_NEW_KEYPOOL_SIZE)
-            assert_equal(wi['keypoolsize'], TEST_NEW_KEYPOOL_SIZE)
+            assert_equal(wi['keypoolsize_hd_internal'], 6)
+            assert_equal(wi['keypoolsize'], 6)
 
         # drain the internal keys
-        for _ in range(TEST_NEW_KEYPOOL_SIZE):
-            nodes[0].getrawchangeaddress()
+        nodes[0].getrawchangeaddress()
+        nodes[0].getrawchangeaddress()
+        nodes[0].getrawchangeaddress()
+        nodes[0].getrawchangeaddress()
+        nodes[0].getrawchangeaddress()
+        nodes[0].getrawchangeaddress()
         # remember keypool sizes
         wi = nodes[0].getwalletinfo()
         kp_size_before = [wi['keypoolsize_hd_internal'], wi['keypoolsize']]
@@ -196,8 +115,13 @@ class KeyPoolTest(BitcoinTestFramework):
 
         # drain the external keys
         addr = set()
-        for _ in range(TEST_NEW_KEYPOOL_SIZE):
-            addr.add(nodes[0].getnewaddress(address_type="bech32"))
+        addr.add(nodes[0].getnewaddress(address_type="bech32"))
+        addr.add(nodes[0].getnewaddress(address_type="bech32"))
+        addr.add(nodes[0].getnewaddress(address_type="bech32"))
+        addr.add(nodes[0].getnewaddress(address_type="bech32"))
+        addr.add(nodes[0].getnewaddress(address_type="bech32"))
+        addr.add(nodes[0].getnewaddress(address_type="bech32"))
+        assert len(addr) == 6
         # remember keypool sizes
         wi = nodes[0].getwalletinfo()
         kp_size_before = [wi['keypoolsize_hd_internal'], wi['keypoolsize']]
@@ -208,18 +132,16 @@ class KeyPoolTest(BitcoinTestFramework):
         kp_size_after = [wi['keypoolsize_hd_internal'], wi['keypoolsize']]
         assert_equal(kp_size_before, kp_size_after)
 
-        # refill keypool
+        # refill keypool with three new addresses
         nodes[0].walletpassphrase('test', 1)
-        # At this point the keypool has >45 keys in it
-        # calling keypoolrefill with anything smaller than that is a noop
-        nodes[0].keypoolrefill(50)
+        nodes[0].keypoolrefill(3)
 
         # test walletpassphrase timeout
         time.sleep(1.1)
         assert_equal(nodes[0].getwalletinfo()["unlocked_until"], 0)
 
         # drain the keypool
-        for _ in range(50):
+        for _ in range(3):
             nodes[0].getnewaddress()
         assert_raises_rpc_error(-12, "Keypool ran out", nodes[0].getnewaddress)
 
diff --git a/test/functional/wallet_labels.py b/test/functional/wallet_labels.py
index cebe42bda7..307e10ae34 100755
--- a/test/functional/wallet_labels.py
+++ b/test/functional/wallet_labels.py
@@ -66,52 +66,6 @@ class WalletLabelsTest(BitcoinTestFramework):
         for rpc_call in rpc_calls:
             assert_raises_rpc_error(-11, "Invalid label name", *rpc_call, "*")
 
-    def test_sort_multisig(self, node):
-        node.importprivkey("cSJUMwramrFYHKPfY77FH94bv4Q5rwUCyfD6zX3kLro4ZcWsXFEM")
-        node.importprivkey("cSpQbSsdKRmxaSWJ3TckCFTrksXNPbh8tfeZESGNQekkVxMbQ77H")
-        node.importprivkey("cRNbfcJgnvk2QJEVbMsxzoprotm1cy3kVA2HoyjSs3ss5NY5mQqr")
-
-        addresses = [
-            "muRmfCwue81ZT9oc3NaepefPscUHtP5kyC",
-            "n12RzKwqWPPA4cWGzkiebiM7Gu6NXUnDW8",
-            "n2yWMtx8jVbo8wv9BK2eN1LdbaakgKL3Mt",
-        ]
-
-        sorted_default = node.addmultisigaddress(2, addresses, None, 'legacy')
-        sorted_false = node.addmultisigaddress(2, addresses, {"sort": False}, 'legacy')
-        sorted_true = node.addmultisigaddress(2, addresses, {"sort": True}, 'legacy')
-
-        assert_equal(sorted_default, sorted_false)
-        assert_equal("2N6dne8yzh13wsRJxCcMgCYNeN9fxKWNHt8", sorted_default['address'])
-        assert_equal("2MsJ2YhGewgDPGEQk4vahGs4wRikJXpRRtU", sorted_true['address'])
-
-        sorted_default = node.addmultisigaddress(2, addresses, {'address_type': 'legacy'})
-        sorted_false = node.addmultisigaddress(2, addresses, {'address_type': 'legacy', "sort": False})
-        sorted_true = node.addmultisigaddress(2, addresses, {'address_type': 'legacy', "sort": True})
-
-        assert_equal(sorted_default, sorted_false)
-        assert_equal("2N6dne8yzh13wsRJxCcMgCYNeN9fxKWNHt8", sorted_default['address'])
-        assert_equal("2MsJ2YhGewgDPGEQk4vahGs4wRikJXpRRtU", sorted_true['address'])
-
-        assert_raises_rpc_error(-1, "address_type provided in both options and 4th parameter", node.addmultisigaddress, 2, addresses, {"address_type": 'legacy'}, 'bech32')
-
-    def test_sort_multisig_with_uncompressed_hash160(self, node):
-        node.importpubkey("02632b12f4ac5b1d1b72b2a3b508c19172de44f6f46bcee50ba33f3f9291e47ed0")
-        node.importpubkey("04dd4fe618a8ad14732f8172fe7c9c5e76dd18c2cc501ef7f86e0f4e285ca8b8b32d93df2f4323ebb02640fa6b975b2e63ab3c9d6979bc291193841332442cc6ad")
-        address = "2MxvEpFdXeEDbnz8MbRwS23kDZC8tzQ9NjK"
-
-        addresses = [
-            "msDoRfEfZQFaQNfAEWyqf69H99yntZoBbG",
-            "myrfasv56W7579LpepuRy7KFhVhaWsJYS8",
-        ]
-        default = self.nodes[0].addmultisigaddress(2, addresses, {'address_type': 'legacy'})
-        assert_equal(address, default['address'])
-
-        unsorted = self.nodes[0].addmultisigaddress(2, addresses, {'address_type': 'legacy', "sort": False})
-        assert_equal(address, unsorted['address'])
-
-        assert_raises_rpc_error(-1, "Compressed key required for BIP67: myrfasv56W7579LpepuRy7KFhVhaWsJYS8", node.addmultisigaddress, 2, addresses, {"sort": True})
-
     def run_test(self):
         # Check that there's no UTXO on the node
         node = self.nodes[0]
@@ -234,10 +188,6 @@ class WalletLabelsTest(BitcoinTestFramework):
 
         self.invalid_label_name_test()
 
-        if not self.options.descriptors:
-            self.test_sort_multisig(node)
-            self.test_sort_multisig_with_uncompressed_hash160(node)
-
         if self.options.descriptors:
             # This is a descriptor wallet test because of segwit v1+ addresses
             self.log.info('Check watchonly labels')
@@ -262,7 +212,7 @@ class WalletLabelsTest(BitcoinTestFramework):
                 ad = BECH32_INVALID[l]
                 assert_raises_rpc_error(
                     -5,
-                    "Invalid Bitcoin address or script",
+                    "Address is not valid" if self.options.descriptors else "Invalid Bitcoin address or script",
                     lambda: wallet_watch_only.importaddress(label=l, rescan=False, address=ad),
                 )
 
diff --git a/test/functional/wallet_listtransactions.py b/test/functional/wallet_listtransactions.py
index 8eea945231..a9f2066dd1 100755
--- a/test/functional/wallet_listtransactions.py
+++ b/test/functional/wallet_listtransactions.py
@@ -114,8 +114,6 @@ class ListTransactionsTest(BitcoinTestFramework):
         self.run_coinjoin_test()
         self.run_invalid_parameters_test()
         self.test_op_return()
-        self.test_listtransactions_display_in_mempool()
-        self.test_gettransaction_display_in_mempool()
 
     def run_rbf_opt_in_test(self):
         """Test the opt-in-rbf flag for sent and received transactions."""
@@ -331,57 +329,5 @@ class ListTransactionsTest(BitcoinTestFramework):
         assert 'address' not in op_ret_tx
 
 
-    def create_and_send_transaction(self, utxo, address, amt, feeRate):
-        psbtx = self.nodes[0].walletcreatefundedpsbt([{"txid": utxo['txid'], "vout": utxo['vout']}],
-                                                      {address: amt},
-                                                      0,
-                                                      {"replaceable":True, "feeRate":feeRate})['psbt']
-        signed_tx = self.nodes[0].walletprocesspsbt(psbtx)['psbt']
-        final_tx = self.nodes[0].finalizepsbt(signed_tx)['hex']
-        return self.nodes[0].sendrawtransaction(final_tx)
-
-    def test_listtransactions_display_in_mempool(self):
-        self.log.info('Testing that listtransactions correctly displays whether a transaction is in the mempool')
-        utxo = self.nodes[0].listunspent(query_options={'minimumAmount': 0.15})[0]
-        address = self.nodes[0].getnewaddress()
-
-        tx1_id = self.create_and_send_transaction(utxo, address, 0.1, 0.001)
-
-        new_txs = self.nodes[0].listtransactions(count=2)
-        for tx in new_txs:
-            assert_equal(tx['txid'], tx1_id)
-            assert_equal(tx['in_mempool'], True)
-
-        tx2_id = self.create_and_send_transaction(utxo, address, 0.1, 0.002)
-
-        new_txs = self.nodes[0].listtransactions(count=4)
-        for i in range(2):
-            assert_equal(new_txs[i]['txid'], tx1_id)
-            assert_equal(new_txs[i]['in_mempool'], False)
-
-        for i in range(2, 4):
-            assert_equal(new_txs[i]['txid'], tx2_id)
-            assert_equal(new_txs[i]['in_mempool'], True)
-
-    def test_gettransaction_display_in_mempool(self):
-        self.log.info('Testing that gettransaction correctly displays whether a transaction is in the mempool')
-        utxo = self.nodes[0].listunspent(query_options={'minimumAmount': 0.15})[0]
-        address = self.nodes[0].getnewaddress()
-
-        tx1_id = self.create_and_send_transaction(utxo, address, 0.1, 0.001)
-
-        tx1 = self.nodes[0].gettransaction(tx1_id)
-        assert_equal(tx1['txid'], tx1_id)
-        assert_equal(tx1['in_mempool'], True)
-
-        tx2_id = self.create_and_send_transaction(utxo, address, 0.1, 0.002)
-        tx1 = self.nodes[0].gettransaction(tx1_id)
-        tx2 = self.nodes[0].gettransaction(tx2_id)
-        assert_equal(tx1['txid'], tx1_id)
-        assert_equal(tx1['in_mempool'], False)
-        assert_equal(tx2['txid'], tx2_id)
-        assert_equal(tx2['in_mempool'], True)
-
-
 if __name__ == '__main__':
     ListTransactionsTest(__file__).main()
diff --git a/test/functional/wallet_migration.py b/test/functional/wallet_migration.py
index c9a21e2554..48ad8e4f2a 100755
--- a/test/functional/wallet_migration.py
+++ b/test/functional/wallet_migration.py
@@ -19,8 +19,7 @@ from test_framework.descriptors import descsum_create
 from test_framework.key import ECPubKey
 from test_framework.test_framework import BitcoinTestFramework
 from test_framework.messages import COIN, CTransaction, CTxOut
-from test_framework.script import hash160
-from test_framework.script_util import key_to_p2pkh_script, key_to_p2pk_script, script_to_p2sh_script, script_to_p2wsh_script
+from test_framework.script_util import key_to_p2pkh_script, script_to_p2sh_script, script_to_p2wsh_script
 from test_framework.util import (
     assert_equal,
     assert_raises_rpc_error,
@@ -28,7 +27,6 @@ from test_framework.util import (
 )
 from test_framework.wallet_util import (
     get_generate_key,
-    generate_keypair,
 )
 
 
@@ -918,22 +916,6 @@ class WalletMigrationTest(BitcoinTestFramework):
             _, _, magic = struct.unpack("QII", data)
             assert_equal(magic, BTREE_MAGIC)
 
-        ####################################################
-        # Perform the same test with a loaded legacy wallet.
-        # The wallet should remain loaded after the failure.
-        #
-        # This applies only when BDB is enabled, as the user
-        # cannot interact with the legacy wallet database
-        # without BDB support.
-        if self.is_bdb_compiled() is not None:
-            # Advance time to generate a different backup name
-            self.master_node.setmocktime(self.master_node.getblockheader(self.master_node.getbestblockhash())['time'] + 100)
-            assert "failed" not in self.master_node.listwallets()
-            self.master_node.loadwallet("failed")
-            assert_raises_rpc_error(-4, "Failed to create database", self.master_node.migratewallet, "failed")
-            wallets = self.master_node.listwallets()
-            assert "failed" in wallets and all(wallet not in wallets for wallet in ["failed_watchonly", "failed_solvables"])
-
     def test_blank(self):
         self.log.info("Test that a blank wallet is migrated")
         wallet = self.create_legacy_wallet("blank", blank=True)
@@ -1030,64 +1012,8 @@ class WalletMigrationTest(BitcoinTestFramework):
 
         wallet.unloadwallet()
 
-    def test_migrate_simple_watch_only(self):
-        self.log.info("Test migrating a watch-only p2pk script")
-        wallet = self.create_legacy_wallet("bare_p2pk", blank=True)
-        _, pubkey = generate_keypair()
-        p2pk_script = key_to_p2pk_script(pubkey)
-        wallet.importaddress(address=p2pk_script.hex())
-        # Migrate wallet in the latest node
-        res = self.migrate_wallet(wallet)
-        wo_wallet = self.master_node.get_wallet_rpc(res['watchonly_name'])
-        assert_equal(wo_wallet.listdescriptors()['descriptors'][0]['desc'], descsum_create(f'pk({pubkey.hex()})'))
-        wo_wallet.unloadwallet()
-
-    def test_manual_keys_import(self):
-        self.log.info("Test migrating standalone private keys")
-        wallet = self.create_legacy_wallet("import_privkeys", blank=True)
-        privkey, pubkey = generate_keypair(wif=True)
-        wallet.importprivkey(privkey=privkey, label="hi", rescan=False)
-
-        # Migrate and verify
-        res = self.migrate_wallet(wallet)
-
-        # There should be descriptors containing the imported key for: pk(), pkh(), sh(wpkh()), wpkh()
-        key_origin = hash160(pubkey)[:4].hex()
-        pubkey_hex = pubkey.hex()
-        pk_desc = descsum_create(f'pk([{key_origin}]{pubkey_hex})')
-        pkh_desc = descsum_create(f'pkh([{key_origin}]{pubkey_hex})')
-        sh_wpkh_desc = descsum_create(f'sh(wpkh([{key_origin}]{pubkey_hex}))')
-        wpkh_desc = descsum_create(f'wpkh([{key_origin}]{pubkey_hex})')
-        expected_descs = [pk_desc, pkh_desc, sh_wpkh_desc, wpkh_desc]
-
-        # Verify all expected descriptors were migrated
-        migrated_desc = [item['desc'] for item in wallet.listdescriptors()['descriptors'] if pubkey.hex() in item['desc']]
-        assert_equal(expected_descs, migrated_desc)
-        wallet.unloadwallet()
-
-        ######################################################
-        self.log.info("Test migrating standalone public keys")
-        wallet = self.create_legacy_wallet("import_pubkeys", blank=True)
-        wallet.importpubkey(pubkey=pubkey_hex, rescan=False)
-
-        res = self.migrate_wallet(wallet)
-
-        # Same as before, there should be descriptors in the watch-only wallet for the imported pubkey
-        wo_wallet = self.nodes[0].get_wallet_rpc(res['watchonly_name'])
-        # As we imported the pubkey only, there will be no key origin in the following descriptors
-        pk_desc = descsum_create(f'pk({pubkey_hex})')
-        pkh_desc = descsum_create(f'pkh({pubkey_hex})')
-        sh_wpkh_desc = descsum_create(f'sh(wpkh({pubkey_hex}))')
-        wpkh_desc = descsum_create(f'wpkh({pubkey_hex})')
-        expected_descs = [pk_desc, pkh_desc, sh_wpkh_desc, wpkh_desc]
-
-        # Verify all expected descriptors were migrated
-        migrated_desc = [item['desc'] for item in wo_wallet.listdescriptors()['descriptors']]
-        assert_equal(expected_descs, migrated_desc)
-        wo_wallet.unloadwallet()
 
     def run_test(self):
-        self.master_node = self.nodes[0]
         self.generate(self.nodes[0], 101)
 
         # TODO: Test the actual records in the wallet for these tests too. The behavior may be correct, but the data written may not be what we actually want
@@ -1109,9 +1035,6 @@ class WalletMigrationTest(BitcoinTestFramework):
         self.test_avoidreuse()
         self.test_preserve_tx_extra_info()
         self.test_blank()
-        self.test_migrate_simple_watch_only()
-        self.test_manual_keys_import()
-
 
 if __name__ == '__main__':
     WalletMigrationTest(__file__).main()
diff --git a/test/functional/wallet_multiwallet.py b/test/functional/wallet_multiwallet.py
index d5f1ba7e69..156f4279b4 100755
--- a/test/functional/wallet_multiwallet.py
+++ b/test/functional/wallet_multiwallet.py
@@ -229,7 +229,7 @@ class MultiWalletTest(BitcoinTestFramework):
         assert_raises_rpc_error(-18, "Requested wallet does not exist or is not loaded", wallet_bad.getwalletinfo)
 
         # accessing wallet RPC without using wallet endpoint fails
-        assert_raises_rpc_error(-19, "Multiple wallets are loaded. Please select which wallet", node.getwalletinfo)
+        assert_raises_rpc_error(-19, "Wallet file not specified", node.getwalletinfo)
 
         w1, w2, w3, w4, *_ = wallets
         self.generatetoaddress(node, nblocks=COINBASE_MATURITY + 1, address=w1.getnewaddress(), sync_fun=self.no_op)
@@ -250,18 +250,12 @@ class MultiWalletTest(BitcoinTestFramework):
         assert_equal(batch[0]["result"]["chain"], self.chain)
         assert_equal(batch[1]["result"]["walletname"], "w1")
 
-        self.log.info('Test per-wallet setfeerate and settxfee calls')
+        self.log.info('Check for per-wallet settxfee call')
         assert_equal(w1.getwalletinfo()['paytxfee'], 0)
         assert_equal(w2.getwalletinfo()['paytxfee'], 0)
-        w2.setfeerate(200)
-        assert_equal(w1.getwalletinfo()['paytxfee'], 0)
-        assert_equal(w2.getwalletinfo()['paytxfee'], Decimal('0.00200000'))
         w2.settxfee(0.001)
         assert_equal(w1.getwalletinfo()['paytxfee'], 0)
         assert_equal(w2.getwalletinfo()['paytxfee'], Decimal('0.00100000'))
-        w1.setfeerate(30)
-        assert_equal(w1.getwalletinfo()['paytxfee'], Decimal('0.00030000'))
-        assert_equal(w2.getwalletinfo()['paytxfee'], Decimal('0.00100000'))
 
         self.log.info("Test dynamic wallet loading")
 
@@ -281,7 +275,7 @@ class MultiWalletTest(BitcoinTestFramework):
         loadwallet_name = node.loadwallet(wallet_names[1])
         assert_equal(loadwallet_name['name'], wallet_names[1])
         assert_equal(node.listwallets(), wallet_names[0:2])
-        assert_raises_rpc_error(-19, "Multiple wallets are loaded. Please select which wallet", node.getwalletinfo)
+        assert_raises_rpc_error(-19, "Wallet file not specified", node.getwalletinfo)
         w2 = node.get_wallet_rpc(wallet_names[1])
         w2.getwalletinfo()
 
diff --git a/test/functional/wallet_reindex.py b/test/functional/wallet_reindex.py
index 21ed2ebc9f..6778f76efc 100755
--- a/test/functional/wallet_reindex.py
+++ b/test/functional/wallet_reindex.py
@@ -8,7 +8,6 @@
 import time
 
 from test_framework.blocktools import COINBASE_MATURITY
-from test_framework.descriptors import descsum_create
 from test_framework.test_framework import BitcoinTestFramework
 from test_framework.util import (
     assert_equal,
@@ -53,15 +52,7 @@ class WalletReindexTest(BitcoinTestFramework):
         # For a descriptors wallet: Import address with timestamp=now.
         # For legacy wallet: There is no way of importing a script/address with a custom time. The wallet always imports it with birthtime=1.
         # In both cases, disable rescan to not detect the transaction.
-        if self.options.descriptors:
-            import_res = wallet_watch_only.importdescriptors([{
-                'desc': descsum_create('addr(' + wallet_addr + ')'),
-                'timestamp': 'now',
-            }])
-            assert len(import_res) == 1
-            assert import_res[0]['success']
-        else:
-            wallet_watch_only.importaddress(wallet_addr, rescan=False)
+        wallet_watch_only.importaddress(wallet_addr, rescan=False)
         assert_equal(len(wallet_watch_only.listtransactions()), 0)
 
         # Depending on the wallet type, the birth time changes.
diff --git a/test/functional/wallet_rescan_unconfirmed.py b/test/functional/wallet_rescan_unconfirmed.py
index 377d7ab7fb..69ad522b5d 100755
--- a/test/functional/wallet_rescan_unconfirmed.py
+++ b/test/functional/wallet_rescan_unconfirmed.py
@@ -57,7 +57,7 @@ class WalletRescanUnconfirmed(BitcoinTestFramework):
         # The only UTXO available to spend is tx_parent_to_reorg.
         assert_equal(len(w0_utxos), 1)
         assert_equal(w0_utxos[0]["txid"], tx_parent_to_reorg["txid"])
-        tx_child_unconfirmed_sweep = w0.sendall(recipients=[ADDRESS_BCRT1_UNSPENDABLE], options={"locktime":0})
+        tx_child_unconfirmed_sweep = w0.sendall([ADDRESS_BCRT1_UNSPENDABLE])
         assert tx_child_unconfirmed_sweep["txid"] in node.getrawmempool()
         node.syncwithvalidationinterfacequeue()
 
diff --git a/test/functional/wallet_send.py b/test/functional/wallet_send.py
index 259f05d957..2d0aad3b5d 100755
--- a/test/functional/wallet_send.py
+++ b/test/functional/wallet_send.py
@@ -142,12 +142,7 @@ class WalletSendTest(BitcoinTestFramework):
             return
 
         if locktime:
-            assert_equal(from_wallet.gettransaction(txid=res["txid"], verbose=True)["decoded"]["locktime"], locktime)
             return res
-        else:
-            if add_to_wallet:
-                decoded_tx = from_wallet.gettransaction(txid=res["txid"], verbose=True)["decoded"]
-                assert_greater_than(decoded_tx["locktime"], from_wallet.getblockcount() - 100)
 
         if from_wallet.getwalletinfo()["private_keys_enabled"] and not include_watching:
             assert_equal(res["complete"], True)
@@ -310,40 +305,6 @@ class WalletSendTest(BitcoinTestFramework):
         res = w2.walletprocesspsbt(res["psbt"])
         assert res["complete"]
 
-        # verify that fee estimation modes parse case insensitively
-        self.log.info("Testing case insensitive fee estimation mode parse")
-        for mode in ["ecoNOMICAL", "economical", "ECONOMICAL"]:
-            res = self.test_send(from_wallet=w0, to_wallet=w1, amount=1,
-                estimate_mode=mode, conf_target=1, add_to_wallet=False
-            )
-            assert_equal(res["complete"], True)
-
-            res = self.test_send(from_wallet=w0, to_wallet=w1, amount=1,
-                arg_estimate_mode=mode, arg_conf_target=1, add_to_wallet=False
-            )
-            assert_equal(res["complete"], True)
-
-        # Verify that different variations of 'unset' still counts as
-        # not setting the estimation mode
-        for mode in ["unSET", "unset", "UNSET"]:
-            self.test_send(from_wallet=w0, to_wallet=w1, amount=1,
-                arg_estimate_mode=mode, arg_conf_target=1, add_to_wallet=False,  expect_error = (-8, 'Specify estimate_mode')
-            )
-
-            self.test_send(from_wallet=w0, to_wallet=w1, amount=1,
-                estimate_mode=mode, conf_target=1, add_to_wallet=False,  expect_error = (-8, 'Specify estimate_mode')
-            )
-
-        # Verify that 'estimate_mode' requires a confirmation target
-        for mode in ["ecoNOMICAL", "economical", "ECONOMICAL"]:
-            self.test_send(from_wallet=w0, to_wallet=w1, amount=1,
-                estimate_mode=mode, conf_target=None, add_to_wallet=False,  expect_error = (-8, 'estimate_mode should be passed with conf_target')
-            )
-
-            self.test_send(from_wallet=w0, to_wallet=w1, amount=1,
-                arg_estimate_mode=mode, arg_conf_target=None, add_to_wallet=False,  expect_error = (-8, 'estimate_mode should be passed with conf_target')
-            )
-
         if not self.options.descriptors:
             # Descriptor wallets do not allow mixed watch-only and non-watch-only things in the same wallet.
             # This is specifically testing that w4 ignores its own private keys and creates a psbt with send
diff --git a/test/functional/wallet_sendall.py b/test/functional/wallet_sendall.py
index 853c4a059b..b256b53b38 100755
--- a/test/functional/wallet_sendall.py
+++ b/test/functional/wallet_sendall.py
@@ -6,7 +6,6 @@
 
 from decimal import Decimal, getcontext
 
-from test_framework.messages import SEQUENCE_FINAL
 from test_framework.test_framework import BitcoinTestFramework
 from test_framework.util import (
     assert_equal,
@@ -438,26 +437,6 @@ class SendallTest(BitcoinTestFramework):
 
         assert_greater_than(higher_parent_feerate_amount, lower_parent_feerate_amount)
 
-    @cleanup
-    def sendall_anti_fee_sniping(self):
-        self.log.info("Testing sendall does anti-fee-sniping when locktime is not specified")
-        self.add_utxos([10,11])
-        tx_from_wallet = self.test_sendall_success(sendall_args = [self.remainder_target])
-
-        assert_greater_than(tx_from_wallet["decoded"]["locktime"], tx_from_wallet["blockheight"] - 100)
-
-        self.log.info("Testing sendall does not do anti-fee-sniping when locktime is specified")
-        self.add_utxos([10,11])
-        txid = self.wallet.sendall(recipients=[self.remainder_target], options={"locktime":0})["txid"]
-        assert_equal(self.wallet.gettransaction(txid=txid, verbose=True)["decoded"]["locktime"], 0)
-
-        self.log.info("Testing sendall does not do anti-fee-sniping when even one of the sequences is final")
-        self.add_utxos([10, 11])
-        utxos = self.wallet.listunspent()
-        utxos[0]["sequence"] = SEQUENCE_FINAL
-        txid = self.wallet.sendall(recipients=[self.remainder_target], inputs=utxos)["txid"]
-        assert_equal(self.wallet.gettransaction(txid=txid, verbose=True)["decoded"]["locktime"], 0)
-
     # This tests needs to be the last one otherwise @cleanup will fail with "Transaction too large" error
     def sendall_fails_with_transaction_too_large(self):
         self.log.info("Test that sendall fails if resulting transaction is too large")
@@ -539,9 +518,6 @@ class SendallTest(BitcoinTestFramework):
         # Sendall only uses outputs with less than a given number of confirmation when using minconf
         self.sendall_with_maxconf()
 
-        # Sendall discourages fee-sniping when a locktime is not specified
-        self.sendall_anti_fee_sniping()
-
         # Sendall spends unconfirmed change
         self.sendall_spends_unconfirmed_change()
 
diff --git a/test/functional/wallet_signer.py b/test/functional/wallet_signer.py
index 76e25b9d46..52b4c390b8 100755
--- a/test/functional/wallet_signer.py
+++ b/test/functional/wallet_signer.py
@@ -88,14 +88,7 @@ class WalletSignerTest(BitcoinTestFramework):
         self.nodes[1].createwallet(wallet_name='not_hww', disable_private_keys=True, descriptors=True, external_signer=False)
         not_hww = self.nodes[1].get_wallet_rpc('not_hww')
         assert_equal(not_hww.getwalletinfo()["external_signer"], False)
-
-        # Flag can be set
-        not_hww.setwalletflag("external_signer", True)
-        assert_equal(not_hww.getwalletinfo()["external_signer"], True)
-
-        # Flag can be unset
-        not_hww.setwalletflag("external_signer", False)
-        assert_equal(not_hww.getwalletinfo()["external_signer"], False)
+        assert_raises_rpc_error(-8, "Wallet flag is immutable: external_signer", not_hww.setwalletflag, "external_signer", True)
 
         # assert_raises_rpc_error(-4, "Multiple signers found, please specify which to use", wallet_name='not_hww', disable_private_keys=True, descriptors=True, external_signer=True)
 
diff --git a/test/functional/wallet_sweepprivkeys.py b/test/functional/wallet_sweepprivkeys.py
deleted file mode 100755
index d1e58f8c6d..0000000000
--- a/test/functional/wallet_sweepprivkeys.py
+++ /dev/null
@@ -1,67 +0,0 @@
-#!/usr/bin/env python3
-# Copyright (c) 2014-2022 The Bitcoin Core developers
-# Distributed under the MIT software license, see the accompanying
-# file COPYING or http://www.opensource.org/licenses/mit-license.php.
-"""Test the sweepprivkeys RPC."""
-
-from test_framework.test_framework import BitcoinTestFramework
-from test_framework.util import assert_equal, assert_fee_amount
-
-class SweepPrivKeysTest(BitcoinTestFramework):
-    def add_options(self, parser):
-        self.add_wallet_options(parser)
-
-    def set_test_params(self):
-        self.num_nodes = 2
-
-    def check_balance(self, delta, txid):
-        node = self.nodes[0]
-        new_balances = node.getbalances()['mine']
-        new_balance = new_balances['trusted'] + new_balances['untrusted_pending']
-        balance_change = new_balance - self.balance
-        actual_fee = delta - balance_change
-        tx_vsize = node.getrawtransaction(txid, True)['vsize']
-        assert_fee_amount(actual_fee, tx_vsize, self.tx_feerate)
-        self.balance = new_balance
-
-    def skip_test_if_missing_module(self):
-        self.skip_if_no_wallet()
-
-    def run_test(self):
-        node = self.nodes[0]
-        miner = self.nodes[1]
-
-        keys = (
-            ('mkckmmfVv89sW1HUjyRuydGhwFmSaYtRvG', '92YkaycAxLPUqbbV78V9nNngKLnyVd9T8uZuZAzQnc26dJSP4fm'),
-            ('mw8s1FS2Vr7GwQF8bnDVUQHQZq5qWqz5kq', '93VijJgAYnVUGXAfxYhbMHVGVwQUEXK1YnPvcCod3x1RLbzUhXe'),
-        )
-
-        # This test is not meant to test fee estimation and we'd like
-        # to be sure all txs are sent at a consistent desired feerate
-        self.tx_feerate = self.nodes[0].getnetworkinfo()['relayfee'] * 2
-        node.settxfee(self.tx_feerate)
-
-        self.generate(miner, 120)
-        self.balance = node.getbalance('*', 0)
-
-        txid = node.sendtoaddress(keys[0][0], 10)
-        self.check_balance(-10, txid)
-
-        # Sweep from mempool
-        txid = node.sweepprivkeys({'privkeys': (keys[0][1],), 'label': 'test 1'})
-        assert_equal(node.listtransactions()[-1]['label'], 'test 1')
-        self.check_balance(10, txid)
-
-        txid = node.sendtoaddress(keys[1][0], 5)
-        self.check_balance(-5, txid)
-        self.sync_all()
-        self.generate(miner, 4)
-        assert_equal(self.balance, node.getbalance('*', 1))
-
-        # Sweep from blockchain
-        txid = node.sweepprivkeys({'privkeys': (keys[1][1],), 'label': 'test 2'})
-        assert_equal(node.listtransactions()[-1]['label'], 'test 2')
-        self.check_balance(5, txid)
-
-if __name__ == '__main__':
-    SweepPrivKeysTest(__file__).main()
diff --git a/test/functional/wallet_taproot.py b/test/functional/wallet_taproot.py
index 20bf971aef..a88d84f4c6 100755
--- a/test/functional/wallet_taproot.py
+++ b/test/functional/wallet_taproot.py
@@ -194,8 +194,6 @@ class WalletTaprootTest(BitcoinTestFramework):
         self.num_nodes = 2
         self.setup_clean_chain = True
         self.extra_args = [['-keypool=100'], ['-keypool=100']]
-        for ea in self.extra_args:
-            ea.append('-addresstype=bech32m')
         self.supports_cli = False
 
     def skip_test_if_missing_module(self):
@@ -307,7 +305,7 @@ class WalletTaprootTest(BitcoinTestFramework):
             assert rpc_online.gettransaction(res)["confirmations"] > 0
 
         # Cleanup
-        txid = rpc_online.sendall(recipients=[self.boring.getnewaddress()], fee_rate=200)["txid"]
+        txid = rpc_online.sendall(recipients=[self.boring.getnewaddress()])["txid"]
         self.generatetoaddress(self.nodes[0], 1, self.boring.getnewaddress(), sync_fun=self.no_op)
         assert rpc_online.gettransaction(txid)["confirmations"] > 0
         rpc_online.unloadwallet()
@@ -380,7 +378,7 @@ class WalletTaprootTest(BitcoinTestFramework):
             assert psbt_online.gettransaction(txid)['confirmations'] > 0
 
         # Cleanup
-        psbt = psbt_online.sendall(recipients=[self.boring.getnewaddress()], psbt=True, conf_target=1, estimate_mode='conservative')["psbt"]
+        psbt = psbt_online.sendall(recipients=[self.boring.getnewaddress()], psbt=True)["psbt"]
         res = psbt_offline.walletprocesspsbt(psbt=psbt, finalize=False)
         rawtx = self.nodes[0].finalizepsbt(res['psbt'])['hex']
         txid = self.nodes[0].sendrawtransaction(rawtx)
diff --git a/test/lint/check-doc.py b/test/lint/check-doc.py
index 8696ca8e0e..f55d0f8cb7 100755
--- a/test/lint/check-doc.py
+++ b/test/lint/check-doc.py
@@ -15,7 +15,7 @@ import re
 
 FOLDER_GREP = 'src'
 FOLDER_TEST = 'src/test/'
-REGEX_ARG = r'\b(?:GetArg|GetArgs|GetBoolArg|GetIntArg|GetFixedPointArg|GetPathArg|IsArgSet|get_net)\("(-[^"]+)"'
+REGEX_ARG = r'\b(?:GetArg|GetArgs|GetBoolArg|GetIntArg|GetPathArg|IsArgSet|get_net)\("(-[^"]+)"'
 REGEX_DOC = r'AddArg\("(-[^"=]+?)(?:=|")'
 CMD_ROOT_DIR = '$(git rev-parse --show-toplevel)/{}'.format(FOLDER_GREP)
 CMD_GREP_ARGS = r"git grep --perl-regexp '{}' -- {} ':(exclude){}'".format(REGEX_ARG, CMD_ROOT_DIR, FOLDER_TEST)
diff --git a/test/lint/git-subtree-check.sh b/test/lint/git-subtree-check.sh
index 364240ee3c..83816bb242 100755
--- a/test/lint/git-subtree-check.sh
+++ b/test/lint/git-subtree-check.sh
@@ -111,7 +111,6 @@ echo "$DIR in $COMMIT was last updated in commit $old (tree $tree_commit)"
 if [ "$tree_actual_tree" != "$tree_commit" ]; then
     git diff "$tree_commit" "$tree_actual_tree" >&2
     echo "FAIL: subtree directory was touched without subtree merge" >&2
-    [ "$DIR:$old" = "src/leveldb:a37778d4d32b4ddeff96f68a130dc8da3a84b278" ] ||  # exception
     exit 1
 fi
 
diff --git a/test/lint/lint-circular-dependencies.py b/test/lint/lint-circular-dependencies.py
index 1e04d17548..6f9a633807 100755
--- a/test/lint/lint-circular-dependencies.py
+++ b/test/lint/lint-circular-dependencies.py
@@ -13,7 +13,6 @@ import sys
 
 EXPECTED_CIRCULAR_DEPENDENCIES = (
     "chainparamsbase -> common/args -> chainparamsbase",
-    "httprpc -> rpc/server -> httprpc",
     "node/blockstorage -> validation -> node/blockstorage",
     "node/utxo_snapshot -> validation -> node/utxo_snapshot",
     "qt/addresstablemodel -> qt/walletmodel -> qt/addresstablemodel",
@@ -26,7 +25,6 @@ EXPECTED_CIRCULAR_DEPENDENCIES = (
     # Temporary, removed in followup https://github.com/bitcoin/bitcoin/pull/24230
     "index/base -> node/context -> net_processing -> index/blockfilterindex -> index/base",
 )
-EXPECTED_CIRCULAR_DEPENDENCIES = ()
 
 CODE_DIR = "src"
 
@@ -49,7 +47,6 @@ def main():
     )
 
     for dependency_str in dependencies_output.stdout.rstrip().split("\n"):
-        if dependency_str == '': continue
         circular_dependencies.append(
             re.sub("^Circular dependency: ", "", dependency_str)
         )
diff --git a/test/lint/lint-includes.py b/test/lint/lint-includes.py
index 22f4b61603..90884299d5 100755
--- a/test/lint/lint-includes.py
+++ b/test/lint/lint-includes.py
@@ -20,7 +20,7 @@ from lint_ignore_dirs import SHARED_EXCLUDED_SUBTREES
 EXCLUDED_DIRS = ["contrib/devtools/bitcoin-tidy/",
                 ] + SHARED_EXCLUDED_SUBTREES
 
-EXPECTED_BOOST_INCLUDES = [
+EXPECTED_BOOST_INCLUDES = ["boost/date_time/posix_time/posix_time.hpp",
                            "boost/multi_index/detail/hash_index_iterator.hpp",
                            "boost/multi_index/hashed_index.hpp",
                            "boost/multi_index/identity.hpp",
@@ -130,6 +130,7 @@ def main():
             for duplicate in duplicates:
                 print(duplicate)
             print("")
+            exit_code = 1
 
     # Check if code includes .cpp-files
     included_cpps = find_included_cpps()
diff --git a/test/lint/lint-python-dead-code.py b/test/lint/lint-python-dead-code.py
index 78b1ac47a2..b3f9394788 100755
--- a/test/lint/lint-python-dead-code.py
+++ b/test/lint/lint-python-dead-code.py
@@ -34,6 +34,7 @@ def main():
     except CalledProcessError as e:
         print(e.output.decode("utf-8"), end="")
         print("Python dead code detection found some issues")
+        exit(1)
 
 
 if __name__ == "__main__":
diff --git a/test/lint/lint-python.py b/test/lint/lint-python.py
index c14d65a254..eabd13322e 100755
--- a/test/lint/lint-python.py
+++ b/test/lint/lint-python.py
@@ -46,9 +46,13 @@ ENABLED = (
     'E272,'  # multiple spaces before keyword
     'E273,'  # tab after keyword
     'E274,'  # tab before keyword
+    'E275,'  # missing whitespace after keyword
     'E304,'  # blank lines found after function decorator
+    'E306,'  # expected 1 blank line before a nested definition
     'E401,'  # multiple imports on one line
     'E402,'  # module level import not at top of file
+    'E502,'  # the backslash is redundant between brackets
+    'E701,'  # multiple statements on one line (colon)
     'E702,'  # multiple statements on one line (semicolon)
     'E703,'  # statement ends with a semicolon
     'E711,'  # comparison to None should be 'if cond is None:'
@@ -59,6 +63,7 @@ ENABLED = (
     'E743,'  # do not define functions named "l", "O", or "I"
     'E901,'  # SyntaxError: invalid syntax
     'E902,'  # TokenError: EOF in multi-line string
+    'F401,'  # module imported but unused
     'F402,'  # import module from line N shadowed by loop variable
     'F403,'  # 'from foo_module import *' used; unable to detect undefined names
     'F404,'  # future import(s) name after other statements
@@ -84,6 +89,7 @@ ENABLED = (
     'F822,'  # undefined name name in __all__
     'F823,'  # local variable name … referenced before assignment
     'F831,'  # duplicate argument name in function definition
+    'F841,'  # local variable 'foo' is assigned to but never used
     'W191,'  # indentation contains tabs
     'W291,'  # trailing whitespace
     'W292,'  # no newline at end of file
diff --git a/test/lint/test_runner/src/main.rs b/test/lint/test_runner/src/main.rs
index c6338f0ecd..77388b78ff 100644
--- a/test/lint/test_runner/src/main.rs
+++ b/test/lint/test_runner/src/main.rs
@@ -376,7 +376,7 @@ fn lint_includes_build_config() -> LintResult {
                     "--files-with-matches"
                 },
                 if mode {
-                    "#include <config/bitcoin-config.h>"
+                    "^#include <config/bitcoin-config.h> // IWYU pragma: keep$"
                 } else {
                     "#include <config/bitcoin-config.h>" // Catch redundant includes with and without the IWYU pragma
                 },
diff --git a/test/util/test_runner.py b/test/util/test_runner.py
index 918a2f645a..1cd368f6f4 100755
--- a/test/util/test_runner.py
+++ b/test/util/test_runner.py
@@ -16,7 +16,6 @@ import json
 import logging
 import os
 import pprint
-import re
 import subprocess
 import sys
 
@@ -35,14 +34,14 @@ def main():
     if verbose:
         level = logging.DEBUG
     else:
-        level = logging.WARNING
+        level = logging.ERROR
     formatter = '%(asctime)s - %(levelname)s - %(message)s'
     # Add the format/level to the logger
     logging.basicConfig(format=formatter, level=level)
 
-    bctester(os.path.join(env_conf["SRCDIR"], "test", "util", "data"), "bitcoin-util-test.json", env_conf, config['components'])
+    bctester(os.path.join(env_conf["SRCDIR"], "test", "util", "data"), "bitcoin-util-test.json", env_conf)
 
-def bctester(testDir, input_basename, buildenv, component_conf):
+def bctester(testDir, input_basename, buildenv):
     """ Loads and parses the input file, runs all tests and reports results"""
     input_filename = os.path.join(testDir, input_basename)
     with open(input_filename, encoding="utf8") as f:
@@ -50,17 +49,8 @@ def bctester(testDir, input_basename, buildenv, component_conf):
     input_data = json.loads(raw_data)
 
     failed_testcases = []
-    skipped_testcases = []
-    skipped_testcase_deps = set()
 
     for testObj in input_data:
-        m = re.match(r'^\.\/bitcoin-(\w+)$', testObj['exec'])
-        if not component_conf.getboolean(f'ENABLE_UTIL_{m.group(1).upper()}'):
-            logging.info("SKIPPED: " + testObj["description"])
-            skipped_testcases.append(testObj['description'])
-            skipped_testcase_deps.add(testObj['exec'])
-            continue
-
         try:
             bctest(testDir, testObj, buildenv)
             logging.info("PASSED: " + testObj["description"])
@@ -74,8 +64,6 @@ def bctester(testDir, input_basename, buildenv, component_conf):
         logging.error(error_message)
         sys.exit(1)
     else:
-        if skipped_testcases:
-            logging.warning(f'{len(skipped_testcases)} tests skipped because {skipped_testcase_deps} is not built')
         sys.exit(0)
 
 def bctest(testDir, testObj, buildenv):
